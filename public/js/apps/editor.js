;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function() {
  var module;

  require("../../vendor/angular/angular");

  require("../../vendor/angular/angular-cookies");

  require("../../vendor/angular-ui/ui-bootstrap");

  require("../../vendor/angular-ui/ui-router");

  require("../services/session.coffee");

  require("../services/notifier.coffee");

  require("../services/disabler.coffee");

  require("../services/basePlunk.coffee");

  require("../services/layout.coffee");

  require("../directives/borderLayout.coffee");

  require("../directives/codeEditor.coffee");

  require("../directives/previewer.coffee");

  require("../directives/toolbar.coffee");

  module = angular.module("plunker.app.editor", ["ui.bootstrap", "ui.router", "fa.borderLayout", "plunker.service.session", "plunker.service.notifier", "plunker.service.disabler", "plunker.service.basePlunk", "plunker.service.layout", "plunker.directive.codeEditor", "plunker.directive.previewer", "plunker.directive.toolbar"]);

  module.config([
    "$stateProvider", "$urlRouterProvider", "$locationProvider", function($stateProvider, $urlRouterProvider, $locationProvider) {
      $locationProvider.html5Mode(true);
      $urlRouterProvider.when("/edit", "/edit/");
      return $urlRouterProvider.otherwise("/edit/");
    }
  ]);

  module.config([
    "$stateProvider", "$urlRouterProvider", function($stateProvider, $urlRouterProvider) {
      $stateProvider.state("editor", {
        url: "/edit",
        template: "<div ui-view=\"body\"></div>",
        controller: [
          "$state", "$scope", function($state, $scope) {
            $scope.showTemplatePane = true;
            $scope.showPreviewPane = false;
            if ($state.is("editor")) {
              return $state.go("editor.blank");
            }
          }
        ]
      });
      $stateProvider.state("editor.blank", {
        url: "/",
        views: {
          "body": {
            templateUrl: "/partials/editor.html",
            controller: [
              "$scope", "session", "basePlunk", "notifier", function($scope, session, basePlunk, notifier) {
                var client, idx;
                client = session.createClient("edit.blank");
                client.reset(basePlunk);
                client.cursorSetIndex((0 <= (idx = client.getFileIndex("index.html"))) && idx || 0);
                return notifier.success("Plunk reset");
              }
            ]
          }
        }
      });
      return $stateProvider.state("editor.gist", {
        url: "/gist:{gistId:[0-9]+|[0-9a-z]{20}}",
        views: {
          "body": {
            templateUrl: "/partials/editor.html",
            controller: [
              "$stateParams", "$q", "$http", "$scope", "$state", "$timeout", "session", "notifier", "disabler", function($stateParams, $q, $http, $scope, $state, $timeout, session, notifier, disabler) {
                var client, parser, request;
                client = session.createClient("edit.gist");
                disabler.enqueue("editor", request = $http.jsonp("https://api.github.com/gists/" + $stateParams.gistId + "?callback=JSON_CALLBACK"));
                parser = request.then(function(response) {
                  var e, file, filename, gist, json, manifest, _ref;
                  if (response.data.meta.status >= 400) {
                    return $q.reject("Gist not found");
                  }
                  gist = response.data.data;
                  json = {
                    'private': true,
                    files: []
                  };
                  if (manifest = gist.files["plunker.json"]) {
                    try {
                      angular.extend(json, angular.fromJson(manifest.content));
                    } catch (_error) {
                      e = _error;
                      notifier.warn("Unable to parse the plunker.json file");
                    }
                  }
                  json.description = gist.description || ("https://gist.github.com/" + $stateParams.gistId);
                  _ref = gist.files;
                  for (filename in _ref) {
                    file = _ref[filename];
                    if (filename !== "plunker.json") {
                      json.files.push({
                        filename: filename,
                        content: file.content
                      });
                    }
                  }
                  return json;
                }, function(error) {
                  console.log("[ERR] Pulling gist", error);
                  return $q.reject("Unable to load gist");
                });
                return parser.then(function(json) {
                  var idx;
                  $scope.showTemplatePane = false;
                  client.reset(json);
                  client.cursorSetIndex((0 <= (idx = client.getFileIndex("index.html"))) && idx || 0);
                  return notifier.success("Imported plunk");
                }, function(errorText) {
                  $state.go("editor.blank");
                  return notifier.error(errorText);
                });
              }
            ]
          }
        }
      });
    }
  ]);

  module.controller("SidebarController", [
    "$scope", "session", function($scope, session) {
      var client;
      $scope.session = client = session.createClient("SidebarController");
      $scope.addFile = function() {
        var filename;
        if (filename = prompt("Filename?")) {
          client.fileCreate(filename);
          return client.cursorSetFile(filename);
        }
      };
      $scope.renameFile = function(old_filename) {
        var filename;
        if (client.hasFile(old_filename) && (filename = prompt("Filename?", old_filename))) {
          return client.fileRename(old_filename, filename);
        }
      };
      $scope.removeFile = function(filename) {
        if (client.hasFile(filename) && confirm("Are you sure you would like to delete " + filename + "?")) {
          return client.fileRemove(filename);
        }
      };
      return $scope.moveTo = function(filename) {
        return client.cursorSetFile(filename);
      };
    }
  ]);

  module.controller("LayoutController", [
    "$scope", "layout", function($scope, layout) {
      $scope.layout = layout;
      return $scope.togglePreviewPane = function() {
        return $scope.showPreviewPane = !$scope.showPreviewPane;
      };
    }
  ]);

}).call(this);


},{"../../vendor/angular-ui/ui-bootstrap":16,"../../vendor/angular-ui/ui-router":17,"../../vendor/angular/angular":19,"../../vendor/angular/angular-cookies":18,"../directives/borderLayout.coffee":2,"../directives/codeEditor.coffee":3,"../directives/previewer.coffee":4,"../directives/toolbar.coffee":5,"../services/basePlunk.coffee":7,"../services/disabler.coffee":8,"../services/layout.coffee":9,"../services/notifier.coffee":10,"../services/session.coffee":11}],2:[function(require,module,exports){
(function() {
  var Region, module, throttle,
    __slice = [].slice;

  module = angular.module("fa.borderLayout", []);

  throttle = function(delay, fn) {
    var throttled;
    throttled = false;
    return function() {
      if (throttled) {
        return;
      }
      throttled = true;
      setTimeout(function() {
        return throttled = false;
      }, delay);
      return fn.call.apply(fn, [this].concat(__slice.call(arguments)));
    };
  };

  Region = (function() {
    function Region(width, height) {
      this.width = width != null ? width : 0;
      this.height = height != null ? height : 0;
      this.top = 0;
      this.right = 0;
      this.bottom = 0;
      this.left = 0;
    }

    Region.prototype.calculateSize = function(orientation, target) {
      var available, matches, terms, total;
      if (target == null) {
        target = 0;
      }
      total = this.getSize(orientation);
      available = this.getAvailableSize(orientation);
      if (angular.isNumber(target)) {
        if (target >= 1) {
          return Math.round(target);
        }
        if (target >= 0) {
          return Math.round(target * total);
        }
        return 0;
      }
      target = target.replace(/\s+/mg, "");
      if ((terms = target.split("-")).length > 1) {
        return this.calculateSize(orientation, terms.shift()) - this.calculateSize(orientation, terms.join("+"));
      }
      if ((terms = target.split("+")).length > 1) {
        return this.calculateSize(orientation, terms.shift()) + this.calculateSize(orientation, terms.join("+"));
      }
      if (matches = target.match(/^(\d+)px$/)) {
        return parseInt(matches[1], 10);
      }
      if (matches = target.match(/^(\d+(?:\.\d+)?)&$/)) {
        return Math.round(available * parseFloat(matches[1]) / 100);
      }
      if (matches = target.match(/^(\d+(?:\.\d+)?)%$/)) {
        return Math.round(total * parseFloat(matches[1]) / 100);
      }
      throw new Error("Unsupported size: " + target);
    };

    Region.prototype.consume = function(anchor, size) {
      var style;
      if (size == null) {
        size = 0;
      }
      switch (anchor) {
        case "north":
          style = {
            top: "" + this.top + "px",
            right: "" + this.right + "px",
            left: "" + this.left + "px",
            height: "" + size + "px"
          };
          this.top += size;
          break;
        case "east":
          style = {
            top: "" + this.top + "px",
            right: "" + this.right + "px",
            bottom: "" + this.bottom + "px",
            width: "" + size + "px"
          };
          this.right += size;
          break;
        case "south":
          style = {
            right: "" + this.right + "px",
            bottom: "" + this.bottom + "px",
            left: "" + this.left + "px",
            height: "" + size + "px"
          };
          this.bottom += size;
          break;
        case "west":
          style = {
            top: "" + this.top + "px",
            bottom: "" + this.bottom + "px",
            left: "" + this.left + "px",
            width: "" + size + "px"
          };
          this.left += size;
      }
      return style;
    };

    Region.prototype.getInnerRegion = function() {
      return new Region(this.width - this.right - this.left, this.height - this.top - this.bottom);
    };

    Region.prototype.getSize = function(orientation) {
      switch (orientation) {
        case "vertical":
          return this.height;
        case "horizontal":
          return this.width;
      }
    };

    Region.prototype.getAvailableSize = function(orientation) {
      switch (orientation) {
        case "vertical":
          return this.height - this.top - this.bottom;
        case "horizontal":
          return this.width - this.right - this.left;
      }
    };

    return Region;

  })();

  module.directive("pane", [
    function() {
      return {
        restrict: "E",
        replace: true,
        require: ["pane", "^borderLayout"],
        transclude: true,
        scope: true,
        template: "<div class=\"border-layout-pane\">\n  <div class=\"border-layout-pane-overlay\" ng-style=\"styleContent\"></div>\n  <div class=\"border-layout-pane-handle\" layout-handle ng-style=\"styleHandle\"></div>\n  <div class=\"border-layout-pane-scroller\" ng-style=\"styleContent\" ng-transclude></div>\n</div>",
        controller: [
          "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
            var $handle, $overlay, $scroller, pane, _ref;
            pane = this;
            _ref = $element.children(), $overlay = _ref[0], $handle = _ref[1], $scroller = _ref[2];
            $attrs.$observe("anchor", function(anchor) {
              var prev;
              prev = pane.anchor;
              pane.anchor = anchor;
              pane.orientation = pane.getOrientation(anchor);
              if (prev) {
                return pane.layout.reflow();
              }
            });
            $attrs.$observe("size", function(size, prev) {
              pane.target = size;
              return pane.layout.reflow();
            });
            $attrs.$observe("open", function(open, wasOpen) {
              if (open == null) {
                open = true;
              }
              if (open === "false") {
                open = false;
              }
              if (open) {
                $element.removeClass("closed");
              } else {
                $element.addClass("closed");
              }
              return pane.toggle(open);
            });
            $attrs.$observe("order", function(order, prev) {
              if (order == null) {
                order = 0;
              }
              pane.order = parseInt(order || 0, 10);
              return pane.layout.reflow();
            });
            this.children = [];
            this.openSize = 0;
            this.attachChild = function(child) {
              return this.children.push(child);
            };
            this.getOrientation = function(anchor) {
              if (anchor == null) {
                anchor = $attrs.anchor;
              }
              switch (anchor) {
                case "north":
                case "south":
                  return "vertical";
                case "east":
                case "west":
                  return "horizontal";
              }
            };
            this.getContentStyle = function(anchor, handleSize) {
              var style;
              style = {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
              };
              switch (anchor) {
                case "north":
                  style.bottom = "" + handleSize + "px";
                  break;
                case "east":
                  style.left = "" + handleSize + "px";
                  break;
                case "south":
                  style.top = "" + handleSize + "px";
                  break;
                case "west":
                  style.right = "" + handleSize + "px";
              }
              return style;
            };
            this.getHandleStyle = function(anchor, region, handleSize) {
              switch (anchor) {
                case "north":
                  return {
                    height: "" + (region.calculateSize('vertical', handleSize)) + "px",
                    right: 0,
                    left: 0,
                    bottom: 0
                  };
                case "south":
                  return {
                    height: "" + (region.calculateSize('vertical', handleSize)) + "px",
                    right: 0,
                    left: 0,
                    top: 0
                  };
                case "east":
                  return {
                    width: "" + (region.calculateSize('horizontal', handleSize)) + "px",
                    top: 0,
                    bottom: 0,
                    left: 0
                  };
                case "west":
                  return {
                    width: "" + (region.calculateSize('horizontal', handleSize)) + "px",
                    top: 0,
                    bottom: 0,
                    right: 0
                  };
              }
            };
            this.onHandleDown = function() {
              $element.addClass("active");
              return this.layout.onHandleDown();
            };
            this.onHandleUp = function() {
              $element.removeClass("active");
              return this.layout.onHandleUp();
            };
            this.toggle = function(open) {
              if (open == null) {
                open = !pane.open;
              }
              pane.open = open;
              if (!open) {
                this.openSize = this.size;
              } else {
                this.size = this.openSize;
              }
              if (open) {
                $element.removeClass("closed");
              } else {
                $element.addClass("closed");
              }
              return this.layout.reflow();
            };
            this.reflow = function(region, target) {
              var anchor, child, handleSize, inner, max, min, orientation, size, styleContainer, styleContent, styleHandle, _i, _len, _ref1;
              if (target == null) {
                target = pane.target;
              }
              anchor = pane.anchor;
              if (anchor === "center") {
                $element.css({
                  top: "" + region.top + "px",
                  right: "" + region.right + "px",
                  bottom: "" + region.bottom + "px",
                  left: "" + region.left + "px"
                });
              } else if (anchor === "north" || anchor === "east" || anchor === "south" || anchor === "west") {
                orientation = this.getOrientation(anchor);
                handleSize = region.calculateSize(orientation, $attrs.handle || 0);
                if (!pane.open) {
                  size = handleSize;
                } else {
                  size = region.calculateSize(orientation, target);
                  max = $attrs.max || Number.MAX_VALUE;
                  min = $attrs.min || 0;
                  size = Math.min(size, region.calculateSize(orientation, max));
                  size = Math.max(size, region.calculateSize(orientation, min));
                  size = Math.min(size, region.getAvailableSize(orientation));
                  size = Math.max(size, handleSize + 2);
                }
                this.size = size;
                styleContainer = region.consume(anchor, size);
                styleContent = this.getContentStyle(anchor, handleSize);
                styleHandle = this.getHandleStyle(anchor, region, handleSize);
                $element.attr("style", "").css(styleContainer);
                angular.element($overlay).attr("style", "").css(styleContent);
                angular.element($scroller).attr("style", "").css(styleContent);
                angular.element($handle).attr("style", "").css(styleHandle);
              }
              if (this.children.length) {
                inner = region.getInnerRegion();
                _ref1 = this.children;
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  child = _ref1[_i];
                  inner = child.reflow(inner);
                }
              }
              return region;
            };
            return this.resize = function(target) {
              $attrs.$set("size", target || 0);
              return this.layout.reflow();
            };
          }
        ],
        link: function($scope, $el, $attrs, _arg) {
          var pane, parent;
          pane = _arg[0], parent = _arg[1];
          pane.layout = parent;
          parent.attachChild(pane);
          $scope.$$nextSibling.pane = pane;
          return $scope.$watch("constrained", function(constrained) {
            if (constrained) {
              return $el.addClass("border-layout-constrained");
            } else {
              return $el.removeClass("border-layout-constrained");
            }
          });
        }
      };
    }
  ]);

  module.directive("layoutHandle", [
    "$window", function($window) {
      return {
        restrict: "A",
        require: ["?^pane", "^?borderLayout"],
        link: function($scope, $element, $attrs, _arg) {
          var clickRadius, clickTime, el, layout, pane;
          pane = _arg[0], layout = _arg[1];
          if (!pane) {
            return;
          }
          el = $element[0];
          clickRadius = 5;
          clickTime = 300;
          $scope.$watch((function() {
            return pane.getOrientation();
          }), function(orientation) {
            $element.removeClass("vertical");
            $element.removeClass("horizontal");
            switch (orientation) {
              case "vertical":
                return $element.addClass("vertical");
              case "horizontal":
                return $element.addClass("horizontal");
            }
          });
          return el.addEventListener("mousedown", function(e) {
            var anchor, coord, handleClick, handleMouseMove, handleMouseMoveThrottled, handleMouseUp, scale, startCoord, startPos, startSize, startTime;
            if (e.button !== 0) {
              return;
            }
            anchor = pane.anchor;
            if (anchor === "north" || anchor === "south") {
              coord = "screenY";
            } else if (anchor === "west" || anchor === "east") {
              coord = "screenX";
            }
            if (anchor === "north" || anchor === "west") {
              scale = 1;
            } else if (anchor === "south" || anchor === "east") {
              scale = -1;
            }
            startPos = {
              x: e.screenX,
              y: e.screenY
            };
            startCoord = e[coord];
            startSize = pane.size;
            startTime = Date.now();
            pane.onHandleDown();
            el.unselectable = "on";
            el.onselectstart = function() {
              return false;
            };
            el.style.userSelect = el.style.MozUserSelect = "none";
            e.preventDefault();
            e.defaultPrevented = true;
            e = null;
            handleClick = function(e) {
              return $scope.$apply(function() {
                return pane.toggle();
              });
            };
            handleMouseMove = function(e) {
              $element.addClass("border-layout-pane-moving");
              $scope.$apply(function() {
                var targetSize;
                return pane.resize(targetSize = startSize + scale * (e[coord] - startCoord));
              });
              e.preventDefault();
              e.defaultPrevented = true;
              return e = null;
            };
            handleMouseUp = function(e) {
              var cleanup, displacementSq, timeElapsed;
              displacementSq = Math.pow(e.screenX - startPos.x, 2) + Math.pow(e.screenY - startPos.y, 2);
              timeElapsed = Date.now() - startTime;
              $window.removeEventListener("mousemove", handleMouseMoveThrottled, true);
              $window.removeEventListener("mouseup", handleMouseUp, true);
              cleanup = function() {
                e.preventDefault();
                e.defaultPrevented = true;
                e = null;
                return pane.onHandleUp();
              };
              if (displacementSq <= Math.pow(clickRadius, 2) && timeElapsed <= clickTime) {
                handleClick(e);
                cleanup();
                return;
              }
              handleMouseMove(e);
              return cleanup();
            };
            handleMouseMoveThrottled = throttle(10, handleMouseMove);
            $window.addEventListener("mousemove", handleMouseMoveThrottled, true);
            return $window.addEventListener("mouseup", handleMouseUp, true);
          });
        }
      };
    }
  ]);

  module.directive("borderLayout", [
    "$window", "$timeout", function($window, $timeout) {
      return {
        restrict: "E",
        replace: true,
        require: ["borderLayout", "^?pane"],
        transclude: true,
        template: "<div class=\"border-layout\" ng-transclude>\n</div>",
        controller: [
          "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
            var layout;
            layout = this;
            this.children = [];
            this.attachChild = function(child) {
              return this.children.push(child);
            };
            this.onHandleDown = function() {
              return $element.addClass("active");
            };
            this.onHandleUp = function() {
              $element.removeClass("active");
              return $scope.$broadcast("border-layout-reflow");
            };
            return this.reflow = function(region) {
              var child, height, width, _i, _len, _ref, _results;
              width = $element[0].offsetWidth;
              height = $element[0].offsetHeight;
              region || (region = new Region(width, height));
              this.children.sort(function(a, b) {
                return b.order - a.order;
              });
              _ref = this.children;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                child = _ref[_i];
                _results.push(region = child.reflow(region));
              }
              return _results;
            };
          }
        ],
        link: function($scope, $el, $attrs, _arg) {
          var layout, parent;
          layout = _arg[0], parent = _arg[1];
          if (parent) {
            parent.attachChild(layout);
          }
          $scope.$on("reflow", function() {
            if (!parent) {
              return layout.reflow();
            }
          });
          $window.addEventListener("resize", function(e) {
            e.stopPropagation();
            return $scope.$apply(function() {
              return $scope.$broadcast("border-layout-reflow");
            });
          });
          return $timeout(function() {
            if (!parent) {
              return layout.reflow();
            }
          });
        }
      };
    }
  ]);

}).call(this);


},{}],3:[function(require,module,exports){
(function() {
  var module;

  require("../services/session.coffee");

  require("../services/types.coffee");

  require("../services/settings.coffee");

  require("../services/annotations.coffee");

  module = angular.module("plunker.directive.codeEditor", ["plunker.service.session", "plunker.service.types", "plunker.service.settings", "plunker.service.annotations"]);

  module.directive("codeEditor", [
    "$rootScope", "$timeout", "session", "types", "settings", "annotations", function($rootScope, $timeout, session, types, settings, annotations) {
      var AceEditor, EditSession, Range, Renderer, UndoManager, config;
      AceEditor = ace.require("ace/editor").Editor;
      Renderer = ace.require("ace/virtual_renderer").VirtualRenderer;
      EditSession = ace.require("ace/edit_session").EditSession;
      UndoManager = ace.require("ace/undomanager").UndoManager;
      Range = ace.require("ace/range").Range;
      config = ace.require("ace/config");
      return {
        restrict: "E",
        replace: true,
        scope: {
          active: "="
        },
        template: "<div class=\"code-editor\">\n</div>",
        link: function($scope, $el, attrs) {
          var activateBuffer, addAceSession, buffers, changeSessionMode, client, editor, guessMode, moveCursor, removeAceSession, reset, snippetManager;
          editor = new AceEditor(new Renderer($el[0], "ace/theme/" + settings.editor.theme));
          client = session.createClient("code-editor");
          snippetManager = null;
          buffers = [];
          ace.config.loadModule("ace/ext/language_tools", function() {
            editor.setOptions({
              enableBasicAutocompletion: true,
              enableSnippets: true
            });
            return snippetManager = ace.require("ace/snippets").snippetManager;
          });
          $scope.$watch((function() {
            return settings.editor.theme;
          }), function(theme) {
            if (theme) {
              return editor.setTheme("ace/theme/" + theme);
            }
          });
          guessMode = function(filename) {
            return "ace/mode/" + types.getByFilename(filename).name;
          };
          activateBuffer = function(index) {
            editor.setSession(buffers[index]);
            return editor.focus();
          };
          moveCursor = function(offset) {
            var doc;
            doc = editor.session.doc;
            return editor.moveCursorToPosition(doc.indexToPosition(offset));
          };
          addAceSession = function(index, file) {
            var aceSession, doc, handleChangeAnnotationEvent, handleChangeEvent;
            aceSession = new EditSession(file.content || "");
            aceSession.setUndoManager(new UndoManager());
            aceSession.setUseWorker(true);
            aceSession.setTabSize(settings.editor.tab_size);
            aceSession.setUseWrapMode(!!settings.editor.wrap.enabled);
            aceSession.setWrapLimitRange(settings.editor.wrap.range.min, settings.editor.wrap.range.max);
            aceSession.setMode(guessMode(file.filename));
            doc = aceSession.getDocument();
            handleChangeEvent = function(e) {
              if (!$rootScope.$$phase) {
                return $scope.$apply(function() {
                  var nl;
                  nl = doc.getNewLineCharacter();
                  switch (e.data.action) {
                    case "insertText":
                      return client.textInsert(file.filename, doc.positionToIndex(e.data.range.start), e.data.text);
                    case "insertLines":
                      return client.textInsert(file.filename, doc.positionToIndex(e.data.range.start), e.data.lines.join(nl) + nl);
                    case "removeText":
                      return client.textRemove(file.filename, doc.positionToIndex(e.data.range.start), e.data.text);
                    case "removeLines":
                      return client.textRemove(file.filename, doc.positionToIndex(e.data.range.start), e.data.lines.join(nl) + nl);
                  }
                });
              }
            };
            handleChangeAnnotationEvent = function(e) {
              if (!$rootScope.$$phase) {
                return $scope.$apply(function() {
                  var idx;
                  if ((idx = client.getFileIndex(file.filename)) < 0) {
                    throw new Error("Buffers and session are out of sync for: " + file.filename);
                  }
                  annotations.update(file.filename, aceSession.getAnnotations());
                  return $rootScope.$broadcast("updateAnnotatinos", file, aceSession.getAnnotations());
                });
              }
            };
            buffers[index] = aceSession;
            annotations.update(file.filename, aceSession.getAnnotations());
            aceSession.on("change", handleChangeEvent);
            aceSession.on("changeAnnotation", handleChangeAnnotationEvent);
            return aceSession.destroy = function() {
              aceSession.off("change", handleChangeEvent);
              return aceSession.off("changeAnnotation", handleChangeAnnotationEvent);
            };
          };
          removeAceSession = function(index) {
            var file;
            if (!buffers[index]) {
              debugger;
            }
            buffers[index].destroy();
            buffers.splice(index, 1);
            if (file = client.getFileByIndex(index)) {
              return annotations.remove(file.filename);
            }
          };
          reset = function(snapshot) {
            var file, idx, _i, _j, _len, _ref, _ref1, _results;
            for (idx = _i = _ref = buffers.length - 1; _i >= 0; idx = _i += -1) {
              removeAceSession(idx);
            }
            _ref1 = snapshot.files;
            _results = [];
            for (idx = _j = 0, _len = _ref1.length; _j < _len; idx = ++_j) {
              file = _ref1[idx];
              _results.push(addAceSession(idx, file));
            }
            return _results;
          };
          changeSessionMode = function(index, filename) {
            var buffer;
            if (buffer = buffers[index]) {
              return buffer.setMode(guessMode(filename));
            }
          };
          client.on("reset", function(e, snapshot) {
            return reset(e.snapshot);
          });
          client.on("cursorSetFile", function(e, snapshot) {
            return activateBuffer(e.index);
          });
          client.on("cursorSetOffset", function(e, snapshot) {
            return moveCursor(e.offset);
          });
          client.on("fileCreate", function(e, snapshot) {
            return addAceSession(e.index, snapshot.files[e.index]);
          });
          client.on("fileRemove", function(e, snapshot) {
            removeAceSession(e.index);
            return annotations.remove(e.filename);
          });
          client.on("fileRename", function(e, snapshot) {
            changeSessionMode(e.index, e.filename);
            return annotations.rename(e.filename, e.old_filename);
          });
          client.on("textInsert", function(e, snapshot) {
            var aceSession;
            if (!(aceSession = buffers[e.index])) {
              throw new Error("Received textInsert event for a file not being tracked");
            }
            return aceSession.doc.insert(aceSession.doc.indexToPosition(e.offset), text);
          });
          client.on("textRemove", function(e, snapshot) {
            var aceSession;
            if (!(aceSession = buffers[e.index])) {
              throw new Error("Received textInsert event for a file not being tracked");
            }
            return aceSession.doc.remove(Range.fromPoints(aceSession.doc.indexToPosition(e.offset), aceSession.doc.indexToPosition(e.offset + e.text.length)));
          });
          reset(client.getSnapshot());
          activateBuffer(client.getCursorFileIndex());
          moveCursor(client.getCursorTextOffset());
          $scope.$on("border-layout-reflow", function() {
            return editor.resize();
          });
          return $timeout(function() {
            return editor.resize();
          }, 100);
        }
      };
    }
  ]);

}).call(this);


},{"../services/annotations.coffee":6,"../services/session.coffee":11,"../services/settings.coffee":12,"../services/types.coffee":13}],4:[function(require,module,exports){
(function() {
  var debounce, genid, module;

  genid = require("genid");

  debounce = require("lodash.debounce");

  require("../../vendor/operative.js");

  require("../services/session.coffee");

  require("../services/types.coffee");

  require("../services/url.coffee");

  require("../services/settings.coffee");

  require("../services/annotations.coffee");

  module = angular.module("plunker.directive.previewer", ["plunker.service.session", "plunker.service.url", "plunker.service.settings", "plunker.service.annotations"]);

  module.directive("previewer", [
    "$timeout", "session", "url", "settings", "annotations", function($timeout, session, url, settings, annotations) {
      return {
        restrict: "E",
        replace: true,
        scope: {
          session: "="
        },
        template: "<div>\n  <div class=\"plunker-preview-container\" ng-class=\"{message: message}\">\n    <iframe name=\"plunkerPreviewTarget\" src=\"about:blank\" width=\"100%\" height=\"100%\" frameborder=\"0\"></iframe>\n  </div>\n  <div class=\"plunker-preview-message alert alert-danger\" ng-show=\"message\">\n    <button type=\"button\" class=\"close\" ng-click=\"message=''\" aria-hidden=\"true\">&times;</button>\n    <span ng-bind=\"message\"></span>\n  </div>\n</div>",
        link: function($scope, $el, attrs) {
          var client, refresh;
          $scope.previewUrl || ($scope.previewUrl = "" + url.run + "/" + (genid()) + "/");
          client = session.createClient("previewer");
          refresh = function(snapshot) {
            return $scope.$apply(function() {
              var field, file, filename, form, _i, _len, _ref;
              if ($scope.mode === "disabled") {
                return;
              }
              if (filename = annotations.hasError()) {
                $scope.message = "Preview has not been updated due to syntax errors in " + filename;
                return;
              } else {
                $scope.message = "";
              }
              form = document.createElement("form");
              form.style.display = "none";
              form.setAttribute("method", "post");
              form.setAttribute("action", $scope.previewUrl);
              form.setAttribute("target", "plunkerPreviewTarget");
              _ref = snapshot.files;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                file = _ref[_i];
                field = document.createElement("input");
                field.setAttribute("type", "hidden");
                field.setAttribute("name", "files[" + file.filename + "][content]");
                field.setAttribute("value", file.content);
                form.appendChild(field);
              }
              document.body.appendChild(form);
              form.submit();
              return document.body.removeChild(form);
            });
          };
          $scope.$watch((function() {
            return settings.previewer.delay;
          }), function(delay) {
            return refresh = debounce(refresh, delay);
          });
          client.on("reset", function(e, snapshot) {
            return refresh(snapshot);
          });
          client.on("fileCreate", function(e, snapshot) {
            return refresh(snapshot);
          });
          client.on("fileRename", function(e, snapshot) {
            return refresh(snapshot);
          });
          client.on("fileRemove", function(e, snapshot) {
            return refresh(snapshot);
          });
          client.on("textInsert", function(e, snapshot) {
            return refresh(snapshot);
          });
          client.on("textRemove", function(e, snapshot) {
            return refresh(snapshot);
          });
          return $timeout(function() {
            return refresh(client.getSnapshot());
          });
        }
      };
    }
  ]);

}).call(this);


},{"../../vendor/operative.js":20,"../services/annotations.coffee":6,"../services/session.coffee":11,"../services/settings.coffee":12,"../services/types.coffee":13,"../services/url.coffee":14,"genid":22,"lodash.debounce":23}],5:[function(require,module,exports){
(function() {
  var module;

  require("../../vendor/angular-ui/ui-bootstrap");

  require("../services/notifier.coffee");

  module = angular.module("plunker.directive.toolbar", ["ui.bootstrap", "plunker.service.notifier"]);

  module.directive("plunkerToolbar", [
    "$state", "session", "notifier", function($state, session, notifier) {
      return {
        restrict: "E",
        replace: true,
        scope: true,
        template: "<div class=\"plunker-editor-toolbar\">\n  <div class=\"pull-left\">\n    <button class=\"btn btn-sm btn-primary\" ng-click=\"save()\">\n      Save\n    </button>\n    \n    <button class=\"btn btn-sm btn-success\" ui-sref=\"editor\">\n      New\n    </button>\n    \n    <button class=\"btn btn-sm btn-info\" ng-class=\"{active: showPreviewPane}\" ng-click=\"togglePreviewPane()\">\n      Preview\n    </button>\n  </div>\n  <div class=\"pull-right\">\n    <div class=\"btn-group btn-sm\" ng-controller=\"LayoutController\">\n      <button class=\"btn btn-sm btn-default\" ng-click=\"layout.setLayout($index)\" ng-repeat=\"preset in layout.presets\" ng-bind=\"$index\" tooltip=\"{{preset.name}}\" tooltip-append-to-body=\"true\" tooltip-placement=\"bottom\"></button>\n    </div>\n  </div>\n</div>",
        link: function($scope, $element, $attrs) {
          var client;
          client = session.createClient("directive.toolbar");
          return $scope.save = function() {
            return notifier.warn("Save not implemented... yet");
          };
        }
      };
    }
  ]);

}).call(this);


},{"../../vendor/angular-ui/ui-bootstrap":16,"../services/notifier.coffee":10}],6:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.annotations", []);

  module.factory("annotations", function() {
    return {
      annotations: {},
      update: function(filename, annotations) {
        var _base;
        if (annotations == null) {
          annotations = [];
        }
        return angular.copy(annotations, ((_base = this.annotations)[filename] || (_base[filename] = [])));
      },
      rename: function(old_filename, new_filename) {
        this.annotations[new_filename] = this.annotations[old_filename] || [];
        return delete this.annotations[old_filename];
      },
      remove: function(filename) {
        return delete this.annotations[filename];
      },
      hasError: function() {
        var annotation, annotations, filename, _i, _len, _ref;
        _ref = this.annotations;
        for (filename in _ref) {
          annotations = _ref[filename];
          for (_i = 0, _len = annotations.length; _i < _len; _i++) {
            annotation = annotations[_i];
            if (annotation.type === "error") {
              return filename;
            }
          }
        }
        return false;
      }
    };
  });

}).call(this);


},{}],7:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.basePlunk", []);

  module.value("basePlunk", {
    files: [
      {
        filename: "index.html",
        content: "<!doctype html>\n<html ng-app=\"plunker\" >\n<head>\n  <meta charset=\"utf-8\">\n  <title>AngularJS Plunker</title>\n  <script>document.write('<base href=\"' + document.location + '\" />');</script>\n  <link rel=\"stylesheet\" href=\"style.css\">\n  <script data-require=\"angular.js@1.1.x\" src=\"http://code.angularjs.org/1.1.4/angular.js\"></script>\n  <script src=\"app.js\"></script>\n</head>\n<body ng-controller=\"MainCtrl\">\n  <p>Hello {{name}}!</p>\n</body>\n</html> "
      }, {
        filename: "app.js",
        content: "var app = angular.module('plunker', []);\n \napp.controller('MainCtrl', function($scope) {\n  $scope.name = 'World';\n});"
      }, {
        filename: "style.css",
        content: "p {\n  color: red;\n}"
      }
    ]
  });

}).call(this);


},{}],8:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.disabler", []);

  module.directive("plunkerDisabler", [
    "disabler", function(disabler) {
      return {
        link: function($scope, $element, $attrs) {
          var mask;
          mask = angular.element("<div class=\"plunker-disabler\"></div>");
          return $scope.$watch((function() {
            return disabler.state[$attrs.plunkerDisabler];
          }), function(state, prev) {
            if (state) {
              return $element.append(mask);
            } else {
              return mask.remove();
            }
          });
        }
      };
    }
  ]);

  module.service("disabler", [
    "$q", function($q) {
      var queues;
      queues = {};
      this.state = {};
      return this.enqueue = function(name, valueOrPromise) {
        var disabler;
        disabler = this;
        disabler.state[name] = true;
        return $q.when(valueOrPromise)["finally"](function() {
          return disabler.state[name] = false;
        });
      };
    }
  ]);

}).call(this);


},{}],9:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.layout", []);

  module.factory("layout", [
    "$rootScope", function($rootScope) {
      var presets, service;
      presets = [
        {
          name: "Preview on the right",
          layout: {
            preview: {
              anchor: "east",
              order: 0,
              size: "50& - 4px",
              open: true
            },
            templates: {
              anchor: "west",
              order: 2,
              size: "300px"
            }
          }
        }, {
          name: "Preview at the bottom",
          layout: {
            preview: {
              anchor: "south",
              order: 2,
              size: "40% - 4px",
              open: true
            },
            templates: {
              anchor: "west",
              order: 2,
              size: "300px"
            }
          }
        }
      ];
      service = {
        current: null,
        presets: presets,
        isOpen: function(paneId) {
          var _ref, _ref1;
          return (_ref = this.current) != null ? (_ref1 = _ref.layout) != null ? _ref1[paneId].open : void 0 : void 0;
        },
        toggle: function(paneId) {
          var _ref, _ref1;
          return (_ref = this.current) != null ? (_ref1 = _ref.layout) != null ? _ref1[paneId].open = !this.current.layout[paneId].open : void 0 : void 0;
        },
        setLayout: function(idx) {
          if (presets[idx]) {
            this.current = angular.copy(presets[idx].layout);
          }
          $rootScope.$broadcast("reflow");
          return this.current;
        }
      };
      service.setLayout(0);
      return service;
    }
  ]);

}).call(this);


},{}],10:[function(require,module,exports){
(function() {
  var module,
    __slice = [].slice;

  require("../../vendor/angular-growl/angular-growl");

  module = angular.module("plunker.service.notifier", ["angular-growl"]);

  module.config([
    "growlProvider", function(growlProvider) {
      return growlProvider.globalTimeToLive(3000);
    }
  ]);

  module.factory("notifier", [
    "growl", function(growl) {
      return {
        error: function(message) {
          console.log.apply(console, ["[ERR]"].concat(__slice.call(arguments)));
          return growl.addErrorMessage(message);
        },
        warn: function(message) {
          console.log.apply(console, ["[WARN]"].concat(__slice.call(arguments)));
          return growl.addWarnMessage(message);
        },
        success: function(message) {
          console.log.apply(console, ["[OK]"].concat(__slice.call(arguments)));
          return growl.addSuccessMessage(message);
        }
      };
    }
  ]);

}).call(this);


},{"../../vendor/angular-growl/angular-growl":15}],11:[function(require,module,exports){
(function() {
  var Session, module;

  require("../../vendor/ottypes/webclient/json0.uncompressed.js");

  module = angular.module("plunker.service.session", []);

  module.service("session", Session = (function() {
    var SessionClient;

    SessionClient = (function() {
      function SessionClient(name, session) {
        this.name = name;
        this.session = session;
        this.listeners = {};
      }

      SessionClient.prototype.on = function(eventName, listener) {
        var _base;
        return ((_base = this.listeners)[eventName] || (_base[eventName] = [])).push(listener);
      };

      SessionClient.prototype.off = function(eventName, listener) {
        var idx;
        if (!(0 > (idx = this.listeners.indexOf(listener)))) {
          return this.listeners.splice(idx, 1);
        }
      };

      SessionClient.prototype._applyOp = function(op) {
        return this._applyOps([op]);
      };

      SessionClient.prototype._applyOps = function(ops) {
        return this.session.applyOps(this.name, ops);
      };

      SessionClient.prototype._handleOp = function(sourceClientName, op, snapshot) {
        var filename;
        if (op.p.length === 0) {
          return this._emit("reset", {
            snapshot: op.oi,
            old_snapshot: op.od
          });
        } else {
          switch (op.p[0]) {
            case "cursor":
              if (op.p[1] === "fileIndex") {
                return this._emit("cursorSetFile", {
                  filename: snapshot.files[op.oi].filename,
                  prev_filename: snapshot.files[op.od].filename,
                  index: op.oi,
                  prev_index: op.od
                });
              } else if (op.p[1] === "textOffset") {
                return this._emit("cursorSetOffset", {
                  offset: op.oi,
                  prev_offset: op.od
                });
              }
              break;
            case "description":
              if (op.p[1] !== 0) {
                return;
              }
              if (!(op.si && op.sd)) {
                return;
              }
              return this._emit("setDescription", {
                description: op.si,
                old_description: op.sd
              });
            case "tags":
              if (!(op.li || op.ld)) {
                return;
              }
              if (op.p.length !== 2) {
                return;
              }
              if (op.li) {
                return this._emit("tagAdd", {
                  tagName: op.li,
                  index: op.p[1]
                });
              } else if (op.ld) {
                return this._emit("tagRemove", {
                  tagName: op.ld,
                  index: op.p[2]
                });
              }
              break;
            case "files":
              if (op.p.length === 2) {
                if (op.li) {
                  return this._emit("fileCreate", {
                    filename: op.li.filename,
                    index: op.p[1],
                    content: op.li.content
                  });
                } else if (op.ld) {
                  return this._emit("fileRemove", {
                    filename: op.ld.filename,
                    index: op.p[1],
                    content: op.ld.content
                  });
                }
              } else if (op.p[2] === "filename") {
                return this._emit("fileRename", {
                  filename: op.oi,
                  index: op.p[1],
                  old_filename: op.od
                });
              } else if (op.p[2] === "content") {
                filename = snapshot.files[op.p[1]].filename;
                if (op.si) {
                  this._emit("textInsert", {
                    filename: filename,
                    index: op.p[1],
                    text: op.si,
                    offset: op.p[3]
                  });
                }
                if (op.sd) {
                  return this._emit("textRemove", {
                    filename: filename,
                    index: op.p[1],
                    text: op.sd,
                    offset: op.p[3]
                  });
                }
              }
          }
        }
      };

      SessionClient.prototype._emit = function(eventName, e) {
        var listener, snapshot, _i, _len, _ref, _results;
        snapshot = this.getSnapshot();
        e.eventName = eventName;
        if (this.listeners[eventName]) {
          _ref = this.listeners[eventName];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            listener = _ref[_i];
            _results.push(listener(e, snapshot));
          }
          return _results;
        }
      };

      SessionClient.prototype.getCursorFileIndex = function() {
        return this.session.snapshot.cursor.fileIndex;
      };

      SessionClient.prototype.getCursorTextOffset = function() {
        return this.session.snapshot.cursor.textOffset;
      };

      SessionClient.prototype.getDescription = function() {
        return this.session.snapshot.description;
      };

      SessionClient.prototype.getFileIndex = function(filename) {
        var file, idx, _i, _len, _ref;
        _ref = this.session.snapshot.files;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          file = _ref[idx];
          if (file.filename === filename) {
            return idx;
          }
        }
        return -1;
      };

      SessionClient.prototype.getFileByIndex = function(idx) {
        if (angular.isString(idx)) {
          idx = this.getFileIndex(idx);
        }
        return this.session.snapshot.files[idx];
      };

      SessionClient.prototype.getFile = function(filename) {
        var file, _i, _len, _ref;
        _ref = this.session.snapshot.files;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          if (file.filename === filename) {
            return file;
          }
        }
      };

      SessionClient.prototype.getNumFiles = function() {
        var _ref;
        return ((_ref = this.session.snapshot.files) != null ? _ref.length : void 0) || 0;
      };

      SessionClient.prototype.getNumTags = function() {
        var _ref;
        return ((_ref = this.session.snapshot.tags) != null ? _ref.length : void 0) || 0;
      };

      SessionClient.prototype.getSnapshot = function() {
        return this.session.snapshot;
      };

      SessionClient.prototype.getTagIndex = function(tagName) {
        var idx, tag, _i, _len, _ref;
        _ref = this.session.snapshot.tags;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          tag = _ref[idx];
          if (tag === tagName) {
            return idx;
          }
        }
        return -1;
      };

      SessionClient.prototype.hasFile = function(filename) {
        return this.getFileIndex(filename) >= 0;
      };

      SessionClient.prototype.hasFileIndex = function(idx) {
        return this.getFileByIndex(idx) != null;
      };

      SessionClient.prototype.hasTag = function(tagName) {
        return this.getTagIndex(tagName) >= 0;
      };

      SessionClient.prototype.isValidTag = function(tagName) {
        return /^[-_a-z0-9\.\[\]]+$/i.test(tagName);
      };

      SessionClient.prototype.isValidFile = function(file) {
        return this.isValidFilename(file.filename) && angular.isString(file.content);
      };

      SessionClient.prototype.isValidFilename = function(filename) {
        return /^[-_a-z0-9\.\[\]]+$/i.test(filename);
      };

      SessionClient.prototype.reset = function(json) {
        var file, tagName, _i, _j, _len, _len1, _ref, _ref1;
        if (json == null) {
          json = {};
        }
        json.description || (json.description = "");
        json.tags || (json.tags = []);
        json.cursor || (json.cursor = {
          fileIndex: 0,
          textOffset: 0
        });
        if (!angular.isString(json.description)) {
          throw new Error("Reset failed. Description must be a string.");
        }
        if (!angular.isArray(json.tags)) {
          throw new Error("Reset failed. Tags must be an array.");
        }
        _ref = json.tags;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tagName = _ref[_i];
          if (!this.isValidTag(tagName)) {
            throw new Error("Reset failed. Invalid tag: " + tagName + ".");
          }
        }
        if (!angular.isArray(json.files)) {
          throw new Error("Reset failed. Files must be an array.");
        }
        _ref1 = json.files;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          file = _ref1[_j];
          if (!this.isValidFile(file)) {
            throw new Error("Reset failed. Invalid file: " + (JSON.stringify(file)) + ".");
          }
        }
        if (!json.files.length) {
          throw new Error("Reset failed. There must be at least one file.");
        }
        return this._applyOp({
          p: [],
          od: angular.copy(this.getSnapshot()),
          oi: json
        });
      };

      SessionClient.prototype.cursorSetFile = function(filename) {
        var idx;
        if (!this.hasFile(filename)) {
          throw new Error("Unable set the active file. File does not exist: " + filename);
        }
        idx = this.getFileIndex(filename);
        return this._applyOp({
          p: ["cursor", "fileIndex"],
          od: this.getCursorFileIndex(),
          oi: idx
        });
      };

      SessionClient.prototype.cursorSetIndex = function(idx) {
        if (!this.hasFileIndex(idx)) {
          throw new Error("Unable set the active file. File does not exist: " + idx);
        }
        return this._applyOp({
          p: ["cursor", "fileIndex"],
          od: this.getCursorFileIndex(),
          oi: idx
        });
      };

      SessionClient.prototype.cursorSetOffset = function(offset) {
        return this._applyOp({
          p: ["cursor", "textOffset"],
          od: this.getCursorTextOffset(),
          oi: offset
        });
      };

      SessionClient.prototype.setDescription = function(description) {
        if (description == null) {
          description = "";
        }
        return this._applyOp({
          p: ["description", 0],
          sd: this.getDescription(),
          si: description
        });
      };

      SessionClient.prototype.fileCreate = function(filename, content) {
        var idx;
        if (content == null) {
          content = "";
        }
        if (!this.isValidFilename(filename)) {
          throw new Error("Unable to create file. Invalid filename: " + filename);
        }
        if (this.hasFile(filename)) {
          throw new Error("Unable to create file. File already exists: " + filename);
        }
        idx = this.getNumFiles();
        return this._applyOp({
          p: ["files", idx],
          li: {
            filename: filename,
            content: content
          }
        });
      };

      SessionClient.prototype.fileRename = function(filename, new_filename) {
        var idx;
        if (!this.isValidFilename(new_filename)) {
          throw new Error("Unable to create file. Invalid filename: " + new_filename);
        }
        if (!this.hasFile(filename)) {
          throw new Error("Unable to rename file. File does not exist: " + filename);
        }
        if (this.hasFile(new_filename)) {
          throw new Error("Unable to rename file. A file already exists named: " + new_filename);
        }
        idx = this.getFileIndex(filename);
        return this._applyOp({
          p: ["files", idx, "filename"],
          od: filename,
          oi: new_filename
        });
      };

      SessionClient.prototype.fileRemove = function(filename) {
        var idx;
        if (!this.hasFile(filename)) {
          throw new Error("Unable to remove file. File does not exist: " + filename);
        }
        if (this.getNumFiles() <= 1) {
          throw new Error("Unable to remove file. You can not remove all files.");
        }
        idx = this.getFileIndex(filename);
        this.cursorSetIndex(0);
        return this._applyOp({
          p: ["files", idx],
          ld: this.getFile(filename)
        });
      };

      SessionClient.prototype.textInsert = function(filename, offset, text) {
        var idx;
        if (!this.hasFile(filename)) {
          throw new Error("Unable to insert text. File does not exist: " + filename);
        }
        idx = this.getFileIndex(filename);
        return this._applyOp({
          p: ["files", idx, "content", offset],
          si: text
        });
      };

      SessionClient.prototype.textRemove = function(filename, offset, text) {
        var idx;
        if (!this.hasFile(filename)) {
          throw new Error("Unable to remove text. File does not exist: " + filename);
        }
        idx = this.getFileIndex(filename);
        return this._applyOp({
          p: ["files", idx, "content", offset],
          sd: text
        });
      };

      SessionClient.prototype.tagAdd = function(tagName) {
        var idx;
        if (!this.isValidTag(tagName)) {
          throw new Error("Unable to add tag. Invalid tag: " + tagName);
        }
        if (this.hasTag(tagName)) {
          throw new Error("Unable to add tag. Tag already exists: " + tagName);
        }
        idx = this.getNumTags();
        return this._applyOp({
          p: ["tags", idx],
          li: tagName
        });
      };

      SessionClient.prototype.tagRemove = function(tagName) {
        var idx;
        if (!this.hasTag(tagName)) {
          throw new Error("Unable to remove tag. Tag not found: " + tagName);
        }
        idx = this.getTagIndex(tagName);
        return this._applyOp({
          p: ["tags", idx],
          ld: tagName
        });
      };

      return SessionClient;

    })();

    function Session() {
      this.$clients = {};
      this.snapshot = {};
      this.iface = this.createClient("session");
      this.iface.reset({
        files: [
          {
            filename: "index.html",
            content: ""
          }
        ]
      });
    }

    Session.prototype.createClient = function(clientName) {
      var session, _base;
      session = this;
      return (_base = this.$clients)[clientName] || (_base[clientName] = new SessionClient(clientName, session));
    };

    Session.prototype.applyOps = function(sourceClientName, ops) {
      var client, clientName, op, postSnapshot, _i, _len, _ref, _results;
      postSnapshot = ottypes.json0.apply(this.snapshot, ops);
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        console.log("[OT] op", op);
      }
      console.log("[OT] snapshot", angular.copy(this.snapshot));
      if (this.snapshot !== postSnapshot) {
        angular.copy(postSnapshot, this.snapshot);
      }
      _ref = this.$clients;
      _results = [];
      for (clientName in _ref) {
        client = _ref[clientName];
        if (clientName !== sourceClientName) {
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = ops.length; _j < _len1; _j++) {
              op = ops[_j];
              _results1.push(client._handleOp(sourceClientName, op, this.snapshot));
            }
            return _results1;
          }).call(this));
        }
      }
      return _results;
    };

    return Session;

  })());

}).call(this);


},{"../../vendor/ottypes/webclient/json0.uncompressed.js":21}],12:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.settings", []);

  module.service("settings", [
    function() {
      var e, saved, settings;
      settings = {
        previewer: {
          delay: 1000,
          auto_refresh: true
        },
        editor: {
          tab_size: 2,
          soft_tabs: true,
          theme: "textmate",
          wrap: {
            range: {
              min: 0,
              max: 80
            },
            enabled: false
          }
        }
      };
      if (typeof localStorage !== "undefined" && localStorage !== null) {
        if (saved = localStorage.getItem("plnkr_settings")) {
          try {
            saved = JSON.parse(saved);
          } catch (_error) {
            e = _error;
            saved = {};
          }
        }
        setInterval(function() {
          return localStorage.setItem("plnkr_settings", JSON.stringify(settings));
        }, 2000);
      }
      return angular.extend(settings, saved);
    }
  ]);

}).call(this);


},{}],13:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.types", []);

  module.factory("types", function() {
    var name, type, types;
    types = {
      html: {
        regex: /\.html$/i,
        mime: "text/html"
      },
      javascript: {
        regex: /\.js$/i,
        mime: "text/javascript"
      },
      coffee: {
        regex: /\.coffee$/i,
        mime: "text/coffee"
      },
      css: {
        regex: /\.css$/i,
        mime: "text/css"
      },
      text: {
        regex: /\.txt$/,
        mime: "text/plain"
      }
    };
    for (name in types) {
      type = types[name];
      type.name = name;
    }
    return {
      types: types,
      getByFilename: function(filename) {
        var mode;
        for (name in types) {
          mode = types[name];
          if (mode.regex.test(filename)) {
            return mode;
          }
        }
        return types.text;
      }
    };
  });

}).call(this);


},{}],14:[function(require,module,exports){
(function() {
  var module;

  module = angular.module("plunker.service.url", []);

  module.constant("url", _plunker.url);

}).call(this);


},{}],15:[function(require,module,exports){
/**
 * angular-growl - v0.3.0 - 2013-09-26
 * https://github.com/marcorinck/angular-growl
 * Copyright (c) 2013 Marco Rinck; Licensed MIT
 */
angular.module('angular-growl', []);
angular.module('angular-growl').directive('growl', [
  '$rootScope',
  function ($rootScope) {
    'use strict';
    return {
      restrict: 'A',
      template: '<div class="growl">' + '\t<div class="growl-item alert" ng-repeat="message in messages" ng-class="computeClasses(message)">' + '\t\t<button type="button" class="close" ng-click="deleteMessage(message)">&times;</button>' + '            {{ message.text}}' + '\t</div>' + '</div>',
      replace: false,
      scope: true,
      controller: [
        '$scope',
        '$timeout',
        function ($scope, $timeout) {
          $scope.messages = [];
          $rootScope.$on('growlMessage', function (event, message) {
            $scope.messages.push(message);
            if (message.ttl && message.ttl !== -1) {
              $timeout(function () {
                $scope.deleteMessage(message);
              }, message.ttl);
            }
          });
          $scope.deleteMessage = function (message) {
            var index = $scope.messages.indexOf(message);
            if (index > -1) {
              $scope.messages.splice(index, 1);
            }
          };
          $scope.computeClasses = function (message) {
            return {
              'alert-success': message.isSuccess,
              'alert-danger': message.isError,
              'alert-warning': message.isWarn,
              'alert-info': message.isInfo
            };
          };
        }
      ]
    };
  }
]);
angular.module('angular-growl').provider('growl', function () {
  'use strict';
  var _ttl = null, _messagesKey = 'messages', _messageTextKey = 'text', _messageSeverityKey = 'severity';
  this.globalTimeToLive = function (ttl) {
    _ttl = ttl;
  };
  this.messagesKey = function (messagesKey) {
    _messagesKey = messagesKey;
  };
  this.messageTextKey = function (messageTextKey) {
    _messageTextKey = messageTextKey;
  };
  this.messageSeverityKey = function (messageSeverityKey) {
    _messageSeverityKey = messageSeverityKey;
  };
  this.serverMessagesInterceptor = [
    '$q',
    'growl',
    function ($q, growl) {
      function checkResponse(response) {
        if (response.data[_messagesKey] && response.data[_messagesKey].length > 0) {
          growl.addServerMessages(response.data[_messagesKey]);
        }
      }
      function success(response) {
        checkResponse(response);
        return response;
      }
      function error(response) {
        checkResponse(response);
        return $q.reject(response);
      }
      return function (promise) {
        return promise.then(success, error);
      };
    }
  ];
  this.$get = [
    '$rootScope',
    '$filter',
    function ($rootScope, $filter) {
      var translate;
      try {
        translate = $filter('translate');
      } catch (e) {
      }
      function broadcastMessage(message) {
        if (translate) {
          message = translate(message);
        }
        $rootScope.$broadcast('growlMessage', message);
      }
      function sendMessage(text, config, severity) {
        var _config = config || {}, message;
        message = {
          text: text,
          isWarn: severity.isWarn,
          isError: severity.isError,
          isInfo: severity.isInfo,
          isSuccess: severity.isSuccess,
          ttl: _config.ttl || _ttl
        };
        broadcastMessage(message);
      }
      function addWarnMessage(text, config) {
        sendMessage(text, config, { isWarn: true });
      }
      function addErrorMessage(text, config) {
        sendMessage(text, config, { isError: true });
      }
      function addInfoMessage(text, config) {
        sendMessage(text, config, { isInfo: true });
      }
      function addSuccessMessage(text, config) {
        sendMessage(text, config, { isSuccess: true });
      }
      function addServerMessages(messages) {
        var i, message, severity, length;
        length = messages.length;
        for (i = 0; i < length; i++) {
          message = messages[i];
          if (message[_messageTextKey] && message[_messageSeverityKey]) {
            switch (message[_messageSeverityKey]) {
            case 'warn':
              severity = { isWarn: true };
              break;
            case 'success':
              severity = { isSuccess: true };
              break;
            case 'info':
              severity = { isInfo: true };
              break;
            case 'error':
              severity = { isError: true };
              break;
            }
            sendMessage(message[_messageTextKey], undefined, severity);
          }
        }
      }
      return {
        addWarnMessage: addWarnMessage,
        addErrorMessage: addErrorMessage,
        addInfoMessage: addInfoMessage,
        addSuccessMessage: addSuccessMessage,
        addServerMessages: addServerMessages
      };
    }
  ];
});
},{}],16:[function(require,module,exports){
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.transition","ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.bindHtml","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdownToggle","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/popup.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-unsafe-popup.html","template/tooltip/tooltip-popup.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset-titles.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.transition', [])

/**
 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
 * @param  {DOMElement} element  The DOMElement that will be animated.
 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
 *   - As a string, it represents the css class to be added to the element.
 *   - As an object, it represents a hash of style attributes to be applied to the element.
 *   - As a function, it represents a function to be called that will cause the transition to occur.
 * @return {Promise}  A promise that is resolved when the transition finishes.
 */
.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {

  var $transition = function(element, trigger, options) {
    options = options || {};
    var deferred = $q.defer();
    var endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"];

    var transitionEndHandler = function(event) {
      $rootScope.$apply(function() {
        element.unbind(endEventName, transitionEndHandler);
        deferred.resolve(element);
      });
    };

    if (endEventName) {
      element.bind(endEventName, transitionEndHandler);
    }

    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
    $timeout(function() {
      if ( angular.isString(trigger) ) {
        element.addClass(trigger);
      } else if ( angular.isFunction(trigger) ) {
        trigger(element);
      } else if ( angular.isObject(trigger) ) {
        element.css(trigger);
      }
      //If browser does not support transitions, instantly resolve
      if ( !endEventName ) {
        deferred.resolve(element);
      }
    });

    // Add our custom cancel function to the promise that is returned
    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
    // i.e. it will therefore never raise a transitionEnd event for that transition
    deferred.promise.cancel = function() {
      if ( endEventName ) {
        element.unbind(endEventName, transitionEndHandler);
      }
      deferred.reject('Transition cancelled');
    };

    return deferred.promise;
  };

  // Work out the name of the transitionEnd event
  var transElement = document.createElement('trans');
  var transitionEndEventNames = {
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'oTransitionEnd',
    'transition': 'transitionend'
  };
  var animationEndEventNames = {
    'WebkitTransition': 'webkitAnimationEnd',
    'MozTransition': 'animationend',
    'OTransition': 'oAnimationEnd',
    'transition': 'animationend'
  };
  function findEndEventName(endEventNames) {
    for (var name in endEventNames){
      if (transElement.style[name] !== undefined) {
        return endEventNames[name];
      }
    }
  }
  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
  return $transition;
}]);

angular.module('ui.bootstrap.collapse',['ui.bootstrap.transition'])

// The collapsible directive indicates a block of html that will expand and collapse
.directive('collapse', ['$transition', function($transition) {
  // CSS transitions don't work with height: auto, so we have to manually change the height to a
  // specific value and then once the animation completes, we can reset the height to auto.
  // Unfortunately if you do this while the CSS transitions are specified (i.e. in the CSS class
  // "collapse") then you trigger a change to height 0 in between.
  // The fix is to remove the "collapse" CSS class while changing the height back to auto - phew!
  var fixUpHeight = function(scope, element, height) {
    // We remove the collapse CSS class to prevent a transition when we change to height: auto
    element.removeClass('collapse');
    element.css({ height: height });
    // It appears that  reading offsetWidth makes the browser realise that we have changed the
    // height already :-/
    var x = element[0].offsetWidth;
    element.addClass('collapse');
  };

  return {
    link: function(scope, element, attrs) {

      var isCollapsed;
      var initialAnimSkip = true;
      scope.$watch(function (){ return element[0].scrollHeight; }, function (value) {
        //The listener is called when scollHeight changes
        //It actually does on 2 scenarios: 
        // 1. Parent is set to display none
        // 2. angular bindings inside are resolved
        //When we have a change of scrollHeight we are setting again the correct height if the group is opened
        if (element[0].scrollHeight !== 0) {
          if (!isCollapsed) {
            if (initialAnimSkip) {
              fixUpHeight(scope, element, element[0].scrollHeight + 'px');
            } else {
              fixUpHeight(scope, element, 'auto');
            }
          }
        }
      });
      
      scope.$watch(attrs.collapse, function(value) {
        if (value) {
          collapse();
        } else {
          expand();
        }
      });
      

      var currentTransition;
      var doTransition = function(change) {
        if ( currentTransition ) {
          currentTransition.cancel();
        }
        currentTransition = $transition(element,change);
        currentTransition.then(
          function() { currentTransition = undefined; },
          function() { currentTransition = undefined; }
        );
        return currentTransition;
      };

      var expand = function() {
        if (initialAnimSkip) {
          initialAnimSkip = false;
          if ( !isCollapsed ) {
            fixUpHeight(scope, element, 'auto');
          }
        } else {
          doTransition({ height : element[0].scrollHeight + 'px' })
          .then(function() {
            // This check ensures that we don't accidentally update the height if the user has closed
            // the group while the animation was still running
            if ( !isCollapsed ) {
              fixUpHeight(scope, element, 'auto');
            }
          });
        }
        isCollapsed = false;
      };
      
      var collapse = function() {
        isCollapsed = true;
        if (initialAnimSkip) {
          initialAnimSkip = false;
          fixUpHeight(scope, element, 0);
        } else {
          fixUpHeight(scope, element, element[0].scrollHeight + 'px');
          doTransition({'height':'0'});
        }
      };
    }
  };
}]);

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

.constant('accordionConfig', {
  closeOthers: true
})

.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {
  
  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if ( closeOthers ) {
      angular.forEach(this.groups, function (group) {
        if ( group !== openGroup ) {
          group.isOpen = false;
        }
      });
    }
  };
  
  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function (event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if ( index !== -1 ) {
      this.groups.splice(this.groups.indexOf(group), 1);
    }
  };

}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('accordion', function () {
  return {
    restrict:'EA',
    controller:'AccordionController',
    transclude: true,
    replace: false,
    templateUrl: 'template/accordion/accordion.html'
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('accordionGroup', ['$parse', '$transition', '$timeout', function($parse, $transition, $timeout) {
  return {
    require:'^accordion',         // We need this directive to be inside an accordion
    restrict:'EA',
    transclude:true,              // It transcludes the contents of the directive into the template
    replace: true,                // The element containing the directive will be replaced with the template
    templateUrl:'template/accordion/accordion-group.html',
    scope:{ heading:'@' },        // Create an isolated scope and interpolate the heading attribute onto this scope
    controller: ['$scope', function($scope) {
      this.setHeading = function(element) {
        this.heading = element;
      };
    }],
    link: function(scope, element, attrs, accordionCtrl) {
      var getIsOpen, setIsOpen;

      accordionCtrl.addGroup(scope);

      scope.isOpen = false;
      
      if ( attrs.isOpen ) {
        getIsOpen = $parse(attrs.isOpen);
        setIsOpen = getIsOpen.assign;

        scope.$watch(
          function watchIsOpen() { return getIsOpen(scope.$parent); },
          function updateOpen(value) { scope.isOpen = value; }
        );
        
        scope.isOpen = getIsOpen ? getIsOpen(scope.$parent) : false;
      }

      scope.$watch('isOpen', function(value) {
        if ( value ) {
          accordionCtrl.closeOthers(scope);
        }
        if ( setIsOpen ) {
          setIsOpen(scope.$parent, value);
        }
      });
    }
  };
}])

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// <accordion-group>
//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
// </accordion-group>
.directive('accordionHeading', function() {
  return {
    restrict: 'EA',
    transclude: true,   // Grab the contents to be used as the heading
    template: '',       // In effect remove this element!
    replace: true,
    require: '^accordionGroup',
    compile: function(element, attr, transclude) {
      return function link(scope, element, attr, accordionGroupCtrl) {
        // Pass the heading to the accordion-group controller
        // so that it can be transcluded into the right place in the template
        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
        accordionGroupCtrl.setHeading(transclude(scope, function() {}));
      };
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// <div class="accordion-group">
//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
//   ...
// </div>
.directive('accordionTransclude', function() {
  return {
    require: '^accordionGroup',
    link: function(scope, element, attr, controller) {
      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
        if ( heading ) {
          element.html('');
          element.append(heading);
        }
      });
    }
  };
});

angular.module("ui.bootstrap.alert", []).directive('alert', function () {
  return {
    restrict:'EA',
    templateUrl:'template/alert/alert.html',
    transclude:true,
    replace:true,
    scope: {
      type: '=',
      close: '&'
    },
    link: function(scope, iElement, iAttrs, controller) {
      scope.closeable = "close" in iAttrs;
    }
  };
});

angular.module('ui.bootstrap.bindHtml', [])

  .directive('bindHtmlUnsafe', function () {
    return function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
        element.html(value || '');
      });
    };
  });
angular.module('ui.bootstrap.buttons', [])

  .constant('buttonConfig', {
    activeClass:'active',
    toggleEvent:'click'
  })

  .directive('btnRadio', ['buttonConfig', function (buttonConfig) {
  var activeClass = buttonConfig.activeClass || 'active';
  var toggleEvent = buttonConfig.toggleEvent || 'click';

  return {

    require:'ngModel',
    link:function (scope, element, attrs, ngModelCtrl) {

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
      };

      //ui->model
      element.bind(toggleEvent, function () {
        if (!element.hasClass(activeClass)) {
          scope.$apply(function () {
            ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
}])

  .directive('btnCheckbox', ['buttonConfig', function (buttonConfig) {

  var activeClass = buttonConfig.activeClass || 'active';
  var toggleEvent = buttonConfig.toggleEvent || 'click';

  return {
    require:'ngModel',
    link:function (scope, element, attrs, ngModelCtrl) {

      function getTrueValue() {
        var trueValue = scope.$eval(attrs.btnCheckboxTrue);
        return angular.isDefined(trueValue) ? trueValue : true;
      }

      function getFalseValue() {
        var falseValue = scope.$eval(attrs.btnCheckboxFalse);
        return angular.isDefined(falseValue) ? falseValue : false;
      }

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui->model
      element.bind(toggleEvent, function () {
        scope.$apply(function () {
          ngModelCtrl.$setViewValue(element.hasClass(activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
}]);
/**
* @ngdoc overview
* @name ui.bootstrap.carousel
*
* @description
* AngularJS version of an image carousel.
*
*/
angular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])
.controller('CarouselController', ['$scope', '$timeout', '$transition', '$q', function ($scope, $timeout, $transition, $q) {
  var self = this,
    slides = self.slides = [],
    currentIndex = -1,
    currentTimeout, isPlaying;
  self.currentSlide = null;

  /* direction: "prev" or "next" */
  self.select = function(nextSlide, direction) {
    var nextIndex = slides.indexOf(nextSlide);
    //Decide direction if it's not given
    if (direction === undefined) {
      direction = nextIndex > currentIndex ? "next" : "prev";
    }
    if (nextSlide && nextSlide !== self.currentSlide) {
      if ($scope.$currentTransition) {
        $scope.$currentTransition.cancel();
        //Timeout so ng-class in template has time to fix classes for finished slide
        $timeout(goNext);
      } else {
        goNext();
      }
    }
    function goNext() {
      //If we have a slide to transition from and we have a transition type and we're allowed, go
      if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
        //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime
        nextSlide.$element.addClass(direction);
        var reflow = nextSlide.$element[0].offsetWidth; //force reflow

        //Set all other slides to stop doing their stuff for the new transition
        angular.forEach(slides, function(slide) {
          angular.extend(slide, {direction: '', entering: false, leaving: false, active: false});
        });
        angular.extend(nextSlide, {direction: direction, active: true, entering: true});
        angular.extend(self.currentSlide||{}, {direction: direction, leaving: true});

        $scope.$currentTransition = $transition(nextSlide.$element, {});
        //We have to create new pointers inside a closure since next & current will change
        (function(next,current) {
          $scope.$currentTransition.then(
            function(){ transitionDone(next, current); },
            function(){ transitionDone(next, current); }
          );
        }(nextSlide, self.currentSlide));
      } else {
        transitionDone(nextSlide, self.currentSlide);
      }
      self.currentSlide = nextSlide;
      currentIndex = nextIndex;
      //every time you change slides, reset the timer
      restartTimer();
    }
    function transitionDone(next, current) {
      angular.extend(next, {direction: '', active: true, leaving: false, entering: false});
      angular.extend(current||{}, {direction: '', active: false, leaving: false, entering: false});
      $scope.$currentTransition = null;
    }
  };

  /* Allow outside people to call indexOf on slides array */
  self.indexOfSlide = function(slide) {
    return slides.indexOf(slide);
  };

  $scope.next = function() {
    var newIndex = (currentIndex + 1) % slides.length;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(slides[newIndex], 'next');
    }
  };

  $scope.prev = function() {
    var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(slides[newIndex], 'prev');
    }
  };

  $scope.select = function(slide) {
    self.select(slide);
  };

  $scope.isActive = function(slide) {
     return self.currentSlide === slide;
  };

  $scope.slides = function() {
    return slides;
  };

  $scope.$watch('interval', restartTimer);
  function restartTimer() {
    if (currentTimeout) {
      $timeout.cancel(currentTimeout);
    }
    function go() {
      if (isPlaying) {
        $scope.next();
        restartTimer();
      } else {
        $scope.pause();
      }
    }
    var interval = +$scope.interval;
    if (!isNaN(interval) && interval>=0) {
      currentTimeout = $timeout(go, interval);
    }
  }
  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };
  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      if (currentTimeout) {
        $timeout.cancel(currentTimeout);
      }
    }
  };

  self.addSlide = function(slide, element) {
    slide.$element = element;
    slides.push(slide);
    //if this is the first slide or the slide is set to active, select it
    if(slides.length === 1 || slide.active) {
      self.select(slides[slides.length-1]);
      if (slides.length == 1) {
        $scope.play();
      }
    } else {
      slide.active = false;
    }
  };

  self.removeSlide = function(slide) {
    //get the index of the slide inside the carousel
    var index = slides.indexOf(slide);
    slides.splice(index, 1);
    if (slides.length > 0 && slide.active) {
      if (index >= slides.length) {
        self.select(slides[index-1]);
      } else {
        self.select(slides[index]);
      }
    } else if (currentIndex > index) {
      currentIndex--;
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:carousel
 * @restrict EA
 *
 * @description
 * Carousel is the outer container for a set of image 'slides' to showcase.
 *
 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <carousel>
      <slide>
        <img src="http://placekitten.com/150/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>Beautiful!</p>
        </div>
      </slide>
      <slide>
        <img src="http://placekitten.com/100/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>D'aww!</p>
        </div>
      </slide>
    </carousel>
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
 */
.directive('carousel', [function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    controller: 'CarouselController',
    require: 'carousel',
    templateUrl: 'template/carousel/carousel.html',
    scope: {
      interval: '=',
      noTransition: '=',
      noPause: '='
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:slide
 * @restrict EA
 *
 * @description
 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
 *
 * @param {boolean=} active Model binding, whether or not this slide is currently active.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
<div ng-controller="CarouselDemoCtrl">
  <carousel>
    <slide ng-repeat="slide in slides" active="slide.active">
      <img ng-src="{{slide.image}}" style="margin:auto;">
      <div class="carousel-caption">
        <h4>Slide {{$index}}</h4>
        <p>{{slide.text}}</p>
      </div>
    </slide>
  </carousel>
  <div class="row-fluid">
    <div class="span6">
      <ul>
        <li ng-repeat="slide in slides">
          <button class="btn btn-mini" ng-class="{'btn-info': !slide.active, 'btn-success': slide.active}" ng-disabled="slide.active" ng-click="slide.active = true">select</button>
          {{$index}}: {{slide.text}}
        </li>
      </ul>
      <a class="btn" ng-click="addSlide()">Add Slide</a>
    </div>
    <div class="span6">
      Interval, in milliseconds: <input type="number" ng-model="myInterval">
      <br />Enter a negative number to stop the interval.
    </div>
  </div>
</div>
  </file>
  <file name="script.js">
function CarouselDemoCtrl($scope) {
  $scope.myInterval = 5000;
  var slides = $scope.slides = [];
  $scope.addSlide = function() {
    var newWidth = 200 + ((slides.length + (25 * slides.length)) % 150);
    slides.push({
      image: 'http://placekitten.com/' + newWidth + '/200',
      text: ['More','Extra','Lots of','Surplus'][slides.length % 4] + ' '
        ['Cats', 'Kittys', 'Felines', 'Cutes'][slides.length % 4]
    });
  };
  for (var i=0; i<4; i++) $scope.addSlide();
}
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
*/

.directive('slide', ['$parse', function($parse) {
  return {
    require: '^carousel',
    restrict: 'EA',
    transclude: true,
    replace: true,
    templateUrl: 'template/carousel/slide.html',
    scope: {
    },
    link: function (scope, element, attrs, carouselCtrl) {
      //Set up optional 'active' = binding
      if (attrs.active) {
        var getActive = $parse(attrs.active);
        var setActive = getActive.assign;
        var lastValue = scope.active = getActive(scope.$parent);
        scope.$watch(function parentActiveWatch() {
          var parentActive = getActive(scope.$parent);

          if (parentActive !== scope.active) {
            // we are out of sync and need to copy
            if (parentActive !== lastValue) {
              // parent changed and it has precedence
              lastValue = scope.active = parentActive;
            } else {
              // if the parent can be assigned then do so
              setActive(scope.$parent, parentActive = lastValue = scope.active);
            }
          }
          return parentActive;
        });
      }

      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
}]);

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$position', ['$document', '$window', function ($document, $window) {

    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, "position") || 'static' ) === 'static';
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function (element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
      position: function (element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        return {
          width: element.prop('offsetWidth'),
          height: element.prop('offsetHeight'),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
      offset: function (element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: element.prop('offsetWidth'),
          height: element.prop('offsetHeight'),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft  || $document[0].documentElement.scrollLeft)
        };
      }
    };
  }]);

angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.position'])

.constant('datepickerConfig', {
  dayFormat: 'dd',
  monthFormat: 'MMMM',
  yearFormat: 'yyyy',
  dayHeaderFormat: 'EEE',
  dayTitleFormat: 'MMMM yyyy',
  monthTitleFormat: 'yyyy',
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null
})

.controller('DatepickerController', ['$scope', '$attrs', 'dateFilter', 'datepickerConfig', function($scope, $attrs, dateFilter, dtConfig) {
  var format = {
    day:        getValue($attrs.dayFormat,        dtConfig.dayFormat),
    month:      getValue($attrs.monthFormat,      dtConfig.monthFormat),
    year:       getValue($attrs.yearFormat,       dtConfig.yearFormat),
    dayHeader:  getValue($attrs.dayHeaderFormat,  dtConfig.dayHeaderFormat),
    dayTitle:   getValue($attrs.dayTitleFormat,   dtConfig.dayTitleFormat),
    monthTitle: getValue($attrs.monthTitleFormat, dtConfig.monthTitleFormat)
  },
  startingDay = getValue($attrs.startingDay,      dtConfig.startingDay),
  yearRange =   getValue($attrs.yearRange,        dtConfig.yearRange);

  this.minDate = dtConfig.minDate ? new Date(dtConfig.minDate) : null;
  this.maxDate = dtConfig.maxDate ? new Date(dtConfig.maxDate) : null;

  function getValue(value, defaultValue) {
    return angular.isDefined(value) ? $scope.$parent.$eval(value) : defaultValue;
  }

  function getDaysInMonth( year, month ) {
    return new Date(year, month, 0).getDate();
  }

  function getDates(startDate, n) {
    var dates = new Array(n);
    var current = startDate, i = 0;
    while (i < n) {
      dates[i++] = new Date(current);
      current.setDate( current.getDate() + 1 );
    }
    return dates;
  }

  function makeDate(date, format, isSelected, isSecondary) {
    return { date: date, label: dateFilter(date, format), selected: !!isSelected, secondary: !!isSecondary };
  }

  this.modes = [
    {
      name: 'day',
      getVisibleDates: function(date, selected) {
        var year = date.getFullYear(), month = date.getMonth(), firstDayOfMonth = new Date(year, month, 1);
        var difference = startingDay - firstDayOfMonth.getDay(),
        numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
        firstDate = new Date(firstDayOfMonth), numDates = 0;

        if ( numDisplayedFromPreviousMonth > 0 ) {
          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );
          numDates += numDisplayedFromPreviousMonth; // Previous
        }
        numDates += getDaysInMonth(year, month + 1); // Current
        numDates += (7 - numDates % 7) % 7; // Next

        var days = getDates(firstDate, numDates), labels = new Array(7);
        for (var i = 0; i < numDates; i ++) {
          var dt = new Date(days[i]);
          days[i] = makeDate(dt, format.day, (selected && selected.getDate() === dt.getDate() && selected.getMonth() === dt.getMonth() && selected.getFullYear() === dt.getFullYear()), dt.getMonth() !== month);
        }
        for (var j = 0; j < 7; j++) {
          labels[j] = dateFilter(days[j].date, format.dayHeader);
        }
        return { objects: days, title: dateFilter(date, format.dayTitle), labels: labels };
      },
      compare: function(date1, date2) {
        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );
      },
      split: 7,
      step: { months: 1 }
    },
    {
      name: 'month',
      getVisibleDates: function(date, selected) {
        var months = new Array(12), year = date.getFullYear();
        for ( var i = 0; i < 12; i++ ) {
          var dt = new Date(year, i, 1);
          months[i] = makeDate(dt, format.month, (selected && selected.getMonth() === i && selected.getFullYear() === year));
        }
        return { objects: months, title: dateFilter(date, format.monthTitle) };
      },
      compare: function(date1, date2) {
        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );
      },
      split: 3,
      step: { years: 1 }
    },
    {
      name: 'year',
      getVisibleDates: function(date, selected) {
        var years = new Array(yearRange), year = date.getFullYear(), startYear = parseInt((year - 1) / yearRange, 10) * yearRange + 1;
        for ( var i = 0; i < yearRange; i++ ) {
          var dt = new Date(startYear + i, 0, 1);
          years[i] = makeDate(dt, format.year, (selected && selected.getFullYear() === dt.getFullYear()));
        }
        return { objects: years, title: [years[0].label, years[yearRange - 1].label].join(' - ') };
      },
      compare: function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      },
      split: 5,
      step: { years: yearRange }
    }
  ];

  this.isDisabled = function(date, mode) {
    var currentMode = this.modes[mode || 0];
    return ((this.minDate && currentMode.compare(date, this.minDate) < 0) || (this.maxDate && currentMode.compare(date, this.maxDate) > 0) || ($scope.dateDisabled && $scope.dateDisabled({date: date, mode: currentMode.name})));
  };
}])

.directive( 'datepicker', ['dateFilter', '$parse', 'datepickerConfig', '$log', function (dateFilter, $parse, datepickerConfig, $log) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/datepicker.html',
    scope: {
      dateDisabled: '&'
    },
    require: ['datepicker', '?^ngModel'],
    controller: 'DatepickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModel = ctrls[1];

      if (!ngModel) {
        return; // do nothing if no ng-model
      }

      // Configuration parameters
      var mode = 0, selected = new Date(), showWeeks = datepickerConfig.showWeeks;

      if (attrs.showWeeks) {
        scope.$parent.$watch($parse(attrs.showWeeks), function(value) {
          showWeeks = !! value;
          updateShowWeekNumbers();
        });
      } else {
        updateShowWeekNumbers();
      }

      if (attrs.min) {
        scope.$parent.$watch($parse(attrs.min), function(value) {
          datepickerCtrl.minDate = value ? new Date(value) : null;
          refill();
        });
      }
      if (attrs.max) {
        scope.$parent.$watch($parse(attrs.max), function(value) {
          datepickerCtrl.maxDate = value ? new Date(value) : null;
          refill();
        });
      }

      function updateShowWeekNumbers() {
        scope.showWeekNumbers = mode === 0 && showWeeks;
      }

      // Split array into smaller arrays
      function split(arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      }

      function refill( updateSelected ) {
        var date = null, valid = true;

        if ( ngModel.$modelValue ) {
          date = new Date( ngModel.$modelValue );

          if ( isNaN(date) ) {
            valid = false;
            $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
          } else if ( updateSelected ) {
            selected = date;
          }
        }
        ngModel.$setValidity('date', valid);

        var currentMode = datepickerCtrl.modes[mode], data = currentMode.getVisibleDates(selected, date);
        angular.forEach(data.objects, function(obj) {
          obj.disabled = datepickerCtrl.isDisabled(obj.date, mode);
        });

        ngModel.$setValidity('date-disabled', (!date || !datepickerCtrl.isDisabled(date)));

        scope.rows = split(data.objects, currentMode.split);
        scope.labels = data.labels || [];
        scope.title = data.title;
      }

      function setMode(value) {
        mode = value;
        updateShowWeekNumbers();
        refill();
      }

      ngModel.$render = function() {
        refill( true );
      };

      scope.select = function( date ) {
        if ( mode === 0 ) {
          var dt = new Date( ngModel.$modelValue );
          dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );
          ngModel.$setViewValue( dt );
          refill( true );
        } else {
          selected = date;
          setMode( mode - 1 );
        }
      };
      scope.move = function(direction) {
        var step = datepickerCtrl.modes[mode].step;
        selected.setMonth( selected.getMonth() + direction * (step.months || 0) );
        selected.setFullYear( selected.getFullYear() + direction * (step.years || 0) );
        refill();
      };
      scope.toggleMode = function() {
        setMode( (mode + 1) % datepickerCtrl.modes.length );
      };
      scope.getWeekNumber = function(row) {
        return ( mode === 0 && scope.showWeekNumbers && row.length === 7 ) ? getISO8601WeekNumber(row[0].date) : null;
      };

      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }
    }
  };
}])

.constant('datepickerPopupConfig', {
  dateFormat: 'yyyy-MM-dd',
  closeOnDateSelection: true
})

.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'datepickerPopupConfig',
function ($compile, $parse, $document, $position, dateFilter, datepickerPopupConfig) {
  return {
    restrict: 'EA',
    require: 'ngModel',
    link: function(originalScope, element, attrs, ngModel) {

      var closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
      var dateFormat = attrs.datepickerPopup || datepickerPopupConfig.dateFormat;

     // create a child scope for the datepicker directive so we are not polluting original scope
      var scope = originalScope.$new();
      originalScope.$on('$destroy', function() {
        scope.$destroy();
      });

      var getIsOpen, setIsOpen;
      if ( attrs.isOpen ) {
        getIsOpen = $parse(attrs.isOpen);
        setIsOpen = getIsOpen.assign;

        originalScope.$watch(getIsOpen, function updateOpen(value) {
          scope.isOpen = !! value;
        });
      }
      scope.isOpen = getIsOpen ? getIsOpen(originalScope) : false; // Initial state

      function setOpen( value ) {
        if (setIsOpen) {
          setIsOpen(originalScope, !!value);
        } else {
          scope.isOpen = !!value;
        }
      }

      var documentClickBind = function(event) {
        if (scope.isOpen && event.target !== element[0]) {
          scope.$apply(function() {
            setOpen(false);
          });
        }
      };

      var elementFocusBind = function() {
        scope.$apply(function() {
          setOpen( true );
        });
      };

      // popup element used to display calendar
      var popupEl = angular.element('<datepicker-popup-wrap><datepicker></datepicker></datepicker-popup-wrap>');
      popupEl.attr({
        'ng-model': 'date',
        'ng-change': 'dateSelection()'
      });
      var datepickerEl = popupEl.find('datepicker');
      if (attrs.datepickerOptions) {
        datepickerEl.attr(angular.extend({}, originalScope.$eval(attrs.datepickerOptions)));
      }

      // TODO: reverse from dateFilter string to Date object
      function parseDate(viewValue) {
        if (!viewValue) {
          ngModel.$setValidity('date', true);
          return null;
        } else if (angular.isDate(viewValue)) {
          ngModel.$setValidity('date', true);
          return viewValue;
        } else if (angular.isString(viewValue)) {
          var date = new Date(viewValue);
          if (isNaN(date)) {
            ngModel.$setValidity('date', false);
            return undefined;
          } else {
            ngModel.$setValidity('date', true);
            return date;
          }
        } else {
          ngModel.$setValidity('date', false);
          return undefined;
        }
      }
      ngModel.$parsers.unshift(parseDate);

      // Inner change
      scope.dateSelection = function() {
        ngModel.$setViewValue(scope.date);
        ngModel.$render();

        if (closeOnDateSelection) {
          setOpen( false );
        }
      };

      element.bind('input change keyup', function() {
        scope.$apply(function() {
          updateCalendar();
        });
      });

      // Outter change
      ngModel.$render = function() {
        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';
        element.val(date);

        updateCalendar();
      };

      function updateCalendar() {
        scope.date = ngModel.$modelValue;
        updatePosition();
      }

      function addWatchableAttribute(attribute, scopeProperty, datepickerAttribute) {
        if (attribute) {
          originalScope.$watch($parse(attribute), function(value){
            scope[scopeProperty] = value;
          });
          datepickerEl.attr(datepickerAttribute || scopeProperty, scopeProperty);
        }
      }
      addWatchableAttribute(attrs.min, 'min');
      addWatchableAttribute(attrs.max, 'max');
      if (attrs.showWeeks) {
        addWatchableAttribute(attrs.showWeeks, 'showWeeks', 'show-weeks');
      } else {
        scope.showWeeks = true;
        datepickerEl.attr('show-weeks', 'showWeeks');
      }
      if (attrs.dateDisabled) {
        datepickerEl.attr('date-disabled', attrs.dateDisabled);
      }

      function updatePosition() {
        scope.position = $position.position(element);
        scope.position.top = scope.position.top + element.prop('offsetHeight');
      }

      var documentBindingInitialized = false, elementFocusInitialized = false;
      scope.$watch('isOpen', function(value) {
        if (value) {
          updatePosition();
          $document.bind('click', documentClickBind);
          if(elementFocusInitialized) {
            element.unbind('focus', elementFocusBind);
          }
          element[0].focus();
          documentBindingInitialized = true;
        } else {
          if(documentBindingInitialized) {
            $document.unbind('click', documentClickBind);
          }
          element.bind('focus', elementFocusBind);
          elementFocusInitialized = true;
        }

        if ( setIsOpen ) {
          setIsOpen(originalScope, value);
        }
      });

      var $setModelValue = $parse(attrs.ngModel).assign;

      scope.today = function() {
        $setModelValue(originalScope, new Date());
      };
      scope.clear = function() {
        $setModelValue(originalScope, null);
      };

      element.after($compile(popupEl)(scope));
    }
  };
}])

.directive('datepickerPopupWrap', [function() {
  return {
    restrict:'E',
    replace: true,
    transclude: true,
    templateUrl: 'template/datepicker/popup.html',
    link:function (scope, element, attrs) {
      element.bind('click', function(event) {
        event.preventDefault();
        event.stopPropagation();
      });
    }
  };
}]);

/*
 * dropdownToggle - Provides dropdown menu functionality in place of bootstrap js
 * @restrict class or attribute
 * @example:
   <li class="dropdown">
     <a class="dropdown-toggle">My Dropdown Menu</a>
     <ul class="dropdown-menu">
       <li ng-repeat="choice in dropChoices">
         <a ng-href="{{choice.href}}">{{choice.text}}</a>
       </li>
     </ul>
   </li>
 */

angular.module('ui.bootstrap.dropdownToggle', []).directive('dropdownToggle', ['$document', '$location', function ($document, $location) {
  var openElement = null,
      closeMenu   = angular.noop;
  return {
    restrict: 'CA',
    link: function(scope, element, attrs) {
      scope.$watch('$location.path', function() { closeMenu(); });
      element.parent().bind('click', function() { closeMenu(); });
      element.bind('click', function (event) {

        var elementWasOpen = (element === openElement);

        event.preventDefault();
        event.stopPropagation();

        if (!!openElement) {
          closeMenu();
        }

        if (!elementWasOpen) {
          element.parent().addClass('open');
          openElement = element;
          closeMenu = function (event) {
            if (event) {
              event.preventDefault();
              event.stopPropagation();
            }
            $document.unbind('click', closeMenu);
            element.parent().removeClass('open');
            closeMenu = angular.noop;
            openElement = null;
          };
          $document.bind('click', closeMenu);
        }
      });
    }
  };
}]);
angular.module('ui.bootstrap.modal', [])

/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function () {
    return {
      createNew: function () {
        var stack = [];

        return {
          add: function (key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function (key) {
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function () {
            return stack[stack.length - 1];
          },
          remove: function (key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function () {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function () {
            return stack.length;
          }
        };
      }
    };
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('modalBackdrop', ['$modalStack', '$timeout', function ($modalStack, $timeout) {
    return {
      restrict: 'EA',
      replace: true,
      templateUrl: 'template/modal/backdrop.html',
      link: function (scope, element, attrs) {

        //trigger CSS transitions
        $timeout(function () {
          scope.animate = true;
        });

        scope.close = function (evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop && modal.value.backdrop != 'static') {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };
      }
    };
  }])

  .directive('modalWindow', ['$timeout', function ($timeout) {
    return {
      restrict: 'EA',
      scope: {
        index: '@'
      },
      replace: true,
      transclude: true,
      templateUrl: 'template/modal/window.html',
      link: function (scope, element, attrs) {
        scope.windowClass = attrs.windowClass || '';

        //trigger CSS transitions
        $timeout(function () {
          scope.animate = true;
        });
      }
    };
  }])

  .factory('$modalStack', ['$document', '$compile', '$rootScope', '$$stackedMap',
    function ($document, $compile, $rootScope, $$stackedMap) {

      var backdropjqLiteEl, backdropDomEl;
      var backdropScope = $rootScope.$new(true);
      var body = $document.find('body').eq(0);
      var openedWindows = $$stackedMap.createNew();
      var $modalStack = {};

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex){
        backdropScope.index = newBackdropIndex;
      });

      function removeModalWindow(modalInstance) {

        var modalWindow = openedWindows.get(modalInstance).value;

        //clean up the stack
        openedWindows.remove(modalInstance);

        //remove window DOM element
        modalWindow.modalDomEl.remove();

        //remove backdrop if no longer needed
        if (backdropIndex() == -1) {
          backdropDomEl.remove();
          backdropDomEl = undefined;
        }

        //destroy scope
        modalWindow.modalScope.$destroy();
      }

      $document.bind('keydown', function (evt) {
        var modal;

        if (evt.which === 27) {
          modal = openedWindows.top();
          if (modal && modal.value.keyboard) {
            $rootScope.$apply(function () {
              $modalStack.dismiss(modal.key);
            });
          }
        }
      });

      $modalStack.open = function (modalInstance, modal) {

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard
        });

        var angularDomEl = angular.element('<div modal-window></div>');
        angularDomEl.attr('window-class', modal.windowClass);
        angularDomEl.attr('index', openedWindows.length() - 1);
        angularDomEl.html(modal.content);

        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        body.append(modalDomEl);

        if (backdropIndex() >= 0 && !backdropDomEl) {
            backdropjqLiteEl = angular.element('<div modal-backdrop></div>');
            backdropDomEl = $compile(backdropjqLiteEl)(backdropScope);
            body.append(backdropDomEl);
        }
      };

      $modalStack.close = function (modalInstance, result) {
        var modal = openedWindows.get(modalInstance);
        if (modal) {
          modal.value.deferred.resolve(result);
          removeModalWindow(modalInstance);
        }
      };

      $modalStack.dismiss = function (modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance).value;
        if (modalWindow) {
          modalWindow.deferred.reject(reason);
          removeModalWindow(modalInstance);
        }
      };

      $modalStack.getTop = function () {
        return openedWindows.top();
      };

      return $modalStack;
    }])

  .provider('$modal', function () {

    var $modalProvider = {
      options: {
        backdrop: true, //can be also false or 'static'
        keyboard: true
      },
      $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack',
        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {

          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $http.get(options.templateUrl, {cache: $templateCache}).then(function (result) {
                return result.data;
              });
          }

          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function (value, key) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              }
            });
            return promisesArr;
          }

          $modal.open = function (modalOptions) {

            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              close: function (result) {
                $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};

            //verify options
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }

            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));


            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {

              var modalScope = (modalOptions.scope || $rootScope).$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;

              var ctrlInstance, ctrlLocals = {};
              var resolveIter = 1;

              //controllers
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$modalInstance = modalInstance;
                angular.forEach(modalOptions.resolve, function (value, key) {
                  ctrlLocals[key] = tplAndVars[resolveIter++];
                });

                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
              }

              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                content: tplAndVars[0],
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                windowClass: modalOptions.windowClass
              });

            }, function resolveError(reason) {
              modalResultDeferred.reject(reason);
            });

            templateAndResolvePromise.then(function () {
              modalOpenedDeferred.resolve(true);
            }, function () {
              modalOpenedDeferred.reject(false);
            });

            return modalInstance;
          };

          return $modal;
        }]
    };

    return $modalProvider;
  });
angular.module('ui.bootstrap.pagination', [])

.controller('PaginationController', ['$scope', '$attrs', '$parse', '$interpolate', function ($scope, $attrs, $parse, $interpolate) {
  var self = this;

  this.init = function(defaultItemsPerPage) {
    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = defaultItemsPerPage;
    }
  };

  this.noPrevious = function() {
    return this.page === 1;
  };
  this.noNext = function() {
    return this.page === $scope.totalPages;
  };

  this.isActive = function(page) {
    return this.page === page;
  };

  this.calculateTotalPages = function() {
    return this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
  };

  this.getAttributeValue = function(attribute, defaultValue, interpolate) {
    return angular.isDefined(attribute) ? (interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute)) : defaultValue;
  };

  this.render = function() {
    this.page = parseInt($scope.page, 10) || 1;
    $scope.pages = this.getPages(this.page, $scope.totalPages);
  };

  $scope.selectPage = function(page) {
    if ( ! self.isActive(page) && page > 0 && page <= $scope.totalPages) {
      $scope.page = page;
      $scope.onSelectPage({ page: page });
    }
  };

  $scope.$watch('totalItems', function() {
    $scope.totalPages = self.calculateTotalPages();
  });

  $scope.$watch('totalPages', function(value) {
    if ( $attrs.numPages ) {
      $scope.numPages = value; // Readonly variable
    }

    if ( self.page > value ) {
      $scope.selectPage(value);
    } else {
      self.render();
    }
  });

  $scope.$watch('page', function() {
    self.render();
  });
}])

.constant('paginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
})

.directive('pagination', ['$parse', 'paginationConfig', function($parse, config) {
  return {
    restrict: 'EA',
    scope: {
      page: '=',
      totalItems: '=',
      onSelectPage:' &',
      numPages: '='
    },
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pagination.html',
    replace: true,
    link: function(scope, element, attrs, paginationCtrl) {

      // Setup configuration parameters
      var maxSize,
      boundaryLinks  = paginationCtrl.getAttributeValue(attrs.boundaryLinks,  config.boundaryLinks      ),
      directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks     ),
      firstText      = paginationCtrl.getAttributeValue(attrs.firstText,      config.firstText,     true),
      previousText   = paginationCtrl.getAttributeValue(attrs.previousText,   config.previousText,  true),
      nextText       = paginationCtrl.getAttributeValue(attrs.nextText,       config.nextText,      true),
      lastText       = paginationCtrl.getAttributeValue(attrs.lastText,       config.lastText,      true),
      rotate         = paginationCtrl.getAttributeValue(attrs.rotate,         config.rotate);

      paginationCtrl.init(config.itemsPerPage);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive, isDisabled) {
        return {
          number: number,
          text: text,
          active: isActive,
          disabled: isDisabled
        };
      }

      paginationCtrl.getPages = function(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );

        // recompute if maxSize
        if ( isMaxSized ) {
          if ( rotate ) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, paginationCtrl.isActive(number), false);
          pages.push(page);
        }

        // Add links to move between page sets
        if ( isMaxSized && ! rotate ) {
          if ( startPage > 1 ) {
            var previousPageSet = makePage(startPage - 1, '...', false, false);
            pages.unshift(previousPageSet);
          }

          if ( endPage < totalPages ) {
            var nextPageSet = makePage(endPage + 1, '...', false, false);
            pages.push(nextPageSet);
          }
        }

        // Add previous & next links
        if (directionLinks) {
          var previousPage = makePage(currentPage - 1, previousText, false, paginationCtrl.noPrevious());
          pages.unshift(previousPage);

          var nextPage = makePage(currentPage + 1, nextText, false, paginationCtrl.noNext());
          pages.push(nextPage);
        }

        // Add first & last links
        if (boundaryLinks) {
          var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());
          pages.unshift(firstPage);

          var lastPage = makePage(totalPages, lastText, false, paginationCtrl.noNext());
          pages.push(lastPage);
        }

        return pages;
      };
    }
  };
}])

.constant('pagerConfig', {
  itemsPerPage: 10,
  previousText: ' Previous',
  nextText: 'Next ',
  align: true
})

.directive('pager', ['pagerConfig', function(config) {
  return {
    restrict: 'EA',
    scope: {
      page: '=',
      totalItems: '=',
      onSelectPage:' &',
      numPages: '='
    },
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pager.html',
    replace: true,
    link: function(scope, element, attrs, paginationCtrl) {

      // Setup configuration parameters
      var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),
      nextText         = paginationCtrl.getAttributeValue(attrs.nextText,     config.nextText,     true),
      align            = paginationCtrl.getAttributeValue(attrs.align,        config.align);

      paginationCtrl.init(config.itemsPerPage);

      // Create page object used in template
      function makePage(number, text, isDisabled, isPrevious, isNext) {
        return {
          number: number,
          text: text,
          disabled: isDisabled,
          previous: ( align && isPrevious ),
          next: ( align && isNext )
        };
      }

      paginationCtrl.getPages = function(currentPage) {
        return [
          makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false),
          makePage(currentPage + 1, nextText, paginationCtrl.noNext(), false, true)
        ];
      };
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position', 'ui.bootstrap.bindHtml' ] )

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider( '$tooltip', function () {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    animation: true,
    popupDelay: 0
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'focus': 'blur'
  };

  // The options specified to the provider globally.
  var globalOptions = {};
  
  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function( value ) {
		angular.extend( globalOptions, value );
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
   */
  this.setTriggers = function setTriggers ( triggers ) {
    angular.extend( triggerMap, triggers );
  };

  /**
   * This is a helper function for translating camel-case to snake-case.
   */
  function snake_case(name){
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {
    return function $tooltip ( type, prefix, defaultTriggerShow ) {
      var options = angular.extend( {}, defaultOptions, globalOptions );

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers ( trigger ) {
        var show = trigger || options.trigger || defaultTriggerShow;
        var hide = triggerMap[show] || show;
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case( type );

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template = 
        '<'+ directiveName +'-popup '+
          'title="'+startSym+'tt_title'+endSym+'" '+
          'content="'+startSym+'tt_content'+endSym+'" '+
          'placement="'+startSym+'tt_placement'+endSym+'" '+
          'animation="tt_animation()" '+
          'is-open="tt_isOpen"'+
          '>'+
        '</'+ directiveName +'-popup>';

      return {
        restrict: 'EA',
        scope: true,
        link: function link ( scope, element, attrs ) {
          var tooltip = $compile( template )( scope );
          var transitionTimeout;
          var popupTimeout;
          var $body;
          var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;
          var triggers = getTriggers( undefined );
          var hasRegisteredTriggers = false;

          // By default, the tooltip is not open.
          // TODO add ability to start tooltip opened
          scope.tt_isOpen = false;

          function toggleTooltipBind () {
            if ( ! scope.tt_isOpen ) {
              showTooltipBind();
            } else {
              hideTooltipBind();
            }
          }
          
          // Show the tooltip with delay if specified, otherwise show it immediately
          function showTooltipBind() {
            if ( scope.tt_popupDelay ) {
              popupTimeout = $timeout( show, scope.tt_popupDelay );
            } else {
              scope.$apply( show );
            }
          }

          function hideTooltipBind () {
            scope.$apply(function () {
              hide();
            });
          }
          
          // Show the tooltip popup element.
          function show() {
            var position,
                ttWidth,
                ttHeight,
                ttPosition;

            // Don't show empty tooltips.
            if ( ! scope.tt_content ) {
              return;
            }

            // If there is a pending remove transition, we must cancel it, lest the
            // tooltip be mysteriously removed.
            if ( transitionTimeout ) {
              $timeout.cancel( transitionTimeout );
            }
            
            // Set the initial positioning.
            tooltip.css({ top: 0, left: 0, display: 'block' });
            
            // Now we add it to the DOM because need some info about it. But it's not 
            // visible yet anyway.
            if ( appendToBody ) {
                $body = $body || $document.find( 'body' );
                $body.append( tooltip );
            } else {
              element.after( tooltip );
            }

            // Get the position of the directive element.
            position = appendToBody ? $position.offset( element ) : $position.position( element );

            // Get the height and width of the tooltip so we can center it.
            ttWidth = tooltip.prop( 'offsetWidth' );
            ttHeight = tooltip.prop( 'offsetHeight' );
            
            // Calculate the tooltip's top and left coordinates to center it with
            // this directive.
            switch ( scope.tt_placement ) {
              case 'right':
                ttPosition = {
                  top: position.top + position.height / 2 - ttHeight / 2,
                  left: position.left + position.width
                };
                break;
              case 'bottom':
                ttPosition = {
                  top: position.top + position.height,
                  left: position.left + position.width / 2 - ttWidth / 2
                };
                break;
              case 'left':
                ttPosition = {
                  top: position.top + position.height / 2 - ttHeight / 2,
                  left: position.left - ttWidth
                };
                break;
              default:
                ttPosition = {
                  top: position.top - ttHeight,
                  left: position.left + position.width / 2 - ttWidth / 2
                };
                break;
            }

            ttPosition.top += 'px';
            ttPosition.left += 'px';

            // Now set the calculated positioning.
            tooltip.css( ttPosition );
              
            // And show the tooltip.
            scope.tt_isOpen = true;
          }
          
          // Hide the tooltip popup element.
          function hide() {
            // First things first: we don't show it anymore.
            scope.tt_isOpen = false;

            //if tooltip is going to be shown after delay, we must cancel this
            $timeout.cancel( popupTimeout );
            
            // And now we remove it from the DOM. However, if we have animation, we 
            // need to wait for it to expire beforehand.
            // FIXME: this is a placeholder for a port of the transitions library.
            if ( angular.isDefined( scope.tt_animation ) && scope.tt_animation() ) {
              transitionTimeout = $timeout( function () { tooltip.remove(); }, 500 );
            } else {
              tooltip.remove();
            }
          }

          /**
           * Observe the relevant attributes.
           */
          attrs.$observe( type, function ( val ) {
            scope.tt_content = val;
          });

          attrs.$observe( prefix+'Title', function ( val ) {
            scope.tt_title = val;
          });

          attrs.$observe( prefix+'Placement', function ( val ) {
            scope.tt_placement = angular.isDefined( val ) ? val : options.placement;
          });

          attrs.$observe( prefix+'Animation', function ( val ) {
            scope.tt_animation = angular.isDefined( val ) ? $parse( val ) : function(){ return options.animation; };
          });

          attrs.$observe( prefix+'PopupDelay', function ( val ) {
            var delay = parseInt( val, 10 );
            scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;
          });

          attrs.$observe( prefix+'Trigger', function ( val ) {

            if (hasRegisteredTriggers) {
              element.unbind( triggers.show, showTooltipBind );
              element.unbind( triggers.hide, hideTooltipBind );
            }

            triggers = getTriggers( val );

            if ( triggers.show === triggers.hide ) {
              element.bind( triggers.show, toggleTooltipBind );
            } else {
              element.bind( triggers.show, showTooltipBind );
              element.bind( triggers.hide, hideTooltipBind );
            }

            hasRegisteredTriggers = true;
          });

          attrs.$observe( prefix+'AppendToBody', function ( val ) {
            appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;
          });

          // if a tooltip is attached to <body> we need to remove it on
          // location change as its parent scope will probably not be destroyed
          // by the change.
          if ( appendToBody ) {
            scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {
            if ( scope.tt_isOpen ) {
              hide();
            }
          });
          }

          // Make sure tooltip is destroyed and removed.
          scope.$on('$destroy', function onDestroyTooltip() {
            if ( scope.tt_isOpen ) {
              hide();
            } else {
              tooltip.remove();
            }
          });
        }
      };
    };
  }];
})

.directive( 'tooltipPopup', function () {
  return {
    restrict: 'E',
    replace: true,
    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-popup.html'
  };
})

.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );
}])

.directive( 'tooltipHtmlUnsafePopup', function () {
  return {
    restrict: 'E',
    replace: true,
    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
  };
})

.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html popovers, and selector delegatation.
 */
angular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )
.directive( 'popoverPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover.html'
  };
})
.directive( 'popover', [ '$compile', '$timeout', '$parse', '$window', '$tooltip', function ( $compile, $timeout, $parse, $window, $tooltip ) {
  return $tooltip( 'popover', 'popover', 'click' );
}]);


angular.module('ui.bootstrap.progressbar', ['ui.bootstrap.transition'])

.constant('progressConfig', {
  animate: true,
  autoType: false,
  stackedTypes: ['success', 'info', 'warning', 'danger']
})

.controller('ProgressBarController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {

    // Whether bar transitions should be animated
    var animate = angular.isDefined($attrs.animate) ? $scope.$eval($attrs.animate) : progressConfig.animate;
    var autoType = angular.isDefined($attrs.autoType) ? $scope.$eval($attrs.autoType) : progressConfig.autoType;
    var stackedTypes = angular.isDefined($attrs.stackedTypes) ? $scope.$eval('[' + $attrs.stackedTypes + ']') : progressConfig.stackedTypes;

    // Create bar object
    this.makeBar = function(newBar, oldBar, index) {
        var newValue = (angular.isObject(newBar)) ? newBar.value : (newBar || 0);
        var oldValue =  (angular.isObject(oldBar)) ? oldBar.value : (oldBar || 0);
        var type = (angular.isObject(newBar) && angular.isDefined(newBar.type)) ? newBar.type : (autoType) ? getStackedType(index || 0) : null;

        return {
            from: oldValue,
            to: newValue,
            type: type,
            animate: animate
        };
    };

    function getStackedType(index) {
        return stackedTypes[index];
    }

    this.addBar = function(bar) {
        $scope.bars.push(bar);
        $scope.totalPercent += bar.to;
    };

    this.clearBars = function() {
        $scope.bars = [];
        $scope.totalPercent = 0;
    };
    this.clearBars();
}])

.directive('progress', function() {
    return {
        restrict: 'EA',
        replace: true,
        controller: 'ProgressBarController',
        scope: {
            value: '=percent',
            onFull: '&',
            onEmpty: '&'
        },
        templateUrl: 'template/progressbar/progress.html',
        link: function(scope, element, attrs, controller) {
            scope.$watch('value', function(newValue, oldValue) {
                controller.clearBars();

                if (angular.isArray(newValue)) {
                    // Stacked progress bar
                    for (var i=0, n=newValue.length; i < n; i++) {
                        controller.addBar(controller.makeBar(newValue[i], oldValue[i], i));
                    }
                } else {
                    // Simple bar
                    controller.addBar(controller.makeBar(newValue, oldValue));
                }
            }, true);

            // Total percent listeners
            scope.$watch('totalPercent', function(value) {
              if (value >= 100) {
                scope.onFull();
              } else if (value <= 0) {
                scope.onEmpty();
              }
            }, true);
        }
    };
})

.directive('progressbar', ['$transition', function($transition) {
    return {
        restrict: 'EA',
        replace: true,
        scope: {
            width: '=',
            old: '=',
            type: '=',
            animate: '='
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function(scope, element) {
            scope.$watch('width', function(value) {
                if (scope.animate) {
                    element.css('width', scope.old + '%');
                    $transition(element, {width: value + '%'});
                } else {
                    element.css('width', value + '%');
                }
            });
        }
    };
}]);
angular.module('ui.bootstrap.rating', [])

.constant('ratingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null
})

.controller('RatingController', ['$scope', '$attrs', '$parse', 'ratingConfig', function($scope, $attrs, $parse, ratingConfig) {

  this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max;
  this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
  this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;

  this.createDefaultRange = function(len) {
    var defaultStateObject = {
      stateOn: this.stateOn,
      stateOff: this.stateOff
    };

    var states = new Array(len);
    for (var i = 0; i < len; i++) {
      states[i] = defaultStateObject;
    }
    return states;
  };

  this.normalizeRange = function(states) {
    for (var i = 0, n = states.length; i < n; i++) {
      states[i].stateOn = states[i].stateOn || this.stateOn;
      states[i].stateOff = states[i].stateOff || this.stateOff;
    }
    return states;
  };

  // Get objects used in template
  $scope.range = angular.isDefined($attrs.ratingStates) ?  this.normalizeRange(angular.copy($scope.$parent.$eval($attrs.ratingStates))): this.createDefaultRange(this.maxRange);

  $scope.rate = function(value) {
    if ( $scope.readonly || $scope.value === value) {
      return;
    }

    $scope.value = value;
  };

  $scope.enter = function(value) {
    if ( ! $scope.readonly ) {
      $scope.val = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.val = angular.copy($scope.value);
    $scope.onLeave();
  };

  $scope.$watch('value', function(value) {
    $scope.val = value;
  });

  $scope.readonly = false;
  if ($attrs.readonly) {
    $scope.$parent.$watch($parse($attrs.readonly), function(value) {
      $scope.readonly = !!value;
    });
  }
}])

.directive('rating', function() {
  return {
    restrict: 'EA',
    scope: {
      value: '=',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'RatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true
  };
});

/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module('ui.bootstrap.tabs', [])

.directive('tabs', function() {
  return function() {
    throw new Error("The `tabs` directive is deprecated, please migrate to `tabset`. Instructions can be found at http://github.com/angular-ui/bootstrap/tree/master/CHANGELOG.md");
  };
})

.controller('TabsetController', ['$scope', '$element',
function TabsetCtrl($scope, $element) {

  var ctrl = this,
    tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function(tab) {
    angular.forEach(tabs, function(tab) {
      tab.active = false;
    });
    tab.active = true;
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    if (tabs.length === 1 || tab.active) {
      ctrl.select(tab);
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected
    if (tab.active && tabs.length > 1) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {string=} direction  What direction the tabs should be rendered. Available:
 * 'right', 'left', 'below'.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab heading="Vertical Tab 1"><b>First</b> Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Content!</tab>
    </tabset>
    <hr />
    <tabset vertical="true">
      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
    </tabset>
  </file>
</example>
 */
.directive('tabset', function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    require: '^tabset',
    scope: {},
    controller: 'TabsetController',
    templateUrl: 'template/tabs/tabset.html',
    compile: function(elm, attrs, transclude) {
      return function(scope, element, attrs, tabsetCtrl) {
        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
        scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : 'tabs';
        scope.direction = angular.isDefined(attrs.direction) ? scope.$parent.$eval(attrs.direction) : 'top';
        scope.tabsAbove = (scope.direction != 'below');
        tabsetCtrl.$scope = scope;
        tabsetCtrl.$transcludeFn = transclude;
      };
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <div ng-controller="TabsDemoCtrl">
      <button class="btn btn-small" ng-click="items[0].active = true">
        Select item 1, using active binding
      </button>
      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
        Enable/disable item 2, using disabled binding
      </button>
      <br />
      <tabset>
        <tab heading="Tab 1">First Tab</tab>
        <tab select="alertMe()">
          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
          Second Tab, with alert callback and html heading!
        </tab>
        <tab ng-repeat="item in items"
          heading="{{item.title}}"
          disabled="item.disabled"
          active="item.active">
          {{item.content}}
        </tab>
      </tabset>
    </div>
  </file>
  <file name="script.js">
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert("You've selected the alert tab!");
        });
      };
    };
  </file>
</example>
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab>
        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
        And some content, too!
      </tab>
      <tab>
        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
        That's right.
      </tab>
    </tabset>
  </file>
</example>
 */
.directive('tab', ['$parse', '$http', '$templateCache', '$compile',
function($parse, $http, $templateCache, $compile) {
  return {
    require: '^tabset',
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/tabs/tab.html',
    transclude: true,
    scope: {
      heading: '@',
      onSelect: '&select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    compile: function(elm, attrs, transclude) {
      return function postLink(scope, elm, attrs, tabsetCtrl) {
        var getActive, setActive;
        if (attrs.active) {
          getActive = $parse(attrs.active);
          setActive = getActive.assign;
          scope.$parent.$watch(getActive, function updateActive(value) {
            scope.active = !!value;
          });
          scope.active = getActive(scope.$parent);
        } else {
          setActive = getActive = angular.noop;
        }

        scope.$watch('active', function(active) {
          setActive(scope.$parent, active);
          if (active) {
            tabsetCtrl.select(scope);
            scope.onSelect();
          } else {
            scope.onDeselect();
          }
        });

        scope.disabled = false;
        if ( attrs.disabled ) {
          scope.$parent.$watch($parse(attrs.disabled), function(value) {
            scope.disabled = !! value;
          });
        }

        scope.select = function() {
          if ( ! scope.disabled ) {
            scope.active = true;
          }
        };

        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function() {
          tabsetCtrl.removeTab(scope);
        });
        if (scope.active) {
          setActive(scope.$parent, true);
        }


        //We need to transclude later, once the content container is ready.
        //when this link happens, we're inside a tab heading.
        scope.$transcludeFn = transclude;
      };
    }
  };
}])

.directive('tabHeadingTransclude', [function() {
  return {
    restrict: 'A',
    require: '^tab',
    link: function(scope, elm, attrs, tabCtrl) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
}])

.directive('tabContentTransclude', ['$compile', '$parse', function($compile, $parse) {
  return {
    restrict: 'A',
    require: '^tabset',
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.tabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };
  function isTabHeading(node) {
    return node.tagName &&  (
      node.hasAttribute('tab-heading') ||
      node.hasAttribute('data-tab-heading') ||
      node.tagName.toLowerCase() === 'tab-heading' ||
      node.tagName.toLowerCase() === 'data-tab-heading'
    );
  }
}])

.directive('tabsetTitles', ['$http', function($http) {
  return {
    restrict: 'A',
    require: '^tabset',
    templateUrl: 'template/tabs/tabset-titles.html',
    replace: true,
    link: function(scope, elm, attrs, tabsetCtrl) {
      if (!scope.$eval(attrs.tabsetTitles)) {
        elm.remove();
      } else {
        //now that tabs location has been decided, transclude the tab titles in
        tabsetCtrl.$transcludeFn(tabsetCtrl.$scope.$parent, function(node) {
          elm.append(node);
        });
      }
    }
  };
}])

;


angular.module('ui.bootstrap.timepicker', [])

.constant('timepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: ['AM', 'PM'],
  readonlyInput: false,
  mousewheel: true
})

.directive('timepicker', ['$parse', '$log', 'timepickerConfig', function ($parse, $log, timepickerConfig) {
  return {
    restrict: 'EA',
    require:'?^ngModel',
    replace: true,
    scope: {},
    templateUrl: 'template/timepicker/timepicker.html',
    link: function(scope, element, attrs, ngModel) {
      if ( !ngModel ) {
        return; // do nothing if no ng-model
      }

      var selected = new Date(), meridians = timepickerConfig.meridians;

      var hourStep = timepickerConfig.hourStep;
      if (attrs.hourStep) {
        scope.$parent.$watch($parse(attrs.hourStep), function(value) {
          hourStep = parseInt(value, 10);
        });
      }

      var minuteStep = timepickerConfig.minuteStep;
      if (attrs.minuteStep) {
        scope.$parent.$watch($parse(attrs.minuteStep), function(value) {
          minuteStep = parseInt(value, 10);
        });
      }

      // 12H / 24H mode
      scope.showMeridian = timepickerConfig.showMeridian;
      if (attrs.showMeridian) {
        scope.$parent.$watch($parse(attrs.showMeridian), function(value) {
          scope.showMeridian = !!value;

          if ( ngModel.$error.time ) {
            // Evaluate from template
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            if (angular.isDefined( hours ) && angular.isDefined( minutes )) {
              selected.setHours( hours );
              refresh();
            }
          } else {
            updateTemplate();
          }
        });
      }

      // Get scope.hours in 24H mode if valid
      function getHoursFromTemplate ( ) {
        var hours = parseInt( scope.hours, 10 );
        var valid = ( scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
        if ( !valid ) {
          return undefined;
        }

        if ( scope.showMeridian ) {
          if ( hours === 12 ) {
            hours = 0;
          }
          if ( scope.meridian === meridians[1] ) {
            hours = hours + 12;
          }
        }
        return hours;
      }

      function getMinutesFromTemplate() {
        var minutes = parseInt(scope.minutes, 10);
        return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;
      }

      function pad( value ) {
        return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value;
      }

      // Input elements
      var inputs = element.find('input'), hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1);

      // Respond on mousewheel spin
      var mousewheel = (angular.isDefined(attrs.mousewheel)) ? scope.$eval(attrs.mousewheel) : timepickerConfig.mousewheel;
      if ( mousewheel ) {

        var isScrollingUp = function(e) {
          if (e.originalEvent) {
            e = e.originalEvent;
          }
          //pick correct delta variable depending on event
          var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
          return (e.detail || delta > 0);
        };

        hoursInputEl.bind('mousewheel wheel', function(e) {
          scope.$apply( (isScrollingUp(e)) ? scope.incrementHours() : scope.decrementHours() );
          e.preventDefault();
        });

        minutesInputEl.bind('mousewheel wheel', function(e) {
          scope.$apply( (isScrollingUp(e)) ? scope.incrementMinutes() : scope.decrementMinutes() );
          e.preventDefault();
        });
      }

      scope.readonlyInput = (angular.isDefined(attrs.readonlyInput)) ? scope.$eval(attrs.readonlyInput) : timepickerConfig.readonlyInput;
      if ( ! scope.readonlyInput ) {

        var invalidate = function(invalidHours, invalidMinutes) {
          ngModel.$setViewValue( null );
          ngModel.$setValidity('time', false);
          if (angular.isDefined(invalidHours)) {
            scope.invalidHours = invalidHours;
          }
          if (angular.isDefined(invalidMinutes)) {
            scope.invalidMinutes = invalidMinutes;
          }
        };

        scope.updateHours = function() {
          var hours = getHoursFromTemplate();

          if ( angular.isDefined(hours) ) {
            selected.setHours( hours );
            refresh( 'h' );
          } else {
            invalidate(true);
          }
        };

        hoursInputEl.bind('blur', function(e) {
          if ( !scope.validHours && scope.hours < 10) {
            scope.$apply( function() {
              scope.hours = pad( scope.hours );
            });
          }
        });

        scope.updateMinutes = function() {
          var minutes = getMinutesFromTemplate();

          if ( angular.isDefined(minutes) ) {
            selected.setMinutes( minutes );
            refresh( 'm' );
          } else {
            invalidate(undefined, true);
          }
        };

        minutesInputEl.bind('blur', function(e) {
          if ( !scope.invalidMinutes && scope.minutes < 10 ) {
            scope.$apply( function() {
              scope.minutes = pad( scope.minutes );
            });
          }
        });
      } else {
        scope.updateHours = angular.noop;
        scope.updateMinutes = angular.noop;
      }

      ngModel.$render = function() {
        var date = ngModel.$modelValue ? new Date( ngModel.$modelValue ) : null;

        if ( isNaN(date) ) {
          ngModel.$setValidity('time', false);
          $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        } else {
          if ( date ) {
            selected = date;
          }
          makeValid();
          updateTemplate();
        }
      };

      // Call internally when we know that model is valid.
      function refresh( keyboardChange ) {
        makeValid();
        ngModel.$setViewValue( new Date(selected) );
        updateTemplate( keyboardChange );
      }

      function makeValid() {
        ngModel.$setValidity('time', true);
        scope.invalidHours = false;
        scope.invalidMinutes = false;
      }

      function updateTemplate( keyboardChange ) {
        var hours = selected.getHours(), minutes = selected.getMinutes();

        if ( scope.showMeridian ) {
          hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system
        }
        scope.hours =  keyboardChange === 'h' ? hours : pad(hours);
        scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);
        scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
      }

      function addMinutes( minutes ) {
        var dt = new Date( selected.getTime() + minutes * 60000 );
        selected.setHours( dt.getHours(), dt.getMinutes() );
        refresh();
      }

      scope.incrementHours = function() {
        addMinutes( hourStep * 60 );
      };
      scope.decrementHours = function() {
        addMinutes( - hourStep * 60 );
      };
      scope.incrementMinutes = function() {
        addMinutes( minuteStep );
      };
      scope.decrementMinutes = function() {
        addMinutes( - minuteStep );
      };
      scope.toggleMeridian = function() {
        addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );
      };
    }
  };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('typeaheadParser', ['$parse', function ($parse) {

  //                      00000111000000000000022200000000000000003333333333333330000000000044000
  var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;

  return {
    parse:function (input) {

      var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;
      if (!match) {
        throw new Error(
          "Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'" +
            " but got '" + input + "'.");
      }

      return {
        itemName:match[3],
        source:$parse(match[4]),
        viewMapper:$parse(match[2] || match[1]),
        modelMapper:$parse(match[1])
      };
    }
  };
}])

  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',
    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {

  var HOT_KEYS = [9, 13, 27, 38, 40];

  return {
    require:'ngModel',
    link:function (originalScope, element, attrs, modelCtrl) {

      //SUPPORTED ATTRIBUTES (OPTIONS)

      //minimal no of characters that needs to be entered before typeahead kicks-in
      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;

      //minimal wait time after last character typed before typehead kicks-in
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

      //should it restrict model values to the ones selected from the popup only?
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

      //binding to a variable that indicates if matches are being retrieved asynchronously
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

      //a callback executed when a match is selected
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);

      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

      //INTERNAL VARIABLES

      //model setter executed upon match selection
      var $setModelValue = $parse(attrs.ngModel).assign;

      //expressions used by typeahead
      var parserResult = typeaheadParser.parse(attrs.typeahead);


      //pop-up element used to display matches
      var popUpEl = angular.element('<typeahead-popup></typeahead-popup>');
      popUpEl.attr({
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx)',
        query: 'query',
        position: 'position'
      });
      //custom item template
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }

      //create a child scope for the typeahead directive so we are not polluting original scope
      //with typeahead-specific data (matches, query etc.)
      var scope = originalScope.$new();
      originalScope.$on('$destroy', function(){
        scope.$destroy();
      });

      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
      };

      var getMatchesAsync = function(inputValue) {

        var locals = {$viewValue: inputValue};
        isLoadingSetter(originalScope, true);
        $q.when(parserResult.source(scope, locals)).then(function(matches) {

          //it might happen that several async queries were in progress if a user were typing fast
          //but we are interested only in responses that correspond to the current view value
          if (inputValue === modelCtrl.$viewValue) {
            if (matches.length > 0) {

              scope.activeIdx = 0;
              scope.matches.length = 0;

              //transform labels
              for(var i=0; i<matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }

              scope.query = inputValue;
              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
              //due to other elements being rendered
              scope.position = $position.position(element);
              scope.position.top = scope.position.top + element.prop('offsetHeight');

            } else {
              resetMatches();
            }
            isLoadingSetter(originalScope, false);
          }
        }, function(){
          resetMatches();
          isLoadingSetter(originalScope, false);
        });
      };

      resetMatches();

      //we need to propagate user's query so we can higlight matches
      scope.query = undefined;

      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later 
      var timeoutPromise;

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function (inputValue) {

        resetMatches();
        if (inputValue && inputValue.length >= minSearch) {
          if (waitTime > 0) {
            if (timeoutPromise) {
              $timeout.cancel(timeoutPromise);//cancel previous timeout
            }
            timeoutPromise = $timeout(function () {
              getMatchesAsync(inputValue);
            }, waitTime);
          } else {
            getMatchesAsync(inputValue);
          }
        }

        if (isEditable) {
          return inputValue;
        } else {
          modelCtrl.$setValidity('editable', false);
          return undefined;
        }
      });

      modelCtrl.$formatters.push(function (modelValue) {

        var candidateViewValue, emptyViewValue;
        var locals = {};

        if (inputFormatter) {

          locals['$model'] = modelValue;
          return inputFormatter(originalScope, locals);

        } else {

          //it might happen that we don't have enough info to properly render input value
          //we need to check for this situation and simply return model value if we can't apply custom formatting
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);

          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;
        }
      });

      scope.select = function (activeIdx) {
        //called from within the $digest() cycle
        var locals = {};
        var model, item;

        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);

        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals)
        });

        resetMatches();

        //return focus to the input element if a mach was selected via a mouse click event
        element[0].focus();
      };

      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
      element.bind('keydown', function (evt) {

        //typeahead is open and an "interesting" key was pressed
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }

        evt.preventDefault();

        if (evt.which === 40) {
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();

        } else if (evt.which === 38) {
          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();

        } else if (evt.which === 13 || evt.which === 9) {
          scope.$apply(function () {
            scope.select(scope.activeIdx);
          });

        } else if (evt.which === 27) {
          evt.stopPropagation();

          resetMatches();
          scope.$digest();
        }
      });

      // Keep reference to click handler to unbind it.
      var dismissClickHandler = function (evt) {
        if (element[0] !== evt.target) {
          resetMatches();
          scope.$digest();
        }
      };

      $document.bind('click', dismissClickHandler);

      originalScope.$on('$destroy', function(){
        $document.unbind('click', dismissClickHandler);
      });

      element.after($compile(popUpEl)(scope));
    }
  };

}])

  .directive('typeaheadPopup', function () {
    return {
      restrict:'E',
      scope:{
        matches:'=',
        query:'=',
        active:'=',
        position:'=',
        select:'&'
      },
      replace:true,
      templateUrl:'template/typeahead/typeahead-popup.html',
      link:function (scope, element, attrs) {

        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function () {
          return scope.matches.length > 0;
        };

        scope.isActive = function (matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function (matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function (activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  })

  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {
    return {
      restrict:'E',
      scope:{
        index:'=',
        match:'=',
        query:'='
      },
      link:function (scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){
           element.replaceWith($compile(tplContent.trim())(scope));
        });
      }
    };
  }])

  .filter('typeaheadHighlight', function() {

    function escapeRegexp(queryToEscape) {
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }

    return function(matchItem, query) {
      return query ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
    };
  });
angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion-group.html",
    "<div class=\"accordion-group\">\n" +
    "  <div class=\"accordion-heading\" ><a class=\"accordion-toggle\" ng-click=\"isOpen = !isOpen\" accordion-transclude=\"heading\">{{heading}}</a></div>\n" +
    "  <div class=\"accordion-body\" collapse=\"!isOpen\">\n" +
    "    <div class=\"accordion-inner\" ng-transclude></div>  </div>\n" +
    "</div>");
}]);

angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion.html",
    "<div class=\"accordion\" ng-transclude></div>");
}]);

angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/alert/alert.html",
    "<div class='alert' ng-class='type && \"alert-\" + type'>\n" +
    "    <button ng-show='closeable' type='button' class='close' ng-click='close()'>&times;</button>\n" +
    "    <div ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/carousel.html",
    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\">\n" +
    "    <ol class=\"carousel-indicators\" ng-show=\"slides().length > 1\">\n" +
    "        <li ng-repeat=\"slide in slides()\" ng-class=\"{active: isActive(slide)}\" ng-click=\"select(slide)\"></li>\n" +
    "    </ol>\n" +
    "    <div class=\"carousel-inner\" ng-transclude></div>\n" +
    "    <a ng-click=\"prev()\" class=\"carousel-control left\" ng-show=\"slides().length > 1\">&lsaquo;</a>\n" +
    "    <a ng-click=\"next()\" class=\"carousel-control right\" ng-show=\"slides().length > 1\">&rsaquo;</a>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/slide.html",
    "<div ng-class=\"{\n" +
    "    'active': leaving || (active && !entering),\n" +
    "    'prev': (next || active) && direction=='prev',\n" +
    "    'next': (next || active) && direction=='next',\n" +
    "    'right': direction=='prev',\n" +
    "    'left': direction=='next'\n" +
    "  }\" class=\"item\" ng-transclude></div>\n" +
    "");
}]);

angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/datepicker.html",
    "<table>\n" +
    "  <thead>\n" +
    "    <tr class=\"text-center\">\n" +
    "      <th><button type=\"button\" class=\"btn pull-left\" ng-click=\"move(-1)\"><i class=\"icon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{rows[0].length - 2 + showWeekNumbers}}\"><button type=\"button\" class=\"btn btn-block\" ng-click=\"toggleMode()\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn pull-right\" ng-click=\"move(1)\"><i class=\"icon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "    <tr class=\"text-center\" ng-show=\"labels.length > 0\">\n" +
    "      <th ng-show=\"showWeekNumbers\">#</th>\n" +
    "      <th ng-repeat=\"label in labels\">{{label}}</th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows\">\n" +
    "      <td ng-show=\"showWeekNumbers\" class=\"text-center\"><em>{{ getWeekNumber(row) }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row\" class=\"text-center\">\n" +
    "        <button type=\"button\" style=\"width:100%;\" class=\"btn\" ng-class=\"{'btn-info': dt.selected}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\"><span ng-class=\"{muted: dt.secondary}\">{{dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/popup.html",
    "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\" class=\"dropdown-menu\">\n" +
    "	<li ng-transclude></li>\n" +
    "	<li class=\"divider\"></li>\n" +
    "	<li style=\"padding: 9px;\">\n" +
    "		<span class=\"btn-group\">\n" +
    "			<button class=\"btn btn-small btn-inverse\" ng-click=\"today()\">Today</button>\n" +
    "			<button class=\"btn btn-small btn-info\" ng-click=\"showWeeks = ! showWeeks\" ng-class=\"{active: showWeeks}\">Weeks</button>\n" +
    "			<button class=\"btn btn-small btn-danger\" ng-click=\"clear()\">Clear</button>\n" +
    "		</span>\n" +
    "		<button class=\"btn btn-small btn-success pull-right\" ng-click=\"isOpen = false\">Close</button>\n" +
    "	</li>\n" +
    "</ul>");
}]);

angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/backdrop.html",
    "<div class=\"modal-backdrop fade\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1040 + index*10}\" ng-click=\"close($event)\"></div>");
}]);

angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/window.html",
    "<div class=\"modal fade {{ windowClass }}\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1050 + index*10}\" ng-transclude></div>");
}]);

angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pager.html",
    "<div class=\"pager\">\n" +
    "  <ul>\n" +
    "    <li ng-repeat=\"page in pages\" ng-class=\"{disabled: page.disabled, previous: page.previous, next: page.next}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
    "  </ul>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pagination.html",
    "<div class=\"pagination\"><ul>\n" +
    "  <li ng-repeat=\"page in pages\" ng-class=\"{active: page.active, disabled: page.disabled}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
    "  </ul>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html",
    "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind-html-unsafe=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-popup.html",
    "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/popover/popover.html",
    "<div class=\"popover {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-show=\"title\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/bar.html",
    "<div class=\"bar\" ng-class='type && \"bar-\" + type'></div>");
}]);

angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/progress.html",
    "<div class=\"progress\"><progressbar ng-repeat=\"bar in bars\" width=\"bar.to\" old=\"bar.from\" animate=\"bar.animate\" type=\"bar.type\"></progressbar></div>");
}]);

angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/rating/rating.html",
    "<span ng-mouseleave=\"reset()\">\n" +
    "	<i ng-repeat=\"r in range\" ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" ng-class=\"$index < val && (r.stateOn || 'icon-star') || (r.stateOff || 'icon-star-empty')\"></i>\n" +
    "</span>");
}]);

angular.module("template/tabs/pane.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/pane.html",
    "<div class=\"tab-pane\" ng-class=\"{active: selected}\" ng-show=\"selected\" ng-transclude></div>\n" +
    "");
}]);

angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tab.html",
    "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
    "  <a ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("template/tabs/tabs.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabs.html",
    "<div class=\"tabbable\">\n" +
    "  <ul class=\"nav nav-tabs\">\n" +
    "    <li ng-repeat=\"pane in panes\" ng-class=\"{active:pane.selected}\">\n" +
    "      <a ng-click=\"select(pane)\">{{pane.heading}}</a>\n" +
    "    </li>\n" +
    "  </ul>\n" +
    "  <div class=\"tab-content\" ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tabs/tabset-titles.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset-titles.html",
    "<ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical}\">\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset.html",
    "\n" +
    "<div class=\"tabbable\" ng-class=\"{'tabs-right': direction == 'right', 'tabs-left': direction == 'left', 'tabs-below': direction == 'below'}\">\n" +
    "  <div tabset-titles=\"tabsAbove\"></div>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\" \n" +
    "         ng-repeat=\"tab in tabs\" \n" +
    "         ng-class=\"{active: tab.active}\"\n" +
    "         tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "  <div tabset-titles=\"!tabsAbove\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/timepicker/timepicker.html",
    "<table class=\"form-inline\">\n" +
    "	<tr class=\"text-center\">\n" +
    "		<td><a ng-click=\"incrementHours()\" class=\"btn btn-link\"><i class=\"icon-chevron-up\"></i></a></td>\n" +
    "		<td>&nbsp;</td>\n" +
    "		<td><a ng-click=\"incrementMinutes()\" class=\"btn btn-link\"><i class=\"icon-chevron-up\"></i></a></td>\n" +
    "		<td ng-show=\"showMeridian\"></td>\n" +
    "	</tr>\n" +
    "	<tr>\n" +
    "		<td class=\"control-group\" ng-class=\"{'error': invalidHours}\"><input type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"span1 text-center\" ng-mousewheel=\"incrementHours()\" ng-readonly=\"readonlyInput\" maxlength=\"2\" /></td>\n" +
    "		<td>:</td>\n" +
    "		<td class=\"control-group\" ng-class=\"{'error': invalidMinutes}\"><input type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"span1 text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\"></td>\n" +
    "		<td ng-show=\"showMeridian\"><button type=\"button\" ng-click=\"toggleMeridian()\" class=\"btn text-center\">{{meridian}}</button></td>\n" +
    "	</tr>\n" +
    "	<tr class=\"text-center\">\n" +
    "		<td><a ng-click=\"decrementHours()\" class=\"btn btn-link\"><i class=\"icon-chevron-down\"></i></a></td>\n" +
    "		<td>&nbsp;</td>\n" +
    "		<td><a ng-click=\"decrementMinutes()\" class=\"btn btn-link\"><i class=\"icon-chevron-down\"></i></a></td>\n" +
    "		<td ng-show=\"showMeridian\"></td>\n" +
    "	</tr>\n" +
    "</table>");
}]);

angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-match.html",
    "<a tabindex=\"-1\" bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>");
}]);

angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-popup.html",
    "<ul class=\"typeahead dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" +
    "    <li ng-repeat=\"match in matches\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\">\n" +
    "        <typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></typeahead-match>\n" +
    "    </li>\n" +
    "</ul>");
}]);

angular.module("template/typeahead/typeahead.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead.html",
    "<ul class=\"typeahead dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" +
    "    <li ng-repeat=\"match in matches\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\">\n" +
    "        <a tabindex=\"-1\" ng-click=\"selectMatch($index)\" ng-bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>\n" +
    "    </li>\n" +
    "</ul>");
}]);
},{}],17:[function(require,module,exports){
/**
 * State-based routing for AngularJS
 * @version v0.2.0
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
(function (window, angular, undefined) {
/*jshint globalstrict:true*/
/*global angular:false*/
'use strict';

var isDefined = angular.isDefined,
    isFunction = angular.isFunction,
    isString = angular.isString,
    isObject = angular.isObject,
    isArray = angular.isArray,
    forEach = angular.forEach,
    extend = angular.extend,
    copy = angular.copy;

function inherit(parent, extra) {
  return extend(new (extend(function() {}, { prototype: parent }))(), extra);
}

function merge(dst) {
  forEach(arguments, function(obj) {
    if (obj !== dst) {
      forEach(obj, function(value, key) {
        if (!dst.hasOwnProperty(key)) dst[key] = value;
      });
    }
  });
  return dst;
}

/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
  var path = [];

  for (var n in first.path) {
    if (first.path[n] === "") continue;
    if (!second.path[n]) break;
    path.push(first.path[n]);
  }
  return path;
}

/**
 * Merges a set of parameters with all parameters inherited between the common parents of the
 * current state and a given destination state.
 *
 * @param {Object} currentParams The value of the current state parameters ($stateParams).
 * @param {Object} newParams The set of parameters which will be composited with inherited params.
 * @param {Object} $current Internal definition of object representing the current state.
 * @param {Object} $to Internal definition of object representing state to transition to.
 */
function inheritParams(currentParams, newParams, $current, $to) {
  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];

  for (var i in parents) {
    if (!parents[i].params || !parents[i].params.length) continue;
    parentParams = parents[i].params;

    for (var j in parentParams) {
      if (inheritList.indexOf(parentParams[j]) >= 0) continue;
      inheritList.push(parentParams[j]);
      inherited[parentParams[j]] = currentParams[parentParams[j]];
    }
  }
  return extend({}, inherited, newParams);
}

angular.module('ui.router.util', ['ng']);
angular.module('ui.router.router', ['ui.router.util']);
angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
angular.module('ui.router', ['ui.router.state']);
angular.module('ui.router.compat', ['ui.router']);


/**
 * Service (`ui-util`). Manages resolution of (acyclic) graphs of promises.
 * @module $resolve
 * @requires $q
 * @requires $injector
 */
$Resolve.$inject = ['$q', '$injector'];
function $Resolve(  $q,    $injector) {
  
  var VISIT_IN_PROGRESS = 1,
      VISIT_DONE = 2,
      NOTHING = {},
      NO_DEPENDENCIES = [],
      NO_LOCALS = NOTHING,
      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });
  

  /**
   * Studies a set of invocables that are likely to be used multiple times.
   *      $resolve.study(invocables)(locals, parent, self)
   * is equivalent to
   *      $resolve.resolve(invocables, locals, parent, self)
   * but the former is more efficient (in fact `resolve` just calls `study` internally).
   * See {@link module:$resolve/resolve} for details.
   * @function
   * @param {Object} invocables
   * @return {Function}
   */
  this.study = function (invocables) {
    if (!isObject(invocables)) throw new Error("'invocables' must be an object");
    
    // Perform a topological sort of invocables to build an ordered plan
    var plan = [], cycle = [], visited = {};
    function visit(value, key) {
      if (visited[key] === VISIT_DONE) return;
      
      cycle.push(key);
      if (visited[key] === VISIT_IN_PROGRESS) {
        cycle.splice(0, cycle.indexOf(key));
        throw new Error("Cyclic dependency: " + cycle.join(" -> "));
      }
      visited[key] = VISIT_IN_PROGRESS;
      
      if (isString(value)) {
        plan.push(key, [ function() { return $injector.get(key); }], NO_DEPENDENCIES);
      } else {
        var params = $injector.annotate(value);
        forEach(params, function (param) {
          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
        });
        plan.push(key, value, params);
      }
      
      cycle.pop();
      visited[key] = VISIT_DONE;
    }
    forEach(invocables, visit);
    invocables = cycle = visited = null; // plan is all that's required
    
    function isResolve(value) {
      return isObject(value) && value.then && value.$$promises;
    }
    
    return function (locals, parent, self) {
      if (isResolve(locals) && self === undefined) {
        self = parent; parent = locals; locals = null;
      }
      if (!locals) locals = NO_LOCALS;
      else if (!isObject(locals)) {
        throw new Error("'locals' must be an object");
      }       
      if (!parent) parent = NO_PARENT;
      else if (!isResolve(parent)) {
        throw new Error("'parent' must be a promise returned by $resolve.resolve()");
      }
      
      // To complete the overall resolution, we have to wait for the parent
      // promise and for the promise for each invokable in our plan.
      var resolution = $q.defer(),
          result = resolution.promise,
          promises = result.$$promises = {},
          values = extend({}, locals),
          wait = 1 + plan.length/3,
          merged = false;
          
      function done() {
        // Merge parent values we haven't got yet and publish our own $$values
        if (!--wait) {
          if (!merged) merge(values, parent.$$values); 
          result.$$values = values;
          result.$$promises = true; // keep for isResolve()
          resolution.resolve(values);
        }
      }
      
      function fail(reason) {
        result.$$failure = reason;
        resolution.reject(reason);
      }
      
      // Short-circuit if parent has already failed
      if (isDefined(parent.$$failure)) {
        fail(parent.$$failure);
        return result;
      }
      
      // Merge parent values if the parent has already resolved, or merge
      // parent promises and wait if the parent resolve is still in progress.
      if (parent.$$values) {
        merged = merge(values, parent.$$values);
        done();
      } else {
        extend(promises, parent.$$promises);
        parent.then(done, fail);
      }
      
      // Process each invocable in the plan, but ignore any where a local of the same name exists.
      for (var i=0, ii=plan.length; i<ii; i+=3) {
        if (locals.hasOwnProperty(plan[i])) done();
        else invoke(plan[i], plan[i+1], plan[i+2]);
      }
      
      function invoke(key, invocable, params) {
        // Create a deferred for this invocation. Failures will propagate to the resolution as well.
        var invocation = $q.defer(), waitParams = 0;
        function onfailure(reason) {
          invocation.reject(reason);
          fail(reason);
        }
        // Wait for any parameter that we have a promise for (either from parent or from this
        // resolve; in that case study() will have made sure it's ordered before us in the plan).
        params.forEach(function (dep) {
          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
            waitParams++;
            promises[dep].then(function (result) {
              values[dep] = result;
              if (!(--waitParams)) proceed();
            }, onfailure);
          }
        });
        if (!waitParams) proceed();
        function proceed() {
          if (isDefined(result.$$failure)) return;
          try {
            invocation.resolve($injector.invoke(invocable, self, values));
            invocation.promise.then(function (result) {
              values[key] = result;
              done();
            }, onfailure);
          } catch (e) {
            onfailure(e);
          }
        }
        // Publish promise synchronously; invocations further down in the plan may depend on it.
        promises[key] = invocation.promise;
      }
      
      return result;
    };
  };
  
  /**
   * Resolves a set of invocables. An invocable is a function to be invoked via `$injector.invoke()`,
   * and can have an arbitrary number of dependencies. An invocable can either return a value directly,
   * or a `$q` promise. If a promise is returned it will be resolved and the resulting value will be
   * used instead. Dependencies of invocables are resolved (in this order of precedence)
   *
   * - from the specified `locals`
   * - from another invocable that is part of this `$resolve` call
   * - from an invocable that is inherited from a `parent` call to `$resolve` (or recursively
   *   from any ancestor `$resolve` of that parent).
   *
   * The return value of `$resolve` is a promise for an object that contains (in this order of precedence)
   *
   * - any `locals` (if specified)
   * - the resolved return values of all injectables
   * - any values inherited from a `parent` call to `$resolve` (if specified)
   *
   * The promise will resolve after the `parent` promise (if any) and all promises returned by injectables
   * have been resolved. If any invocable (or `$injector.invoke`) throws an exception, or if a promise
   * returned by an invocable is rejected, the `$resolve` promise is immediately rejected with the same error.
   * A rejection of a `parent` promise (if specified) will likewise be propagated immediately. Once the
   * `$resolve` promise has been rejected, no further invocables will be called.
   * 
   * Cyclic dependencies between invocables are not permitted and will caues `$resolve` to throw an
   * error. As a special case, an injectable can depend on a parameter with the same name as the injectable,
   * which will be fulfilled from the `parent` injectable of the same name. This allows inherited values
   * to be decorated. Note that in this case any other injectable in the same `$resolve` with the same
   * dependency would see the decorated value, not the inherited value.
   *
   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an (asynchronous) rejection
   * of the `$resolve` promise rather than a (synchronous) exception.
   *
   * Invocables are invoked eagerly as soon as all dependencies are available. This is true even for
   * dependencies inherited from a `parent` call to `$resolve`.
   *
   * As a special case, an invocable can be a string, in which case it is taken to be a service name
   * to be passed to `$injector.get()`. This is supported primarily for backwards-compatibility with the
   * `resolve` property of `$routeProvider` routes.
   *
   * @function
   * @param {Object.<string, Function|string>} invocables  functions to invoke or `$injector` services to fetch.
   * @param {Object.<string, *>} [locals]  values to make available to the injectables
   * @param {Promise.<Object>} [parent]  a promise returned by another call to `$resolve`.
   * @param {Object} [self]  the `this` for the invoked methods
   * @return {Promise.<Object>}  Promise for an object that contains the resolved return value
   *    of all invocables, as well as any inherited and local values.
   */
  this.resolve = function (invocables, locals, parent, self) {
    return this.study(invocables)(locals, parent, self);
  };
}

angular.module('ui.router.util').service('$resolve', $Resolve);


/**
 * Service. Manages loading of templates.
 * @constructor
 * @name $templateFactory
 * @requires $http
 * @requires $templateCache
 * @requires $injector
 */
$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
function $TemplateFactory(  $http,   $templateCache,   $injector) {

  /**
   * Creates a template from a configuration object. 
   * @function
   * @name $templateFactory#fromConfig
   * @methodOf $templateFactory
   * @param {Object} config  Configuration object for which to load a template. The following
   *    properties are search in the specified order, and the first one that is defined is
   *    used to create the template:
   * @param {string|Function} config.template  html string template or function to load via
   *    {@link $templateFactory#fromString fromString}.
   * @param {string|Function} config.templateUrl  url to load or a function returning the url
   *    to load via {@link $templateFactory#fromUrl fromUrl}.
   * @param {Function} config.templateProvider  function to invoke via
   *    {@link $templateFactory#fromProvider fromProvider}.
   * @param {Object} params  Parameters to pass to the template function.
   * @param {Object} [locals] Locals to pass to `invoke` if the template is loaded via a
   *      `templateProvider`. Defaults to `{ params: params }`.
   * @return {string|Promise.<string>}  The template html as a string, or a promise for that string,
   *      or `null` if no template is configured.
   */
  this.fromConfig = function (config, params, locals) {
    return (
      isDefined(config.template) ? this.fromString(config.template, params) :
      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :
      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :
      null
    );
  };

  /**
   * Creates a template from a string or a function returning a string.
   * @function
   * @name $templateFactory#fromString
   * @methodOf $templateFactory
   * @param {string|Function} template  html template as a string or function that returns an html
   *      template as a string.
   * @param {Object} params  Parameters to pass to the template function.
   * @return {string|Promise.<string>}  The template html as a string, or a promise for that string.
   */
  this.fromString = function (template, params) {
    return isFunction(template) ? template(params) : template;
  };

  /**
   * Loads a template from the a URL via `$http` and `$templateCache`.
   * @function
   * @name $templateFactory#fromUrl
   * @methodOf $templateFactory
   * @param {string|Function} url  url of the template to load, or a function that returns a url.
   * @param {Object} params  Parameters to pass to the url function.
   * @return {string|Promise.<string>}  The template html as a string, or a promise for that string.
   */
  this.fromUrl = function (url, params) {
    if (isFunction(url)) url = url(params);
    if (url == null) return null;
    else return $http
        .get(url, { cache: $templateCache })
        .then(function(response) { return response.data; });
  };

  /**
   * Creates a template by invoking an injectable provider function.
   * @function
   * @name $templateFactory#fromUrl
   * @methodOf $templateFactory
   * @param {Function} provider Function to invoke via `$injector.invoke`
   * @param {Object} params Parameters for the template.
   * @param {Object} [locals] Locals to pass to `invoke`. Defaults to `{ params: params }`.
   * @return {string|Promise.<string>} The template html as a string, or a promise for that string.
   */
  this.fromProvider = function (provider, params, locals) {
    return $injector.invoke(provider, null, locals || { params: params });
  };
}

angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);

/**
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
 * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by {@link UrlMatcher#exec exec}.
 * 
 * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
 * syntax, which optionally allows a regular expression for the parameter to be specified:
 *
 * * ':' name - colon placeholder
 * * '*' name - catch-all placeholder
 * * '{' name '}' - curly placeholder
 * * '{' name ':' regexp '}' - curly placeholder with regexp. Should the regexp itself contain
 *   curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters). For colon 
 * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
 * number of characters other than '/'. For catch-all placeholders the path parameter matches
 * any number of characters.
 * 
 * ### Examples
 * 
 * * '/hello/' - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * '/user/:id' - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * '/user/{id}' - Same as the previous example, but using curly brace syntax.
 * * '/user/{id:[^/]*}' - Same as the previous example.
 * * '/user/{id:[0-9a-fA-F]{1,8}}' - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * '/files/{path:.*}' - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * '/files/*path' - ditto.
 *
 * @constructor
 * @param {string} pattern  the pattern to compile into a matcher.
 *
 * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
 *   URL matching this matcher (i.e. any string for which {@link UrlMatcher#exec exec()} returns
 *   non-null) will start with this prefix.
 */
function UrlMatcher(pattern) {

  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
  //   '*' name
  //   ':' name
  //   '{' name '}'
  //   '{' name ':' regexp '}'
  // The regular expression is somewhat complicated due to the need to allow curly braces
  // inside the regular expression. The placeholder regexp breaks down as follows:
  //    ([:*])(\w+)               classic placeholder ($1 / $2)
  //    \{(\w+)(?:\:( ... ))?\}   curly brace placeholder ($3) with optional regexp ... ($4)
  //    (?: ... | ... | ... )+    the regexp consists of any number of atoms, an atom being either
  //    [^{}\\]+                  - anything other than curly braces or backslash
  //    \\.                       - a backslash escape
  //    \{(?:[^{}\\]+|\\.)*\}     - a matched set of curly braces containing other atoms
  var placeholder = /([:*])(\w+)|\{(\w+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      names = {}, compiled = '^', last = 0, m,
      segments = this.segments = [],
      params = this.params = [];

  function addParameter(id) {
    if (!/^\w+(-+\w+)*$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
    if (names[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
    names[id] = true;
    params.push(id);
  }

  function quoteRegExp(string) {
    return string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
  }

  this.source = pattern;

  // Split into static segments separated by path parameter placeholders.
  // The number of segments is always 1 more than the number of parameters.
  var id, regexp, segment;
  while ((m = placeholder.exec(pattern))) {
    id = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null
    regexp = m[4] || (m[1] == '*' ? '.*' : '[^/]*');
    segment = pattern.substring(last, m.index);
    if (segment.indexOf('?') >= 0) break; // we're into the search part
    compiled += quoteRegExp(segment) + '(' + regexp + ')';
    addParameter(id);
    segments.push(segment);
    last = placeholder.lastIndex;
  }
  segment = pattern.substring(last);

  // Find any search parameter names and remove them from the last segment
  var i = segment.indexOf('?');
  if (i >= 0) {
    var search = this.sourceSearch = segment.substring(i);
    segment = segment.substring(0, i);
    this.sourcePath = pattern.substring(0, last+i);

    // Allow parameters to be separated by '?' as well as '&' to make concat() easier
    forEach(search.substring(1).split(/[&?]/), addParameter);
  } else {
    this.sourcePath = pattern;
    this.sourceSearch = '';
  }

  compiled += quoteRegExp(segment) + '$';
  segments.push(segment);
  this.regexp = new RegExp(compiled);
  this.prefix = segments[0];
}

/**
 * Returns a new matcher for a pattern constructed by appending the path part and adding the
 * search parameters of the specified pattern to this pattern. The current pattern is not
 * modified. This can be understood as creating a pattern for URLs that are relative to (or
 * suffixes of) the current pattern.
 *
 * ### Example
 * The following two matchers are equivalent:
 * ```
 * new UrlMatcher('/user/{id}?q').concat('/details?date');
 * new UrlMatcher('/user/{id}/details?q&date');
 * ```
 *
 * @param {string} pattern  The pattern to append.
 * @return {UrlMatcher}  A matcher for the concatenated pattern.
 */
UrlMatcher.prototype.concat = function (pattern) {
  // Because order of search parameters is irrelevant, we can add our own search
  // parameters to the end of the new pattern. Parse the new pattern by itself
  // and then join the bits together, but it's much easier to do this on a string level.
  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch);
};

UrlMatcher.prototype.toString = function () {
  return this.source;
};

/**
 * Tests the specified path against this matcher, and returns an object containing the captured
 * parameter values, or null if the path does not match. The returned object contains the values
 * of any search parameters that are mentioned in the pattern, but their value may be null if
 * they are not present in `searchParams`. This means that search parameters are always treated
 * as optional.
 *
 * ### Example
 * ```
 * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', { x:'1', q:'hello' });
 * // returns { id:'bob', q:'hello', r:null }
 * ```
 *
 * @param {string} path  The URL path to match, e.g. `$location.path()`.
 * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.
 * @return {Object}  The captured parameter values.
 */
UrlMatcher.prototype.exec = function (path, searchParams) {
  var m = this.regexp.exec(path);
  if (!m) return null;

  var params = this.params, nTotal = params.length,
    nPath = this.segments.length-1,
    values = {}, i;

  if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");

  for (i=0; i<nPath; i++) values[params[i]] = m[i+1];
  for (/**/; i<nTotal; i++) values[params[i]] = searchParams[params[i]];

  return values;
};

/**
 * Returns the names of all path and search parameters of this pattern in an unspecified order.
 * @return {Array.<string>}  An array of parameter names. Must be treated as read-only. If the
 *    pattern has no parameters, an empty array is returned.
 */
UrlMatcher.prototype.parameters = function () {
  return this.params;
};

/**
 * Creates a URL that matches this pattern by substituting the specified values
 * for the path and search parameters. Null values for path parameters are
 * treated as empty strings.
 *
 * ### Example
 * ```
 * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
 * // returns '/user/bob?q=yes'
 * ```
 *
 * @param {Object} values  the values to substitute for the parameters in this pattern.
 * @return {string}  the formatted URL (path and optionally search part).
 */
UrlMatcher.prototype.format = function (values) {
  var segments = this.segments, params = this.params;
  if (!values) return segments.join('');

  var nPath = segments.length-1, nTotal = params.length,
    result = segments[0], i, search, value;

  for (i=0; i<nPath; i++) {
    value = values[params[i]];
    // TODO: Maybe we should throw on null here? It's not really good style to use '' and null interchangeabley
    if (value != null) result += encodeURIComponent(value);
    result += segments[i+1];
  }
  for (/**/; i<nTotal; i++) {
    value = values[params[i]];
    if (value != null) {
      result += (search ? '&' : '?') + params[i] + '=' + encodeURIComponent(value);
      search = true;
    }
  }

  return result;
};

/**
 * Service. Factory for {@link UrlMatcher} instances. The factory is also available to providers
 * under the name `$urlMatcherFactoryProvider`.
 * @constructor
 * @name $urlMatcherFactory
 */
function $UrlMatcherFactory() {
  /**
   * Creates a {@link UrlMatcher} for the specified pattern.
   * @function
   * @name $urlMatcherFactory#compile
   * @methodOf $urlMatcherFactory
   * @param {string} pattern  The URL pattern.
   * @return {UrlMatcher}  The UrlMatcher.
   */
  this.compile = function (pattern) {
    return new UrlMatcher(pattern);
  };

  /**
   * Returns true if the specified object is a UrlMatcher, or false otherwise.
   * @function
   * @name $urlMatcherFactory#isMatcher
   * @methodOf $urlMatcherFactory
   * @param {Object} o
   * @return {boolean}
   */
  this.isMatcher = function (o) {
    return isObject(o) && isFunction(o.exec) && isFunction(o.format) && isFunction(o.concat);
  };

  this.$get = function () {
    return this;
  };
}

// Register as a provider so it's available to other providers
angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);


$UrlRouterProvider.$inject = ['$urlMatcherFactoryProvider'];
function $UrlRouterProvider(  $urlMatcherFactory) {
  var rules = [], 
      otherwise = null;

  // Returns a string that is a prefix of all strings matching the RegExp
  function regExpPrefix(re) {
    var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
    return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
  }

  // Interpolates matched values into a String.replace()-style pattern
  function interpolate(pattern, match) {
    return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
      return match[what === '$' ? 0 : Number(what)];
    });
  }

  this.rule =
    function (rule) {
      if (!isFunction(rule)) throw new Error("'rule' must be a function");
      rules.push(rule);
      return this;
    };

  this.otherwise =
    function (rule) {
      if (isString(rule)) {
        var redirect = rule;
        rule = function () { return redirect; };
      }
      else if (!isFunction(rule)) throw new Error("'rule' must be a function");
      otherwise = rule;
      return this;
    };


  function handleIfMatch($injector, handler, match) {
    if (!match) return false;
    var result = $injector.invoke(handler, handler, { $match: match });
    return isDefined(result) ? result : true;
  }

  this.when =
    function (what, handler) {
      var redirect, handlerIsString = isString(handler);
      if (isString(what)) what = $urlMatcherFactory.compile(what);

      if (!handlerIsString && !isFunction(handler) && !isArray(handler))
        throw new Error("invalid 'handler' in when()");

      var strategies = {
        matcher: function (what, handler) {
          if (handlerIsString) {
            redirect = $urlMatcherFactory.compile(handler);
            handler = ['$match', function ($match) { return redirect.format($match); }];
          }
          return extend(function ($injector, $location) {
            return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
          }, {
            prefix: isString(what.prefix) ? what.prefix : ''
          });
        },
        regex: function (what, handler) {
          if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");

          if (handlerIsString) {
            redirect = handler;
            handler = ['$match', function ($match) { return interpolate(redirect, $match); }];
          }
          return extend(function ($injector, $location) {
            return handleIfMatch($injector, handler, what.exec($location.path()));
          }, {
            prefix: regExpPrefix(what)
          });
        }
      };

      var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };

      for (var n in check) {
        if (check[n]) {
          return this.rule(strategies[n](what, handler));
        }
      }

      throw new Error("invalid 'what' in when()");
    };

  this.$get =
    [        '$location', '$rootScope', '$injector',
    function ($location,   $rootScope,   $injector) {
      // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
      function update() {
        function check(rule) {
          var handled = rule($injector, $location);
          if (handled) {
            if (isString(handled)) $location.replace().url(handled);
            return true;
          }
          return false;
        }
        var n=rules.length, i;
        for (i=0; i<n; i++) {
          if (check(rules[i])) return;
        }
        // always check otherwise last to allow dynamic updates to the set of rules
        if (otherwise) check(otherwise);
      }

      $rootScope.$on('$locationChangeSuccess', update);
      return {};
    }];
}

angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);

$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider', '$locationProvider'];
function $StateProvider(   $urlRouterProvider,   $urlMatcherFactory,           $locationProvider) {

  var root, states = {}, $state;

  // Builds state properties from definition passed to registerState()
  var stateBuilder = {

    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.
    // state.children = [];
    // if (parent) parent.children.push(state);
    parent: function(state) {
      if (isDefined(state.parent) && state.parent) return findState(state.parent);
      // regex matches any valid composite state name
      // would match "contact.list" but not "contacts"
      var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
      return compositeName ? findState(compositeName[1]) : root;
    },

    // inherit 'data' from parent and override by own values (if any)
    data: function(state) {
      if (state.parent && state.parent.data) {
        state.data = state.self.data = angular.extend({}, state.parent.data, state.data);
      }
      return state.data;
    },

    // Build a URLMatcher if necessary, either via a relative or absolute URL
    url: function(state) {
      var url = state.url;

      if (isString(url)) {
        if (url.charAt(0) == '^') {
          return $urlMatcherFactory.compile(url.substring(1));
        }
        return (state.parent.navigable || root).url.concat(url);
      }

      if ($urlMatcherFactory.isMatcher(url) || url == null) {
        return url;
      }
      throw new Error("Invalid url '" + url + "' in state '" + state + "'");
    },

    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
    navigable: function(state) {
      return state.url ? state : (state.parent ? state.parent.navigable : null);
    },

    // Derive parameters for this state and ensure they're a super-set of parent's parameters
    params: function(state) {
      if (!state.params) {
        return state.url ? state.url.parameters() : state.parent.params;
      }
      if (!isArray(state.params)) throw new Error("Invalid params in state '" + state + "'");
      if (state.url) throw new Error("Both params and url specicified in state '" + state + "'");
      return state.params;
    },

    // If there is no explicit multi-view configuration, make one up so we don't have
    // to handle both cases in the view directive later. Note that having an explicit
    // 'views' property will mean the default unnamed view properties are ignored. This
    // is also a good time to resolve view names to absolute names, so everything is a
    // straight lookup at link time.
    views: function(state) {
      var views = {};

      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
        if (name.indexOf('@') < 0) name += '@' + state.parent.name;
        views[name] = view;
      });
      return views;
    },

    ownParams: function(state) {
      if (!state.parent) {
        return state.params;
      }
      var paramNames = {}; forEach(state.params, function (p) { paramNames[p] = true; });

      forEach(state.parent.params, function (p) {
        if (!paramNames[p]) {
          throw new Error("Missing required parameter '" + p + "' in state '" + state.name + "'");
        }
        paramNames[p] = false;
      });
      var ownParams = [];

      forEach(paramNames, function (own, p) {
        if (own) ownParams.push(p);
      });
      return ownParams;
    },

    // Keep a full path from the root down to this state as this is needed for state activation.
    path: function(state) {
      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
    },

    // Speed up $state.contains() as it's used a lot
    includes: function(state) {
      var includes = state.parent ? extend({}, state.parent.includes) : {};
      includes[state.name] = true;
      return includes;
    }
  };


  function findState(stateOrName, base) {
    var isStr = isString(stateOrName),
        name  = isStr ? stateOrName : stateOrName.name,
        path  = name.indexOf(".") === 0 || name.indexOf("^") === 0;

    if (path) {
      if (!base) throw new Error("No reference point given for path '"  + name + "'");
      var rel = name.split("."), i = 0, pathLength = rel.length, current = base;

      for (; i < pathLength; i++) {
        if (rel[i] === "" && i === 0) {
          current = base;
          continue;
        }
        if (rel[i] === "^") {
          if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
          current = current.parent;
          continue;
        }
        break;
      }
      rel = rel.slice(i).join(".");
      name = current.name + (current.name && rel ? "." : "") + rel;
    }
    var state = states[name];

    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
      return state;
    }
    return undefined;
  }


  function registerState(state) {
    // Wrap a new object around the state so we can store our private details easily.
    state = inherit(state, {
      self: state,
      resolve: state.resolve || {},
      toString: function() { return this.name; }
    });

    var name = state.name;
    if (!isString(name) || name.indexOf('@') >= 0) throw new Error("State must have a valid name");
    if (states[name]) throw new Error("State '" + name + "'' is already defined");

    for (var key in stateBuilder) {
      state[key] = stateBuilder[key](state);
    }
    states[name] = state;

    // Register the state in the global state list and with $urlRouter if necessary.
    if (!state['abstract'] && state.url) {
      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {
        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
          $state.transitionTo(state, $match, false);
        }
      }]);
    }
    return state;
  }


  // Implicit root state that is always active
  root = registerState({
    name: '',
    url: '^',
    views: null,
    'abstract': true
  });
  root.navigable = null;


  // .state(state)
  // .state(name, state)
  this.state = state;
  function state(name, definition) {
    /*jshint validthis: true */
    if (isObject(name)) definition = name;
    else definition.name = name;
    registerState(definition);
    return this;
  }

  // $urlRouter is injected just to ensure it gets instantiated
  this.$get = $get;
  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$location', '$urlRouter'];
  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $location,   $urlRouter) {

    var TransitionSuperseded = $q.reject(new Error('transition superseded'));
    var TransitionPrevented = $q.reject(new Error('transition prevented'));

    root.locals = { resolve: null, globals: { $stateParams: {} } };
    $state = {
      params: {},
      current: root.self,
      $current: root,
      transition: null
    };

    $state.go = function go(to, params, options) {
      return this.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
    };

    $state.transitionTo = function transitionTo(to, toParams, options) {
      if (!isDefined(options)) options = (options === true || options === false) ? { location: options } : {};
      toParams = toParams || {};
      options = extend({ location: true, inherit: false, relative: null }, options);

      var toState = findState(to, options.relative);
      if (!isDefined(toState)) throw new Error("No such state " + toState);
      if (toState['abstract']) throw new Error("Cannot transition to abstract state '" + to + "'");
      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
      to = toState;

      var toPath = to.path,
          from = $state.$current, fromParams = $state.params, fromPath = from.path;

      // Starting from the root of the path, keep all levels that haven't changed
      var keep, state, locals = root.locals, toLocals = [];
      for (keep = 0, state = toPath[keep];
           state && state === fromPath[keep] && equalForKeys(toParams, fromParams, state.ownParams);
           keep++, state = toPath[keep]) {
        locals = toLocals[keep] = state.locals;
      }

      // If we're going to the same state and all locals are kept, we've got nothing to do.
      // But clear 'transition', as we still want to cancel any other pending transitions.
      // TODO: We may not want to bump 'transition' if we're called from a location change that we've initiated ourselves,
      // because we might accidentally abort a legitimate transition initiated from code?
      if (to === from && locals === from.locals) {
        $state.transition = null;
        return $q.when($state.current);
      }

      // Normalize/filter parameters before we pass them to event handlers etc.
      toParams = normalize(to.params, toParams || {});

      // Broadcast start event and cancel the transition if requested
      var evt = $rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams);
      if (evt.defaultPrevented) return TransitionPrevented;

      // Resolve locals for the remaining states, but don't update any global state just
      // yet -- if anything fails to resolve the current state needs to remain untouched.
      // We also set up an inheritance chain for the locals here. This allows the view directive
      // to quickly look up the correct definition for each view in the current state. Even
      // though we create the locals object itself outside resolveState(), it is initially
      // empty and gets filled asynchronously. We need to keep track of the promise for the
      // (fully resolved) current locals, and pass this down the chain.
      var resolved = $q.when(locals);
      for (var l=keep; l<toPath.length; l++, state=toPath[l]) {
        locals = toLocals[l] = inherit(locals);
        resolved = resolveState(state, toParams, state===to, resolved, locals);
      }

      // Once everything is resolved, wer are ready to perform the actual transition
      // and return a promise for the new state. We also keep track of what the
      // current promise is, so that we can detect overlapping transitions and
      // keep only the outcome of the last transition.
      var transition = $state.transition = resolved.then(function () {
        var l, entering, exiting;

        if ($state.transition !== transition) return TransitionSuperseded;

        // Exit 'from' states not kept
        for (l=fromPath.length-1; l>=keep; l--) {
          exiting = fromPath[l];
          if (exiting.self.onExit) {
            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
          }
          exiting.locals = null;
        }

        // Enter 'to' states not kept
        for (l=keep; l<toPath.length; l++) {
          entering = toPath[l];
          entering.locals = toLocals[l];
          if (entering.self.onEnter) {
            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
          }
        }

        // Update globals in $state
        $state.$current = to;
        $state.current = to.self;
        $state.params = toParams;
        copy($state.params, $stateParams);
        $state.transition = null;

        // Update $location
        var toNav = to.navigable;
        if (options.location && toNav) {
          $location.url(toNav.url.format(toNav.locals.globals.$stateParams));
        }

        $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);

        return $state.current;
      }, function (error) {
        if ($state.transition !== transition) return TransitionSuperseded;

        $state.transition = null;
        $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);

        return $q.reject(error);
      });

      return transition;
    };

    $state.is = function is(stateOrName) {
      var state = findState(stateOrName);
      return (isDefined(state)) ? $state.$current === state : undefined;
    };

    $state.includes = function includes(stateOrName) {
      var state = findState(stateOrName);
      return (isDefined(state)) ? isDefined($state.$current.includes[state.name]) : undefined;
    };

    $state.href = function href(stateOrName, params, options) {
      options = extend({ lossy: true, inherit: false, relative: $state.$current }, options || {});
      var state = findState(stateOrName, options.relative);
      if (!isDefined(state)) return null;

      params = inheritParams($stateParams, params || {}, $state.$current, state);
      var nav = (state && options.lossy) ? state.navigable : state;
      var url = (nav && nav.url) ? nav.url.format(normalize(state.params, params || {})) : null;
      return !$locationProvider.html5Mode() && url ? "#" + url : url;
    };

    $state.get = function (stateOrName) {
      var state = findState(stateOrName);
      return (state && state.self) ? state.self : null;
    };

    function resolveState(state, params, paramsAreFiltered, inherited, dst) {
      // Make a restricted $stateParams with only the parameters that apply to this state if
      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
      // we also need $stateParams to be available for any $injector calls we make during the
      // dependency resolution process.
      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params, params);
      var locals = { $stateParams: $stateParams };

      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.
      // We're also including $stateParams in this; that way the parameters are restricted
      // to the set that should be visible to the state, and are independent of when we update
      // the global $state and $stateParams values.
      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
      var promises = [ dst.resolve.then(function (globals) {
        dst.globals = globals;
      }) ];
      if (inherited) promises.push(inherited);

      // Resolve template and dependencies for all views.
      forEach(state.views, function (view, name) {
        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
        injectables.$template = [ function () {
          return $view.load(name, { view: view, locals: locals, params: $stateParams, notify: false }) || '';
        }];

        promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function (result) {
          // References to the controller (only instantiated at link time)
          result.$$controller = view.controller;
          // Provide access to the state itself for internal use
          result.$$state = state;
          dst[name] = result;
        }));
      });

      // Wait for all the promises and then return the activation object
      return $q.all(promises).then(function (values) {
        return dst;
      });
    }

    return $state;
  }

  function normalize(keys, values) {
    var normalized = {};

    forEach(keys, function (name) {
      var value = values[name];
      normalized[name] = (value != null) ? String(value) : null;
    });
    return normalized;
  }

  function equalForKeys(a, b, keys) {
    // If keys not provided, assume keys from object 'a'
    if (!keys) {
      keys = [];
      for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility
    }

    for (var i=0; i<keys.length; i++) {
      var k = keys[i];
      if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized
    }
    return true;
  }

  function filterByKeys(keys, values) {
    var filtered = {};

    forEach(keys, function (name) {
      filtered[name] = values[name];
    });
    return filtered;
  }
}

angular.module('ui.router.state')
  .value('$stateParams', {})
  .provider('$state', $StateProvider);


$ViewProvider.$inject = [];
function $ViewProvider() {

  this.$get = $get;
  $get.$inject = ['$rootScope', '$templateFactory'];
  function $get(   $rootScope,   $templateFactory) {
    return {
      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })
      load: function load(name, options) {
        var result, defaults = {
          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}
        };
        options = extend(defaults, options);

        if (options.view) {
          result = $templateFactory.fromConfig(options.view, options.params, options.locals);
        }
        if (result && options.notify) {
          $rootScope.$broadcast('$viewContentLoading', options);
        }
        return result;
      }
    };
  }
}

angular.module('ui.router.state').provider('$view', $ViewProvider);


$ViewDirective.$inject = ['$state', '$compile', '$controller', '$injector', '$anchorScroll'];
function $ViewDirective(   $state,   $compile,   $controller,   $injector,   $anchorScroll) {
  // TODO: Change to $injector.has() when we version bump to Angular 1.1.5.
  // See: https://github.com/angular/angular.js/blob/master/CHANGELOG.md#115-triangle-squarification-2013-05-22
  var $animator; try { $animator = $injector.get('$animator'); } catch (e) { /* do nothing */ }
  var viewIsUpdating = false;

  var directive = {
    restrict: 'ECA',
    terminal: true,
    transclude: true,
    compile: function (element, attr, transclude) {
      return function(scope, element, attr) {
        var viewScope, viewLocals,
            name = attr[directive.name] || attr.name || '',
            onloadExp = attr.onload || '',
            animate = isDefined($animator) && $animator(scope, attr);

        // Returns a set of DOM manipulation functions based on whether animation
        // should be performed
        var renderer = function(doAnimate) {
          return ({
            "true": {
              remove: function(element) { animate.leave(element.contents(), element); },
              restore: function(compiled, element) { animate.enter(compiled, element); },
              populate: function(template, element) {
                var contents = angular.element('<div></div>').html(template).contents();
                animate.enter(contents, element);
                return contents;
              }
            },
            "false": {
              remove: function(element) { element.html(''); },
              restore: function(compiled, element) { element.append(compiled); },
              populate: function(template, element) {
                element.html(template);
                return element.contents();
              }
            }
          })[doAnimate.toString()];
        };

        // Put back the compiled initial view
        element.append(transclude(scope));

        // Find the details of the parent view directive (if any) and use it
        // to derive our own qualified view name, then hang our own details
        // off the DOM so child directives can find it.
        var parent = element.parent().inheritedData('$uiView');
        if (name.indexOf('@') < 0) name  = name + '@' + (parent ? parent.state.name : '');
        var view = { name: name, state: null };
        element.data('$uiView', view);

        var eventHook = function() {
          if (viewIsUpdating) return;
          viewIsUpdating = true;

          try { updateView(true); } catch (e) {
            viewIsUpdating = false;
            throw e;
          }
          viewIsUpdating = false;
        };

        scope.$on('$stateChangeSuccess', eventHook);
        scope.$on('$viewContentLoading', eventHook);
        updateView(false);

        function updateView(doAnimate) {
          var locals = $state.$current && $state.$current.locals[name];
          if (locals === viewLocals) return; // nothing to do
          var render = renderer(animate && doAnimate);

          // Remove existing content
          render.remove(element);

          // Destroy previous view scope
          if (viewScope) {
            viewScope.$destroy();
            viewScope = null;
          }

          if (!locals) {
            viewLocals = null;
            view.state = null;

            // Restore the initial view
            return render.restore(transclude(scope), element);
          }

          viewLocals = locals;
          view.state = locals.$$state;

          var link = $compile(render.populate(locals.$template, element));
          viewScope = scope.$new();

          if (locals.$$controller) {
            locals.$scope = viewScope;
            var controller = $controller(locals.$$controller, locals);
            element.children().data('$ngControllerController', controller);
          }
          link(viewScope);
          viewScope.$emit('$viewContentLoaded');
          if (onloadExp) viewScope.$eval(onloadExp);

          // TODO: This seems strange, shouldn't $anchorScroll listen for $viewContentLoaded if necessary?
          // $anchorScroll might listen on event...
          $anchorScroll();
        }
      };
    }
  };
  return directive;
}

angular.module('ui.router.state').directive('uiView', $ViewDirective);

function parseStateRef(ref) {
  var parsed = ref.match(/^([^(]+?)\s*(\((.*)\))?$/);
  if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
  return { state: parsed[1], paramExpr: parsed[3] || null };
}

$StateRefDirective.$inject = ['$state'];
function $StateRefDirective($state) {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      var ref = parseStateRef(attrs.uiSref);
      var params = null, url = null, base = $state.$current;
      var isForm = element[0].nodeName === "FORM";
      var attr = isForm ? "action" : "href", nav = true;

      var stateData = element.parent().inheritedData('$uiView');

      if (stateData && stateData.state && stateData.state.name) {
        base = stateData.state;
      }

      var update = function(newVal) {
        if (newVal) params = newVal;
        if (!nav) return;

        var newHref = $state.href(ref.state, params, { relative: base });

        if (!newHref) {
          nav = false;
          return false;
        }
        element[0][attr] = newHref;
      };

      if (ref.paramExpr) {
        scope.$watch(ref.paramExpr, function(newVal, oldVal) {
          if (newVal !== oldVal) update(newVal);
        }, true);
        params = scope.$eval(ref.paramExpr);
      }
      update();

      if (isForm) return;

      element.bind("click", function(e) {
        if ((e.which == 1) && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
          $state.go(ref.state, params, { relative: base });
          scope.$apply();
          e.preventDefault();
        }
      });
    }
  };
}

angular.module('ui.router.state').directive('uiSref', $StateRefDirective);

$RouteProvider.$inject = ['$stateProvider', '$urlRouterProvider'];
function $RouteProvider(  $stateProvider,    $urlRouterProvider) {

  var routes = [];

  onEnterRoute.$inject = ['$$state'];
  function onEnterRoute(   $$state) {
    /*jshint validthis: true */
    this.locals = $$state.locals.globals;
    this.params = this.locals.$stateParams;
  }

  function onExitRoute() {
    /*jshint validthis: true */
    this.locals = null;
    this.params = null;
  }

  this.when = when;
  function when(url, route) {
    /*jshint validthis: true */
    if (route.redirectTo != null) {
      // Redirect, configure directly on $urlRouterProvider
      var redirect = route.redirectTo, handler;
      if (isString(redirect)) {
        handler = redirect; // leave $urlRouterProvider to handle
      } else if (isFunction(redirect)) {
        // Adapt to $urlRouterProvider API
        handler = function (params, $location) {
          return redirect(params, $location.path(), $location.search());
        };
      } else {
        throw new Error("Invalid 'redirectTo' in when()");
      }
      $urlRouterProvider.when(url, handler);
    } else {
      // Regular route, configure as state
      $stateProvider.state(inherit(route, {
        parent: null,
        name: 'route:' + encodeURIComponent(url),
        url: url,
        onEnter: onEnterRoute,
        onExit: onExitRoute
      }));
    }
    routes.push(route);
    return this;
  }

  this.$get = $get;
  $get.$inject = ['$state', '$rootScope', '$routeParams'];
  function $get(   $state,   $rootScope,   $routeParams) {

    var $route = {
      routes: routes,
      params: $routeParams,
      current: undefined
    };

    function stateAsRoute(state) {
      return (state.name !== '') ? state : undefined;
    }

    $rootScope.$on('$stateChangeStart', function (ev, to, toParams, from, fromParams) {
      $rootScope.$broadcast('$routeChangeStart', stateAsRoute(to), stateAsRoute(from));
    });

    $rootScope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {
      $route.current = stateAsRoute(to);
      $rootScope.$broadcast('$routeChangeSuccess', stateAsRoute(to), stateAsRoute(from));
      copy(toParams, $route.params);
    });

    $rootScope.$on('$stateChangeError', function (ev, to, toParams, from, fromParams, error) {
      $rootScope.$broadcast('$routeChangeError', stateAsRoute(to), stateAsRoute(from), error);
    });

    return $route;
  }
}

angular.module('ui.router.compat')
  .provider('$route', $RouteProvider)
  .directive('ngView', $ViewDirective);
})(window, window.angular);
},{}],18:[function(require,module,exports){
/**
 * @license AngularJS v1.2.0-rc.2
 * (c) 2010-2012 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/**
 * @ngdoc overview
 * @name ngCookies
 * @description
 *
 * # ngCookies
 *
 * Provides the {@link ngCookies.$cookies `$cookies`} and
 * {@link ngCookies.$cookieStore `$cookieStore`} services.
 *
 * {@installModule cookies}
 *
 * See {@link ngCookies.$cookies `$cookies`} and
 * {@link ngCookies.$cookieStore `$cookieStore`} for usage.
 */


angular.module('ngCookies', ['ng']).
  /**
   * @ngdoc object
   * @name ngCookies.$cookies
   * @requires $browser
   *
   * @description
   * Provides read/write access to browser's cookies.
   *
   * Only a simple Object is exposed and by adding or removing properties to/from
   * this object, new cookies are created/deleted at the end of current $eval.
   *
   * Requires the {@link ngCookies `ngCookies`} module to be installed.
   *
   * @example
   <doc:example>
     <doc:source>
       <script>
         function ExampleController($cookies) {
           // Retrieving a cookie
           var favoriteCookie = $cookies.myFavorite;
           // Setting a cookie
           $cookies.myFavorite = 'oatmeal';
         }
       </script>
     </doc:source>
   </doc:example>
   */
   factory('$cookies', ['$rootScope', '$browser', function ($rootScope, $browser) {
      var cookies = {},
          lastCookies = {},
          lastBrowserCookies,
          runEval = false,
          copy = angular.copy,
          isUndefined = angular.isUndefined;

      //creates a poller fn that copies all cookies from the $browser to service & inits the service
      $browser.addPollFn(function() {
        var currentCookies = $browser.cookies();
        if (lastBrowserCookies != currentCookies) { //relies on browser.cookies() impl
          lastBrowserCookies = currentCookies;
          copy(currentCookies, lastCookies);
          copy(currentCookies, cookies);
          if (runEval) $rootScope.$apply();
        }
      })();

      runEval = true;

      //at the end of each eval, push cookies
      //TODO: this should happen before the "delayed" watches fire, because if some cookies are not
      //      strings or browser refuses to store some cookies, we update the model in the push fn.
      $rootScope.$watch(push);

      return cookies;


      /**
       * Pushes all the cookies from the service to the browser and verifies if all cookies were stored.
       */
      function push() {
        var name,
            value,
            browserCookies,
            updated;

        //delete any cookies deleted in $cookies
        for (name in lastCookies) {
          if (isUndefined(cookies[name])) {
            $browser.cookies(name, undefined);
          }
        }

        //update all cookies updated in $cookies
        for(name in cookies) {
          value = cookies[name];
          if (!angular.isString(value)) {
            if (angular.isDefined(lastCookies[name])) {
              cookies[name] = lastCookies[name];
            } else {
              delete cookies[name];
            }
          } else if (value !== lastCookies[name]) {
            $browser.cookies(name, value);
            updated = true;
          }
        }

        //verify what was actually stored
        if (updated){
          updated = false;
          browserCookies = $browser.cookies();

          for (name in cookies) {
            if (cookies[name] !== browserCookies[name]) {
              //delete or reset all cookies that the browser dropped from $cookies
              if (isUndefined(browserCookies[name])) {
                delete cookies[name];
              } else {
                cookies[name] = browserCookies[name];
              }
              updated = true;
            }
          }
        }
      }
    }]).


  /**
   * @ngdoc object
   * @name ngCookies.$cookieStore
   * @requires $cookies
   *
   * @description
   * Provides a key-value (string-object) storage, that is backed by session cookies.
   * Objects put or retrieved from this storage are automatically serialized or
   * deserialized by angular's toJson/fromJson.
   *
   * Requires the {@link ngCookies `ngCookies`} module to be installed.
   *
   * @example
   */
   factory('$cookieStore', ['$cookies', function($cookies) {

      return {
        /**
         * @ngdoc method
         * @name ngCookies.$cookieStore#get
         * @methodOf ngCookies.$cookieStore
         *
         * @description
         * Returns the value of given cookie key
         *
         * @param {string} key Id to use for lookup.
         * @returns {Object} Deserialized cookie value.
         */
        get: function(key) {
          var value = $cookies[key];
          return value ? angular.fromJson(value) : value;
        },

        /**
         * @ngdoc method
         * @name ngCookies.$cookieStore#put
         * @methodOf ngCookies.$cookieStore
         *
         * @description
         * Sets a value for given cookie key
         *
         * @param {string} key Id for the `value`.
         * @param {Object} value Value to be stored.
         */
        put: function(key, value) {
          $cookies[key] = angular.toJson(value);
        },

        /**
         * @ngdoc method
         * @name ngCookies.$cookieStore#remove
         * @methodOf ngCookies.$cookieStore
         *
         * @description
         * Remove given cookie
         *
         * @param {string} key Id of the key-value pair to delete.
         */
        remove: function(key) {
          delete $cookies[key];
        }
      };

    }]);


})(window, window.angular);
},{}],19:[function(require,module,exports){
/**
 * @license AngularJS v1.2.0-rc.2
 * (c) 2010-2012 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, document, undefined) {'use strict';

/**
 * @description
 *
 * This object provides a utility for producing rich Error messages within
 * Angular. It can be called as follows:
 *
 * var exampleMinErr = minErr('example');
 * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);
 *
 * The above creates an instance of minErr in the example namespace. The
 * resulting error will have a namespaced error code of example.one.  The
 * resulting error will replace {0} with the value of foo, and {1} with the
 * value of bar. The object is not restricted in the number of arguments it can
 * take.
 *
 * If fewer arguments are specified than necessary for interpolation, the extra
 * interpolation markers will be preserved in the final string.
 *
 * Since data will be parsed statically during a build step, some restrictions
 * are applied with respect to how minErr instances are created and called.
 * Instances should have names of the form namespaceMinErr for a minErr created
 * using minErr('namespace') . Error codes, namespaces and template strings
 * should all be static strings, not variables or general expressions.
 *
 * @param {string} module The namespace to use for the new minErr instance.
 * @returns {function(string, string, ...): Error} instance
 */

function minErr(module) {
  return function () {
    var code = arguments[0],
      prefix = '[' + (module ? module + ':' : '') + code + '] ',
      template = arguments[1],
      templateArgs = arguments,
      stringify = function (obj) {
        if (isFunction(obj)) {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (!isString(obj)) {
          return JSON.stringify(obj);
        }
        return obj;
      },
      message, i;

    message = prefix + template.replace(/\{\d+\}/g, function (match) {
      var index = +match.slice(1, -1), arg;

      if (index + 2 < templateArgs.length) {
        arg = templateArgs[index + 2];
        if (isFunction(arg)) {
          return arg.toString().replace(/ ?\{[\s\S]*$/, '');
        } else if (isUndefined(arg)) {
          return 'undefined';
        } else if (!isString(arg)) {
          return toJson(arg);
        }
        return arg;
      }
      return match;
    });

    message = message + '\nhttp://errors.angularjs.org/' + version.full + '/' +
      (module ? module + '/' : '') + code;
    for (i = 2; i < arguments.length; i++) {
      message = message + (i == 2 ? '?' : '&') + 'p' + (i-2) + '=' +
        encodeURIComponent(stringify(arguments[i]));
    }

    return new Error(message);
  };
}

////////////////////////////////////

/**
 * hasOwnProperty may be overwritten by a property of the same name, or entirely
 * absent from an object that does not inherit Object.prototype; this copy is
 * used instead
 */
var hasOwnPropertyFn = Object.prototype.hasOwnProperty;
var hasOwnPropertyLocal = function(obj, key) {
  return hasOwnPropertyFn.call(obj, key);
};

/**
 * @ngdoc function
 * @name angular.lowercase
 * @function
 *
 * @description Converts the specified string to lowercase.
 * @param {string} string String to be converted to lowercase.
 * @returns {string} Lowercased string.
 */
var lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};


/**
 * @ngdoc function
 * @name angular.uppercase
 * @function
 *
 * @description Converts the specified string to uppercase.
 * @param {string} string String to be converted to uppercase.
 * @returns {string} Uppercased string.
 */
var uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};


var manualLowercase = function(s) {
  return isString(s)
      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})
      : s;
};
var manualUppercase = function(s) {
  return isString(s)
      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})
      : s;
};


// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish
// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods
// with correct but slower alternatives.
if ('i' !== 'I'.toLowerCase()) {
  lowercase = manualLowercase;
  uppercase = manualUppercase;
}


var /** holds major version number for IE or NaN for real browsers */
    msie,
    jqLite,           // delay binding since jQuery could be loaded after us.
    jQuery,           // delay binding
    slice             = [].slice,
    push              = [].push,
    toString          = Object.prototype.toString,
    ngMinErr          = minErr('ng'),


    _angular          = window.angular,
    /** @name angular */
    angular           = window.angular || (window.angular = {}),
    angularModule,
    nodeName_,
    uid               = ['0', '0', '0'];

/**
 * IE 11 changed the format of the UserAgent string.
 * See http://msdn.microsoft.com/en-us/library/ms537503.aspx
 */
msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);
if (isNaN(msie)) {
  msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);
}


/**
 * @private
 * @param {*} obj
 * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments, ...)
 */
function isArrayLike(obj) {
  if (obj == null || isWindow(obj)) {
    return false;
  }
  
  var length = obj.length;

  if (obj.nodeType === 1 && length) {
    return true;
  }

  return isArray(obj) || !isFunction(obj) && (
    length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj
  );
}

/**
 * @ngdoc function
 * @name angular.forEach
 * @function
 *
 * @description
 * Invokes the `iterator` function once for each item in `obj` collection, which can be either an
 * object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`
 * is the value of an object property or an array element and `key` is the object property key or
 * array element index. Specifying a `context` for the function is optional.
 *
 * Note: this function was previously known as `angular.foreach`.
 *
   <pre>
     var values = {name: 'misko', gender: 'male'};
     var log = [];
     angular.forEach(values, function(value, key){
       this.push(key + ': ' + value);
     }, log);
     expect(log).toEqual(['name: misko', 'gender:male']);
   </pre>
 *
 * @param {Object|Array} obj Object to iterate over.
 * @param {Function} iterator Iterator function.
 * @param {Object=} context Object to become context (`this`) for the iterator function.
 * @returns {Object|Array} Reference to `obj`.
 */
function forEach(obj, iterator, context) {
  var key;
  if (obj) {
    if (isFunction(obj)){
      for (key in obj) {
        if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {
          iterator.call(context, obj[key], key);
        }
      }
    } else if (obj.forEach && obj.forEach !== forEach) {
      obj.forEach(iterator, context);
    } else if (isArrayLike(obj)) {
      for (key = 0; key < obj.length; key++)
        iterator.call(context, obj[key], key);
    } else {
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          iterator.call(context, obj[key], key);
        }
      }
    }
  }
  return obj;
}

function sortedKeys(obj) {
  var keys = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      keys.push(key);
    }
  }
  return keys.sort();
}

function forEachSorted(obj, iterator, context) {
  var keys = sortedKeys(obj);
  for ( var i = 0; i < keys.length; i++) {
    iterator.call(context, obj[keys[i]], keys[i]);
  }
  return keys;
}


/**
 * when using forEach the params are value, key, but it is often useful to have key, value.
 * @param {function(string, *)} iteratorFn
 * @returns {function(*, string)}
 */
function reverseParams(iteratorFn) {
  return function(value, key) { iteratorFn(key, value) };
}

/**
 * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric
 * characters such as '012ABC'. The reason why we are not using simply a number counter is that
 * the number string gets longer over time, and it can also overflow, where as the nextId
 * will grow much slower, it is a string, and it will never overflow.
 *
 * @returns an unique alpha-numeric string
 */
function nextUid() {
  var index = uid.length;
  var digit;

  while(index) {
    index--;
    digit = uid[index].charCodeAt(0);
    if (digit == 57 /*'9'*/) {
      uid[index] = 'A';
      return uid.join('');
    }
    if (digit == 90  /*'Z'*/) {
      uid[index] = '0';
    } else {
      uid[index] = String.fromCharCode(digit + 1);
      return uid.join('');
    }
  }
  uid.unshift('0');
  return uid.join('');
}


/**
 * Set or clear the hashkey for an object.
 * @param obj object
 * @param h the hashkey (!truthy to delete the hashkey)
 */
function setHashKey(obj, h) {
  if (h) {
    obj.$$hashKey = h;
  }
  else {
    delete obj.$$hashKey;
  }
}

/**
 * @ngdoc function
 * @name angular.extend
 * @function
 *
 * @description
 * Extends the destination object `dst` by copying all of the properties from the `src` object(s)
 * to `dst`. You can specify multiple `src` objects.
 *
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
function extend(dst) {
  var h = dst.$$hashKey;
  forEach(arguments, function(obj){
    if (obj !== dst) {
      forEach(obj, function(value, key){
        dst[key] = value;
      });
    }
  });

  setHashKey(dst,h);
  return dst;
}

function int(str) {
  return parseInt(str, 10);
}


function inherit(parent, extra) {
  return extend(new (extend(function() {}, {prototype:parent}))(), extra);
}

/**
 * @ngdoc function
 * @name angular.noop
 * @function
 *
 * @description
 * A function that performs no operations. This function can be useful when writing code in the
 * functional style.
   <pre>
     function foo(callback) {
       var result = calculateResult();
       (callback || angular.noop)(result);
     }
   </pre>
 */
function noop() {}
noop.$inject = [];


/**
 * @ngdoc function
 * @name angular.identity
 * @function
 *
 * @description
 * A function that returns its first argument. This function is useful when writing code in the
 * functional style.
 *
   <pre>
     function transformer(transformationFn, value) {
       return (transformationFn || angular.identity)(value);
     };
   </pre>
 */
function identity($) {return $;}
identity.$inject = [];


function valueFn(value) {return function() {return value;};}

/**
 * @ngdoc function
 * @name angular.isUndefined
 * @function
 *
 * @description
 * Determines if a reference is undefined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is undefined.
 */
function isUndefined(value){return typeof value == 'undefined';}


/**
 * @ngdoc function
 * @name angular.isDefined
 * @function
 *
 * @description
 * Determines if a reference is defined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is defined.
 */
function isDefined(value){return typeof value != 'undefined';}


/**
 * @ngdoc function
 * @name angular.isObject
 * @function
 *
 * @description
 * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
 * considered to be objects.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is an `Object` but not `null`.
 */
function isObject(value){return value != null && typeof value == 'object';}


/**
 * @ngdoc function
 * @name angular.isString
 * @function
 *
 * @description
 * Determines if a reference is a `String`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `String`.
 */
function isString(value){return typeof value == 'string';}


/**
 * @ngdoc function
 * @name angular.isNumber
 * @function
 *
 * @description
 * Determines if a reference is a `Number`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Number`.
 */
function isNumber(value){return typeof value == 'number';}


/**
 * @ngdoc function
 * @name angular.isDate
 * @function
 *
 * @description
 * Determines if a value is a date.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Date`.
 */
function isDate(value){
  return toString.apply(value) == '[object Date]';
}


/**
 * @ngdoc function
 * @name angular.isArray
 * @function
 *
 * @description
 * Determines if a reference is an `Array`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is an `Array`.
 */
function isArray(value) {
  return toString.apply(value) == '[object Array]';
}


/**
 * @ngdoc function
 * @name angular.isFunction
 * @function
 *
 * @description
 * Determines if a reference is a `Function`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Function`.
 */
function isFunction(value){return typeof value == 'function';}


/**
 * Determines if a value is a regular expression object.
 *
 * @private
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `RegExp`.
 */
function isRegExp(value) {
  return toString.apply(value) == '[object RegExp]';
}


/**
 * Checks if `obj` is a window object.
 *
 * @private
 * @param {*} obj Object to check
 * @returns {boolean} True if `obj` is a window obj.
 */
function isWindow(obj) {
  return obj && obj.document && obj.location && obj.alert && obj.setInterval;
}


function isScope(obj) {
  return obj && obj.$evalAsync && obj.$watch;
}


function isFile(obj) {
  return toString.apply(obj) === '[object File]';
}


function isBoolean(value) {
  return typeof value == 'boolean';
}


var trim = (function() {
  // native trim is way faster: http://jsperf.com/angular-trim-test
  // but IE doesn't have it... :-(
  // TODO: we should move this into IE/ES5 polyfill
  if (!String.prototype.trim) {
    return function(value) {
      return isString(value) ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;
    };
  }
  return function(value) {
    return isString(value) ? value.trim() : value;
  };
})();


/**
 * @ngdoc function
 * @name angular.isElement
 * @function
 *
 * @description
 * Determines if a reference is a DOM element (or wrapped jQuery element).
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).
 */
function isElement(node) {
  return node &&
    (node.nodeName  // we are a direct element
    || (node.on && node.find));  // we have an on and find method part of jQuery API
}

/**
 * @param str 'key1,key2,...'
 * @returns {object} in the form of {key1:true, key2:true, ...}
 */
function makeMap(str){
  var obj = {}, items = str.split(","), i;
  for ( i = 0; i < items.length; i++ )
    obj[ items[i] ] = true;
  return obj;
}


if (msie < 9) {
  nodeName_ = function(element) {
    element = element.nodeName ? element : element[0];
    return (element.scopeName && element.scopeName != 'HTML')
      ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
  };
} else {
  nodeName_ = function(element) {
    return element.nodeName ? element.nodeName : element[0].nodeName;
  };
}


function map(obj, iterator, context) {
  var results = [];
  forEach(obj, function(value, index, list) {
    results.push(iterator.call(context, value, index, list));
  });
  return results;
}


/**
 * @description
 * Determines the number of elements in an array, the number of properties an object has, or
 * the length of a string.
 *
 * Note: This function is used to augment the Object type in Angular expressions. See
 * {@link angular.Object} for more information about Angular arrays.
 *
 * @param {Object|Array|string} obj Object, array, or string to inspect.
 * @param {boolean} [ownPropsOnly=false] Count only "own" properties in an object
 * @returns {number} The size of `obj` or `0` if `obj` is neither an object nor an array.
 */
function size(obj, ownPropsOnly) {
  var size = 0, key;

  if (isArray(obj) || isString(obj)) {
    return obj.length;
  } else if (isObject(obj)){
    for (key in obj)
      if (!ownPropsOnly || obj.hasOwnProperty(key))
        size++;
  }

  return size;
}


function includes(array, obj) {
  return indexOf(array, obj) != -1;
}

function indexOf(array, obj) {
  if (array.indexOf) return array.indexOf(obj);

  for ( var i = 0; i < array.length; i++) {
    if (obj === array[i]) return i;
  }
  return -1;
}

function arrayRemove(array, value) {
  var index = indexOf(array, value);
  if (index >=0)
    array.splice(index, 1);
  return value;
}

function isLeafNode (node) {
  if (node) {
    switch (node.nodeName) {
    case "OPTION":
    case "PRE":
    case "TITLE":
      return true;
    }
  }
  return false;
}

/**
 * @ngdoc function
 * @name angular.copy
 * @function
 *
 * @description
 * Creates a deep copy of `source`, which should be an object or an array.
 *
 * * If no destination is supplied, a copy of the object or array is created.
 * * If a destination is provided, all of its elements (for array) or properties (for objects)
 *   are deleted and then all elements/properties from the source are copied to it.
 * * If  `source` is not an object or array, `source` is returned.
 *
 * Note: this function is used to augment the Object type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {*} source The source that will be used to make a copy.
 *                   Can be any type, including primitives, `null`, and `undefined`.
 * @param {(Object|Array)=} destination Destination into which the source is copied. If
 *     provided, must be of the same type as `source`.
 * @returns {*} The copy or updated `destination`, if `destination` was specified.
 */
function copy(source, destination){
  if (isWindow(source) || isScope(source)) {
    throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
  }

  if (!destination) {
    destination = source;
    if (source) {
      if (isArray(source)) {
        destination = copy(source, []);
      } else if (isDate(source)) {
        destination = new Date(source.getTime());
      } else if (isRegExp(source)) {
        destination = new RegExp(source.source);
      } else if (isObject(source)) {
        destination = copy(source, {});
      }
    }
  } else {
    if (source === destination) throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
    if (isArray(source)) {
      destination.length = 0;
      for ( var i = 0; i < source.length; i++) {
        destination.push(copy(source[i]));
      }
    } else {
      var h = destination.$$hashKey;
      forEach(destination, function(value, key){
        delete destination[key];
      });
      for ( var key in source) {
        destination[key] = copy(source[key]);
      }
      setHashKey(destination,h);
    }
  }
  return destination;
}

/**
 * Create a shallow copy of an object
 */
function shallowCopy(src, dst) {
  dst = dst || {};

  for(var key in src) {
    if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {
      dst[key] = src[key];
    }
  }

  return dst;
}


/**
 * @ngdoc function
 * @name angular.equals
 * @function
 *
 * @description
 * Determines if two objects or two values are equivalent. Supports value types, regular expressions, arrays and
 * objects.
 *
 * Two objects or values are considered equivalent if at least one of the following is true:
 *
 * * Both objects or values pass `===` comparison.
 * * Both objects or values are of the same type and all of their properties pass `===` comparison.
 * * Both values are NaN. (In JavasScript, NaN == NaN => false. But we consider two NaN as equal)
 * * Both values represent the same regular expression (In JavasScript,
 *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
 *   representation matches).
 *
 * During a property comparison, properties of `function` type and properties with names
 * that begin with `$` are ignored.
 *
 * Scope and DOMWindow objects are being compared only by identify (`===`).
 *
 * @param {*} o1 Object or value to compare.
 * @param {*} o2 Object or value to compare.
 * @returns {boolean} True if arguments are equal.
 */
function equals(o1, o2) {
  if (o1 === o2) return true;
  if (o1 === null || o2 === null) return false;
  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
  if (t1 == t2) {
    if (t1 == 'object') {
      if (isArray(o1)) {
        if (!isArray(o2)) return false;
        if ((length = o1.length) == o2.length) {
          for(key=0; key<length; key++) {
            if (!equals(o1[key], o2[key])) return false;
          }
          return true;
        }
      } else if (isDate(o1)) {
        return isDate(o2) && o1.getTime() == o2.getTime();
      } else if (isRegExp(o1) && isRegExp(o2)) {
        return o1.toString() == o2.toString();
      } else {
        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
        keySet = {};
        for(key in o1) {
          if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
          if (!equals(o1[key], o2[key])) return false;
          keySet[key] = true;
        }
        for(key in o2) {
          if (!keySet.hasOwnProperty(key) &&
              key.charAt(0) !== '$' &&
              o2[key] !== undefined &&
              !isFunction(o2[key])) return false;
        }
        return true;
      }
    }
  }
  return false;
}


function concat(array1, array2, index) {
  return array1.concat(slice.call(array2, index));
}

function sliceArgs(args, startIndex) {
  return slice.call(args, startIndex || 0);
}


/**
 * @ngdoc function
 * @name angular.bind
 * @function
 *
 * @description
 * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
 * `fn`). You can supply optional `args` that are prebound to the function. This feature is also
 * known as [function currying](http://en.wikipedia.org/wiki/Currying).
 *
 * @param {Object} self Context which `fn` should be evaluated in.
 * @param {function()} fn Function to be bound.
 * @param {...*} args Optional arguments to be prebound to the `fn` function call.
 * @returns {function()} Function that wraps the `fn` with all the specified bindings.
 */
function bind(self, fn) {
  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
  if (isFunction(fn) && !(fn instanceof RegExp)) {
    return curryArgs.length
      ? function() {
          return arguments.length
            ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))
            : fn.apply(self, curryArgs);
        }
      : function() {
          return arguments.length
            ? fn.apply(self, arguments)
            : fn.call(self);
        };
  } else {
    // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)
    return fn;
  }
}


function toJsonReplacer(key, value) {
  var val = value;

  if (/^\$+/.test(key)) {
    val = undefined;
  } else if (isWindow(value)) {
    val = '$WINDOW';
  } else if (value &&  document === value) {
    val = '$DOCUMENT';
  } else if (isScope(value)) {
    val = '$SCOPE';
  }

  return val;
}


/**
 * @ngdoc function
 * @name angular.toJson
 * @function
 *
 * @description
 * Serializes input into a JSON-formatted string. Properties with leading $ characters will be
 * stripped since angular uses this notation internally.
 *
 * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.
 * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.
 * @returns {string|undefined} JSON-ified string representing `obj`.
 */
function toJson(obj, pretty) {
  if (typeof obj === 'undefined') return undefined;
  return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
}


/**
 * @ngdoc function
 * @name angular.fromJson
 * @function
 *
 * @description
 * Deserializes a JSON string.
 *
 * @param {string} json JSON string to deserialize.
 * @returns {Object|Array|Date|string|number} Deserialized thingy.
 */
function fromJson(json) {
  return isString(json)
      ? JSON.parse(json)
      : json;
}


function toBoolean(value) {
  if (value && value.length !== 0) {
    var v = lowercase("" + value);
    value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
  } else {
    value = false;
  }
  return value;
}

/**
 * @returns {string} Returns the string representation of the element.
 */
function startingTag(element) {
  element = jqLite(element).clone();
  try {
    // turns out IE does not let you set .html() on elements which
    // are not allowed to have children. So we just ignore it.
    element.html('');
  } catch(e) {}
  // As Per DOM Standards
  var TEXT_NODE = 3;
  var elemHtml = jqLite('<div>').append(element).html();
  try {
    return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) :
        elemHtml.
          match(/^(<[^>]+>)/)[1].
          replace(/^<([\w\-]+)/, function(match, nodeName) { return '<' + lowercase(nodeName); });
  } catch(e) {
    return lowercase(elemHtml);
  }

}


/////////////////////////////////////////////////

/**
 * Tries to decode the URI component without throwing an exception.
 *
 * @private
 * @param str value potential URI component to check.
 * @returns {boolean} True if `value` can be decoded
 * with the decodeURIComponent function.
 */
function tryDecodeURIComponent(value) {
  try {
    return decodeURIComponent(value);
  } catch(e) {
    // Ignore any invalid uri component
  }
}


/**
 * Parses an escaped url query string into key-value pairs.
 * @returns Object.<(string|boolean)>
 */
function parseKeyValue(/**string*/keyValue) {
  var obj = {}, key_value, key;
  forEach((keyValue || "").split('&'), function(keyValue){
    if ( keyValue ) {
      key_value = keyValue.split('=');
      key = tryDecodeURIComponent(key_value[0]);
      if ( isDefined(key) ) {
        var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
        if (!obj[key]) {
          obj[key] = val;
        } else if(isArray(obj[key])) {
          obj[key].push(val);
        } else {
          obj[key] = [obj[key],val];
        }
      }
    }
  });
  return obj;
}

function toKeyValue(obj) {
  var parts = [];
  forEach(obj, function(value, key) {
    if (isArray(value)) {
      forEach(value, function(arrayValue) {
        parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
      });
    } else {
    parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
    }
  });
  return parts.length ? parts.join('&') : '';
}


/**
 * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
 * segments:
 *    segment       = *pchar
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriSegment(val) {
  return encodeUriQuery(val, true).
             replace(/%26/gi, '&').
             replace(/%3D/gi, '=').
             replace(/%2B/gi, '+');
}


/**
 * This method is intended for encoding *key* or *value* parts of query component. We need a custom
 * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
 * encoded per http://tools.ietf.org/html/rfc3986:
 *    query       = *( pchar / "/" / "?" )
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriQuery(val, pctEncodeSpaces) {
  return encodeURIComponent(val).
             replace(/%40/gi, '@').
             replace(/%3A/gi, ':').
             replace(/%24/g, '$').
             replace(/%2C/gi, ',').
             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
}


/**
 * @ngdoc directive
 * @name ng.directive:ngApp
 *
 * @element ANY
 * @param {angular.Module} ngApp an optional application
 *   {@link angular.module module} name to load.
 *
 * @description
 *
 * Use this directive to auto-bootstrap an application. Only
 * one ngApp directive can be used per HTML document. The directive
 * designates the root of the application and is typically placed
 * at the root of the page.
 *
 * The first ngApp found in the document will be auto-bootstrapped. To use multiple applications in an
 * HTML document you must manually bootstrap them using {@link angular.bootstrap}.
 * Applications cannot be nested.
 *
 * In the example below if the `ngApp` directive would not be placed
 * on the `html` element then the document would not be compiled
 * and the `{{ 1+2 }}` would not be resolved to `3`.
 *
 * `ngApp` is the easiest way to bootstrap an application.
 *
 <doc:example>
   <doc:source>
    I can add: 1 + 2 =  {{ 1+2 }}
   </doc:source>
 </doc:example>
 *
 */
function angularInit(element, bootstrap) {
  var elements = [element],
      appElement,
      module,
      names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],
      NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;

  function append(element) {
    element && elements.push(element);
  }

  forEach(names, function(name) {
    names[name] = true;
    append(document.getElementById(name));
    name = name.replace(':', '\\:');
    if (element.querySelectorAll) {
      forEach(element.querySelectorAll('.' + name), append);
      forEach(element.querySelectorAll('.' + name + '\\:'), append);
      forEach(element.querySelectorAll('[' + name + ']'), append);
    }
  });

  forEach(elements, function(element) {
    if (!appElement) {
      var className = ' ' + element.className + ' ';
      var match = NG_APP_CLASS_REGEXP.exec(className);
      if (match) {
        appElement = element;
        module = (match[2] || '').replace(/\s+/g, ',');
      } else {
        forEach(element.attributes, function(attr) {
          if (!appElement && names[attr.name]) {
            appElement = element;
            module = attr.value;
          }
        });
      }
    }
  });
  if (appElement) {
    bootstrap(appElement, module ? [module] : []);
  }
}

/**
 * @ngdoc function
 * @name angular.bootstrap
 * @description
 * Use this function to manually start up angular application.
 *
 * See: {@link guide/bootstrap Bootstrap}
 *
 * Note that ngScenario-based end-to-end tests cannot use this function to bootstrap manually.
 * They must use {@link api/ng.directive:ngApp ngApp}.
 *
 * @param {Element} element DOM element which is the root of angular application.
 * @param {Array<String|Function>=} modules an array of module declarations. See: {@link angular.module modules}
 * @returns {AUTO.$injector} Returns the newly created injector for this app.
 */
function bootstrap(element, modules) {
  var doBootstrap = function() {
    element = jqLite(element);

    if (element.injector()) {
      var tag = (element[0] === document) ? 'document' : startingTag(element);
      throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag);
    }

    modules = modules || [];
    modules.unshift(['$provide', function($provide) {
      $provide.value('$rootElement', element);
    }]);
    modules.unshift('ng');
    var injector = createInjector(modules);
    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', '$animate',
       function(scope, element, compile, injector, animate) {
        scope.$apply(function() {
          element.data('$injector', injector);
          compile(element)(scope);
        });
        animate.enabled(true);
      }]
    );
    return injector;
  };

  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;

  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
    return doBootstrap();
  }

  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
  angular.resumeBootstrap = function(extraModules) {
    forEach(extraModules, function(module) {
      modules.push(module);
    });
    doBootstrap();
  };
}

var SNAKE_CASE_REGEXP = /[A-Z]/g;
function snake_case(name, separator){
  separator = separator || '_';
  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
    return (pos ? separator : '') + letter.toLowerCase();
  });
}

function bindJQuery() {
  // bind to jQuery if present;
  jQuery = window.jQuery;
  // reset to jQuery or default to us.
  if (jQuery) {
    jqLite = jQuery;
    extend(jQuery.fn, {
      scope: JQLitePrototype.scope,
      controller: JQLitePrototype.controller,
      injector: JQLitePrototype.injector,
      inheritedData: JQLitePrototype.inheritedData
    });
    // Method signature: JQLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments)
    JQLitePatchJQueryRemove('remove', true, true, false);
    JQLitePatchJQueryRemove('empty', false, false, false);
    JQLitePatchJQueryRemove('html', false, false, true);
  } else {
    jqLite = JQLite;
  }
  angular.element = jqLite;
}

/**
 * throw error if the argument is falsy.
 */
function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
  }
  return arg;
}

function assertArgFn(arg, name, acceptArrayAnnotation) {
  if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
  }

  assertArg(isFunction(arg), name, 'not a function, got ' +
      (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
  return arg;
}

/**
 * Return the value accessible from the object by path. Any undefined traversals are ignored
 * @param {Object} obj starting object
 * @param {string} path path to traverse
 * @param {boolean=true} bindFnToScope
 * @returns value as accessible by path
 */
//TODO(misko): this function needs to be removed
function getter(obj, path, bindFnToScope) {
  if (!path) return obj;
  var keys = path.split('.');
  var key;
  var lastInstance = obj;
  var len = keys.length;

  for (var i = 0; i < len; i++) {
    key = keys[i];
    if (obj) {
      obj = (lastInstance = obj)[key];
    }
  }
  if (!bindFnToScope && isFunction(obj)) {
    return bind(lastInstance, obj);
  }
  return obj;
}

/**
 * @ngdoc interface
 * @name angular.Module
 * @description
 *
 * Interface for configuring angular {@link angular.module modules}.
 */

function setupModuleLoader(window) {

  function ensure(obj, name, factory) {
    return obj[name] || (obj[name] = factory());
  }

  return ensure(ensure(window, 'angular', Object), 'module', function() {
    /** @type {Object.<string, angular.Module>} */
    var modules = {};

    /**
     * @ngdoc function
     * @name angular.module
     * @description
     *
     * The `angular.module` is a global place for creating, registering and retrieving Angular modules.
     * All modules (angular core or 3rd party) that should be available to an application must be
     * registered using this mechanism.
     *
     * When passed two or more arguments, a new module is created.  If passed only one argument, an
     * existing module (the name passed as the first argument to `module`) is retrieved.
     *
     *
     * # Module
     *
     * A module is a collection of services, directives, filters, and configuration information.
     * `angular.module` is used to configure the {@link AUTO.$injector $injector}.
     *
     * <pre>
     * // Create a new module
     * var myModule = angular.module('myModule', []);
     *
     * // register a new service
     * myModule.value('appName', 'MyCoolApp');
     *
     * // configure existing services inside initialization blocks.
     * myModule.config(function($locationProvider) {
     *   // Configure existing providers
     *   $locationProvider.hashPrefix('!');
     * });
     * </pre>
     *
     * Then you can create an injector and load your modules like this:
     *
     * <pre>
     * var injector = angular.injector(['ng', 'MyModule'])
     * </pre>
     *
     * However it's more likely that you'll just use
     * {@link ng.directive:ngApp ngApp} or
     * {@link angular.bootstrap} to simplify this process for you.
     *
     * @param {!string} name The name of the module to create or retrieve.
     * @param {Array.<string>=} requires If specified then new module is being created. If unspecified then the
     *        the module is being retrieved for further configuration.
     * @param {Function} configFn Optional configuration function for the module. Same as
     *        {@link angular.Module#config Module#config()}.
     * @returns {module} new module with the {@link angular.Module} api.
     */
    return function module(name, requires, configFn) {
      if (requires && modules.hasOwnProperty(name)) {
        modules[name] = null;
      }
      return ensure(modules, name, function() {
        if (!requires) {
          throw minErr('$injector')('nomod', "Module '{0}' is not available! You either misspelled the module name " +
              "or forgot to load it. If registering a module ensure that you specify the dependencies as the second " +
              "argument.", name);
        }

        /** @type {!Array.<Array.<*>>} */
        var invokeQueue = [];

        /** @type {!Array.<Function>} */
        var runBlocks = [];

        var config = invokeLater('$injector', 'invoke');

        /** @type {angular.Module} */
        var moduleInstance = {
          // Private state
          _invokeQueue: invokeQueue,
          _runBlocks: runBlocks,

          /**
           * @ngdoc property
           * @name angular.Module#requires
           * @propertyOf angular.Module
           * @returns {Array.<string>} List of module names which must be loaded before this module.
           * @description
           * Holds the list of modules which the injector will load before the current module is loaded.
           */
          requires: requires,

          /**
           * @ngdoc property
           * @name angular.Module#name
           * @propertyOf angular.Module
           * @returns {string} Name of the module.
           * @description
           */
          name: name,


          /**
           * @ngdoc method
           * @name angular.Module#provider
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} providerType Construction function for creating new instance of the service.
           * @description
           * See {@link AUTO.$provide#provider $provide.provider()}.
           */
          provider: invokeLater('$provide', 'provider'),

          /**
           * @ngdoc method
           * @name angular.Module#factory
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} providerFunction Function for creating new instance of the service.
           * @description
           * See {@link AUTO.$provide#factory $provide.factory()}.
           */
          factory: invokeLater('$provide', 'factory'),

          /**
           * @ngdoc method
           * @name angular.Module#service
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} constructor A constructor function that will be instantiated.
           * @description
           * See {@link AUTO.$provide#service $provide.service()}.
           */
          service: invokeLater('$provide', 'service'),

          /**
           * @ngdoc method
           * @name angular.Module#value
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {*} object Service instance object.
           * @description
           * See {@link AUTO.$provide#value $provide.value()}.
           */
          value: invokeLater('$provide', 'value'),

          /**
           * @ngdoc method
           * @name angular.Module#constant
           * @methodOf angular.Module
           * @param {string} name constant name
           * @param {*} object Constant value.
           * @description
           * Because the constant are fixed, they get applied before other provide methods.
           * See {@link AUTO.$provide#constant $provide.constant()}.
           */
          constant: invokeLater('$provide', 'constant', 'unshift'),

          /**
           * @ngdoc method
           * @name angular.Module#animation
           * @methodOf angular.Module
           * @param {string} name animation name
           * @param {Function} animationFactory Factory function for creating new instance of an animation.
           * @description
           *
           * **NOTE**: animations are take effect only if the **ngAnimate** module is loaded.
           *
           *
           * Defines an animation hook that can be later used with {@link ngAnimate.$animate $animate} service and
           * directives that use this service.
           *
           * <pre>
           * module.animation('.animation-name', function($inject1, $inject2) {
           *   return {
           *     eventName : function(element, done) {
           *       //code to run the animation
           *       //once complete, then run done()
           *       return function cancellationFunction(element) {
           *         //code to cancel the animation
           *       }
           *     }
           *   }
           * })
           * </pre>
           *
           * See {@link ngAnimate.$animateProvider#register $animateProvider.register()} and
           * {@link ngAnimate ngAnimate module} for more information.
           */
          animation: invokeLater('$animateProvider', 'register'),

          /**
           * @ngdoc method
           * @name angular.Module#filter
           * @methodOf angular.Module
           * @param {string} name Filter name.
           * @param {Function} filterFactory Factory function for creating new instance of filter.
           * @description
           * See {@link ng.$filterProvider#register $filterProvider.register()}.
           */
          filter: invokeLater('$filterProvider', 'register'),

          /**
           * @ngdoc method
           * @name angular.Module#controller
           * @methodOf angular.Module
           * @param {string} name Controller name.
           * @param {Function} constructor Controller constructor function.
           * @description
           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.
           */
          controller: invokeLater('$controllerProvider', 'register'),

          /**
           * @ngdoc method
           * @name angular.Module#directive
           * @methodOf angular.Module
           * @param {string} name directive name
           * @param {Function} directiveFactory Factory function for creating new instance of
           * directives.
           * @description
           * See {@link ng.$compileProvider#directive $compileProvider.directive()}.
           */
          directive: invokeLater('$compileProvider', 'directive'),

          /**
           * @ngdoc method
           * @name angular.Module#config
           * @methodOf angular.Module
           * @param {Function} configFn Execute this function on module load. Useful for service
           *    configuration.
           * @description
           * Use this method to register work which needs to be performed on module loading.
           */
          config: config,

          /**
           * @ngdoc method
           * @name angular.Module#run
           * @methodOf angular.Module
           * @param {Function} initializationFn Execute this function after injector creation.
           *    Useful for application initialization.
           * @description
           * Use this method to register work which should be performed when the injector is done
           * loading all modules.
           */
          run: function(block) {
            runBlocks.push(block);
            return this;
          }
        };

        if (configFn) {
          config(configFn);
        }

        return  moduleInstance;

        /**
         * @param {string} provider
         * @param {string} method
         * @param {String=} insertMethod
         * @returns {angular.Module}
         */
        function invokeLater(provider, method, insertMethod) {
          return function() {
            invokeQueue[insertMethod || 'push']([provider, method, arguments]);
            return moduleInstance;
          }
        }
      });
    };
  });

}

/**
 * @ngdoc property
 * @name angular.version
 * @description
 * An object that contains information about the current AngularJS version. This object has the
 * following properties:
 *
 * - `full`  `{string}`  Full version string, such as "0.9.18".
 * - `major`  `{number}`  Major version number, such as "0".
 * - `minor`  `{number}`  Minor version number, such as "9".
 * - `dot`  `{number}`  Dot version number, such as "18".
 * - `codeName`  `{string}`  Code name of the release, such as "jiggling-armfat".
 */
var version = {
  full: '1.2.0-rc.2',    // all of these placeholder strings will be replaced by grunt's
  major: 1,    // package task
  minor: 2,
  dot: 0,
  codeName: 'barehand-atomsplitting'
};


function publishExternalAPI(angular){
  extend(angular, {
    'bootstrap': bootstrap,
    'copy': copy,
    'extend': extend,
    'equals': equals,
    'element': jqLite,
    'forEach': forEach,
    'injector': createInjector,
    'noop':noop,
    'bind':bind,
    'toJson': toJson,
    'fromJson': fromJson,
    'identity':identity,
    'isUndefined': isUndefined,
    'isDefined': isDefined,
    'isString': isString,
    'isFunction': isFunction,
    'isObject': isObject,
    'isNumber': isNumber,
    'isElement': isElement,
    'isArray': isArray,
    '$$minErr': minErr,
    'version': version,
    'isDate': isDate,
    'lowercase': lowercase,
    'uppercase': uppercase,
    'callbacks': {counter: 0}
  });

  angularModule = setupModuleLoader(window);
  try {
    angularModule('ngLocale');
  } catch (e) {
    angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
  }

  angularModule('ng', ['ngLocale'], ['$provide',
    function ngModule($provide) {
      $provide.provider('$compile', $CompileProvider).
        directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCsp: ngCspDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            ngValue: ngValueDirective
        }).
        directive(ngAttributeAliasDirectives).
        directive(ngEventDirectives);
      $provide.provider({
        $anchorScroll: $AnchorScrollProvider,
        $animate: $AnimateProvider,
        $browser: $BrowserProvider,
        $cacheFactory: $CacheFactoryProvider,
        $controller: $ControllerProvider,
        $document: $DocumentProvider,
        $exceptionHandler: $ExceptionHandlerProvider,
        $filter: $FilterProvider,
        $interpolate: $InterpolateProvider,
        $http: $HttpProvider,
        $httpBackend: $HttpBackendProvider,
        $location: $LocationProvider,
        $log: $LogProvider,
        $parse: $ParseProvider,
        $rootScope: $RootScopeProvider,
        $q: $QProvider,
        $sce: $SceProvider,
        $sceDelegate: $SceDelegateProvider,
        $sniffer: $SnifferProvider,
        $templateCache: $TemplateCacheProvider,
        $timeout: $TimeoutProvider,
        $window: $WindowProvider,
        $$urlUtils: $$UrlUtilsProvider
      });
    }
  ]);
}

//////////////////////////////////
//JQLite
//////////////////////////////////

/**
 * @ngdoc function
 * @name angular.element
 * @function
 *
 * @description
 * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.
 * `angular.element` can be either an alias for [jQuery](http://api.jquery.com/jQuery/) function, if
 * jQuery is available, or a function that wraps the element or string in Angular's jQuery lite
 * implementation (commonly referred to as jqLite).
 *
 * Real jQuery always takes precedence over jqLite, provided it was loaded before `DOMContentLoaded`
 * event fired.
 *
 * jqLite is a tiny, API-compatible subset of jQuery that allows
 * Angular to manipulate the DOM. jqLite implements only the most commonly needed functionality
 * within a very small footprint, so only a subset of the jQuery API - methods, arguments and
 * invocation styles - are supported.
 *
 * Note: All element references in Angular are always wrapped with jQuery or jqLite; they are never
 * raw DOM references.
 *
 * ## Angular's jqLite
 * Angular's lite version of jQuery provides only the following jQuery methods:
 *
 * - [addClass()](http://api.jquery.com/addClass/)
 * - [after()](http://api.jquery.com/after/)
 * - [append()](http://api.jquery.com/append/)
 * - [attr()](http://api.jquery.com/attr/)
 * - [bind()](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData
 * - [children()](http://api.jquery.com/children/) - Does not support selectors
 * - [clone()](http://api.jquery.com/clone/)
 * - [contents()](http://api.jquery.com/contents/)
 * - [css()](http://api.jquery.com/css/)
 * - [data()](http://api.jquery.com/data/)
 * - [eq()](http://api.jquery.com/eq/)
 * - [find()](http://api.jquery.com/find/) - Limited to lookups by tag name
 * - [hasClass()](http://api.jquery.com/hasClass/)
 * - [html()](http://api.jquery.com/html/)
 * - [next()](http://api.jquery.com/next/) - Does not support selectors
 * - [on()](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData
 * - [off()](http://api.jquery.com/off/) - Does not support namespaces or selectors
 * - [parent()](http://api.jquery.com/parent/) - Does not support selectors
 * - [prepend()](http://api.jquery.com/prepend/)
 * - [prop()](http://api.jquery.com/prop/)
 * - [ready()](http://api.jquery.com/ready/)
 * - [remove()](http://api.jquery.com/remove/)
 * - [removeAttr()](http://api.jquery.com/removeAttr/)
 * - [removeClass()](http://api.jquery.com/removeClass/)
 * - [removeData()](http://api.jquery.com/removeData/)
 * - [replaceWith()](http://api.jquery.com/replaceWith/)
 * - [text()](http://api.jquery.com/text/)
 * - [toggleClass()](http://api.jquery.com/toggleClass/)
 * - [triggerHandler()](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.
 * - [unbind()](http://api.jquery.com/off/) - Does not support namespaces
 * - [val()](http://api.jquery.com/val/)
 * - [wrap()](http://api.jquery.com/wrap/)
 *
 * ## jQuery/jqLite Extras
 * Angular also provides the following additional methods and events to both jQuery and jqLite:
 *
 * ### Events
 * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM destruction apis and fires this event
 *    on all DOM nodes being removed.  This can be used to clean up and 3rd party bindings to the DOM
 *    element before it is removed.
 * ### Methods
 * - `controller(name)` - retrieves the controller of the current element or its parent. By default
 *   retrieves controller associated with the `ngController` directive. If `name` is provided as
 *   camelCase directive name, then the controller for this directive will be retrieved (e.g.
 *   `'ngModel'`).
 * - `injector()` - retrieves the injector of the current element or its parent.
 * - `scope()` - retrieves the {@link api/ng.$rootScope.Scope scope} of the current
 *   element or its parent.
 * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top
 *   parent element is reached.
 *
 * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.
 * @returns {Object} jQuery object.
 */

var jqCache = JQLite.cache = {},
    jqName = JQLite.expando = 'ng-' + new Date().getTime(),
    jqId = 1,
    addEventListenerFn = (window.document.addEventListener
      ? function(element, type, fn) {element.addEventListener(type, fn, false);}
      : function(element, type, fn) {element.attachEvent('on' + type, fn);}),
    removeEventListenerFn = (window.document.removeEventListener
      ? function(element, type, fn) {element.removeEventListener(type, fn, false); }
      : function(element, type, fn) {element.detachEvent('on' + type, fn); });

function jqNextId() { return ++jqId; }


var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;
var jqLiteMinErr = minErr('jqLite');

/**
 * Converts snake_case to camelCase.
 * Also there is special case for Moz prefix starting with upper case letter.
 * @param name Name to normalize
 */
function camelCase(name) {
  return name.
    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).
    replace(MOZ_HACK_REGEXP, 'Moz$1');
}

/////////////////////////////////////////////
// jQuery mutation patch
//
// In conjunction with bindJQuery intercepts all jQuery's DOM destruction apis and fires a
// $destroy event on all DOM nodes being removed.
//
/////////////////////////////////////////////

function JQLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
  var originalJqFn = jQuery.fn[name];
  originalJqFn = originalJqFn.$original || originalJqFn;
  removePatch.$original = originalJqFn;
  jQuery.fn[name] = removePatch;

  function removePatch(param) {
    var list = filterElems && param ? [this.filter(param)] : [this],
        fireEvent = dispatchThis,
        set, setIndex, setLength,
        element, childIndex, childLength, children;

    if (!getterIfNoArguments || param != null) {
      while(list.length) {
        set = list.shift();
        for(setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
          element = jqLite(set[setIndex]);
          if (fireEvent) {
            element.triggerHandler('$destroy');
          } else {
            fireEvent = !fireEvent;
          }
          for(childIndex = 0, childLength = (children = element.children()).length;
              childIndex < childLength;
              childIndex++) {
            list.push(jQuery(children[childIndex]));
          }
        }
      }
    }
    return originalJqFn.apply(this, arguments);
  }
}

/////////////////////////////////////////////
function JQLite(element) {
  if (element instanceof JQLite) {
    return element;
  }
  if (!(this instanceof JQLite)) {
    if (isString(element) && element.charAt(0) != '<') {
      throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
    }
    return new JQLite(element);
  }

  if (isString(element)) {
    var div = document.createElement('div');
    // Read about the NoScope elements here:
    // http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx
    div.innerHTML = '<div>&#160;</div>' + element; // IE insanity to make NoScope elements work!
    div.removeChild(div.firstChild); // remove the superfluous div
    JQLiteAddNodes(this, div.childNodes);
    var fragment = jqLite(document.createDocumentFragment());
    fragment.append(this); // detach the elements from the temporary DOM div.
  } else {
    JQLiteAddNodes(this, element);
  }
}

function JQLiteClone(element) {
  return element.cloneNode(true);
}

function JQLiteDealoc(element){
  JQLiteRemoveData(element);
  for ( var i = 0, children = element.childNodes || []; i < children.length; i++) {
    JQLiteDealoc(children[i]);
  }
}

function JQLiteOff(element, type, fn, unsupported) {
  if (isDefined(unsupported)) throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');

  var events = JQLiteExpandoStore(element, 'events'),
      handle = JQLiteExpandoStore(element, 'handle');

  if (!handle) return; //no listeners registered

  if (isUndefined(type)) {
    forEach(events, function(eventHandler, type) {
      removeEventListenerFn(element, type, eventHandler);
      delete events[type];
    });
  } else {
    forEach(type.split(' '), function(type) {
      if (isUndefined(fn)) {
        removeEventListenerFn(element, type, events[type]);
        delete events[type];
      } else {
        arrayRemove(events[type] || [], fn);
      }
    });
  }
}

function JQLiteRemoveData(element, name) {
  var expandoId = element[jqName],
      expandoStore = jqCache[expandoId];

  if (expandoStore) {
    if (name) {
      delete jqCache[expandoId].data[name];
      return;
    }

    if (expandoStore.handle) {
      expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');
      JQLiteOff(element);
    }
    delete jqCache[expandoId];
    element[jqName] = undefined; // ie does not allow deletion of attributes on elements.
  }
}

function JQLiteExpandoStore(element, key, value) {
  var expandoId = element[jqName],
      expandoStore = jqCache[expandoId || -1];

  if (isDefined(value)) {
    if (!expandoStore) {
      element[jqName] = expandoId = jqNextId();
      expandoStore = jqCache[expandoId] = {};
    }
    expandoStore[key] = value;
  } else {
    return expandoStore && expandoStore[key];
  }
}

function JQLiteData(element, key, value) {
  var data = JQLiteExpandoStore(element, 'data'),
      isSetter = isDefined(value),
      keyDefined = !isSetter && isDefined(key),
      isSimpleGetter = keyDefined && !isObject(key);

  if (!data && !isSimpleGetter) {
    JQLiteExpandoStore(element, 'data', data = {});
  }

  if (isSetter) {
    data[key] = value;
  } else {
    if (keyDefined) {
      if (isSimpleGetter) {
        // don't create data in this case.
        return data && data[key];
      } else {
        extend(data, key);
      }
    } else {
      return data;
    }
  }
}

function JQLiteHasClass(element, selector) {
  return ((" " + element.className + " ").replace(/[\n\t]/g, " ").
      indexOf( " " + selector + " " ) > -1);
}

function JQLiteRemoveClass(element, cssClasses) {
  if (cssClasses) {
    forEach(cssClasses.split(' '), function(cssClass) {
      element.className = trim(
          (" " + element.className + " ")
          .replace(/[\n\t]/g, " ")
          .replace(" " + trim(cssClass) + " ", " ")
      );
    });
  }
}

function JQLiteAddClass(element, cssClasses) {
  if (cssClasses) {
    forEach(cssClasses.split(' '), function(cssClass) {
      if (!JQLiteHasClass(element, cssClass)) {
        element.className = trim(element.className + ' ' + trim(cssClass));
      }
    });
  }
}

function JQLiteAddNodes(root, elements) {
  if (elements) {
    elements = (!elements.nodeName && isDefined(elements.length) && !isWindow(elements))
      ? elements
      : [ elements ];
    for(var i=0; i < elements.length; i++) {
      root.push(elements[i]);
    }
  }
}

function JQLiteController(element, name) {
  return JQLiteInheritedData(element, '$' + (name || 'ngController' ) + 'Controller');
}

function JQLiteInheritedData(element, name, value) {
  element = jqLite(element);

  // if element is the document object work with the html element instead
  // this makes $(document).scope() possible
  if(element[0].nodeType == 9) {
    element = element.find('html');
  }

  while (element.length) {
    if ((value = element.data(name)) !== undefined) return value;
    element = element.parent();
  }
}

//////////////////////////////////////////
// Functions which are declared directly.
//////////////////////////////////////////
var JQLitePrototype = JQLite.prototype = {
  ready: function(fn) {
    var fired = false;

    function trigger() {
      if (fired) return;
      fired = true;
      fn();
    }

    // check if document already is loaded
    if (document.readyState === 'complete'){
      setTimeout(trigger);
    } else {
      this.on('DOMContentLoaded', trigger); // works for modern browsers and IE9
      // we can not use jqLite since we are not done loading and jQuery could be loaded later.
      JQLite(window).on('load', trigger); // fallback to window.onload for others
    }
  },
  toString: function() {
    var value = [];
    forEach(this, function(e){ value.push('' + e);});
    return '[' + value.join(', ') + ']';
  },

  eq: function(index) {
      return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
  },

  length: 0,
  push: push,
  sort: [].sort,
  splice: [].splice
};

//////////////////////////////////////////
// Functions iterating getter/setters.
// these functions return self on setter and
// value on get.
//////////////////////////////////////////
var BOOLEAN_ATTR = {};
forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
  BOOLEAN_ATTR[lowercase(value)] = value;
});
var BOOLEAN_ELEMENTS = {};
forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
  BOOLEAN_ELEMENTS[uppercase(value)] = true;
});

function getBooleanAttrName(element, name) {
  // check dom last since we will most likely fail on name
  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];

  // booleanAttr is here twice to minimize DOM access
  return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
}

forEach({
  data: JQLiteData,
  inheritedData: JQLiteInheritedData,

  scope: function(element) {
    return JQLiteInheritedData(element, '$scope');
  },

  controller: JQLiteController ,

  injector: function(element) {
    return JQLiteInheritedData(element, '$injector');
  },

  removeAttr: function(element,name) {
    element.removeAttribute(name);
  },

  hasClass: JQLiteHasClass,

  css: function(element, name, value) {
    name = camelCase(name);

    if (isDefined(value)) {
      element.style[name] = value;
    } else {
      var val;

      if (msie <= 8) {
        // this is some IE specific weirdness that jQuery 1.6.4 does not sure why
        val = element.currentStyle && element.currentStyle[name];
        if (val === '') val = 'auto';
      }

      val = val || element.style[name];

      if (msie <= 8) {
        // jquery weirdness :-/
        val = (val === '') ? undefined : val;
      }

      return  val;
    }
  },

  attr: function(element, name, value){
    var lowercasedName = lowercase(name);
    if (BOOLEAN_ATTR[lowercasedName]) {
      if (isDefined(value)) {
        if (!!value) {
          element[name] = true;
          element.setAttribute(name, lowercasedName);
        } else {
          element[name] = false;
          element.removeAttribute(lowercasedName);
        }
      } else {
        return (element[name] ||
                 (element.attributes.getNamedItem(name)|| noop).specified)
               ? lowercasedName
               : undefined;
      }
    } else if (isDefined(value)) {
      element.setAttribute(name, value);
    } else if (element.getAttribute) {
      // the extra argument "2" is to get the right thing for a.href in IE, see jQuery code
      // some elements (e.g. Document) don't have get attribute, so return undefined
      var ret = element.getAttribute(name, 2);
      // normalize non-existing attributes to undefined (as jQuery)
      return ret === null ? undefined : ret;
    }
  },

  prop: function(element, name, value) {
    if (isDefined(value)) {
      element[name] = value;
    } else {
      return element[name];
    }
  },

  text: (function() {
    var NODE_TYPE_TEXT_PROPERTY = [];
    if (msie < 9) {
      NODE_TYPE_TEXT_PROPERTY[1] = 'innerText';    /** Element **/
      NODE_TYPE_TEXT_PROPERTY[3] = 'nodeValue';    /** Text **/
    } else {
      NODE_TYPE_TEXT_PROPERTY[1] =                 /** Element **/
      NODE_TYPE_TEXT_PROPERTY[3] = 'textContent';  /** Text **/
    }
    getText.$dv = '';
    return getText;

    function getText(element, value) {
      var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType]
      if (isUndefined(value)) {
        return textProp ? element[textProp] : '';
      }
      element[textProp] = value;
    }
  })(),

  val: function(element, value) {
    if (isUndefined(value)) {
      if (nodeName_(element) === 'SELECT' && element.multiple) {
        var result = [];
        forEach(element.options, function (option) {
          if (option.selected) {
            result.push(option.value || option.text);
          }
        });
        return result.length === 0 ? null : result;
      }
      return element.value;
    }
    element.value = value;
  },

  html: function(element, value) {
    if (isUndefined(value)) {
      return element.innerHTML;
    }
    for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
      JQLiteDealoc(childNodes[i]);
    }
    element.innerHTML = value;
  }
}, function(fn, name){
  /**
   * Properties: writes return selection, reads return first value
   */
  JQLite.prototype[name] = function(arg1, arg2) {
    var i, key;

    // JQLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
    // in a way that survives minification.
    if (((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController)) ? arg1 : arg2) === undefined) {
      if (isObject(arg1)) {

        // we are a write, but the object properties are the key/values
        for(i=0; i < this.length; i++) {
          if (fn === JQLiteData) {
            // data() takes the whole object in jQuery
            fn(this[i], arg1);
          } else {
            for (key in arg1) {
              fn(this[i], key, arg1[key]);
            }
          }
        }
        // return self for chaining
        return this;
      } else {
        // we are a read, so read the first child.
        var value = fn.$dv;
        // Only if we have $dv do we iterate over all, otherwise it is just the first element.
        var jj = value == undefined ? Math.min(this.length, 1) : this.length;
        for (var j = 0; j < jj; j++) {
          var nodeValue = fn(this[j], arg1, arg2);
          value = value ? value + nodeValue : nodeValue;
        }
        return value;
      }
    } else {
      // we are a write, so apply to all children
      for(i=0; i < this.length; i++) {
        fn(this[i], arg1, arg2);
      }
      // return self for chaining
      return this;
    }
  };
});

function createEventHandler(element, events) {
  var eventHandler = function (event, type) {
    if (!event.preventDefault) {
      event.preventDefault = function() {
        event.returnValue = false; //ie
      };
    }

    if (!event.stopPropagation) {
      event.stopPropagation = function() {
        event.cancelBubble = true; //ie
      };
    }

    if (!event.target) {
      event.target = event.srcElement || document;
    }

    if (isUndefined(event.defaultPrevented)) {
      var prevent = event.preventDefault;
      event.preventDefault = function() {
        event.defaultPrevented = true;
        prevent.call(event);
      };
      event.defaultPrevented = false;
    }

    event.isDefaultPrevented = function() {
      return event.defaultPrevented || event.returnValue == false;
    };

    forEach(events[type || event.type], function(fn) {
      fn.call(element, event);
    });

    // Remove monkey-patched methods (IE),
    // as they would cause memory leaks in IE8.
    if (msie <= 8) {
      // IE7/8 does not allow to delete property on native object
      event.preventDefault = null;
      event.stopPropagation = null;
      event.isDefaultPrevented = null;
    } else {
      // It shouldn't affect normal browsers (native methods are defined on prototype).
      delete event.preventDefault;
      delete event.stopPropagation;
      delete event.isDefaultPrevented;
    }
  };
  eventHandler.elem = element;
  return eventHandler;
}

//////////////////////////////////////////
// Functions iterating traversal.
// These functions chain results into a single
// selector.
//////////////////////////////////////////
forEach({
  removeData: JQLiteRemoveData,

  dealoc: JQLiteDealoc,

  on: function onFn(element, type, fn, unsupported){
    if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');

    var events = JQLiteExpandoStore(element, 'events'),
        handle = JQLiteExpandoStore(element, 'handle');

    if (!events) JQLiteExpandoStore(element, 'events', events = {});
    if (!handle) JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));

    forEach(type.split(' '), function(type){
      var eventFns = events[type];

      if (!eventFns) {
        if (type == 'mouseenter' || type == 'mouseleave') {
          var contains = document.body.contains || document.body.compareDocumentPosition ?
          function( a, b ) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
            return a === bup || !!( bup && bup.nodeType === 1 && (
              adown.contains ?
              adown.contains( bup ) :
              a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
              ));
            } :
            function( a, b ) {
              if ( b ) {
                while ( (b = b.parentNode) ) {
                  if ( b === a ) {
                    return true;
                  }
                }
              }
              return false;
            };

          events[type] = [];

          // Refer to jQuery's implementation of mouseenter & mouseleave
          // Read about mouseenter and mouseleave:
          // http://www.quirksmode.org/js/events_mouse.html#link8
          var eventmap = { mouseleave : "mouseout", mouseenter : "mouseover"};

          onFn(element, eventmap[type], function(event) {
            var target = this, related = event.relatedTarget;
            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target && !contains(target, related)) ){
              handle(event, type);
            }
          });

        } else {
          addEventListenerFn(element, type, handle);
          events[type] = [];
        }
        eventFns = events[type]
      }
      eventFns.push(fn);
    });
  },

  off: JQLiteOff,

  replaceWith: function(element, replaceNode) {
    var index, parent = element.parentNode;
    JQLiteDealoc(element);
    forEach(new JQLite(replaceNode), function(node){
      if (index) {
        parent.insertBefore(node, index.nextSibling);
      } else {
        parent.replaceChild(node, element);
      }
      index = node;
    });
  },

  children: function(element) {
    var children = [];
    forEach(element.childNodes, function(element){
      if (element.nodeType === 1)
        children.push(element);
    });
    return children;
  },

  contents: function(element) {
    return element.childNodes || [];
  },

  append: function(element, node) {
    forEach(new JQLite(node), function(child){
      if (element.nodeType === 1 || element.nodeType === 11) {
        element.appendChild(child);
      }
    });
  },

  prepend: function(element, node) {
    if (element.nodeType === 1) {
      var index = element.firstChild;
      forEach(new JQLite(node), function(child){
        element.insertBefore(child, index);
      });
    }
  },

  wrap: function(element, wrapNode) {
    wrapNode = jqLite(wrapNode)[0];
    var parent = element.parentNode;
    if (parent) {
      parent.replaceChild(wrapNode, element);
    }
    wrapNode.appendChild(element);
  },

  remove: function(element) {
    JQLiteDealoc(element);
    var parent = element.parentNode;
    if (parent) parent.removeChild(element);
  },

  after: function(element, newElement) {
    var index = element, parent = element.parentNode;
    forEach(new JQLite(newElement), function(node){
      parent.insertBefore(node, index.nextSibling);
      index = node;
    });
  },

  addClass: JQLiteAddClass,
  removeClass: JQLiteRemoveClass,

  toggleClass: function(element, selector, condition) {
    if (isUndefined(condition)) {
      condition = !JQLiteHasClass(element, selector);
    }
    (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);
  },

  parent: function(element) {
    var parent = element.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },

  next: function(element) {
    if (element.nextElementSibling) {
      return element.nextElementSibling;
    }

    // IE8 doesn't have nextElementSibling
    var elm = element.nextSibling;
    while (elm != null && elm.nodeType !== 1) {
      elm = elm.nextSibling;
    }
    return elm;
  },

  find: function(element, selector) {
    return element.getElementsByTagName(selector);
  },

  clone: JQLiteClone,

  triggerHandler: function(element, eventName, eventData) {
    var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];
    eventData = eventData || {
      preventDefault: noop,
      stopPropagation: noop
    };

    forEach(eventFns, function(fn) {
      fn.call(element, eventData);
    });
  }
}, function(fn, name){
  /**
   * chaining functions
   */
  JQLite.prototype[name] = function(arg1, arg2, arg3) {
    var value;
    for(var i=0; i < this.length; i++) {
      if (value == undefined) {
        value = fn(this[i], arg1, arg2, arg3);
        if (value !== undefined) {
          // any function which returns a value needs to be wrapped
          value = jqLite(value);
        }
      } else {
        JQLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
      }
    }
    return value == undefined ? this : value;
  };

  // bind legacy bind/unbind to on/off
  JQLite.prototype.bind = JQLite.prototype.on;
  JQLite.prototype.unbind = JQLite.prototype.off;
});

/**
 * Computes a hash of an 'obj'.
 * Hash of a:
 *  string is string
 *  number is number as string
 *  object is either result of calling $$hashKey function on the object or uniquely generated id,
 *         that is also assigned to the $$hashKey property of the object.
 *
 * @param obj
 * @returns {string} hash string such that the same input will have the same hash string.
 *         The resulting string key is in 'type:hashKey' format.
 */
function hashKey(obj) {
  var objType = typeof obj,
      key;

  if (objType == 'object' && obj !== null) {
    if (typeof (key = obj.$$hashKey) == 'function') {
      // must invoke on object to keep the right this
      key = obj.$$hashKey();
    } else if (key === undefined) {
      key = obj.$$hashKey = nextUid();
    }
  } else {
    key = obj;
  }

  return objType + ':' + key;
}

/**
 * HashMap which can use objects as keys
 */
function HashMap(array){
  forEach(array, this.put, this);
}
HashMap.prototype = {
  /**
   * Store key value pair
   * @param key key to store can be any type
   * @param value value to store can be any type
   */
  put: function(key, value) {
    this[hashKey(key)] = value;
  },

  /**
   * @param key
   * @returns the value for the key
   */
  get: function(key) {
    return this[hashKey(key)];
  },

  /**
   * Remove the key/value pair
   * @param key
   */
  remove: function(key) {
    var value = this[key = hashKey(key)];
    delete this[key];
    return value;
  }
};

/**
 * @ngdoc function
 * @name angular.injector
 * @function
 *
 * @description
 * Creates an injector function that can be used for retrieving services as well as for
 * dependency injection (see {@link guide/di dependency injection}).
 *

 * @param {Array.<string|Function>} modules A list of module functions or their aliases. See
 *        {@link angular.module}. The `ng` module must be explicitly added.
 * @returns {function()} Injector function. See {@link AUTO.$injector $injector}.
 *
 * @example
 * Typical usage
 * <pre>
 *   // create an injector
 *   var $injector = angular.injector(['ng']);
 *
 *   // use the injector to kick off your application
 *   // use the type inference to auto inject arguments, or use implicit injection
 *   $injector.invoke(function($rootScope, $compile, $document){
 *     $compile($document)($rootScope);
 *     $rootScope.$digest();
 *   });
 * </pre>
 */


/**
 * @ngdoc overview
 * @name AUTO
 * @description
 *
 * Implicit module which gets automatically added to each {@link AUTO.$injector $injector}.
 */

var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var $injectorMinErr = minErr('$injector');
function annotate(fn) {
  var $inject,
      fnText,
      argDecl,
      last;

  if (typeof fn == 'function') {
    if (!($inject = fn.$inject)) {
      $inject = [];
      if (fn.length) {
        fnText = fn.toString().replace(STRIP_COMMENTS, '');
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){
          arg.replace(FN_ARG, function(all, underscore, name){
            $inject.push(name);
          });
        });
      }
      fn.$inject = $inject;
    }
  } else if (isArray(fn)) {
    last = fn.length - 1;
    assertArgFn(fn[last], 'fn');
    $inject = fn.slice(0, last);
  } else {
    assertArgFn(fn, 'fn', true);
  }
  return $inject;
}

///////////////////////////////////////

/**
 * @ngdoc object
 * @name AUTO.$injector
 * @function
 *
 * @description
 *
 * `$injector` is used to retrieve object instances as defined by
 * {@link AUTO.$provide provider}, instantiate types, invoke methods,
 * and load modules.
 *
 * The following always holds true:
 *
 * <pre>
 *   var $injector = angular.injector();
 *   expect($injector.get('$injector')).toBe($injector);
 *   expect($injector.invoke(function($injector){
 *     return $injector;
 *   }).toBe($injector);
 * </pre>
 *
 * # Injection Function Annotation
 *
 * JavaScript does not have annotations, and annotations are needed for dependency injection. The
 * following are all valid ways of annotating function with injection arguments and are equivalent.
 *
 * <pre>
 *   // inferred (only works if code not minified/obfuscated)
 *   $injector.invoke(function(serviceA){});
 *
 *   // annotated
 *   function explicit(serviceA) {};
 *   explicit.$inject = ['serviceA'];
 *   $injector.invoke(explicit);
 *
 *   // inline
 *   $injector.invoke(['serviceA', function(serviceA){}]);
 * </pre>
 *
 * ## Inference
 *
 * In JavaScript calling `toString()` on a function returns the function definition. The definition can then be
 * parsed and the function arguments can be extracted. *NOTE:* This does not work with minification, and obfuscation
 * tools since these tools change the argument names.
 *
 * ## `$inject` Annotation
 * By adding a `$inject` property onto a function the injection parameters can be specified.
 *
 * ## Inline
 * As an array of injection names, where the last item in the array is the function to call.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#get
 * @methodOf AUTO.$injector
 *
 * @description
 * Return an instance of the service.
 *
 * @param {string} name The name of the instance to retrieve.
 * @return {*} The instance.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#invoke
 * @methodOf AUTO.$injector
 *
 * @description
 * Invoke the method and supply the method arguments from the `$injector`.
 *
 * @param {!function} fn The function to invoke. The function arguments come form the function annotation.
 * @param {Object=} self The `this` for the invoked method.
 * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before
 *   the `$injector` is consulted.
 * @returns {*} the value returned by the invoked `fn` function.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#has
 * @methodOf AUTO.$injector
 *
 * @description
 * Allows the user to query if the particular service exist.
 *
 * @param {string} Name of the service to query.
 * @returns {boolean} returns true if injector has given service.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#instantiate
 * @methodOf AUTO.$injector
 * @description
 * Create a new instance of JS type. The method takes a constructor function invokes the new operator and supplies
 * all of the arguments to the constructor function as specified by the constructor annotation.
 *
 * @param {function} Type Annotated constructor function.
 * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before
 *   the `$injector` is consulted.
 * @returns {Object} new instance of `Type`.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#annotate
 * @methodOf AUTO.$injector
 *
 * @description
 * Returns an array of service names which the function is requesting for injection. This API is used by the injector
 * to determine which services need to be injected into the function when the function is invoked. There are three
 * ways in which the function can be annotated with the needed dependencies.
 *
 * # Argument names
 *
 * The simplest form is to extract the dependencies from the arguments of the function. This is done by converting
 * the function into a string using `toString()` method and extracting the argument names.
 * <pre>
 *   // Given
 *   function MyController($scope, $route) {
 *     // ...
 *   }
 *
 *   // Then
 *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
 * </pre>
 *
 * This method does not work with code minification / obfuscation. For this reason the following annotation strategies
 * are supported.
 *
 * # The `$inject` property
 *
 * If a function has an `$inject` property and its value is an array of strings, then the strings represent names of
 * services to be injected into the function.
 * <pre>
 *   // Given
 *   var MyController = function(obfuscatedScope, obfuscatedRoute) {
 *     // ...
 *   }
 *   // Define function dependencies
 *   MyController.$inject = ['$scope', '$route'];
 *
 *   // Then
 *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
 * </pre>
 *
 * # The array notation
 *
 * It is often desirable to inline Injected functions and that's when setting the `$inject` property is very
 * inconvenient. In these situations using the array notation to specify the dependencies in a way that survives
 * minification is a better choice:
 *
 * <pre>
 *   // We wish to write this (not minification / obfuscation safe)
 *   injector.invoke(function($compile, $rootScope) {
 *     // ...
 *   });
 *
 *   // We are forced to write break inlining
 *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {
 *     // ...
 *   };
 *   tmpFn.$inject = ['$compile', '$rootScope'];
 *   injector.invoke(tmpFn);
 *
 *   // To better support inline function the inline annotation is supported
 *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {
 *     // ...
 *   }]);
 *
 *   // Therefore
 *   expect(injector.annotate(
 *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])
 *    ).toEqual(['$compile', '$rootScope']);
 * </pre>
 *
 * @param {function|Array.<string|Function>} fn Function for which dependent service names need to be retrieved as described
 *   above.
 *
 * @returns {Array.<string>} The names of the services which the function requires.
 */




/**
 * @ngdoc object
 * @name AUTO.$provide
 *
 * @description
 *
 * Use `$provide` to register new providers with the `$injector`. The providers are the factories for the instance.
 * The providers share the same name as the instance they create with `Provider` suffixed to them.
 *
 * A provider is an object with a `$get()` method. The injector calls the `$get` method to create a new instance of
 * a service. The Provider can have additional methods which would allow for configuration of the provider.
 *
 * <pre>
 *   function GreetProvider() {
 *     var salutation = 'Hello';
 *
 *     this.salutation = function(text) {
 *       salutation = text;
 *     };
 *
 *     this.$get = function() {
 *       return function (name) {
 *         return salutation + ' ' + name + '!';
 *       };
 *     };
 *   }
 *
 *   describe('Greeter', function(){
 *
 *     beforeEach(module(function($provide) {
 *       $provide.provider('greet', GreetProvider);
 *     }));
 *
 *     it('should greet', inject(function(greet) {
 *       expect(greet('angular')).toEqual('Hello angular!');
 *     }));
 *
 *     it('should allow configuration of salutation', function() {
 *       module(function(greetProvider) {
 *         greetProvider.salutation('Ahoj');
 *       });
 *       inject(function(greet) {
 *         expect(greet('angular')).toEqual('Ahoj angular!');
 *       });
 *     });
 * </pre>
 */

/**
 * @ngdoc method
 * @name AUTO.$provide#provider
 * @methodOf AUTO.$provide
 * @description
 *
 * Register a provider for a service. The providers can be retrieved and can have additional configuration methods.
 *
 * @param {string} name The name of the instance. NOTE: the provider will be available under `name + 'Provider'` key.
 * @param {(Object|function())} provider If the provider is:
 *
 *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using
 *               {@link AUTO.$injector#invoke $injector.invoke()} when an instance needs to be created.
 *   - `Constructor`: a new instance of the provider will be created using
 *               {@link AUTO.$injector#instantiate $injector.instantiate()}, then treated as `object`.
 *
 * @returns {Object} registered provider instance
 */

/**
 * @ngdoc method
 * @name AUTO.$provide#factory
 * @methodOf AUTO.$provide
 * @description
 *
 * A short hand for configuring services if only `$get` method is required.
 *
 * @param {string} name The name of the instance.
 * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand for
 * `$provide.provider(name, {$get: $getFn})`.
 * @returns {Object} registered provider instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#service
 * @methodOf AUTO.$provide
 * @description
 *
 * A short hand for registering service of given class.
 *
 * @param {string} name The name of the instance.
 * @param {Function} constructor A class (constructor function) that will be instantiated.
 * @returns {Object} registered provider instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#value
 * @methodOf AUTO.$provide
 * @description
 *
 * A short hand for configuring services if the `$get` method is a constant.
 *
 * @param {string} name The name of the instance.
 * @param {*} value The value.
 * @returns {Object} registered provider instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#constant
 * @methodOf AUTO.$provide
 * @description
 *
 * A constant value, but unlike {@link AUTO.$provide#value value} it can be injected
 * into configuration function (other modules) and it is not interceptable by
 * {@link AUTO.$provide#decorator decorator}.
 *
 * @param {string} name The name of the constant.
 * @param {*} value The constant value.
 * @returns {Object} registered instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#decorator
 * @methodOf AUTO.$provide
 * @description
 *
 * Decoration of service, allows the decorator to intercept the service instance creation. The
 * returned instance may be the original instance, or a new instance which delegates to the
 * original instance.
 *
 * @param {string} name The name of the service to decorate.
 * @param {function()} decorator This function will be invoked when the service needs to be
 *    instantiated. The function is called using the {@link AUTO.$injector#invoke
 *    injector.invoke} method and is therefore fully injectable. Local injection arguments:
 *
 *    * `$delegate` - The original service instance, which can be monkey patched, configured,
 *      decorated or delegated to.
 */


function createInjector(modulesToLoad) {
  var INSTANTIATING = {},
      providerSuffix = 'Provider',
      path = [],
      loadedModules = new HashMap(),
      providerCache = {
        $provide: {
            provider: supportObject(provider),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant),
            decorator: decorator
          }
      },
      providerInjector = (providerCache.$injector =
          createInternalInjector(providerCache, function() {
            throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
          })),
      instanceCache = {},
      instanceInjector = (instanceCache.$injector =
          createInternalInjector(instanceCache, function(servicename) {
            var provider = providerInjector.get(servicename + providerSuffix);
            return instanceInjector.invoke(provider.$get, provider);
          }));


  forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });

  return instanceInjector;

  ////////////////////////////////////
  // $provider
  ////////////////////////////////////

  function supportObject(delegate) {
    return function(key, value) {
      if (isObject(key)) {
        forEach(key, reverseParams(delegate));
      } else {
        return delegate(key, value);
      }
    }
  }

  function provider(name, provider_) {
    if (isFunction(provider_) || isArray(provider_)) {
      provider_ = providerInjector.instantiate(provider_);
    }
    if (!provider_.$get) {
      throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
    }
    return providerCache[name + providerSuffix] = provider_;
  }

  function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }

  function service(name, constructor) {
    return factory(name, ['$injector', function($injector) {
      return $injector.instantiate(constructor);
    }]);
  }

  function value(name, value) { return factory(name, valueFn(value)); }

  function constant(name, value) {
    providerCache[name] = value;
    instanceCache[name] = value;
  }

  function decorator(serviceName, decorFn) {
    var origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;

    origProvider.$get = function() {
      var origInstance = instanceInjector.invoke(orig$get, origProvider);
      return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
    };
  }

  ////////////////////////////////////
  // Module Loading
  ////////////////////////////////////
  function loadModules(modulesToLoad){
    var runBlocks = [];
    forEach(modulesToLoad, function(module) {
      if (loadedModules.get(module)) return;
      loadedModules.put(module, true);

      try {
        if (isString(module)) {
          var moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);

          for(var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
            var invokeArgs = invokeQueue[i],
                provider = providerInjector.get(invokeArgs[0]);

            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
          }
        } else if (isFunction(module)) {
            runBlocks.push(providerInjector.invoke(module));
        } else if (isArray(module)) {
            runBlocks.push(providerInjector.invoke(module));
        } else {
          assertArgFn(module, 'module');
        }
      } catch (e) {
        if (isArray(module)) {
          module = module[module.length - 1];
        }
        if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
          // Safari & FF's stack traces don't contain error.message content unlike those of Chrome and IE
          // So if stack doesn't contain message, we create a new string that contains both.
          // Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.
          e = e.message + '\n' + e.stack;
        }
        throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
      }
    });
    return runBlocks;
  }

  ////////////////////////////////////
  // internal Injector
  ////////////////////////////////////

  function createInternalInjector(cache, factory) {

    function getService(serviceName) {
      if (cache.hasOwnProperty(serviceName)) {
        if (cache[serviceName] === INSTANTIATING) {
          throw $injectorMinErr('cdep', 'Circular dependency found: {0}', path.join(' <- '));
        }
        return cache[serviceName];
      } else {
        try {
          path.unshift(serviceName);
          cache[serviceName] = INSTANTIATING;
          return cache[serviceName] = factory(serviceName);
        } finally {
          path.shift();
        }
      }
    }

    function invoke(fn, self, locals){
      var args = [],
          $inject = annotate(fn),
          length, i,
          key;

      for(i = 0, length = $inject.length; i < length; i++) {
        key = $inject[i];
        if (typeof key !== 'string') {
          throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
        }
        args.push(
          locals && locals.hasOwnProperty(key)
          ? locals[key]
          : getService(key)
        );
      }
      if (!fn.$inject) {
        // this means that we must be an array.
        fn = fn[length];
      }


      // Performance optimization: http://jsperf.com/apply-vs-call-vs-invoke
      switch (self ? -1 : args.length) {
        case  0: return fn();
        case  1: return fn(args[0]);
        case  2: return fn(args[0], args[1]);
        case  3: return fn(args[0], args[1], args[2]);
        case  4: return fn(args[0], args[1], args[2], args[3]);
        case  5: return fn(args[0], args[1], args[2], args[3], args[4]);
        case  6: return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
        case  7: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        case  8: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        case  9: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
        case 10: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
        default: return fn.apply(self, args);
      }
    }

    function instantiate(Type, locals) {
      var Constructor = function() {},
          instance, returnedValue;

      // Check if Type is annotated and use just the given function at n-1 as parameter
      // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);
      Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
      instance = new Constructor();
      returnedValue = invoke(Type, instance, locals);

      return isObject(returnedValue) ? returnedValue : instance;
    }

    return {
      invoke: invoke,
      instantiate: instantiate,
      get: getService,
      annotate: annotate,
      has: function(name) {
        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
      }
    };
  }
}

/**
 * @ngdoc function
 * @name ng.$anchorScroll
 * @requires $window
 * @requires $location
 * @requires $rootScope
 *
 * @description
 * When called, it checks current value of `$location.hash()` and scroll to related element,
 * according to rules specified in
 * {@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.
 *
 * It also watches the `$location.hash()` and scroll whenever it changes to match any anchor.
 * This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.
 */
function $AnchorScrollProvider() {

  var autoScrollingEnabled = true;

  this.disableAutoScrolling = function() {
    autoScrollingEnabled = false;
  };

  this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
    var document = $window.document;

    // helper function to get first anchor from a NodeList
    // can't use filter.filter, as it accepts only instances of Array
    // and IE can't convert NodeList to an array using [].slice
    // TODO(vojta): use filter if we change it to accept lists as well
    function getFirstAnchor(list) {
      var result = null;
      forEach(list, function(element) {
        if (!result && lowercase(element.nodeName) === 'a') result = element;
      });
      return result;
    }

    function scroll() {
      var hash = $location.hash(), elm;

      // empty hash, scroll to the top of the page
      if (!hash) $window.scrollTo(0, 0);

      // element with given id
      else if ((elm = document.getElementById(hash))) elm.scrollIntoView();

      // first anchor with given name :-D
      else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();

      // no element and hash == 'top', scroll to the top of the page
      else if (hash === 'top') $window.scrollTo(0, 0);
    }

    // does not scroll when user clicks on anchor link that is currently on
    // (no url change, no $location.hash() change), browser native does scroll
    if (autoScrollingEnabled) {
      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},
        function autoScrollWatchAction() {
          $rootScope.$evalAsync(scroll);
        });
    }

    return scroll;
  }];
}

var $animateMinErr = minErr('$animate');

/**
 * @ngdoc object
 * @name ng.$animateProvider
 *
 * @description
 * Default implementation of $animate that doesn't perform any animations, instead just synchronously performs DOM
 * updates and calls done() callbacks.
 *
 * In order to enable animations the ngAnimate module has to be loaded.
 *
 * To see the functional implementation check out src/ngAnimate/animate.js
 */
var $AnimateProvider = ['$provide', function($provide) {

  this.$$selectors = {};


  /**
   * @ngdoc function
   * @name ng.$animateProvider#register
   * @methodOf ng.$animateProvider
   *
   * @description
   * Registers a new injectable animation factory function. The factory function produces the animation object which
   * contains callback functions for each event that is expected to be animated.
   *
   *   * `eventFn`: `function(Element, doneFunction)` The element to animate, the `doneFunction` must be called once the
   *   element animation is complete. If a function is returned then the animation service will use this function to
   *   cancel the animation whenever a cancel event is triggered.
   *
   *
   *<pre>
   *   return {
     *     eventFn : function(element, done) {
     *       //code to run the animation
     *       //once complete, then run done()
     *       return function cancellationFunction() {
     *         //code to cancel the animation
     *       }
     *     }
     *   }
   *</pre>
   *
   * @param {string} name The name of the animation.
   * @param {function} factory The factory function that will be executed to return the animation object.
   */
  this.register = function(name, factory) {
    var key = name + '-animation';
    if (name && name.charAt(0) != '.') throw $animateMinErr('notcsel',
        "Expecting class selector starting with '.' got '{0}'.", name);
    this.$$selectors[name.substr(1)] = key;
    $provide.factory(key, factory);
  };

  this.$get = ['$timeout', function($timeout) {

    /**
     * @ngdoc object
     * @name ng.$animate
     *
     * @description
     * The $animate service provides rudimentary DOM manipulation functions to insert, remove, move elements within
     * the DOM as well as adding and removing classes. This service is the core service used by the ngAnimate $animator
     * service which provides high-level animation hooks for CSS and JavaScript. 
     *
     * $animate is available in the AngularJS core, however, the ngAnimate module must be included to enable full out
     * animation support. Otherwise, $animate will only perform simple DOM manipulation operations.
     *
     * To learn more about enabling animation support, click here to visit the {@link ngAnimate ngAnimate module page}
     * as well as the {@link ngAnimate.$animate ngAnimate $animate service page}.
     */
    return {

      /**
       * @ngdoc function
       * @name ng.$animate#enter
       * @methodOf ng.$animate
       * @function
       *
       * @description
       * Inserts the element into the DOM either after the `after` element or within the `parent` element. Once complete,
       * the done() callback will be fired (if provided).
       *
       * @param {jQuery/jqLite element} element the element which will be inserted into the DOM
       * @param {jQuery/jqLite element} parent the parent element which will append the element as a child (if the after element is not present)
       * @param {jQuery/jqLite element} after the sibling element which will append the element after itself
       * @param {function=} done callback function that will be called after the element has been inserted into the DOM
       */
      enter : function(element, parent, after, done) {
        var afterNode = after && after[after.length - 1];
        var parentNode = parent && parent[0] || afterNode && afterNode.parentNode;
        // IE does not like undefined so we have to pass null.
        var afterNextSibling = (afterNode && afterNode.nextSibling) || null;
        forEach(element, function(node) {
          parentNode.insertBefore(node, afterNextSibling);
        });
        done && $timeout(done, 0, false);
      },

      /**
       * @ngdoc function
       * @name ng.$animate#leave
       * @methodOf ng.$animate
       * @function
       *
       * @description
       * Removes the element from the DOM. Once complete, the done() callback will be fired (if provided).
       *
       * @param {jQuery/jqLite element} element the element which will be removed from the DOM
       * @param {function=} done callback function that will be called after the element has been removed from the DOM
       */
      leave : function(element, done) {
        element.remove();
        done && $timeout(done, 0, false);
      },

      /**
       * @ngdoc function
       * @name ng.$animate#move
       * @methodOf ng.$animate
       * @function
       *
       * @description
       * Moves the position of the provided element within the DOM to be placed either after the `after` element or inside of the `parent` element.
       * Once complete, the done() callback will be fired (if provided).
       *
       * @param {jQuery/jqLite element} element the element which will be moved around within the DOM
       * @param {jQuery/jqLite element} parent the parent element where the element will be inserted into (if the after element is not present)
       * @param {jQuery/jqLite element} after the sibling element where the element will be positioned next to
       * @param {function=} done the callback function (if provided) that will be fired after the element has been moved to it's new position
       */
      move : function(element, parent, after, done) {
        // Do not remove element before insert. Removing will cause data associated with the
        // element to be dropped. Insert will implicitly do the remove.
        this.enter(element, parent, after, done);
      },

      /**
       * @ngdoc function
       * @name ng.$animate#addClass
       * @methodOf ng.$animate
       * @function
       *
       * @description
       * Adds the provided className CSS class value to the provided element. Once complete, the done() callback will be fired (if provided).
       *
       * @param {jQuery/jqLite element} element the element which will have the className value added to it
       * @param {string} className the CSS class which will be added to the element
       * @param {function=} done the callback function (if provided) that will be fired after the className value has been added to the element
       */
      addClass : function(element, className, done) {
        className = isString(className) ?
                      className :
                      isArray(className) ? className.join(' ') : '';
        element.addClass(className);
        done && $timeout(done, 0, false);
      },

      /**
       * @ngdoc function
       * @name ng.$animate#removeClass
       * @methodOf ng.$animate
       * @function
       *
       * @description
       * Removes the provided className CSS class value from the provided element. Once complete, the done() callback will be fired (if provided).
       *
       * @param {jQuery/jqLite element} element the element which will have the className value removed from it
       * @param {string} className the CSS class which will be removed from the element
       * @param {function=} done the callback function (if provided) that will be fired after the className value has been removed from the element
       */
      removeClass : function(element, className, done) {
        className = isString(className) ?
                      className :
                      isArray(className) ? className.join(' ') : '';
        element.removeClass(className);
        done && $timeout(done, 0, false);
      },

      enabled : noop
    };
  }];
}];

/**
 * ! This is a private undocumented service !
 *
 * @name ng.$browser
 * @requires $log
 * @description
 * This object has two goals:
 *
 * - hide all the global state in the browser caused by the window object
 * - abstract away all the browser specific features and inconsistencies
 *
 * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`
 * service, which can be used for convenient testing of the application without the interaction with
 * the real browser apis.
 */
/**
 * @param {object} window The global window object.
 * @param {object} document jQuery wrapped document.
 * @param {function()} XHR XMLHttpRequest constructor.
 * @param {object} $log console.log or an object with the same interface.
 * @param {object} $sniffer $sniffer service
 */
function Browser(window, document, $log, $sniffer) {
  var self = this,
      rawDocument = document[0],
      location = window.location,
      history = window.history,
      setTimeout = window.setTimeout,
      clearTimeout = window.clearTimeout,
      pendingDeferIds = {};

  self.isMock = false;

  var outstandingRequestCount = 0;
  var outstandingRequestCallbacks = [];

  // TODO(vojta): remove this temporary api
  self.$$completeOutstandingRequest = completeOutstandingRequest;
  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };

  /**
   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`
   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.
   */
  function completeOutstandingRequest(fn) {
    try {
      fn.apply(null, sliceArgs(arguments, 1));
    } finally {
      outstandingRequestCount--;
      if (outstandingRequestCount === 0) {
        while(outstandingRequestCallbacks.length) {
          try {
            outstandingRequestCallbacks.pop()();
          } catch (e) {
            $log.error(e);
          }
        }
      }
    }
  }

  /**
   * @private
   * Note: this method is used only by scenario runner
   * TODO(vojta): prefix this method with $$ ?
   * @param {function()} callback Function that will be called when no outstanding request
   */
  self.notifyWhenNoOutstandingRequests = function(callback) {
    // force browser to execute all pollFns - this is needed so that cookies and other pollers fire
    // at some deterministic time in respect to the test runner's actions. Leaving things up to the
    // regular poller would result in flaky tests.
    forEach(pollFns, function(pollFn){ pollFn(); });

    if (outstandingRequestCount === 0) {
      callback();
    } else {
      outstandingRequestCallbacks.push(callback);
    }
  };

  //////////////////////////////////////////////////////////////
  // Poll Watcher API
  //////////////////////////////////////////////////////////////
  var pollFns = [],
      pollTimeout;

  /**
   * @name ng.$browser#addPollFn
   * @methodOf ng.$browser
   *
   * @param {function()} fn Poll function to add
   *
   * @description
   * Adds a function to the list of functions that poller periodically executes,
   * and starts polling if not started yet.
   *
   * @returns {function()} the added function
   */
  self.addPollFn = function(fn) {
    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
    pollFns.push(fn);
    return fn;
  };

  /**
   * @param {number} interval How often should browser call poll functions (ms)
   * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.
   *
   * @description
   * Configures the poller to run in the specified intervals, using the specified
   * setTimeout fn and kicks it off.
   */
  function startPoller(interval, setTimeout) {
    (function check() {
      forEach(pollFns, function(pollFn){ pollFn(); });
      pollTimeout = setTimeout(check, interval);
    })();
  }

  //////////////////////////////////////////////////////////////
  // URL API
  //////////////////////////////////////////////////////////////

  var lastBrowserUrl = location.href,
      baseElement = document.find('base'),
      replacedUrl = null;

  /**
   * @name ng.$browser#url
   * @methodOf ng.$browser
   *
   * @description
   * GETTER:
   * Without any argument, this method just returns current value of location.href.
   *
   * SETTER:
   * With at least one argument, this method sets url to new value.
   * If html5 history api supported, pushState/replaceState is used, otherwise
   * location.href/location.replace is used.
   * Returns its own instance to allow chaining
   *
   * NOTE: this api is intended for use only by the $location service. Please use the
   * {@link ng.$location $location service} to change url.
   *
   * @param {string} url New url (when used as setter)
   * @param {boolean=} replace Should new url replace current history record ?
   */
  self.url = function(url, replace) {
    // setter
    if (url) {
      if (lastBrowserUrl == url) return;
      lastBrowserUrl = url;
      if ($sniffer.history) {
        if (replace) history.replaceState(null, '', url);
        else {
          history.pushState(null, '', url);
          // Crazy Opera Bug: http://my.opera.com/community/forums/topic.dml?id=1185462
          baseElement.attr('href', baseElement.attr('href'));
        }
      } else {
        if (replace) {
          location.replace(url);
          replacedUrl = url;
        } else {
          location.href = url;
          replacedUrl = null;
        }
      }
      return self;
    // getter
    } else {
      // - the replacedUrl is a workaround for an IE8-9 issue with location.replace method that doesn't update
      //   location.href synchronously
      // - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172
      return replacedUrl || location.href.replace(/%27/g,"'");
    }
  };

  var urlChangeListeners = [],
      urlChangeInit = false;

  function fireUrlChange() {
    if (lastBrowserUrl == self.url()) return;

    lastBrowserUrl = self.url();
    forEach(urlChangeListeners, function(listener) {
      listener(self.url());
    });
  }

  /**
   * @name ng.$browser#onUrlChange
   * @methodOf ng.$browser
   * @TODO(vojta): refactor to use node's syntax for events
   *
   * @description
   * Register callback function that will be called, when url changes.
   *
   * It's only called when the url is changed by outside of angular:
   * - user types different url into address bar
   * - user clicks on history (forward/back) button
   * - user clicks on a link
   *
   * It's not called when url is changed by $browser.url() method
   *
   * The listener gets called with new url as parameter.
   *
   * NOTE: this api is intended for use only by the $location service. Please use the
   * {@link ng.$location $location service} to monitor url changes in angular apps.
   *
   * @param {function(string)} listener Listener function to be called when url changes.
   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.
   */
  self.onUrlChange = function(callback) {
    if (!urlChangeInit) {
      // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)
      // don't fire popstate when user change the address bar and don't fire hashchange when url
      // changed by push/replaceState

      // html5 history api - popstate event
      if ($sniffer.history) jqLite(window).on('popstate', fireUrlChange);
      // hashchange event
      if ($sniffer.hashchange) jqLite(window).on('hashchange', fireUrlChange);
      // polling
      else self.addPollFn(fireUrlChange);

      urlChangeInit = true;
    }

    urlChangeListeners.push(callback);
    return callback;
  };

  //////////////////////////////////////////////////////////////
  // Misc API
  //////////////////////////////////////////////////////////////

  /**
   * Returns current <base href>
   * (always relative - without domain)
   *
   * @returns {string=}
   */
  self.baseHref = function() {
    var href = baseElement.attr('href');
    return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : '';
  };

  //////////////////////////////////////////////////////////////
  // Cookies API
  //////////////////////////////////////////////////////////////
  var lastCookies = {};
  var lastCookieString = '';
  var cookiePath = self.baseHref();

  /**
   * @name ng.$browser#cookies
   * @methodOf ng.$browser
   *
   * @param {string=} name Cookie name
   * @param {string=} value Cookie value
   *
   * @description
   * The cookies method provides a 'private' low level access to browser cookies.
   * It is not meant to be used directly, use the $cookie service instead.
   *
   * The return values vary depending on the arguments that the method was called with as follows:
   * <ul>
   *   <li>cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify it</li>
   *   <li>cookies(name, value) -> set name to value, if value is undefined delete the cookie</li>
   *   <li>cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that way)</li>
   * </ul>
   *
   * @returns {Object} Hash of all cookies (if called without any parameter)
   */
  self.cookies = function(name, value) {
    var cookieLength, cookieArray, cookie, i, index;

    if (name) {
      if (value === undefined) {
        rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
      } else {
        if (isString(value)) {
          cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;

          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
          // - 300 cookies
          // - 20 cookies per unique domain
          // - 4096 bytes per cookie
          if (cookieLength > 4096) {
            $log.warn("Cookie '"+ name +"' possibly not set or overflowed because it was too large ("+
              cookieLength + " > 4096 bytes)!");
          }
        }
      }
    } else {
      if (rawDocument.cookie !== lastCookieString) {
        lastCookieString = rawDocument.cookie;
        cookieArray = lastCookieString.split("; ");
        lastCookies = {};

        for (i = 0; i < cookieArray.length; i++) {
          cookie = cookieArray[i];
          index = cookie.indexOf('=');
          if (index > 0) { //ignore nameless cookies
            var name = unescape(cookie.substring(0, index));
            // the first value that is seen for a cookie is the most
            // specific one.  values for the same cookie name that
            // follow are for less specific paths.
            if (lastCookies[name] === undefined) {
              lastCookies[name] = unescape(cookie.substring(index + 1));
            }
          }
        }
      }
      return lastCookies;
    }
  };


  /**
   * @name ng.$browser#defer
   * @methodOf ng.$browser
   * @param {function()} fn A function, who's execution should be deferred.
   * @param {number=} [delay=0] of milliseconds to defer the function execution.
   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.
   *
   * @description
   * Executes a fn asynchronously via `setTimeout(fn, delay)`.
   *
   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using
   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed
   * via `$browser.defer.flush()`.
   *
   */
  self.defer = function(fn, delay) {
    var timeoutId;
    outstandingRequestCount++;
    timeoutId = setTimeout(function() {
      delete pendingDeferIds[timeoutId];
      completeOutstandingRequest(fn);
    }, delay || 0);
    pendingDeferIds[timeoutId] = true;
    return timeoutId;
  };


  /**
   * @name ng.$browser#defer.cancel
   * @methodOf ng.$browser.defer
   *
   * @description
   * Cancels a deferred task identified with `deferId`.
   *
   * @param {*} deferId Token returned by the `$browser.defer` function.
   * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully canceled.
   */
  self.defer.cancel = function(deferId) {
    if (pendingDeferIds[deferId]) {
      delete pendingDeferIds[deferId];
      clearTimeout(deferId);
      completeOutstandingRequest(noop);
      return true;
    }
    return false;
  };

}

function $BrowserProvider(){
  this.$get = ['$window', '$log', '$sniffer', '$document',
      function( $window,   $log,   $sniffer,   $document){
        return new Browser($window, $document, $log, $sniffer);
      }];
}

/**
 * @ngdoc object
 * @name ng.$cacheFactory
 *
 * @description
 * Factory that constructs cache objects and gives access to them.
 * 
 * <pre>
 * 
 *  var cache = $cacheFactory('cacheId');
 *  expect($cacheFactory.get('cacheId')).toBe(cache);
 *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();
 *
 *  cache.put("key", "value");
 *  cache.put("another key", "another value");
 * 
 *  expect(cache.info()).toEqual({id: 'cacheId', size: 2}); // Since we've specified no options on creation
 * 
 * </pre>
 *
 *
 * @param {string} cacheId Name or id of the newly created cache.
 * @param {object=} options Options object that specifies the cache behavior. Properties:
 *
 *   - `{number=}` `capacity`  turns the cache into LRU cache.
 *
 * @returns {object} Newly created cache object with the following set of methods:
 *
 * - `{object}` `info()`  Returns id, size, and options of cache.
 * - `{{*}}` `put({string} key, {*} value)`  Puts a new key-value pair into the cache and returns it.
 * - `{{*}}` `get({string} key)`  Returns cached value for `key` or undefined for cache miss.
 * - `{void}` `remove({string} key)`  Removes a key-value pair from the cache.
 * - `{void}` `removeAll()`  Removes all cached values.
 * - `{void}` `destroy()`  Removes references to this cache from $cacheFactory.
 *
 */
function $CacheFactoryProvider() {

  this.$get = function() {
    var caches = {};

    function cacheFactory(cacheId, options) {
      if (cacheId in caches) {
        throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
      }

      var size = 0,
          stats = extend({}, options, {id: cacheId}),
          data = {},
          capacity = (options && options.capacity) || Number.MAX_VALUE,
          lruHash = {},
          freshEnd = null,
          staleEnd = null;

      return caches[cacheId] = {

        put: function(key, value) {
          var lruEntry = lruHash[key] || (lruHash[key] = {key: key});

          refresh(lruEntry);

          if (isUndefined(value)) return;
          if (!(key in data)) size++;
          data[key] = value;

          if (size > capacity) {
            this.remove(staleEnd.key);
          }

          return value;
        },


        get: function(key) {
          var lruEntry = lruHash[key];

          if (!lruEntry) return;

          refresh(lruEntry);

          return data[key];
        },


        remove: function(key) {
          var lruEntry = lruHash[key];

          if (!lruEntry) return;

          if (lruEntry == freshEnd) freshEnd = lruEntry.p;
          if (lruEntry == staleEnd) staleEnd = lruEntry.n;
          link(lruEntry.n,lruEntry.p);

          delete lruHash[key];
          delete data[key];
          size--;
        },


        removeAll: function() {
          data = {};
          size = 0;
          lruHash = {};
          freshEnd = staleEnd = null;
        },


        destroy: function() {
          data = null;
          stats = null;
          lruHash = null;
          delete caches[cacheId];
        },


        info: function() {
          return extend({}, stats, {size: size});
        }
      };


      /**
       * makes the `entry` the freshEnd of the LRU linked list
       */
      function refresh(entry) {
        if (entry != freshEnd) {
          if (!staleEnd) {
            staleEnd = entry;
          } else if (staleEnd == entry) {
            staleEnd = entry.n;
          }

          link(entry.n, entry.p);
          link(entry, freshEnd);
          freshEnd = entry;
          freshEnd.n = null;
        }
      }


      /**
       * bidirectionally links two entries of the LRU linked list
       */
      function link(nextEntry, prevEntry) {
        if (nextEntry != prevEntry) {
          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify
          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify
        }
      }
    }


  /**
   * @ngdoc method
   * @name ng.$cacheFactory#info
   * @methodOf ng.$cacheFactory
   *
   * @description
   * Get information about all the of the caches that have been created
   *
   * @returns {Object} - key-value map of `cacheId` to the result of calling `cache#info`
   */
    cacheFactory.info = function() {
      var info = {};
      forEach(caches, function(cache, cacheId) {
        info[cacheId] = cache.info();
      });
      return info;
    };


  /**
   * @ngdoc method
   * @name ng.$cacheFactory#get
   * @methodOf ng.$cacheFactory
   *
   * @description
   * Get access to a cache object by the `cacheId` used when it was created.
   *
   * @param {string} cacheId Name or id of a cache to access.
   * @returns {object} Cache object identified by the cacheId or undefined if no such cache.
   */
    cacheFactory.get = function(cacheId) {
      return caches[cacheId];
    };


    return cacheFactory;
  };
}

/**
 * @ngdoc object
 * @name ng.$templateCache
 *
 * @description
 * The first time a template is used, it is loaded in the template cache for quick retrieval. You can
 * load templates directly into the cache in a `script` tag, or by consuming the `$templateCache`
 * service directly.
 * 
 * Adding via the `script` tag:
 * <pre>
 * <html ng-app>
 * <head>
 * <script type="text/ng-template" id="templateId.html">
 *   This is the content of the template
 * </script>
 * </head>
 *   ...
 * </html>
 * </pre>
 * 
 * **Note:** the `script` tag containing the template does not need to be included in the `head` of the document, but 
 * it must be below the `ng-app` definition.
 * 
 * Adding via the $templateCache service:
 * 
 * <pre>
 * var myApp = angular.module('myApp', []);
 * myApp.run(function($templateCache) {
 *   $templateCache.put('templateId.html', 'This is the content of the template');
 * });
 * </pre>
 * 
 * To retrieve the template later, simply use it in your HTML:
 * <pre>
 * <div ng-include=" 'templateId.html' "></div>
 * </pre>
 * 
 * or get it via Javascript:
 * <pre>
 * $templateCache.get('templateId.html')
 * </pre>
 * 
 * See {@link ng.$cacheFactory $cacheFactory}.
 *
 */
function $TemplateCacheProvider() {
  this.$get = ['$cacheFactory', function($cacheFactory) {
    return $cacheFactory('templates');
  }];
}

/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!
 *
 * DOM-related variables:
 *
 * - "node" - DOM Node
 * - "element" - DOM Element or Node
 * - "$node" or "$element" - jqLite-wrapped node or element
 *
 *
 * Compiler related stuff:
 *
 * - "linkFn" - linking fn of a single directive
 * - "nodeLinkFn" - function that aggregates all linking fns for a particular node
 * - "childLinkFn" -  function that aggregates all linking fns for child nodes of a particular node
 * - "compositeLinkFn" - function that aggregates all linking fns for a compilation root (nodeList)
 */


/**
 * @ngdoc function
 * @name ng.$compile
 * @function
 *
 * @description
 * Compiles a piece of HTML string or DOM into a template and produces a template function, which
 * can then be used to link {@link ng.$rootScope.Scope scope} and the template together.
 *
 * The compilation is a process of walking the DOM tree and trying to match DOM elements to
 * {@link ng.$compileProvider#directive directives}. For each match it
 * executes corresponding template function and collects the
 * instance functions into a single template function which is then returned.
 *
 * The template function can then be used once to produce the view or as it is the case with
 * {@link ng.directive:ngRepeat repeater} many-times, in which
 * case each call results in a view that is a DOM clone of the original template.
 *
 <doc:example module="compile">
   <doc:source>
    <script>
      // declare a new module, and inject the $compileProvider
      angular.module('compile', [], function($compileProvider) {
        // configure new 'compile' directive by passing a directive
        // factory function. The factory function injects the '$compile'
        $compileProvider.directive('compile', function($compile) {
          // directive factory creates a link function
          return function(scope, element, attrs) {
            scope.$watch(
              function(scope) {
                 // watch the 'compile' expression for changes
                return scope.$eval(attrs.compile);
              },
              function(value) {
                // when the 'compile' expression changes
                // assign it into the current DOM
                element.html(value);

                // compile the new DOM and link it to the current
                // scope.
                // NOTE: we only compile .childNodes so that
                // we don't get into infinite loop compiling ourselves
                $compile(element.contents())(scope);
              }
            );
          };
        })
      });

      function Ctrl($scope) {
        $scope.name = 'Angular';
        $scope.html = 'Hello {{name}}';
      }
    </script>
    <div ng-controller="Ctrl">
      <input ng-model="name"> <br>
      <textarea ng-model="html"></textarea> <br>
      <div compile="html"></div>
    </div>
   </doc:source>
   <doc:scenario>
     it('should auto compile', function() {
       expect(element('div[compile]').text()).toBe('Hello Angular');
       input('html').enter('{{name}}!');
       expect(element('div[compile]').text()).toBe('Angular!');
     });
   </doc:scenario>
 </doc:example>

 *
 *
 * @param {string|DOMElement} element Element or HTML string to compile into a template function.
 * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.
 * @param {number} maxPriority only apply directives lower then given priority (Only effects the
 *                 root element(s), not their children)
 * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template
 * (a DOM element/tree) to a scope. Where:
 *
 *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.
 *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the
 *               `template` and call the `cloneAttachFn` function allowing the caller to attach the
 *               cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is
 *               called as: <br> `cloneAttachFn(clonedElement, scope)` where:
 *
 *      * `clonedElement` - is a clone of the original `element` passed into the compiler.
 *      * `scope` - is the current scope with which the linking function is working with.
 *
 * Calling the linking function returns the element of the template. It is either the original element
 * passed in, or the clone of the element if the `cloneAttachFn` is provided.
 *
 * After linking the view is not updated until after a call to $digest which typically is done by
 * Angular automatically.
 *
 * If you need access to the bound view, there are two ways to do it:
 *
 * - If you are not asking the linking function to clone the template, create the DOM element(s)
 *   before you send them to the compiler and keep this reference around.
 *   <pre>
 *     var element = $compile('<p>{{total}}</p>')(scope);
 *   </pre>
 *
 * - if on the other hand, you need the element to be cloned, the view reference from the original
 *   example would not point to the clone, but rather to the original template that was cloned. In
 *   this case, you can access the clone via the cloneAttachFn:
 *   <pre>
 *     var templateHTML = angular.element('<p>{{total}}</p>'),
 *         scope = ....;
 *
 *     var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {
 *       //attach the clone to DOM document at the right place
 *     });
 *
 *     //now we have reference to the cloned DOM via `clone`
 *   </pre>
 *
 *
 * For information on how the compiler works, see the
 * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.
 */

var $compileMinErr = minErr('$compile');

/**
 * @ngdoc service
 * @name ng.$compileProvider
 * @function
 *
 * @description
 */
$CompileProvider.$inject = ['$provide'];
function $CompileProvider($provide) {
  var hasDirectives = {},
      Suffix = 'Directive',
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/,
      aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|file):/,
      imgSrcSanitizationWhitelist = /^\s*(https?|ftp|file):|data:image\//;

  // Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
  // The assumption is that future DOM event attribute names will begin with
  // 'on' and be composed of only English letters.
  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]*|formaction)$/;

  /**
   * @ngdoc function
   * @name ng.$compileProvider#directive
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Register a new directive with the compiler.
   *
   * @param {string} name Name of the directive in camel-case. (ie <code>ngBind</code> which will match as
   *                <code>ng-bind</code>).
   * @param {function|Array} directiveFactory An injectable directive factory function. See {@link guide/directive} for more
   *                info.
   * @returns {ng.$compileProvider} Self for chaining.
   */
   this.directive = function registerDirective(name, directiveFactory) {
    if (isString(name)) {
      assertArg(directiveFactory, 'directiveFactory');
      if (!hasDirectives.hasOwnProperty(name)) {
        hasDirectives[name] = [];
        $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
          function($injector, $exceptionHandler) {
            var directives = [];
            forEach(hasDirectives[name], function(directiveFactory) {
              try {
                var directive = $injector.invoke(directiveFactory);
                if (isFunction(directive)) {
                  directive = { compile: valueFn(directive) };
                } else if (!directive.compile && directive.link) {
                  directive.compile = valueFn(directive.link);
                }
                directive.priority = directive.priority || 0;
                directive.name = directive.name || name;
                directive.require = directive.require || (directive.controller && directive.name);
                directive.restrict = directive.restrict || 'A';
                directives.push(directive);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
            return directives;
          }]);
      }
      hasDirectives[name].push(directiveFactory);
    } else {
      forEach(name, reverseParams(registerDirective));
    }
    return this;
  };


  /**
   * @ngdoc function
   * @name ng.$compileProvider#aHrefSanitizationWhitelist
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
   * urls during a[href] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
   *
   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`
   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to whitelist urls with.
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.aHrefSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      aHrefSanitizationWhitelist = regexp;
      return this;
    }
    return aHrefSanitizationWhitelist;
  };


  /**
   * @ngdoc function
   * @name ng.$compileProvider#imgSrcSanitizationWhitelist
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
   * urls during img[src] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
   *
   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into an
   * absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist` regular
   * expression. If a match is found, the original url is written into the dom. Otherwise, the
   * absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to whitelist urls with.
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.imgSrcSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      imgSrcSanitizationWhitelist = regexp;
      return this;
    }
    return imgSrcSanitizationWhitelist;
  };


  this.$get = [
            '$injector', '$interpolate', '$exceptionHandler', '$http', '$templateCache', '$parse',
            '$controller', '$rootScope', '$document', '$sce', '$$urlUtils', '$animate',
    function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,
             $controller,   $rootScope,   $document,   $sce,   $$urlUtils, $animate) {

    var Attributes = function(element, attr) {
      this.$$element = element;
      this.$attr = attr || {};
    };

    Attributes.prototype = {
      $normalize: directiveNormalize,


      /**
       * @ngdoc function
       * @name ng.$compile.directive.Attributes#$addClass
       * @methodOf ng.$compile.directive.Attributes
       * @function
       *
       * @description
       * Adds the CSS class value specified by the classVal parameter to the element. If animations
       * are enabled then an animation will be triggered for the class addition.
       *
       * @param {string} classVal The className value that will be added to the element
       */
      $addClass : function(classVal) {
        if(classVal && classVal.length > 0) {
          $animate.addClass(this.$$element, classVal);
        }
      },

      /**
       * @ngdoc function
       * @name ng.$compile.directive.Attributes#$removeClass
       * @methodOf ng.$compile.directive.Attributes
       * @function
       *
       * @description
       * Removes the CSS class value specified by the classVal parameter from the element. If animations
       * are enabled then an animation will be triggered for the class removal.
       *
       * @param {string} classVal The className value that will be removed from the element
       */
      $removeClass : function(classVal) {
        if(classVal && classVal.length > 0) {
          $animate.removeClass(this.$$element, classVal);
        }
      },

      /**
       * Set a normalized attribute on the element in a way such that all directives
       * can share the attribute. This function properly handles boolean attributes.
       * @param {string} key Normalized key. (ie ngAttribute)
       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
       *     Defaults to true.
       * @param {string=} attrName Optional none normalized name. Defaults to key.
       */
      $set: function(key, value, writeAttr, attrName) {
        //special case for class attribute addition + removal
        //so that class changes can tap into the animation
        //hooks provided by the $animate service
        if(key == 'class') {
          value = value || '';
          var current = this.$$element.attr('class') || '';
          this.$removeClass(tokenDifference(current, value).join(' '));
          this.$addClass(tokenDifference(value, current).join(' '));
        } else {
          var booleanKey = getBooleanAttrName(this.$$element[0], key),
              normalizedVal,
              nodeName;

          if (booleanKey) {
            this.$$element.prop(key, value);
            attrName = booleanKey;
          }

          this[key] = value;

          // translate normalized key to actual key
          if (attrName) {
            this.$attr[key] = attrName;
          } else {
            attrName = this.$attr[key];
            if (!attrName) {
              this.$attr[key] = attrName = snake_case(key, '-');
            }
          }

          nodeName = nodeName_(this.$$element);

          // sanitize a[href] and img[src] values
          if ((nodeName === 'A' && key === 'href') ||
              (nodeName === 'IMG' && key === 'src')) {
            // NOTE: $$urlUtils.resolve() doesn't support IE < 8 so we don't sanitize for that case.
            if (!msie || msie >= 8 ) {
              normalizedVal = $$urlUtils.resolve(value);
              if (normalizedVal !== '') {
                if ((key === 'href' && !normalizedVal.match(aHrefSanitizationWhitelist)) ||
                    (key === 'src' && !normalizedVal.match(imgSrcSanitizationWhitelist))) {
                  this[key] = value = 'unsafe:' + normalizedVal;
                }
              }
            }
          }

          if (writeAttr !== false) {
            if (value === null || value === undefined) {
              this.$$element.removeAttr(attrName);
            } else {
              this.$$element.attr(attrName, value);
            }
          }
        }

        // fire observers
        var $$observers = this.$$observers;
        $$observers && forEach($$observers[key], function(fn) {
          try {
            fn(value);
          } catch (e) {
            $exceptionHandler(e);
          }
        });

        function tokenDifference(str1, str2) {
          var values = [],
              tokens1 = str1.split(/\s+/),
              tokens2 = str2.split(/\s+/);

          outer:
          for(var i=0;i<tokens1.length;i++) {
            var token = tokens1[i];
            for(var j=0;j<tokens2.length;j++) {
              if(token == tokens2[j]) continue outer;
            }
            values.push(token);
          }
          return values;
        };
      },


      /**
       * Observe an interpolated attribute.
       * The observer will never be called, if given attribute is not interpolated.
       *
       * @param {string} key Normalized key. (ie ngAttribute) .
       * @param {function(*)} fn Function that will be called whenever the attribute value changes.
       * @returns {function(*)} the `fn` Function passed in.
       */
      $observe: function(key, fn) {
        var attrs = this,
            $$observers = (attrs.$$observers || (attrs.$$observers = {})),
            listeners = ($$observers[key] || ($$observers[key] = []));

        listeners.push(fn);
        $rootScope.$evalAsync(function() {
          if (!listeners.$$inter) {
            // no one registered attribute interpolation function, so lets call it manually
            fn(attrs[key]);
          }
        });
        return fn;
      }
    };

    var urlSanitizationNode = $document[0].createElement('a'),
        startSymbol = $interpolate.startSymbol(),
        endSymbol = $interpolate.endSymbol(),
        denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')
            ? identity
            : function denormalizeTemplate(template) {
              return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
        },
        NG_ATTR_BINDING = /^ngAttr[A-Z]/;


    return compile;

    //================================

    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective) {
      if (!($compileNodes instanceof jqLite)) {
        // jquery always rewraps, whereas we need to preserve the original selector so that we can modify it.
        $compileNodes = jqLite($compileNodes);
      }
      // We can not compile top level text elements since text nodes can be merged and we will
      // not be able to attach scope data to them, so we will wrap them in <span>
      forEach($compileNodes, function(node, index){
        if (node.nodeType == 3 /* text node */ && node.nodeValue.match(/\S+/) /* non-empty */ ) {
          $compileNodes[index] = node = jqLite(node).wrap('<span></span>').parent()[0];
        }
      });
      var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective);
      return function publicLinkFn(scope, cloneConnectFn){
        assertArg(scope, 'scope');
        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
        // and sometimes changes the structure of the DOM.
        var $linkNode = cloneConnectFn
          ? JQLitePrototype.clone.call($compileNodes) // IMPORTANT!!!
          : $compileNodes;

        // Attach scope only to non-text nodes.
        for(var i = 0, ii = $linkNode.length; i<ii; i++) {
          var node = $linkNode[i];
          if (node.nodeType == 1 /* element */ || node.nodeType == 9 /* document */) {
            $linkNode.eq(i).data('$scope', scope);
          }
        }
        safeAddClass($linkNode, 'ng-scope');
        if (cloneConnectFn) cloneConnectFn($linkNode, scope);
        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode);
        return $linkNode;
      };
    }

    function safeAddClass($element, className) {
      try {
        $element.addClass(className);
      } catch(e) {
        // ignore, since it means that we are trying to set class on
        // SVG element, where class name is read-only.
      }
    }

    /**
     * Compile function matches each node in nodeList against the directives. Once all directives
     * for a particular node are collected their compile functions are executed. The compile
     * functions return values - the linking functions - are combined into a composite linking
     * function, which is the a linking function for the node.
     *
     * @param {NodeList} nodeList an array of nodes or NodeList to compile
     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
     *        scope argument is auto-generated to the new child of the transcluded parent scope.
     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then the
     *        rootElement must be set the jqLite collection of the compile root. This is
     *        needed so that the jqLite collection items can be replaced with widgets.
     * @param {number=} max directive priority
     * @returns {?function} A composite linking function of all of the matched directives or null.
     */
    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective) {
      var linkFns = [],
          nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;

      for(var i = 0; i < nodeList.length; i++) {
        attrs = new Attributes();

        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.
        directives = collectDirectives(nodeList[i], [], attrs, i == 0 ? maxPriority : undefined, ignoreDirective);

        nodeLinkFn = (directives.length)
            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement)
            : null;

        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length)
            ? null
            : compileNodes(nodeList[i].childNodes,
                 nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);

        linkFns.push(nodeLinkFn);
        linkFns.push(childLinkFn);
        linkFnFound = (linkFnFound || nodeLinkFn || childLinkFn);
      }

      // return a linking function if we have found anything, null otherwise
      return linkFnFound ? compositeLinkFn : null;

      function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
        var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;

        // copy nodeList so that linking doesn't break due to live list updates.
        var stableNodeList = [];
        for (i = 0, ii = nodeList.length; i < ii; i++) {
          stableNodeList.push(nodeList[i]);
        }

        for(i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
          node = stableNodeList[n];
          nodeLinkFn = linkFns[i++];
          childLinkFn = linkFns[i++];

          if (nodeLinkFn) {
            if (nodeLinkFn.scope) {
              childScope = scope.$new(isObject(nodeLinkFn.scope));
              jqLite(node).data('$scope', childScope);
            } else {
              childScope = scope;
            }
            childTranscludeFn = nodeLinkFn.transclude;
            if (childTranscludeFn || (!boundTranscludeFn && transcludeFn)) {
              nodeLinkFn(childLinkFn, childScope, node, $rootElement,
                  (function(transcludeFn) {
                    return function(cloneFn) {
                      var transcludeScope = scope.$new();
                      transcludeScope.$$transcluded = true;

                      return transcludeFn(transcludeScope, cloneFn).
                          on('$destroy', bind(transcludeScope, transcludeScope.$destroy));
                    };
                  })(childTranscludeFn || transcludeFn)
              );
            } else {
              nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);
            }
          } else if (childLinkFn) {
            childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
          }
        }
      }
    }


    /**
     * Looks for directives on the given node and adds them to the directive collection which is
     * sorted.
     *
     * @param node Node to search.
     * @param directives An array to which the directives are added to. This array is sorted before
     *        the function returns.
     * @param attrs The shared attrs object which is used to populate the normalized attributes.
     * @param {number=} maxPriority Max directive priority.
     */
    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
      var nodeType = node.nodeType,
          attrsMap = attrs.$attr,
          match,
          className;

      switch(nodeType) {
        case 1: /* Element */
          // use the node name: <directive>
          addDirective(directives,
              directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority, ignoreDirective);

          // iterate over the attributes
          for (var attr, name, nName, ngAttrName, value, nAttrs = node.attributes,
                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
            var attrStartName;
            var attrEndName;
            var index;

            attr = nAttrs[j];
            if (!msie || msie >= 8 || attr.specified) {
              name = attr.name;
              // support ngAttr attribute binding
              ngAttrName = directiveNormalize(name);
              if (NG_ATTR_BINDING.test(ngAttrName)) {
                name = ngAttrName.substr(6).toLowerCase();
              }
              if ((index = ngAttrName.lastIndexOf('Start')) != -1 && index == ngAttrName.length - 5) {
                attrStartName = name;
                attrEndName = name.substr(0, name.length - 5) + 'end';
                name = name.substr(0, name.length - 6);
              }
              nName = directiveNormalize(name.toLowerCase());
              attrsMap[nName] = name;
              attrs[nName] = value = trim((msie && name == 'href')
                ? decodeURIComponent(node.getAttribute(name, 2))
                : attr.value);
              if (getBooleanAttrName(node, nName)) {
                attrs[nName] = true; // presence means true
              }
              addAttrInterpolateDirective(node, directives, value, nName);
              addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
            }
          }

          // use class as directive
          className = node.className;
          if (isString(className) && className !== '') {
            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
              nName = directiveNormalize(match[2]);
              if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[3]);
              }
              className = className.substr(match.index + match[0].length);
            }
          }
          break;
        case 3: /* Text Node */
          addTextInterpolateDirective(directives, node.nodeValue);
          break;
        case 8: /* Comment */
          try {
            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
            if (match) {
              nName = directiveNormalize(match[1]);
              if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[2]);
              }
            }
          } catch (e) {
            // turns out that under some circumstances IE9 throws errors when one attempts to read comment's node value.
            // Just ignore it and continue. (Can't seem to reproduce in test case.)
          }
          break;
      }

      directives.sort(byPriority);
      return directives;
    }

    /**
     * Given a node with an directive-start it collects all of the siblings until it find directive-end.
     * @param node
     * @param attrStart
     * @param attrEnd
     * @returns {*}
     */
    function groupScan(node, attrStart, attrEnd) {
      var nodes = [];
      var depth = 0;
      if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
        var startNode = node;
        do {
          if (!node) {
            throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
          }
          if (node.nodeType == 1 /** Element **/) {
            if (node.hasAttribute(attrStart)) depth++;
            if (node.hasAttribute(attrEnd)) depth--;
          }
          nodes.push(node);
          node = node.nextSibling;
        } while (depth > 0);
      } else {
        nodes.push(node);
      }
      return jqLite(nodes);
    }

    /**
     * Wrapper for linking function which converts normal linking function into a grouped
     * linking function.
     * @param linkFn
     * @param attrStart
     * @param attrEnd
     * @returns {Function}
     */
    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
      return function(scope, element, attrs, controllers) {
        element = groupScan(element[0], attrStart, attrEnd);
        return linkFn(scope, element, attrs, controllers);
      }
    }

    /**
     * Once the directives have been collected, their compile functions are executed. This method
     * is responsible for inlining directive templates as well as terminating the application
     * of the directives if the terminal directive has been reached.
     *
     * @param {Array} directives Array of collected directives to execute their compile function.
     *        this needs to be pre-sorted by priority order.
     * @param {Node} compileNode The raw DOM node to apply the compile functions to
     * @param {Object} templateAttrs The shared attribute function
     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
     *        scope argument is auto-generated to the new child of the transcluded parent scope.
     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this
     *        argument has the root jqLite array so that we can replace nodes on it.
     * @returns linkFn
     */
    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective) {
      var terminalPriority = -Number.MAX_VALUE,
          preLinkFns = [],
          postLinkFns = [],
          newScopeDirective = null,
          newIsolateScopeDirective = null,
          templateDirective = null,
          $compileNode = templateAttrs.$$element = jqLite(compileNode),
          directive,
          directiveName,
          $template,
          transcludeDirective,
          replaceDirective = originalReplaceDirective,
          childTranscludeFn = transcludeFn,
          controllerDirectives,
          linkFn,
          directiveValue;

      // executes all directives on the current element
      for(var i = 0, ii = directives.length; i < ii; i++) {
        directive = directives[i];
        var attrStart = directive.$$start;
        var attrEnd = directive.$$end;

        // collect multiblock sections
        if (attrStart) {
          $compileNode = groupScan(compileNode, attrStart, attrEnd)
        }
        $template = undefined;

        if (terminalPriority > directive.priority) {
          break; // prevent further processing of directives
        }

        if (directiveValue = directive.scope) {
          assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);
          if (isObject(directiveValue)) {
            safeAddClass($compileNode, 'ng-isolate-scope');
            newIsolateScopeDirective = directive;
          }
          safeAddClass($compileNode, 'ng-scope');
          newScopeDirective = newScopeDirective || directive;
        }

        directiveName = directive.name;

        if (directiveValue = directive.controller) {
          controllerDirectives = controllerDirectives || {};
          assertNoDuplicate("'" + directiveName + "' controller",
              controllerDirectives[directiveName], directive, $compileNode);
          controllerDirectives[directiveName] = directive;
        }

        if (directiveValue = directive.transclude) {
          assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);
          transcludeDirective = directive;
          terminalPriority = directive.priority;
          if (directiveValue == 'element') {
            $template = groupScan(compileNode, attrStart, attrEnd)
            $compileNode = templateAttrs.$$element =
                jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
            compileNode = $compileNode[0];
            replaceWith(jqCollection, jqLite(sliceArgs($template)), compileNode);

            childTranscludeFn = compile($template, transcludeFn, terminalPriority,
                                        replaceDirective && replaceDirective.name);
          } else {
            $template = jqLite(JQLiteClone(compileNode)).contents();
            $compileNode.html(''); // clear contents
            childTranscludeFn = compile($template, transcludeFn);
          }
        }

        if (directive.template) {
          assertNoDuplicate('template', templateDirective, directive, $compileNode);
          templateDirective = directive;

          directiveValue = (isFunction(directive.template))
              ? directive.template($compileNode, templateAttrs)
              : directive.template;

          directiveValue = denormalizeTemplate(directiveValue);

          if (directive.replace) {
            replaceDirective = directive;
            $template = jqLite('<div>' +
                                 trim(directiveValue) +
                               '</div>').contents();
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== 1) {
              throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
            }

            replaceWith(jqCollection, $compileNode, compileNode);

            var newTemplateAttrs = {$attr: {}};

            // combine directives from the original node and from the template:
            // - take the array of directives for this element
            // - split it into two parts, those that were already applied and those that weren't
            // - collect directives from the template, add them to the second group and sort them
            // - append the second group with new directives to the first group
            directives = directives.concat(
                collectDirectives(
                    compileNode,
                    directives.splice(i + 1, directives.length - (i + 1)),
                    newTemplateAttrs
                )
            );
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

            ii = directives.length;
          } else {
            $compileNode.html(directiveValue);
          }
        }

        if (directive.templateUrl) {
          assertNoDuplicate('template', templateDirective, directive, $compileNode);
          templateDirective = directive;

          if (directive.replace) {
            replaceDirective = directive;
          }
          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i),
              nodeLinkFn, $compileNode, templateAttrs, jqCollection, childTranscludeFn);
          ii = directives.length;
        } else if (directive.compile) {
          try {
            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
            if (isFunction(linkFn)) {
              addLinkFns(null, linkFn, attrStart, attrEnd);
            } else if (linkFn) {
              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
            }
          } catch (e) {
            $exceptionHandler(e, startingTag($compileNode));
          }
        }

        if (directive.terminal) {
          nodeLinkFn.terminal = true;
          terminalPriority = Math.max(terminalPriority, directive.priority);
        }

      }

      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;
      nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;

      // might be normal or delayed nodeLinkFn depending on if templateUrl is present
      return nodeLinkFn;

      ////////////////////

      function addLinkFns(pre, post, attrStart, attrEnd) {
        if (pre) {
          if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
          pre.require = directive.require;
          preLinkFns.push(pre);
        }
        if (post) {
          if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
          post.require = directive.require;
          postLinkFns.push(post);
        }
      }


      function getControllers(require, $element) {
        var value, retrievalMethod = 'data', optional = false;
        if (isString(require)) {
          while((value = require.charAt(0)) == '^' || value == '?') {
            require = require.substr(1);
            if (value == '^') {
              retrievalMethod = 'inheritedData';
            }
            optional = optional || value == '?';
          }
          value = $element[retrievalMethod]('$' + require + 'Controller');
          if (!value && !optional) {
            throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
          }
          return value;
        } else if (isArray(require)) {
          value = [];
          forEach(require, function(require) {
            value.push(getControllers(require, $element));
          });
        }
        return value;
      }


      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
        var attrs, $element, i, ii, linkFn, controller;

        if (compileNode === linkNode) {
          attrs = templateAttrs;
        } else {
          attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
        }
        $element = attrs.$$element;

        if (newIsolateScopeDirective) {
          var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;

          var parentScope = scope.$parent || scope;

          forEach(newIsolateScopeDirective.scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP) || [],
                attrName = match[3] || scopeName,
                optional = (match[2] == '?'),
                mode = match[1], // @, =, or &
                lastValue,
                parentGet, parentSet;

            scope.$$isolateBindings[scopeName] = mode + attrName;

            switch (mode) {

              case '@': {
                attrs.$observe(attrName, function(value) {
                  scope[scopeName] = value;
                });
                attrs.$$observers[attrName].$$scope = parentScope;
                if( attrs[attrName] ) {
                  // If the attribute has been provided then we trigger an interpolation to ensure the value is there for use in the link fn
                  scope[scopeName] = $interpolate(attrs[attrName])(parentScope);
                }
                break;
              }

              case '=': {
                if (optional && !attrs[attrName]) {
                  return;
                }
                parentGet = $parse(attrs[attrName]);
                parentSet = parentGet.assign || function() {
                  // reset the change, or we will throw this exception on every $digest
                  lastValue = scope[scopeName] = parentGet(parentScope);
                  throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!",
                      attrs[attrName], newIsolateScopeDirective.name);
                };
                lastValue = scope[scopeName] = parentGet(parentScope);
                scope.$watch(function parentValueWatch() {
                  var parentValue = parentGet(parentScope);

                  if (parentValue !== scope[scopeName]) {
                    // we are out of sync and need to copy
                    if (parentValue !== lastValue) {
                      // parent changed and it has precedence
                      lastValue = scope[scopeName] = parentValue;
                    } else {
                      // if the parent can be assigned then do so
                      parentSet(parentScope, parentValue = lastValue = scope[scopeName]);
                    }
                  }
                  return parentValue;
                });
                break;
              }

              case '&': {
                parentGet = $parse(attrs[attrName]);
                scope[scopeName] = function(locals) {
                  return parentGet(parentScope, locals);
                };
                break;
              }

              default: {
                throw $compileMinErr('iscp', "Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}",
                    newIsolateScopeDirective.name, scopeName, definition);
              }
            }
          });
        }

        if (controllerDirectives) {
          forEach(controllerDirectives, function(directive) {
            var locals = {
              $scope: scope,
              $element: $element,
              $attrs: attrs,
              $transclude: boundTranscludeFn
            }, controllerInstance;

            controller = directive.controller;
            if (controller == '@') {
              controller = attrs[directive.name];
            }

            controllerInstance = $controller(controller, locals);
            $element.data(
                '$' + directive.name + 'Controller',
                controllerInstance);
            if (directive.controllerAs) {
              locals.$scope[directive.controllerAs] = controllerInstance;
            }
          });
        }

        // PRELINKING
        for(i = 0, ii = preLinkFns.length; i < ii; i++) {
          try {
            linkFn = preLinkFns[i];
            linkFn(scope, $element, attrs,
                linkFn.require && getControllers(linkFn.require, $element));
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }

        // RECURSION
        childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);

        // POSTLINKING
        for(i = 0, ii = postLinkFns.length; i < ii; i++) {
          try {
            linkFn = postLinkFns[i];
            linkFn(scope, $element, attrs,
                linkFn.require && getControllers(linkFn.require, $element));
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }
      }
    }


    /**
     * looks up the directive and decorates it with exception handling and proper parameters. We
     * call this the boundDirective.
     *
     * @param {string} name name of the directive to look up.
     * @param {string} location The directive must be found in specific format.
     *   String containing any of theses characters:
     *
     *   * `E`: element name
     *   * `A': attribute
     *   * `C`: class
     *   * `M`: comment
     * @returns true if directive was added.
     */
    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
      if (name === ignoreDirective) return null;
      var match = null;
      if (hasDirectives.hasOwnProperty(name)) {
        for(var directive, directives = $injector.get(name + Suffix),
            i = 0, ii = directives.length; i<ii; i++) {
          try {
            directive = directives[i];
            if ( (maxPriority === undefined || maxPriority > directive.priority) &&
                 directive.restrict.indexOf(location) != -1) {
              if (startAttrName) {
                directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName});
              }
              tDirectives.push(directive);
              match = directive;
            }
          } catch(e) { $exceptionHandler(e); }
        }
      }
      return match;
    }


    /**
     * When the element is replaced with HTML template then the new attributes
     * on the template need to be merged with the existing attributes in the DOM.
     * The desired effect is to have both of the attributes present.
     *
     * @param {object} dst destination attributes (original DOM)
     * @param {object} src source attributes (from the directive template)
     */
    function mergeTemplateAttributes(dst, src) {
      var srcAttr = src.$attr,
          dstAttr = dst.$attr,
          $element = dst.$$element;

      // reapply the old attributes to the new element
      forEach(dst, function(value, key) {
        if (key.charAt(0) != '$') {
          if (src[key]) {
            value += (key === 'style' ? ';' : ' ') + src[key];
          }
          dst.$set(key, value, true, srcAttr[key]);
        }
      });

      // copy the new attributes on the old attrs object
      forEach(src, function(value, key) {
        if (key == 'class') {
          safeAddClass($element, value);
          dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
        } else if (key == 'style') {
          $element.attr('style', $element.attr('style') + ';' + value);
        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
          dst[key] = value;
          dstAttr[key] = srcAttr[key];
        }
      });
    }


    function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs,
        $rootElement, childTranscludeFn) {
      var linkQueue = [],
          afterTemplateNodeLinkFn,
          afterTemplateChildLinkFn,
          beforeTemplateCompileNode = $compileNode[0],
          origAsyncDirective = directives.shift(),
          // The fact that we have to copy and patch the directive seems wrong!
          derivedSyncDirective = extend({}, origAsyncDirective, {
            controller: null, templateUrl: null, transclude: null, scope: null, replace: null
          }),
          templateUrl = (isFunction(origAsyncDirective.templateUrl))
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
              : origAsyncDirective.templateUrl;

      $compileNode.html('');

      $http.get($sce.getTrustedResourceUrl(templateUrl), {cache: $templateCache}).
        success(function(content) {
          var compileNode, tempTemplateAttrs, $template;

          content = denormalizeTemplate(content);

          if (origAsyncDirective.replace) {
            $template = jqLite('<div>' + trim(content) + '</div>').contents();
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== 1) {
              throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}",
                  origAsyncDirective.name, templateUrl);
            }

            tempTemplateAttrs = {$attr: {}};
            replaceWith($rootElement, $compileNode, compileNode);
            collectDirectives(compileNode, directives, tempTemplateAttrs);
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
          } else {
            compileNode = beforeTemplateCompileNode;
            $compileNode.html(content);
          }

          directives.unshift(derivedSyncDirective);

          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective);
          forEach($rootElement, function(node, i) {
            if (node == compileNode) {
              $rootElement[i] = $compileNode[0];
            }
          });
          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);


          while(linkQueue.length) {
            var scope = linkQueue.shift(),
                beforeTemplateLinkNode = linkQueue.shift(),
                linkRootElement = linkQueue.shift(),
                controller = linkQueue.shift(),
                linkNode = $compileNode[0];

            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
              // it was cloned therefore we have to clone as well.
              linkNode = JQLiteClone(compileNode);
              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
            }

            afterTemplateNodeLinkFn(
              beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller),
              scope, linkNode, $rootElement, controller
            );
          }
          linkQueue = null;
        }).
        error(function(response, code, headers, config) {
          throw $compileMinErr('tpload', 'Failed to load template: {0}', config.url);
        });

      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {
        if (linkQueue) {
          linkQueue.push(scope);
          linkQueue.push(node);
          linkQueue.push(rootElement);
          linkQueue.push(controller);
        } else {
          afterTemplateNodeLinkFn(function() {
            beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);
          }, scope, node, rootElement, controller);
        }
      };
    }


    /**
     * Sorting function for bound directives.
     */
    function byPriority(a, b) {
      return b.priority - a.priority;
    }


    function assertNoDuplicate(what, previousDirective, directive, element) {
      if (previousDirective) {
        throw $compileMinErr('multidir', 'Multiple directives [{0}, {1}] asking for {2} on: {3}',
            previousDirective.name, directive.name, what, startingTag(element));
      }
    }


    function addTextInterpolateDirective(directives, text) {
      var interpolateFn = $interpolate(text, true);
      if (interpolateFn) {
        directives.push({
          priority: 0,
          compile: valueFn(function textInterpolateLinkFn(scope, node) {
            var parent = node.parent(),
                bindings = parent.data('$binding') || [];
            bindings.push(interpolateFn);
            safeAddClass(parent.data('$binding', bindings), 'ng-binding');
            scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
              node[0].nodeValue = value;
            });
          })
        });
      }
    }


    function getTrustedContext(node, attrNormalizedName) {
      // maction[xlink:href] can source SVG.  It's not limited to <maction>.
      if (attrNormalizedName == "xlinkHref" ||
          (nodeName_(node) != "IMG" && (attrNormalizedName == "src" ||
                                        attrNormalizedName == "ngSrc"))) {
        return $sce.RESOURCE_URL;
      }
    }


    function addAttrInterpolateDirective(node, directives, value, name) {
      var interpolateFn = $interpolate(value, true);

      // no interpolation found -> ignore
      if (!interpolateFn) return;


      if (name === "multiple" && nodeName_(node) === "SELECT") {
        throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}",
            startingTag(node));
      }

      directives.push({
        priority: 100,
        compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {
          var $$observers = (attr.$$observers || (attr.$$observers = {}));

          if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
            throw $compileMinErr('nodomevents',
                "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- " +
                "versions (such as ng-click instead of onclick) instead.");
          }

          // we need to interpolate again, in case the attribute value has been updated
          // (e.g. by another directive's compile function)
          interpolateFn = $interpolate(attr[name], true, getTrustedContext(node, name));

          // if attribute was updated so that there is no interpolation going on we don't want to
          // register any observers
          if (!interpolateFn) return;

          attr[name] = interpolateFn(scope);
          ($$observers[name] || ($$observers[name] = [])).$$inter = true;
          (attr.$$observers && attr.$$observers[name].$$scope || scope).
            $watch(interpolateFn, function interpolateFnWatchAction(value) {
              attr.$set(name, value);
            });
        })
      });
    }


    /**
     * This is a special jqLite.replaceWith, which can replace items which
     * have no parents, provided that the containing jqLite collection is provided.
     *
     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes
     *    in the root of the tree.
     * @param {JqLite} elementsToRemove The jqLite element which we are going to replace. We keep the shell,
     *    but replace its DOM node reference.
     * @param {Node} newNode The new DOM node.
     */
    function replaceWith($rootElement, elementsToRemove, newNode) {
      var firstElementToRemove = elementsToRemove[0],
          removeCount = elementsToRemove.length,
          parent = firstElementToRemove.parentNode,
          i, ii;

      if ($rootElement) {
        for(i = 0, ii = $rootElement.length; i < ii; i++) {
          if ($rootElement[i] == firstElementToRemove) {
            $rootElement[i++] = newNode;
            for (var j = i, j2 = j + removeCount - 1,
                     jj = $rootElement.length;
                 j < jj; j++, j2++) {
              if (j2 < jj) {
                $rootElement[j] = $rootElement[j2];
              } else {
                delete $rootElement[j];
              }
            }
            $rootElement.length -= removeCount - 1;
            break;
          }
        }
      }

      if (parent) {
        parent.replaceChild(newNode, firstElementToRemove);
      }
      var fragment = document.createDocumentFragment();
      fragment.appendChild(firstElementToRemove);
      newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
      for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
        var element = elementsToRemove[k];
        jqLite(element).remove(); // must do this way to clean up expando
        fragment.appendChild(element);
        delete elementsToRemove[k];
      }

      elementsToRemove[0] = newNode;
      elementsToRemove.length = 1
    }
  }];
}

var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
/**
 * Converts all accepted directives format into proper directive name.
 * All of these will become 'myDirective':
 *   my:Directive
 *   my-directive
 *   x-my-directive
 *   data-my:directive
 *
 * Also there is special case for Moz prefix starting with upper case letter.
 * @param name Name to normalize
 */
function directiveNormalize(name) {
  return camelCase(name.replace(PREFIX_REGEXP, ''));
}

/**
 * @ngdoc object
 * @name ng.$compile.directive.Attributes
 * @description
 *
 * A shared object between directive compile / linking functions which contains normalized DOM element
 * attributes. The the values reflect current binding state `{{ }}`. The normalization is needed
 * since all of these are treated as equivalent in Angular:
 *
 *          <span ng:bind="a" ng-bind="a" data-ng-bind="a" x-ng-bind="a">
 */

/**
 * @ngdoc property
 * @name ng.$compile.directive.Attributes#$attr
 * @propertyOf ng.$compile.directive.Attributes
 * @returns {object} A map of DOM element attribute names to the normalized name. This is
 *          needed to do reverse lookup from normalized name back to actual name.
 */


/**
 * @ngdoc function
 * @name ng.$compile.directive.Attributes#$set
 * @methodOf ng.$compile.directive.Attributes
 * @function
 *
 * @description
 * Set DOM element attribute value.
 *
 *
 * @param {string} name Normalized element attribute name of the property to modify. The name is
 *          revers translated using the {@link ng.$compile.directive.Attributes#$attr $attr}
 *          property to the original name.
 * @param {string} value Value to set the attribute to. The value can be an interpolated string.
 */



/**
 * Closure compiler type information
 */

function nodesetLinkingFn(
  /* angular.Scope */ scope,
  /* NodeList */ nodeList,
  /* Element */ rootElement,
  /* function(Function) */ boundTranscludeFn
){}

function directiveLinkingFn(
  /* nodesetLinkingFn */ nodesetLinkingFn,
  /* angular.Scope */ scope,
  /* Node */ node,
  /* Element */ rootElement,
  /* function(Function) */ boundTranscludeFn
){}

/**
 * @ngdoc object
 * @name ng.$controllerProvider
 * @description
 * The {@link ng.$controller $controller service} is used by Angular to create new
 * controllers.
 *
 * This provider allows controller registration via the
 * {@link ng.$controllerProvider#register register} method.
 */
function $ControllerProvider() {
  var controllers = {},
      CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;


  /**
   * @ngdoc function
   * @name ng.$controllerProvider#register
   * @methodOf ng.$controllerProvider
   * @param {string} name Controller name
   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI
   *    annotations in the array notation).
   */
  this.register = function(name, constructor) {
    if (isObject(name)) {
      extend(controllers, name)
    } else {
      controllers[name] = constructor;
    }
  };


  this.$get = ['$injector', '$window', function($injector, $window) {

    /**
     * @ngdoc function
     * @name ng.$controller
     * @requires $injector
     *
     * @param {Function|string} constructor If called with a function then it's considered to be the
     *    controller constructor function. Otherwise it's considered to be a string which is used
     *    to retrieve the controller constructor using the following steps:
     *
     *    * check if a controller with given name is registered via `$controllerProvider`
     *    * check if evaluating the string on the current scope returns a constructor
     *    * check `window[constructor]` on the global `window` object
     *
     * @param {Object} locals Injection locals for Controller.
     * @return {Object} Instance of given controller.
     *
     * @description
     * `$controller` service is responsible for instantiating controllers.
     *
     * It's just a simple call to {@link AUTO.$injector $injector}, but extracted into
     * a service, so that one can override this service with {@link https://gist.github.com/1649788
     * BC version}.
     */
    return function(expression, locals) {
      var instance, match, constructor, identifier;

      if(isString(expression)) {
        match = expression.match(CNTRL_REG),
        constructor = match[1],
        identifier = match[3];
        expression = controllers.hasOwnProperty(constructor)
            ? controllers[constructor]
            : getter(locals.$scope, constructor, true) || getter($window, constructor, true);

        assertArgFn(expression, constructor, true);
      }

      instance = $injector.instantiate(expression, locals);

      if (identifier) {
        if (!(locals && typeof locals.$scope == 'object')) {
          throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", constructor || expression.name, identifier);
        }

        locals.$scope[identifier] = instance;
      }

      return instance;
    };
  }];
}

/**
 * @ngdoc object
 * @name ng.$document
 * @requires $window
 *
 * @description
 * A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`
 * element.
 */
function $DocumentProvider(){
  this.$get = ['$window', function(window){
    return jqLite(window.document);
  }];
}

/**
 * @ngdoc function
 * @name ng.$exceptionHandler
 * @requires $log
 *
 * @description
 * Any uncaught exception in angular expressions is delegated to this service.
 * The default implementation simply delegates to `$log.error` which logs it into
 * the browser console.
 *
 * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by
 * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.
 *
 * @param {Error} exception Exception associated with the error.
 * @param {string=} cause optional information about the context in which
 *       the error was thrown.
 *
 */
function $ExceptionHandlerProvider() {
  this.$get = ['$log', function($log) {
    return function(exception, cause) {
      $log.error.apply($log, arguments);
    };
  }];
}

/**
 * Parse headers into key value object
 *
 * @param {string} headers Raw headers as a string
 * @returns {Object} Parsed headers as key value object
 */
function parseHeaders(headers) {
  var parsed = {}, key, val, i;

  if (!headers) return parsed;

  forEach(headers.split('\n'), function(line) {
    i = line.indexOf(':');
    key = lowercase(trim(line.substr(0, i)));
    val = trim(line.substr(i + 1));

    if (key) {
      if (parsed[key]) {
        parsed[key] += ', ' + val;
      } else {
        parsed[key] = val;
      }
    }
  });

  return parsed;
}


/**
 * Returns a function that provides access to parsed headers.
 *
 * Headers are lazy parsed when first requested.
 * @see parseHeaders
 *
 * @param {(string|Object)} headers Headers to provide access to.
 * @returns {function(string=)} Returns a getter function which if called with:
 *
 *   - if called with single an argument returns a single header value or null
 *   - if called with no arguments returns an object containing all headers.
 */
function headersGetter(headers) {
  var headersObj = isObject(headers) ? headers : undefined;

  return function(name) {
    if (!headersObj) headersObj =  parseHeaders(headers);

    if (name) {
      return headersObj[lowercase(name)] || null;
    }

    return headersObj;
  };
}


/**
 * Chain all given functions
 *
 * This function is used for both request and response transforming
 *
 * @param {*} data Data to transform.
 * @param {function(string=)} headers Http headers getter fn.
 * @param {(function|Array.<function>)} fns Function or an array of functions.
 * @returns {*} Transformed data.
 */
function transformData(data, headers, fns) {
  if (isFunction(fns))
    return fns(data, headers);

  forEach(fns, function(fn) {
    data = fn(data, headers);
  });

  return data;
}


function isSuccess(status) {
  return 200 <= status && status < 300;
}


function $HttpProvider() {
  var JSON_START = /^\s*(\[|\{[^\{])/,
      JSON_END = /[\}\]]\s*$/,
      PROTECTION_PREFIX = /^\)\]\}',?\n/,
      CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': 'application/json;charset=utf-8'};

  var defaults = this.defaults = {
    // transform incoming response data
    transformResponse: [function(data) {
      if (isString(data)) {
        // strip json vulnerability protection prefix
        data = data.replace(PROTECTION_PREFIX, '');
        if (JSON_START.test(data) && JSON_END.test(data))
          data = fromJson(data);
      }
      return data;
    }],

    // transform outgoing request data
    transformRequest: [function(d) {
      return isObject(d) && !isFile(d) ? toJson(d) : d;
    }],

    // default headers
    headers: {
      common: {
        'Accept': 'application/json, text/plain, */*'
      },
      post:   CONTENT_TYPE_APPLICATION_JSON,
      put:    CONTENT_TYPE_APPLICATION_JSON,
      patch:  CONTENT_TYPE_APPLICATION_JSON
    },

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN'
  };

  /**
   * Are order by request. I.E. they are applied in the same order as
   * array on request, but revers order on response.
   */
  var interceptorFactories = this.interceptors = [];
  /**
   * For historical reasons, response interceptors ordered by the order in which
   * they are applied to response. (This is in revers to interceptorFactories)
   */
  var responseInterceptorFactories = this.responseInterceptors = [];

  this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector', '$$urlUtils',
      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector, $$urlUtils) {

    var defaultCache = $cacheFactory('$http');

    /**
     * Interceptors stored in reverse order. Inner interceptors before outer interceptors.
     * The reversal is needed so that we can build up the interception chain around the
     * server request.
     */
    var reversedInterceptors = [];

    forEach(interceptorFactories, function(interceptorFactory) {
      reversedInterceptors.unshift(isString(interceptorFactory)
          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
    });

    forEach(responseInterceptorFactories, function(interceptorFactory, index) {
      var responseFn = isString(interceptorFactory)
          ? $injector.get(interceptorFactory)
          : $injector.invoke(interceptorFactory);

      /**
       * Response interceptors go before "around" interceptors (no real reason, just
       * had to pick one.) But they are already reversed, so we can't use unshift, hence
       * the splice.
       */
      reversedInterceptors.splice(index, 0, {
        response: function(response) {
          return responseFn($q.when(response));
        },
        responseError: function(response) {
          return responseFn($q.reject(response));
        }
      });
    });


    /**
     * @ngdoc function
     * @name ng.$http
     * @requires $httpBackend
     * @requires $browser
     * @requires $cacheFactory
     * @requires $rootScope
     * @requires $q
     * @requires $injector
     *
     * @description
     * The `$http` service is a core Angular service that facilitates communication with the remote
     * HTTP servers via the browser's {@link https://developer.mozilla.org/en/xmlhttprequest
     * XMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.
     *
     * For unit testing applications that use `$http` service, see
     * {@link ngMock.$httpBackend $httpBackend mock}.
     *
     * For a higher level of abstraction, please check out the {@link ngResource.$resource
     * $resource} service.
     *
     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by
     * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage
     * it is important to familiarize yourself with these APIs and the guarantees they provide.
     *
     *
     * # General usage
     * The `$http` service is a function which takes a single argument  a configuration object 
     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}
     * with two $http specific methods: `success` and `error`.
     *
     * <pre>
     *   $http({method: 'GET', url: '/someUrl'}).
     *     success(function(data, status, headers, config) {
     *       // this callback will be called asynchronously
     *       // when the response is available
     *     }).
     *     error(function(data, status, headers, config) {
     *       // called asynchronously if an error occurs
     *       // or server returns response with an error status.
     *     });
     * </pre>
     *
     * Since the returned value of calling the $http function is a `promise`, you can also use
     * the `then` method to register callbacks, and these callbacks will receive a single argument 
     * an object representing the response. See the API signature and type info below for more
     * details.
     *
     * A response status code between 200 and 299 is considered a success status and
     * will result in the success callback being called. Note that if the response is a redirect,
     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be
     * called for such responses.
     *
     * # Shortcut methods
     *
     * Since all invocations of the $http service require passing in an HTTP method and URL, and
     * POST/PUT requests require request data to be provided as well, shortcut methods
     * were created:
     *
     * <pre>
     *   $http.get('/someUrl').success(successCallback);
     *   $http.post('/someUrl', data).success(successCallback);
     * </pre>
     *
     * Complete list of shortcut methods:
     *
     * - {@link ng.$http#get $http.get}
     * - {@link ng.$http#head $http.head}
     * - {@link ng.$http#post $http.post}
     * - {@link ng.$http#put $http.put}
     * - {@link ng.$http#delete $http.delete}
     * - {@link ng.$http#jsonp $http.jsonp}
     *
     *
     * # Setting HTTP Headers
     *
     * The $http service will automatically add certain HTTP headers to all requests. These defaults
     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration
     * object, which currently contains this default configuration:
     *
     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):
     *   - `Accept: application/json, text/plain, * / *`
     * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)
     *   - `Content-Type: application/json`
     * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)
     *   - `Content-Type: application/json`
     *
     * To add or overwrite these defaults, simply add or remove a property from these configuration
     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
     * with the lowercased HTTP method name as the key, e.g.
     * `$httpProvider.defaults.headers.get['My-Header']='value'`.
     *
     * Additionally, the defaults can be set at runtime via the `$http.defaults` object in the same
     * fashion.
     *
     *
     * # Transforming Requests and Responses
     *
     * Both requests and responses can be transformed using transform functions. By default, Angular
     * applies these transformations:
     *
     * Request transformations:
     *
     * - If the `data` property of the request configuration object contains an object, serialize it into
     *   JSON format.
     *
     * Response transformations:
     *
     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).
     *  - If JSON response is detected, deserialize it using a JSON parser.
     *
     * To globally augment or override the default transforms, modify the `$httpProvider.defaults.transformRequest` and
     * `$httpProvider.defaults.transformResponse` properties. These properties are by default an
     * array of transform functions, which allows you to `push` or `unshift` a new transformation function into the
     * transformation chain. You can also decide to completely override any default transformations by assigning your
     * transformation functions to these properties directly without the array wrapper.
     *
     * Similarly, to locally override the request/response transforms, augment the `transformRequest` and/or
     * `transformResponse` properties of the configuration object passed into `$http`.
     *
     *
     * # Caching
     *
     * To enable caching, set the configuration property `cache` to `true`. When the cache is
     * enabled, `$http` stores the response from the server in local cache. Next time the
     * response is served from the cache without sending a request to the server.
     *
     * Note that even if the response is served from cache, delivery of the data is asynchronous in
     * the same way that real requests are.
     *
     * If there are multiple GET requests for the same URL that should be cached using the same
     * cache, but the cache is not populated yet, only one request to the server will be made and
     * the remaining requests will be fulfilled using the response from the first request.
     *
     * A custom default cache built with $cacheFactory can be provided in $http.defaults.cache.
     * To skip it, set configuration property `cache` to `false`.
     *
     *
     * # Interceptors
     *
     * Before you start creating interceptors, be sure to understand the
     * {@link ng.$q $q and deferred/promise APIs}.
     *
     * For purposes of global error handling, authentication, or any kind of synchronous or
     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be
     * able to intercept requests before they are handed to the server and
     * responses before they are handed over to the application code that
     * initiated these requests. The interceptors leverage the {@link ng.$q
     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.
     *
     * The interceptors are service factories that are registered with the `$httpProvider` by
     * adding them to the `$httpProvider.interceptors` array. The factory is called and
     * injected with dependencies (if specified) and returns the interceptor.
     *
     * There are two kinds of interceptors (and two kinds of rejection interceptors):
     *
     *   * `request`: interceptors get called with http `config` object. The function is free to modify
     *     the `config` or create a new one. The function needs to return the `config` directly or as a
     *     promise.
     *   * `requestError`: interceptor gets called when a previous interceptor threw an error or resolved
     *      with a rejection.
     *   * `response`: interceptors get called with http `response` object. The function is free to modify
     *     the `response` or create a new one. The function needs to return the `response` directly or as a
     *     promise.
     *   * `responseError`: interceptor gets called when a previous interceptor threw an error or resolved
     *      with a rejection.
     *
     *
     * <pre>
     *   // register the interceptor as a service
     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
     *     return {
     *       // optional method
     *       'request': function(config) {
     *         // do something on success
     *         return config || $q.when(config);
     *       },
     *
     *       // optional method
     *      'requestError': function(rejection) {
     *         // do something on error
     *         if (canRecover(rejection)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(rejection);
     *       },
     *
     *
     *
     *       // optional method
     *       'response': function(response) {
     *         // do something on success
     *         return response || $q.when(response);
     *       },
     *
     *       // optional method
     *      'responseError': function(rejection) {
     *         // do something on error
     *         if (canRecover(rejection)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(rejection);
     *       };
     *     }
     *   });
     *
     *   $httpProvider.interceptors.push('myHttpInterceptor');
     *
     *
     *   // register the interceptor via an anonymous factory
     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {
     *     return {
     *      'request': function(config) {
     *          // same as above
     *       },
     *       'response': function(response) {
     *          // same as above
     *       }
     *   });
     * </pre>
     *
     * # Response interceptors (DEPRECATED)
     *
     * Before you start creating interceptors, be sure to understand the
     * {@link ng.$q $q and deferred/promise APIs}.
     *
     * For purposes of global error handling, authentication or any kind of synchronous or
     * asynchronous preprocessing of received responses, it is desirable to be able to intercept
     * responses for http requests before they are handed over to the application code that
     * initiated these requests. The response interceptors leverage the {@link ng.$q
     * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.
     *
     * The interceptors are service factories that are registered with the $httpProvider by
     * adding them to the `$httpProvider.responseInterceptors` array. The factory is called and
     * injected with dependencies (if specified) and returns the interceptor   a function that
     * takes a {@link ng.$q promise} and returns the original or a new promise.
     *
     * <pre>
     *   // register the interceptor as a service
     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
     *     return function(promise) {
     *       return promise.then(function(response) {
     *         // do something on success
     *         return response;
     *       }, function(response) {
     *         // do something on error
     *         if (canRecover(response)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(response);
     *       });
     *     }
     *   });
     *
     *   $httpProvider.responseInterceptors.push('myHttpInterceptor');
     *
     *
     *   // register the interceptor via an anonymous factory
     *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {
     *     return function(promise) {
     *       // same as above
     *     }
     *   });
     * </pre>
     *
     *
     * # Security Considerations
     *
     * When designing web applications, consider security threats from:
     *
     * - {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
     *   JSON vulnerability}
     * - {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}
     *
     * Both server and the client must cooperate in order to eliminate these threats. Angular comes
     * pre-configured with strategies that address these issues, but for this to work backend server
     * cooperation is required.
     *
     * ## JSON Vulnerability Protection
     *
     * A {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
     * JSON vulnerability} allows third party website to turn your JSON resource URL into
     * {@link http://en.wikipedia.org/wiki/JSONP JSONP} request under some conditions. To
     * counter this your server can prefix all JSON requests with following string `")]}',\n"`.
     * Angular will automatically strip the prefix before processing it as JSON.
     *
     * For example if your server needs to return:
     * <pre>
     * ['one','two']
     * </pre>
     *
     * which is vulnerable to attack, your server can return:
     * <pre>
     * )]}',
     * ['one','two']
     * </pre>
     *
     * Angular will strip the prefix, before processing the JSON.
     *
     *
     * ## Cross Site Request Forgery (XSRF) Protection
     *
     * {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which
     * an unauthorized site can gain your user's private data. Angular provides a mechanism
     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie
     * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only
     * JavaScript that runs on your domain could read the cookie, your server can be assured that
     * the XHR came from JavaScript running on your domain. The header will not be set for
     * cross-domain requests.
     *
     * To take advantage of this, your server needs to set a token in a JavaScript readable session
     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the
     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure
     * that only JavaScript running on your domain could have sent the request. The token must be
     * unique for each user and must be verifiable by the server (to prevent the JavaScript from making
     * up its own tokens). We recommend that the token is a digest of your site's authentication
     * cookie with a {@link https://en.wikipedia.org/wiki/Salt_(cryptography) salt} for added security.
     *
     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
     * properties of either $httpProvider.defaults, or the per-request config object.
     *
     *
     * @param {object} config Object describing the request to be made and how it should be
     *    processed. The object has following properties:
     *
     *    - **method**  `{string}`  HTTP method (e.g. 'GET', 'POST', etc)
     *    - **url**  `{string}`  Absolute or relative URL of the resource that is being requested.
     *    - **params**  `{Object.<string|Object>}`  Map of strings or objects which will be turned to
     *      `?key1=value1&key2=value2` after the url. If the value is not a string, it will be JSONified.
     *    - **data**  `{string|Object}`  Data to be sent as the request message data.
     *    - **headers**  `{Object}`  Map of strings or functions which return strings representing
     *      HTTP headers to send to the server. If the return value of a function is null, the header will
     *      not be sent.
     *    - **xsrfHeaderName**  `{string}`  Name of HTTP header to populate with the XSRF token.
     *    - **xsrfCookieName**  `{string}`  Name of cookie containing the XSRF token.
     *    - **transformRequest**  `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` 
     *      transform function or an array of such functions. The transform function takes the http
     *      request body and headers and returns its transformed (typically serialized) version.
     *    - **transformResponse**  `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` 
     *      transform function or an array of such functions. The transform function takes the http
     *      response body and headers and returns its transformed (typically deserialized) version.
     *    - **cache**  `{boolean|Cache}`  If true, a default $http cache will be used to cache the
     *      GET request, otherwise if a cache instance built with
     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
     *      caching.
     *    - **timeout**  `{number|Promise}`  timeout in milliseconds, or {@link ng.$q promise}
     *      that should abort the request when resolved.
     *    - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the
     *      XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5
     *      requests with credentials} for more information.
     *    - **responseType** - `{string}` - see {@link
     *      https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType requestType}.
     *
     * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the
     *   standard `then` method and two http specific methods: `success` and `error`. The `then`
     *   method takes two arguments a success and an error callback which will be called with a
     *   response object. The `success` and `error` methods take a single argument - a function that
     *   will be called when the request succeeds or fails respectively. The arguments passed into
     *   these functions are destructured representation of the response object passed into the
     *   `then` method. The response object has these properties:
     *
     *   - **data**  `{string|Object}`  The response body transformed with the transform functions.
     *   - **status**  `{number}`  HTTP status code of the response.
     *   - **headers**  `{function([headerName])}`  Header getter function.
     *   - **config**  `{Object}`  The configuration object that was used to generate the request.
     *
     * @property {Array.<Object>} pendingRequests Array of config objects for currently pending
     *   requests. This is primarily meant to be used for debugging purposes.
     *
     *
     * @example
      <example>
        <file name="index.html">
          <div ng-controller="FetchCtrl">
            <select ng-model="method">
              <option>GET</option>
              <option>JSONP</option>
            </select>
            <input type="text" ng-model="url" size="80"/>
            <button ng-click="fetch()">fetch</button><br>
            <button ng-click="updateModel('GET', 'http-hello.html')">Sample GET</button>
            <button ng-click="updateModel('JSONP', 'http://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')">Sample JSONP</button>
            <button ng-click="updateModel('JSONP', 'http://angularjs.org/doesntexist&callback=JSON_CALLBACK')">Invalid JSONP</button>
            <pre>http status code: {{status}}</pre>
            <pre>http response data: {{data}}</pre>
          </div>
        </file>
        <file name="script.js">
          function FetchCtrl($scope, $http, $templateCache) {
            $scope.method = 'GET';
            $scope.url = 'http-hello.html';

            $scope.fetch = function() {
              $scope.code = null;
              $scope.response = null;

              $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
                success(function(data, status) {
                  $scope.status = status;
                  $scope.data = data;
                }).
                error(function(data, status) {
                  $scope.data = data || "Request failed";
                  $scope.status = status;
              });
            };

            $scope.updateModel = function(method, url) {
              $scope.method = method;
              $scope.url = url;
            };
          }
        </file>
        <file name="http-hello.html">
          Hello, $http!
        </file>
        <file name="scenario.js">
          it('should make an xhr GET request', function() {
            element(':button:contains("Sample GET")').click();
            element(':button:contains("fetch")').click();
            expect(binding('status')).toBe('200');
            expect(binding('data')).toMatch(/Hello, \$http!/);
          });

          it('should make a JSONP request to angularjs.org', function() {
            element(':button:contains("Sample JSONP")').click();
            element(':button:contains("fetch")').click();
            expect(binding('status')).toBe('200');
            expect(binding('data')).toMatch(/Super Hero!/);
          });

          it('should make JSONP request to invalid URL and invoke the error handler',
              function() {
            element(':button:contains("Invalid JSONP")').click();
            element(':button:contains("fetch")').click();
            expect(binding('status')).toBe('0');
            expect(binding('data')).toBe('Request failed');
          });
        </file>
      </example>
     */
    function $http(requestConfig) {
      var config = {
        transformRequest: defaults.transformRequest,
        transformResponse: defaults.transformResponse
      };
      var headers = mergeHeaders(requestConfig);

      extend(config, requestConfig);
      config.headers = headers;
      config.method = uppercase(config.method);

      var xsrfValue = $$urlUtils.isSameOrigin(config.url)
          ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]
          : undefined;
      if (xsrfValue) {
        headers[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
      }


      var serverRequest = function(config) {
        headers = config.headers;
        var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);

        // strip content-type if data is undefined
        if (isUndefined(config.data)) {
          forEach(headers, function(value, header) {
            if (lowercase(header) === 'content-type') {
                delete headers[header];
            }
          });
        }

        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
          config.withCredentials = defaults.withCredentials;
        }

        // send request
        return sendReq(config, reqData, headers).then(transformResponse, transformResponse);
      };

      var chain = [serverRequest, undefined];
      var promise = $q.when(config);

      // apply interceptors
      forEach(reversedInterceptors, function(interceptor) {
        if (interceptor.request || interceptor.requestError) {
          chain.unshift(interceptor.request, interceptor.requestError);
        }
        if (interceptor.response || interceptor.responseError) {
          chain.push(interceptor.response, interceptor.responseError);
        }
      });

      while(chain.length) {
        var thenFn = chain.shift();
        var rejectFn = chain.shift();

        promise = promise.then(thenFn, rejectFn);
      }

      promise.success = function(fn) {
        promise.then(function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };

      promise.error = function(fn) {
        promise.then(null, function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };

      return promise;

      function transformResponse(response) {
        // make a copy since the response must be cacheable
        var resp = extend({}, response, {
          data: transformData(response.data, response.headers, config.transformResponse)
        });
        return (isSuccess(response.status))
          ? resp
          : $q.reject(resp);
      }

      function mergeHeaders(config) {
        var defHeaders = defaults.headers,
            reqHeaders = extend({}, config.headers),
            defHeaderName, lowercaseDefHeaderName, reqHeaderName;

        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);

        // execute if header value is function
        execHeaders(defHeaders);
        execHeaders(reqHeaders);

        // using for-in instead of forEach to avoid unecessary iteration after header has been found
        defaultHeadersIteration:
        for (defHeaderName in defHeaders) {
          lowercaseDefHeaderName = lowercase(defHeaderName);

          for (reqHeaderName in reqHeaders) {
            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
              continue defaultHeadersIteration;
            }
          }

          reqHeaders[defHeaderName] = defHeaders[defHeaderName];
        }

        return reqHeaders;

        function execHeaders(headers) {
          var headerContent;

          forEach(headers, function(headerFn, header) {
            if (isFunction(headerFn)) {
              headerContent = headerFn();
              if (headerContent != null) {
                headers[header] = headerContent;
              } else {
                delete headers[header];
              }
            }
          });
        }
      }
    }

    $http.pendingRequests = [];

    /**
     * @ngdoc method
     * @name ng.$http#get
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `GET` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#delete
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `DELETE` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#head
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `HEAD` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#jsonp
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `JSONP` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request.
     *                     Should contain `JSON_CALLBACK` string.
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */
    createShortMethods('get', 'delete', 'head', 'jsonp');

    /**
     * @ngdoc method
     * @name ng.$http#post
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `POST` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {*} data Request content
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#put
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `PUT` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {*} data Request content
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */
    createShortMethodsWithData('post', 'put');

        /**
         * @ngdoc property
         * @name ng.$http#defaults
         * @propertyOf ng.$http
         *
         * @description
         * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of
         * default headers, withCredentials as well as request and response transformations.
         *
         * See "Setting HTTP Headers" and "Transforming Requests and Responses" sections above.
         */
    $http.defaults = defaults;


    return $http;


    function createShortMethods(names) {
      forEach(arguments, function(name) {
        $http[name] = function(url, config) {
          return $http(extend(config || {}, {
            method: name,
            url: url
          }));
        };
      });
    }


    function createShortMethodsWithData(name) {
      forEach(arguments, function(name) {
        $http[name] = function(url, data, config) {
          return $http(extend(config || {}, {
            method: name,
            url: url,
            data: data
          }));
        };
      });
    }


    /**
     * Makes the request.
     *
     * !!! ACCESSES CLOSURE VARS:
     * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests
     */
    function sendReq(config, reqData, reqHeaders) {
      var deferred = $q.defer(),
          promise = deferred.promise,
          cache,
          cachedResp,
          url = buildUrl(config.url, config.params);

      $http.pendingRequests.push(config);
      promise.then(removePendingReq, removePendingReq);


      if ((config.cache || defaults.cache) && config.cache !== false && config.method == 'GET') {
        cache = isObject(config.cache) ? config.cache
              : isObject(defaults.cache) ? defaults.cache
              : defaultCache;
      }

      if (cache) {
        cachedResp = cache.get(url);
        if (isDefined(cachedResp)) {
          if (cachedResp.then) {
            // cached request has already been sent, but there is no response yet
            cachedResp.then(removePendingReq, removePendingReq);
            return cachedResp;
          } else {
            // serving from cache
            if (isArray(cachedResp)) {
              resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
            } else {
              resolvePromise(cachedResp, 200, {});
            }
          }
        } else {
          // put the promise for the non-transformed response into cache as a placeholder
          cache.put(url, promise);
        }
      }

      // if we won't have the response in cache, send the request to the backend
      if (isUndefined(cachedResp)) {
        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
            config.withCredentials, config.responseType);
      }

      return promise;


      /**
       * Callback registered to $httpBackend():
       *  - caches the response if desired
       *  - resolves the raw $http promise
       *  - calls $apply
       */
      function done(status, response, headersString) {
        if (cache) {
          if (isSuccess(status)) {
            cache.put(url, [status, response, parseHeaders(headersString)]);
          } else {
            // remove promise from the cache
            cache.remove(url);
          }
        }

        resolvePromise(response, status, headersString);
        if (!$rootScope.$$phase) $rootScope.$apply();
      }


      /**
       * Resolves the raw $http promise.
       */
      function resolvePromise(response, status, headers) {
        // normalize internal statuses to 0
        status = Math.max(status, 0);

        (isSuccess(status) ? deferred.resolve : deferred.reject)({
          data: response,
          status: status,
          headers: headersGetter(headers),
          config: config
        });
      }


      function removePendingReq() {
        var idx = indexOf($http.pendingRequests, config);
        if (idx !== -1) $http.pendingRequests.splice(idx, 1);
      }
    }


    function buildUrl(url, params) {
          if (!params) return url;
          var parts = [];
          forEachSorted(params, function(value, key) {
            if (value == null || value == undefined) return;
            if (!isArray(value)) value = [value];

            forEach(value, function(v) {
              if (isObject(v)) {
                v = toJson(v);
              }
              parts.push(encodeUriQuery(key) + '=' +
                         encodeUriQuery(v));
            });
          });
          return url + ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');
        }


  }];
}

var XHR = window.XMLHttpRequest || function() {
  try { return new ActiveXObject("Msxml2.XMLHTTP.6.0"); } catch (e1) {}
  try { return new ActiveXObject("Msxml2.XMLHTTP.3.0"); } catch (e2) {}
  try { return new ActiveXObject("Msxml2.XMLHTTP"); } catch (e3) {}
  throw minErr('$httpBackend')('noxhr', "This browser does not support XMLHttpRequest.");
};


/**
 * @ngdoc object
 * @name ng.$httpBackend
 * @requires $browser
 * @requires $window
 * @requires $document
 *
 * @description
 * HTTP backend used by the {@link ng.$http service} that delegates to
 * XMLHttpRequest object or JSONP and deals with browser incompatibilities.
 *
 * You should never need to use this service directly, instead use the higher-level abstractions:
 * {@link ng.$http $http} or {@link ngResource.$resource $resource}.
 *
 * During testing this implementation is swapped with {@link ngMock.$httpBackend mock
 * $httpBackend} which can be trained with responses.
 */
function $HttpBackendProvider() {
  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
    return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks,
        $document[0], $window.location.protocol.replace(':', ''));
  }];
}

function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {
  // TODO(vojta): fix the signature
  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
    var status;
    $browser.$$incOutstandingRequestCount();
    url = url || $browser.url();

    if (lowercase(method) == 'jsonp') {
      var callbackId = '_' + (callbacks.counter++).toString(36);
      callbacks[callbackId] = function(data) {
        callbacks[callbackId].data = data;
      };

      var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
          function() {
        if (callbacks[callbackId].data) {
          completeRequest(callback, 200, callbacks[callbackId].data);
        } else {
          completeRequest(callback, status || -2);
        }
        delete callbacks[callbackId];
      });
    } else {
      var xhr = new XHR();
      xhr.open(method, url, true);
      forEach(headers, function(value, key) {
        if (value) xhr.setRequestHeader(key, value);
      });

      // In IE6 and 7, this might be called synchronously when xhr.send below is called and the
      // response is in the cache. the promise api will ensure that to the app code the api is
      // always async
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          var responseHeaders = xhr.getAllResponseHeaders();

          // TODO(vojta): remove once Firefox 21 gets released.
          // begin: workaround to overcome Firefox CORS http response headers bug
          // https://bugzilla.mozilla.org/show_bug.cgi?id=608735
          // Firefox already patched in nightly. Should land in Firefox 21.

          // CORS "simple response headers" http://www.w3.org/TR/cors/
          var value,
              simpleHeaders = ["Cache-Control", "Content-Language", "Content-Type",
                                  "Expires", "Last-Modified", "Pragma"];
          if (!responseHeaders) {
            responseHeaders = "";
            forEach(simpleHeaders, function (header) {
              var value = xhr.getResponseHeader(header);
              if (value) {
                  responseHeaders += header + ": " + value + "\n";
              }
            });
          }
          // end of the workaround.

          // responseText is the old-school way of retrieving response (supported by IE8 & 9)
          // response and responseType properties were introduced in XHR Level2 spec (supported by IE10)
          completeRequest(callback,
              status || xhr.status,
              (xhr.responseType ? xhr.response : xhr.responseText),
              responseHeaders);
        }
      };

      if (withCredentials) {
        xhr.withCredentials = true;
      }

      if (responseType) {
        xhr.responseType = responseType;
      }

      xhr.send(post || '');
    }

    if (timeout > 0) {
      var timeoutId = $browserDefer(timeoutRequest, timeout);
    } else if (timeout && timeout.then) {
      timeout.then(timeoutRequest);
    }


    function timeoutRequest() {
      status = -1;
      jsonpDone && jsonpDone();
      xhr && xhr.abort();
    }

    function completeRequest(callback, status, response, headersString) {
      // URL_MATCH is defined in src/service/location.js
      var protocol = (url.match(SERVER_MATCH) || ['', locationProtocol])[1];

      // cancel timeout and subsequent timeout promise resolution
      timeoutId && $browserDefer.cancel(timeoutId);
      jsonpDone = xhr = null;

      // fix status code for file protocol (it's always 0)
      status = (protocol == 'file') ? (response ? 200 : 404) : status;

      // normalize IE bug (http://bugs.jquery.com/ticket/1450)
      status = status == 1223 ? 204 : status;

      callback(status, response, headersString);
      $browser.$$completeOutstandingRequest(noop);
    }
  };

  function jsonpReq(url, done) {
    // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:
    // - fetches local scripts via XHR and evals them
    // - adds and immediately removes script elements from the document
    var script = rawDocument.createElement('script'),
        doneWrapper = function() {
          rawDocument.body.removeChild(script);
          if (done) done();
        };

    script.type = 'text/javascript';
    script.src = url;

    if (msie) {
      script.onreadystatechange = function() {
        if (/loaded|complete/.test(script.readyState)) doneWrapper();
      };
    } else {
      script.onload = script.onerror = doneWrapper;
    }

    rawDocument.body.appendChild(script);
    return doneWrapper;
  }
}

var $interpolateMinErr = minErr('$interpolate');

/**
 * @ngdoc object
 * @name ng.$interpolateProvider
 * @function
 *
 * @description
 *
 * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.
 *
 * @example
   <doc:example module="customInterpolationApp">
     <doc:source>
      <script>
        var customInterpolationApp = angular.module('customInterpolationApp', []);

        customInterpolationApp.config(function($interpolateProvider) {
          $interpolateProvider.startSymbol('//');
          $interpolateProvider.endSymbol('//');
        });


        customInterpolationApp.controller('DemoController', function DemoController() {
            this.label = "This bindings is brought you you by // interpolation symbols.";
        });
      </script>
      <div ng-app="App" ng-controller="DemoController as demo">
          //demo.label//
      </div>
     </doc:source>
     <doc:scenario>
       it('should interpolate binding with custom symbols', function() {
         expect(binding('demo.label')).toBe('This bindings is brought you you by // interpolation symbols.');
       });
 </doc:scenario>
   </doc:example>
 */
function $InterpolateProvider() {
  var startSymbol = '{{';
  var endSymbol = '}}';

  /**
   * @ngdoc method
   * @name ng.$interpolateProvider#startSymbol
   * @methodOf ng.$interpolateProvider
   * @description
   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
   *
   * @param {string=} value new value to set the starting symbol to.
   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
   */
  this.startSymbol = function(value){
    if (value) {
      startSymbol = value;
      return this;
    } else {
      return startSymbol;
    }
  };

  /**
   * @ngdoc method
   * @name ng.$interpolateProvider#endSymbol
   * @methodOf ng.$interpolateProvider
   * @description
   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
   *
   * @param {string=} value new value to set the ending symbol to.
   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
   */
  this.endSymbol = function(value){
    if (value) {
      endSymbol = value;
      return this;
    } else {
      return endSymbol;
    }
  };


  this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
    var startSymbolLength = startSymbol.length,
        endSymbolLength = endSymbol.length;

    /**
     * @ngdoc function
     * @name ng.$interpolate
     * @function
     *
     * @requires $parse
     * @requires $sce
     *
     * @description
     *
     * Compiles a string with markup into an interpolation function. This service is used by the
     * HTML {@link ng.$compile $compile} service for data binding. See
     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the
     * interpolation markup.
     *
     *
       <pre>
         var $interpolate = ...; // injected
         var exp = $interpolate('Hello {{name}}!');
         expect(exp({name:'Angular'}).toEqual('Hello Angular!');
       </pre>
     *
     *
     * @param {string} text The text with markup to interpolate.
     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
     *    embedded expression in order to return an interpolation function. Strings with no
     *    embedded expression will return null for the interpolation function.
     * @param {string=} trustedContext when provided, the returned function passes the interpolated
     *    result through {@link ng.$sce#getTrusted $sce.getTrusted(interpolatedResult,
     *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that
     *    provides Strict Contextual Escaping for details.
     * @returns {function(context)} an interpolation function which is used to compute the interpolated
     *    string. The function has these parameters:
     *
     *    * `context`: an object against which any expressions embedded in the strings are evaluated
     *      against.
     *
     */
    function $interpolate(text, mustHaveExpression, trustedContext) {
      var startIndex,
          endIndex,
          index = 0,
          parts = [],
          length = text.length,
          hasInterpolation = false,
          fn,
          exp,
          concat = [];

      while(index < length) {
        if ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &&
             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) {
          (index != startIndex) && parts.push(text.substring(index, startIndex));
          parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
          fn.exp = exp;
          index = endIndex + endSymbolLength;
          hasInterpolation = true;
        } else {
          // we did not find anything, so we have to add the remainder to the parts array
          (index != length) && parts.push(text.substring(index));
          index = length;
        }
      }

      if (!(length = parts.length)) {
        // we added, nothing, must have been an empty string.
        parts.push('');
        length = 1;
      }

      // Concatenating expressions makes it hard to reason about whether some combination of concatenated
      // values are unsafe to use and could easily lead to XSS.  By requiring that a single
      // expression be used for iframe[src], object[src], etc., we ensure that the value that's used
      // is assigned or constructed by some JS code somewhere that is more testable or make it
      // obvious that you bound the value to some user controlled value.  This helps reduce the load
      // when auditing for XSS issues.
      if (trustedContext && parts.length > 1) {
          throw $interpolateMinErr('noconcat',
              "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
              "interpolations that concatenate multiple expressions when a trusted value is " +
              "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      }

      if (!mustHaveExpression  || hasInterpolation) {
        concat.length = length;
        fn = function(context) {
          try {
            for(var i = 0, ii = length, part; i<ii; i++) {
              if (typeof (part = parts[i]) == 'function') {
                part = part(context);
                if (trustedContext) {
                  part = $sce.getTrusted(trustedContext, part);
                } else {
                  part = $sce.valueOf(part);
                }
                if (part == null || part == undefined) {
                  part = '';
                } else if (typeof part != 'string') {
                  part = toJson(part);
                }
              }
              concat[i] = part;
            }
            return concat.join('');
          }
          catch(err) {
            var newErr = $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
            $exceptionHandler(newErr);
          }
        };
        fn.exp = text;
        fn.parts = parts;
        return fn;
      }
    }


    /**
     * @ngdoc method
     * @name ng.$interpolate#startSymbol
     * @methodOf ng.$interpolate
     * @description
     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
     *
     * Use {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change
     * the symbol.
     *
     * @returns {string} start symbol.
     */
    $interpolate.startSymbol = function() {
      return startSymbol;
    }


    /**
     * @ngdoc method
     * @name ng.$interpolate#endSymbol
     * @methodOf ng.$interpolate
     * @description
     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
     *
     * Use {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change
     * the symbol.
     *
     * @returns {string} start symbol.
     */
    $interpolate.endSymbol = function() {
      return endSymbol;
    }

    return $interpolate;
  }];
}

/**
 * @ngdoc object
 * @name ng.$locale
 *
 * @description
 * $locale service provides localization rules for various Angular components. As of right now the
 * only public api is:
 *
 * * `id`  `{string}`  locale id formatted as `languageId-countryId` (e.g. `en-us`)
 */
function $LocaleProvider(){
  this.$get = function() {
    return {
      id: 'en-us',

      NUMBER_FORMATS: {
        DECIMAL_SEP: '.',
        GROUP_SEP: ',',
        PATTERNS: [
          { // Decimal Pattern
            minInt: 1,
            minFrac: 0,
            maxFrac: 3,
            posPre: '',
            posSuf: '',
            negPre: '-',
            negSuf: '',
            gSize: 3,
            lgSize: 3
          },{ //Currency Pattern
            minInt: 1,
            minFrac: 2,
            maxFrac: 2,
            posPre: '\u00A4',
            posSuf: '',
            negPre: '(\u00A4',
            negSuf: ')',
            gSize: 3,
            lgSize: 3
          }
        ],
        CURRENCY_SYM: '$'
      },

      DATETIME_FORMATS: {
        MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'
                .split(','),
        SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
        DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
        SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
        AMPMS: ['AM','PM'],
        medium: 'MMM d, y h:mm:ss a',
        short: 'M/d/yy h:mm a',
        fullDate: 'EEEE, MMMM d, y',
        longDate: 'MMMM d, y',
        mediumDate: 'MMM d, y',
        shortDate: 'M/d/yy',
        mediumTime: 'h:mm:ss a',
        shortTime: 'h:mm a'
      },

      pluralCat: function(num) {
        if (num === 1) {
          return 'one';
        }
        return 'other';
      }
    };
  };
}

var SERVER_MATCH = /^([^:]+):\/\/(\w+:{0,1}\w*@)?(\{?[\w\.-]*\}?)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/,
    PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
    DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};
var $locationMinErr = minErr('$location');


/**
 * Encode path using encodeUriSegment, ignoring forward slashes
 *
 * @param {string} path Path to encode
 * @returns {string}
 */
function encodePath(path) {
  var segments = path.split('/'),
      i = segments.length;

  while (i--) {
    segments[i] = encodeUriSegment(segments[i]);
  }

  return segments.join('/');
}

function matchUrl(url, obj) {
  var match = SERVER_MATCH.exec(url);

  obj.$$protocol = match[1];
  obj.$$host = match[3];
  obj.$$port = int(match[5]) || DEFAULT_PORTS[match[1]] || null;
}

function matchAppUrl(url, obj) {
  var match = PATH_MATCH.exec(url);

  obj.$$path = decodeURIComponent(match[1]);
  obj.$$search = parseKeyValue(match[3]);
  obj.$$hash = decodeURIComponent(match[5] || '');

  // make sure path starts with '/';
  if (obj.$$path && obj.$$path.charAt(0) != '/') obj.$$path = '/' + obj.$$path;
}


function composeProtocolHostPort(protocol, host, port) {
  return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);
}

/**
 *
 * @param {string} begin
 * @param {string} whole
 * @param {string} otherwise
 * @returns {string} returns text from whole after begin or otherwise if it does not begin with expected string.
 */
function beginsWith(begin, whole, otherwise) {
  return whole.indexOf(begin) == 0 ? whole.substr(begin.length) : otherwise;
}


function stripHash(url) {
  var index = url.indexOf('#');
  return index == -1 ? url : url.substr(0, index);
}


function stripFile(url) {
  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
}

/* return the server only (scheme://host:port) */
function serverBase(url) {
  return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
}


/**
 * LocationHtml5Url represents an url
 * This object is exposed as $location service when HTML5 mode is enabled and supported
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} basePrefix url path prefix
 */
function LocationHtml5Url(appBase, basePrefix) {
  this.$$html5 = true;
  basePrefix = basePrefix || '';
  var appBaseNoFile = stripFile(appBase);
  /**
   * Parse given html5 (regular) url string into properties
   * @param {string} newAbsoluteUrl HTML5 url
   * @private
   */
  this.$$parse = function(url) {
    var parsed = {}
    matchUrl(url, parsed);
    var pathUrl = beginsWith(appBaseNoFile, url);
    if (!isString(pathUrl)) {
      throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
    }
    matchAppUrl(pathUrl, parsed);
    extend(this, parsed);
    if (!this.$$path) {
      this.$$path = '/';
    }

    this.$$compose();
  };

  /**
   * Compose url and update `absUrl` property
   * @private
   */
  this.$$compose = function() {
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always '/'
  };

  this.$$rewrite = function(url) {
    var appUrl, prevAppUrl;

    if ( (appUrl = beginsWith(appBase, url)) !== undefined ) {
      prevAppUrl = appUrl;
      if ( (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ) {
        return appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
      } else {
        return appBase + prevAppUrl;
      }
    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ) {
      return appBaseNoFile + appUrl;
    } else if (appBaseNoFile == url + '/') {
      return appBaseNoFile;
    }
  }
}


/**
 * LocationHashbangUrl represents url
 * This object is exposed as $location service when developer doesn't opt into html5 mode.
 * It also serves as the base class for html5 mode fallback on legacy browsers.
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} hashPrefix hashbang prefix
 */
function LocationHashbangUrl(appBase, hashPrefix) {
  var appBaseNoFile = stripFile(appBase);

  matchUrl(appBase, this);


  /**
   * Parse given hashbang url into properties
   * @param {string} url Hashbang url
   * @private
   */
  this.$$parse = function(url) {
    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
    var withoutHashUrl = withoutBaseUrl.charAt(0) == '#'
        ? beginsWith(hashPrefix, withoutBaseUrl)
        : (this.$$html5)
          ? withoutBaseUrl
          : '';

    if (!isString(withoutHashUrl)) {
      throw $locationMinErr('ihshprfx', 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix);
    }
    matchAppUrl(withoutHashUrl, this);
    this.$$compose();
  };

  /**
   * Compose hashbang url and update `absUrl` property
   * @private
   */
  this.$$compose = function() {
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
  };

  this.$$rewrite = function(url) {
    if(stripHash(appBase) == stripHash(url)) {
      return url;
    }
  }
}


/**
 * LocationHashbangUrl represents url
 * This object is exposed as $location service when html5 history api is enabled but the browser
 * does not support it.
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} hashPrefix hashbang prefix
 */
function LocationHashbangInHtml5Url(appBase, hashPrefix) {
  this.$$html5 = true;
  LocationHashbangUrl.apply(this, arguments);

  var appBaseNoFile = stripFile(appBase);

  this.$$rewrite = function(url) {
    var appUrl;

    if ( appBase == stripHash(url) ) {
      return url;
    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) ) {
      return appBase + hashPrefix + appUrl;
    } else if ( appBaseNoFile === url + '/') {
      return appBaseNoFile;
    }
  }
}


LocationHashbangInHtml5Url.prototype =
  LocationHashbangUrl.prototype =
  LocationHtml5Url.prototype = {

  /**
   * Are we in html5 mode?
   * @private
   */
  $$html5: false,

  /**
   * Has any change been replacing ?
   * @private
   */
  $$replace: false,

  /**
   * @ngdoc method
   * @name ng.$location#absUrl
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return full url representation with all segments encoded according to rules specified in
   * {@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.
   *
   * @return {string} full url
   */
  absUrl: locationGetter('$$absUrl'),

  /**
   * @ngdoc method
   * @name ng.$location#url
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.
   *
   * Change path, search and hash, when called with parameter and return `$location`.
   *
   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)
   * @param {string=} replace The path that will be changed
   * @return {string} url
   */
  url: function(url, replace) {
    if (isUndefined(url))
      return this.$$url;

    var match = PATH_MATCH.exec(url);
    if (match[1]) this.path(decodeURIComponent(match[1]));
    if (match[2] || match[1]) this.search(match[3] || '');
    this.hash(match[5] || '', replace);

    return this;
  },

  /**
   * @ngdoc method
   * @name ng.$location#protocol
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return protocol of current url.
   *
   * @return {string} protocol of current url
   */
  protocol: locationGetter('$$protocol'),

  /**
   * @ngdoc method
   * @name ng.$location#host
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return host of current url.
   *
   * @return {string} host of current url.
   */
  host: locationGetter('$$host'),

  /**
   * @ngdoc method
   * @name ng.$location#port
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return port of current url.
   *
   * @return {Number} port
   */
  port: locationGetter('$$port'),

  /**
   * @ngdoc method
   * @name ng.$location#path
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return path of current url when called without any parameter.
   *
   * Change path when called with parameter and return `$location`.
   *
   * Note: Path should always begin with forward slash (/), this method will add the forward slash
   * if it is missing.
   *
   * @param {string=} path New path
   * @return {string} path
   */
  path: locationGetterSetter('$$path', function(path) {
    return path.charAt(0) == '/' ? path : '/' + path;
  }),

  /**
   * @ngdoc method
   * @name ng.$location#search
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return search part (as object) of current url when called without any parameter.
   *
   * Change search part when called with parameter and return `$location`.
   *
   * @param {string|Object.<string>|Object.<Array.<string>>} search New search params - string or hash object. Hash object
   *    may contain an array of values, which will be decoded as duplicates in the url.
   * @param {string=} paramValue If `search` is a string, then `paramValue` will override only a
   *    single search parameter. If the value is `null`, the parameter will be deleted.
   *
   * @return {string} search
   */
  search: function(search, paramValue) {
    switch (arguments.length) {
      case 0:
        return this.$$search;
      case 1:
        if (isString(search)) {
          this.$$search = parseKeyValue(search);
        } else if (isObject(search)) {
          this.$$search = search;
        } else {
          throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
        }
        break;
      default:
        if (paramValue == undefined || paramValue == null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
    }

    this.$$compose();
    return this;
  },

  /**
   * @ngdoc method
   * @name ng.$location#hash
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return hash fragment when called without any parameter.
   *
   * Change hash fragment when called with parameter and return `$location`.
   *
   * @param {string=} hash New hash fragment
   * @return {string} hash
   */
  hash: locationGetterSetter('$$hash', identity),

  /**
   * @ngdoc method
   * @name ng.$location#replace
   * @methodOf ng.$location
   *
   * @description
   * If called, all changes to $location during current `$digest` will be replacing current history
   * record, instead of adding new one.
   */
  replace: function() {
    this.$$replace = true;
    return this;
  }
};

function locationGetter(property) {
  return function() {
    return this[property];
  };
}


function locationGetterSetter(property, preprocess) {
  return function(value) {
    if (isUndefined(value))
      return this[property];

    this[property] = preprocess(value);
    this.$$compose();

    return this;
  };
}


/**
 * @ngdoc object
 * @name ng.$location
 *
 * @requires $browser
 * @requires $sniffer
 * @requires $rootElement
 *
 * @description
 * The $location service parses the URL in the browser address bar (based on the
 * {@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL
 * available to your application. Changes to the URL in the address bar are reflected into
 * $location service and changes to $location are reflected into the browser address bar.
 *
 * **The $location service:**
 *
 * - Exposes the current URL in the browser address bar, so you can
 *   - Watch and observe the URL.
 *   - Change the URL.
 * - Synchronizes the URL with the browser when the user
 *   - Changes the address bar.
 *   - Clicks the back or forward button (or clicks a History link).
 *   - Clicks on a link.
 * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).
 *
 * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular
 * Services: Using $location}
 */

/**
 * @ngdoc object
 * @name ng.$locationProvider
 * @description
 * Use the `$locationProvider` to configure how the application deep linking paths are stored.
 */
function $LocationProvider(){
  var hashPrefix = '',
      html5Mode = false;

  /**
   * @ngdoc property
   * @name ng.$locationProvider#hashPrefix
   * @methodOf ng.$locationProvider
   * @description
   * @param {string=} prefix Prefix for hash part (containing path and search)
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.hashPrefix = function(prefix) {
    if (isDefined(prefix)) {
      hashPrefix = prefix;
      return this;
    } else {
      return hashPrefix;
    }
  };

  /**
   * @ngdoc property
   * @name ng.$locationProvider#html5Mode
   * @methodOf ng.$locationProvider
   * @description
   * @param {string=} mode Use HTML5 strategy if available.
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.html5Mode = function(mode) {
    if (isDefined(mode)) {
      html5Mode = mode;
      return this;
    } else {
      return html5Mode;
    }
  };

  this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',
      function( $rootScope,   $browser,   $sniffer,   $rootElement) {
    var $location,
        LocationMode,
        baseHref = $browser.baseHref(), // if base[href] is undefined, it defaults to ''
        initialUrl = $browser.url(),
        appBase;

    if (html5Mode) {
      appBase = serverBase(initialUrl) + (baseHref || '/');
      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
    } else {
      appBase = stripHash(initialUrl);
      LocationMode = LocationHashbangUrl;
    }
    $location = new LocationMode(appBase, '#' + hashPrefix);
    $location.$$parse($location.$$rewrite(initialUrl));

    $rootElement.on('click', function(event) {
      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
      // currently we open nice url link and redirect then

      if (event.ctrlKey || event.metaKey || event.which == 2) return;

      var elm = jqLite(event.target);

      // traverse the DOM up to find first A tag
      while (lowercase(elm[0].nodeName) !== 'a') {
        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)
        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
      }

      var absHref = elm.prop('href');
      var rewrittenUrl = $location.$$rewrite(absHref);

      if (absHref && !elm.attr('target') && rewrittenUrl && !event.isDefaultPrevented()) {
        event.preventDefault();
        if (rewrittenUrl != $browser.url()) {
          // update location manually
          $location.$$parse(rewrittenUrl);
          $rootScope.$apply();
          // hack to work around FF6 bug 684208 when scenario runner clicks on links
          window.angular['ff-684208-preventDefault'] = true;
        }
      }
    });


    // rewrite hashbang url <> html5 url
    if ($location.absUrl() != initialUrl) {
      $browser.url($location.absUrl(), true);
    }

    // update $location when $browser url changes
    $browser.onUrlChange(function(newUrl) {
      if ($location.absUrl() != newUrl) {
        if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {
          $browser.url($location.absUrl());
          return;
        }
        $rootScope.$evalAsync(function() {
          var oldUrl = $location.absUrl();

          $location.$$parse(newUrl);
          afterLocationChange(oldUrl);
        });
        if (!$rootScope.$$phase) $rootScope.$digest();
      }
    });

    // update browser
    var changeCounter = 0;
    $rootScope.$watch(function $locationWatch() {
      var oldUrl = $browser.url();
      var currentReplace = $location.$$replace;

      if (!changeCounter || oldUrl != $location.absUrl()) {
        changeCounter++;
        $rootScope.$evalAsync(function() {
          if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).
              defaultPrevented) {
            $location.$$parse(oldUrl);
          } else {
            $browser.url($location.absUrl(), currentReplace);
            afterLocationChange(oldUrl);
          }
        });
      }
      $location.$$replace = false;

      return changeCounter;
    });

    return $location;

    function afterLocationChange(oldUrl) {
      $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);
    }
}];
}

/**
 * @ngdoc object
 * @name ng.$log
 * @requires $window
 *
 * @description
 * Simple service for logging. Default implementation writes the message
 * into the browser's console (if present).
 *
 * The main purpose of this service is to simplify debugging and troubleshooting.
 *
 * @example
   <example>
     <file name="script.js">
       function LogCtrl($scope, $log) {
         $scope.$log = $log;
         $scope.message = 'Hello World!';
       }
     </file>
     <file name="index.html">
       <div ng-controller="LogCtrl">
         <p>Reload this page with open console, enter text and hit the log button...</p>
         Message:
         <input type="text" ng-model="message"/>
         <button ng-click="$log.log(message)">log</button>
         <button ng-click="$log.warn(message)">warn</button>
         <button ng-click="$log.info(message)">info</button>
         <button ng-click="$log.error(message)">error</button>
       </div>
     </file>
   </example>
 */

/**
 * @ngdoc object
 * @name ng.$logProvider
 * @description
 * Use the `$logProvider` to configure how the application logs messages
 */
function $LogProvider(){
  var debug = true,
      self = this;
  
  /**
   * @ngdoc property
   * @name ng.$logProvider#debugEnabled
   * @methodOf ng.$logProvider
   * @description
   * @param {string=} flag enable or disable debug level messages
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.debugEnabled = function(flag) {
	  if (isDefined(flag)) {
		  debug = flag;
		  return this;
	  } else {
		  return debug;
	  }
  };
  
  this.$get = ['$window', function($window){
    return {
      /**
       * @ngdoc method
       * @name ng.$log#log
       * @methodOf ng.$log
       *
       * @description
       * Write a log message
       */
      log: consoleLog('log'),

      /**
       * @ngdoc method
       * @name ng.$log#info
       * @methodOf ng.$log
       *
       * @description
       * Write an information message
       */
      info: consoleLog('info'),

      /**
       * @ngdoc method
       * @name ng.$log#warn
       * @methodOf ng.$log
       *
       * @description
       * Write a warning message
       */
      warn: consoleLog('warn'),

      /**
       * @ngdoc method
       * @name ng.$log#error
       * @methodOf ng.$log
       *
       * @description
       * Write an error message
       */
      error: consoleLog('error'),
      
      /**
       * @ngdoc method
       * @name ng.$log#debug
       * @methodOf ng.$log
       * 
       * @description
       * Write a debug message
       */
      debug: (function () {
    	var fn = consoleLog('debug');
    	
    	return function() {
    		if (debug) {
    			fn.apply(self, arguments);
    		}
    	}
      }())
    };

    function formatError(arg) {
      if (arg instanceof Error) {
        if (arg.stack) {
          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
              ? 'Error: ' + arg.message + '\n' + arg.stack
              : arg.stack;
        } else if (arg.sourceURL) {
          arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
        }
      }
      return arg;
    }

    function consoleLog(type) {
      var console = $window.console || {},
          logFn = console[type] || console.log || noop;

      if (logFn.apply) {
        return function() {
          var args = [];
          forEach(arguments, function(arg) {
            args.push(formatError(arg));
          });
          return logFn.apply(console, args);
        };
      }

      // we are IE which either doesn't have window.console => this is noop and we do nothing,
      // or we are IE where console.log doesn't have apply so we log at least first 2 args
      return function(arg1, arg2) {
        logFn(arg1, arg2);
      }
    }
  }];
}

var $parseMinErr = minErr('$parse');

// Sandboxing Angular Expressions
// ------------------------------
// Angular expressions are generally considered safe because these expressions only have direct access to $scope and
// locals. However, one can obtain the ability to execute arbitrary JS code by obtaining a reference to native JS
// functions such as the Function constructor.
//
// As an example, consider the following Angular expression:
//
//   {}.toString.constructor(alert("evil JS code"))
//
// We want to prevent this type of access. For the sake of performance, during the lexing phase we disallow any "dotted"
// access to any member named "constructor".
//
// For reflective calls (a[b]) we check that the value of the lookup is not the Function constructor while evaluating
// the expression, which is a stronger but more expensive test. Since reflective calls are expensive anyway, this is not
// such a big deal compared to static dereferencing.
//
// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits against the
// expression language, but not to prevent exploits that were enabled by exposing sensitive JavaScript or browser apis
// on Scope. Exposing such objects on a Scope is never a good practice and therefore we are not even trying to protect
// against interaction with an object explicitly exposed in this way.
//
// A developer could foil the name check by aliasing the Function constructor under a different name on the scope.
//
// In general, it is not possible to access a Window object from an angular expression unless a window or some DOM
// object that has a reference to window is published onto a Scope.

function ensureSafeMemberName(name, fullExpression) {
  if (name === "constructor") {
    throw $parseMinErr('isecfld',
        'Referencing "constructor" field in Angular expressions is disallowed! Expression: {0}', fullExpression);
  }
  return name;
};

function ensureSafeObject(obj, fullExpression) {
  // nifty check if obj is Function that is fast and works across iframes and other contexts
  if (obj && obj.constructor === obj) {
    throw $parseMinErr('isecfn',
        'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
  } else {
    return obj;
  }
}


var OPERATORS = {
    'null':function(){return null;},
    'true':function(){return true;},
    'false':function(){return false;},
    undefined:noop,
    '+':function(self, locals, a,b){
      a=a(self, locals); b=b(self, locals);
      if (isDefined(a)) {
        if (isDefined(b)) {
          return a + b;
        }
        return a;
      }
      return isDefined(b)?b:undefined;},
    '-':function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)-(isDefined(b)?b:0);},
    '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);},
    '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);},
    '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);},
    '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);},
    '=':noop,
    '===':function(self, locals, a, b){return a(self, locals)===b(self, locals);},
    '!==':function(self, locals, a, b){return a(self, locals)!==b(self, locals);},
    '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);},
    '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);},
    '<':function(self, locals, a,b){return a(self, locals)<b(self, locals);},
    '>':function(self, locals, a,b){return a(self, locals)>b(self, locals);},
    '<=':function(self, locals, a,b){return a(self, locals)<=b(self, locals);},
    '>=':function(self, locals, a,b){return a(self, locals)>=b(self, locals);},
    '&&':function(self, locals, a,b){return a(self, locals)&&b(self, locals);},
    '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);},
    '&':function(self, locals, a,b){return a(self, locals)&b(self, locals);},
//    '|':function(self, locals, a,b){return a|b;},
    '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},
    '!':function(self, locals, a){return !a(self, locals);}
};
var ESCAPE = {"n":"\n", "f":"\f", "r":"\r", "t":"\t", "v":"\v", "'":"'", '"':'"'};

function lex(text, csp){
  var tokens = [],
      token,
      index = 0,
      json = [],
      ch,
      lastCh = ':'; // can start regexp

  while (index < text.length) {
    ch = text.charAt(index);
    if (is('"\'')) {
      readString(ch);
    } else if (isNumber(ch) || is('.') && isNumber(peek())) {
      readNumber();
    } else if (isIdent(ch)) {
      readIdent();
      // identifiers can only be if the preceding char was a { or ,
      if (was('{,') && json[0]=='{' &&
         (token=tokens[tokens.length-1])) {
        token.json = token.text.indexOf('.') == -1;
      }
    } else if (is('(){}[].,;:?')) {
      tokens.push({
        index:index,
        text:ch,
        json:(was(':[,') && is('{[')) || is('}]:,')
      });
      if (is('{[')) json.unshift(ch);
      if (is('}]')) json.shift();
      index++;
    } else if (isWhitespace(ch)) {
      index++;
      continue;
    } else {
      var ch2 = ch + peek(),
          ch3 = ch2 + peek(2),
          fn = OPERATORS[ch],
          fn2 = OPERATORS[ch2],
          fn3 = OPERATORS[ch3];
      if (fn3) {
        tokens.push({index:index, text:ch3, fn:fn3});
        index += 3;
      } else if (fn2) {
        tokens.push({index:index, text:ch2, fn:fn2});
        index += 2;
      } else if (fn) {
        tokens.push({index:index, text:ch, fn:fn, json: was('[,:') && is('+-')});
        index += 1;
      } else {
        throwError("Unexpected next character ", index, index+1);
      }
    }
    lastCh = ch;
  }
  return tokens;

  function is(chars) {
    return chars.indexOf(ch) != -1;
  }

  function was(chars) {
    return chars.indexOf(lastCh) != -1;
  }

  function peek(i) {
    var num = i || 1;
    return index + num < text.length ? text.charAt(index + num) : false;
  }
  function isNumber(ch) {
    return '0' <= ch && ch <= '9';
  }
  function isWhitespace(ch) {
    return ch == ' ' || ch == '\r' || ch == '\t' ||
           ch == '\n' || ch == '\v' || ch == '\u00A0'; // IE treats non-breaking space as \u00A0
  }
  function isIdent(ch) {
    return 'a' <= ch && ch <= 'z' ||
           'A' <= ch && ch <= 'Z' ||
           '_' == ch || ch == '$';
  }
  function isExpOperator(ch) {
    return ch == '-' || ch == '+' || isNumber(ch);
  }

  function throwError(error, start, end) {
    end = end || index;
    var colStr = (isDefined(start) ?
        "s " + start +  "-" + index + " [" + text.substring(start, end) + "]"
        : " " + end);
    throw $parseMinErr('lexerr', "Lexer Error: {0} at column{1} in expression [{2}].",
        error, colStr, text);
  }

  function readNumber() {
    var number = "";
    var start = index;
    while (index < text.length) {
      var ch = lowercase(text.charAt(index));
      if (ch == '.' || isNumber(ch)) {
        number += ch;
      } else {
        var peekCh = peek();
        if (ch == 'e' && isExpOperator(peekCh)) {
          number += ch;
        } else if (isExpOperator(ch) &&
            peekCh && isNumber(peekCh) &&
            number.charAt(number.length - 1) == 'e') {
          number += ch;
        } else if (isExpOperator(ch) &&
            (!peekCh || !isNumber(peekCh)) &&
            number.charAt(number.length - 1) == 'e') {
          throwError('Invalid exponent');
        } else {
          break;
        }
      }
      index++;
    }
    number = 1 * number;
    tokens.push({index:start, text:number, json:true,
      fn:function() {return number;}});
  }
  function readIdent() {
    var ident = "",
        start = index,
        lastDot, peekIndex, methodName, ch;

    while (index < text.length) {
      ch = text.charAt(index);
      if (ch == '.' || isIdent(ch) || isNumber(ch)) {
        if (ch == '.') lastDot = index;
        ident += ch;
      } else {
        break;
      }
      index++;
    }

    //check if this is not a method invocation and if it is back out to last dot
    if (lastDot) {
      peekIndex = index;
      while(peekIndex < text.length) {
        ch = text.charAt(peekIndex);
        if (ch == '(') {
          methodName = ident.substr(lastDot - start + 1);
          ident = ident.substr(0, lastDot - start);
          index = peekIndex;
          break;
        }
        if(isWhitespace(ch)) {
          peekIndex++;
        } else {
          break;
        }
      }
    }


    var token = {
      index:start,
      text:ident
    };

    if (OPERATORS.hasOwnProperty(ident)) {
      token.fn = token.json = OPERATORS[ident];
    } else {
      var getter = getterFn(ident, csp, text);
      token.fn = extend(function(self, locals) {
        return (getter(self, locals));
      }, {
        assign: function(self, value) {
          return setter(self, ident, value, text);
        }
      });
    }

    tokens.push(token);

    if (methodName) {
      tokens.push({
        index:lastDot,
        text: '.',
        json: false
      });
      tokens.push({
        index: lastDot + 1,
        text: methodName,
        json: false
      });
    }
  }

  function readString(quote) {
    var start = index;
    index++;
    var string = "";
    var rawString = quote;
    var escape = false;
    while (index < text.length) {
      var ch = text.charAt(index);
      rawString += ch;
      if (escape) {
        if (ch == 'u') {
          var hex = text.substring(index + 1, index + 5);
          if (!hex.match(/[\da-f]{4}/i))
            throwError( "Invalid unicode escape [\\u" + hex + "]");
          index += 4;
          string += String.fromCharCode(parseInt(hex, 16));
        } else {
          var rep = ESCAPE[ch];
          if (rep) {
            string += rep;
          } else {
            string += ch;
          }
        }
        escape = false;
      } else if (ch == '\\') {
        escape = true;
      } else if (ch == quote) {
        index++;
        tokens.push({
          index:start,
          text:rawString,
          string:string,
          json:true,
          fn:function() { return string; }
        });
        return;
      } else {
        string += ch;
      }
      index++;
    }
    throwError("Unterminated quote", start);
  }
}

/////////////////////////////////////////

function parser(text, json, $filter, csp){
  var ZERO = valueFn(0),
      value,
      tokens = lex(text, csp),
      assignment = _assignment,
      functionCall = _functionCall,
      fieldAccess = _fieldAccess,
      objectIndex = _objectIndex,
      filterChain = _filterChain;

  if(json){
    // The extra level of aliasing is here, just in case the lexer misses something, so that
    // we prevent any accidental execution in JSON.
    assignment = logicalOR;
    functionCall =
      fieldAccess =
      objectIndex =
      filterChain =
        function() { throwError("is not valid json", {text:text, index:0}); };
    value = primary();
  } else {
    value = statements();
  }
  if (tokens.length !== 0) {
    throwError("is an unexpected token", tokens[0]);
  }
  value.literal = !!value.literal;
  value.constant = !!value.constant;
  return value;

  ///////////////////////////////////
  function throwError(msg, token) {
    throw $parseMinErr('syntax',
        "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].",
        token.text, msg, (token.index + 1), text, text.substring(token.index));
  }

  function peekToken() {
    if (tokens.length === 0)
      throw $parseMinErr('ueoe', "Unexpected end of expression: {0}", text);
    return tokens[0];
  }

  function peek(e1, e2, e3, e4) {
    if (tokens.length > 0) {
      var token = tokens[0];
      var t = token.text;
      if (t==e1 || t==e2 || t==e3 || t==e4 ||
          (!e1 && !e2 && !e3 && !e4)) {
        return token;
      }
    }
    return false;
  }

  function expect(e1, e2, e3, e4){
    var token = peek(e1, e2, e3, e4);
    if (token) {
      if (json && !token.json) {
        throwError("is not valid json", token);
      }
      tokens.shift();
      return token;
    }
    return false;
  }

  function consume(e1){
    if (!expect(e1)) {
      throwError("is unexpected, expecting [" + e1 + "]", peek());
    }
  }

  function unaryFn(fn, right) {
    return extend(function(self, locals) {
      return fn(self, locals, right);
    }, {
      constant:right.constant
    });
  }

  function ternaryFn(left, middle, right){
    return extend(function(self, locals){
      return left(self, locals) ? middle(self, locals) : right(self, locals);
    }, {
      constant: left.constant && middle.constant && right.constant
    });
  }

  function binaryFn(left, fn, right) {
    return extend(function(self, locals) {
      return fn(self, locals, left, right);
    }, {
      constant:left.constant && right.constant
    });
  }

  function statements() {
    var statements = [];
    while(true) {
      if (tokens.length > 0 && !peek('}', ')', ';', ']'))
        statements.push(filterChain());
      if (!expect(';')) {
        // optimize for the common case where there is only one statement.
        // TODO(size): maybe we should not support multiple statements?
        return statements.length == 1
          ? statements[0]
          : function(self, locals){
            var value;
            for ( var i = 0; i < statements.length; i++) {
              var statement = statements[i];
              if (statement)
                value = statement(self, locals);
            }
            return value;
          };
      }
    }
  }

  function _filterChain() {
    var left = expression();
    var token;
    while(true) {
      if ((token = expect('|'))) {
        left = binaryFn(left, token.fn, filter());
      } else {
        return left;
      }
    }
  }

  function filter() {
    var token = expect();
    var fn = $filter(token.text);
    var argsFn = [];
    while(true) {
      if ((token = expect(':'))) {
        argsFn.push(expression());
      } else {
        var fnInvoke = function(self, locals, input){
          var args = [input];
          for ( var i = 0; i < argsFn.length; i++) {
            args.push(argsFn[i](self, locals));
          }
          return fn.apply(self, args);
        };
        return function() {
          return fnInvoke;
        };
      }
    }
  }

  function expression() {
    return assignment();
  }

  function _assignment() {
    var left = ternary();
    var right;
    var token;
    if ((token = expect('='))) {
      if (!left.assign) {
        throwError("implies assignment but [" +
          text.substring(0, token.index) + "] can not be assigned to", token);
      }
      right = ternary();
      return function(scope, locals){
        return left.assign(scope, right(scope, locals), locals);
      };
    } else {
      return left;
    }
  }

  function ternary() {
    var left = logicalOR();
    var middle;
    var token;
    if((token = expect('?'))){
      middle = ternary();
      if((token = expect(':'))){
        return ternaryFn(left, middle, ternary());
      }
      else {
        throwError('expected :', token);
      }
    }
    else {
      return left;
    }
  }

  function logicalOR() {
    var left = logicalAND();
    var token;
    while(true) {
      if ((token = expect('||'))) {
        left = binaryFn(left, token.fn, logicalAND());
      } else {
        return left;
      }
    }
  }

  function logicalAND() {
    var left = equality();
    var token;
    if ((token = expect('&&'))) {
      left = binaryFn(left, token.fn, logicalAND());
    }
    return left;
  }

  function equality() {
    var left = relational();
    var token;
    if ((token = expect('==','!=','===','!=='))) {
      left = binaryFn(left, token.fn, equality());
    }
    return left;
  }

  function relational() {
    var left = additive();
    var token;
    if ((token = expect('<', '>', '<=', '>='))) {
      left = binaryFn(left, token.fn, relational());
    }
    return left;
  }

  function additive() {
    var left = multiplicative();
    var token;
    while ((token = expect('+','-'))) {
      left = binaryFn(left, token.fn, multiplicative());
    }
    return left;
  }

  function multiplicative() {
    var left = unary();
    var token;
    while ((token = expect('*','/','%'))) {
      left = binaryFn(left, token.fn, unary());
    }
    return left;
  }

  function unary() {
    var token;
    if (expect('+')) {
      return primary();
    } else if ((token = expect('-'))) {
      return binaryFn(ZERO, token.fn, unary());
    } else if ((token = expect('!'))) {
      return unaryFn(token.fn, unary());
    } else {
      return primary();
    }
  }


  function primary() {
    var primary;
    if (expect('(')) {
      primary = filterChain();
      consume(')');
    } else if (expect('[')) {
      primary = arrayDeclaration();
    } else if (expect('{')) {
      primary = object();
    } else {
      var token = expect();
      primary = token.fn;
      if (!primary) {
        throwError("not a primary expression", token);
      }
      if (token.json) {
        primary.constant = primary.literal = true;
      }
    }

    var next, context;
    while ((next = expect('(', '[', '.'))) {
      if (next.text === '(') {
        primary = functionCall(primary, context);
        context = null;
      } else if (next.text === '[') {
        context = primary;
        primary = objectIndex(primary);
      } else if (next.text === '.') {
        context = primary;
        primary = fieldAccess(primary);
      } else {
        throwError("IMPOSSIBLE");
      }
    }
    return primary;
  }

  function _fieldAccess(object) {
    var field = expect().text;
    var getter = getterFn(field, csp, text);
    return extend(
        function(scope, locals, self) {
          return getter(self || object(scope, locals), locals);
        },
        {
          assign:function(scope, value, locals) {
            return setter(object(scope, locals), field, value, text);
          }
        }
    );
  }

  function _objectIndex(obj) {
    var indexFn = expression();
    consume(']');
    return extend(
      function(self, locals){
        var o = obj(self, locals),
            i = indexFn(self, locals),
            v, p;

        if (!o) return undefined;
        v = ensureSafeObject(o[i], text);
        if (v && v.then) {
          p = v;
          if (!('$$v' in v)) {
            p.$$v = undefined;
            p.then(function(val) { p.$$v = val; });
          }
          v = v.$$v;
        }
        return v;
      }, {
        assign:function(self, value, locals){
          var key = indexFn(self, locals);
          // prevent overwriting of Function.constructor which would break ensureSafeObject check
          return ensureSafeObject(obj(self, locals), text)[key] = value;
        }
      });
  }

  function _functionCall(fn, contextGetter) {
    var argsFn = [];
    if (peekToken().text != ')') {
      do {
        argsFn.push(expression());
      } while (expect(','));
    }
    consume(')');
    return function(scope, locals){
      var args = [],
          context = contextGetter ? contextGetter(scope, locals) : scope;

      for ( var i = 0; i < argsFn.length; i++) {
        args.push(argsFn[i](scope, locals));
      }
      var fnPtr = fn(scope, locals, context) || noop;
      // IE stupidity!
      var v = fnPtr.apply
          ? fnPtr.apply(context, args)
          : fnPtr(args[0], args[1], args[2], args[3], args[4]);

      // Check for promise
      if (v && v.then) {
        var p = v;
        if (!('$$v' in v)) {
          p.$$v = undefined;
          p.then(function(val) { p.$$v = val; });
        }
        v = v.$$v;
      }

      return v;
    };
  }

  // This is used with json array declaration
  function arrayDeclaration () {
    var elementFns = [];
    var allConstant = true;
    if (peekToken().text != ']') {
      do {
        var elementFn = expression();
        elementFns.push(elementFn);
        if (!elementFn.constant) {
          allConstant = false;
        }
      } while (expect(','));
    }
    consume(']');
    return extend(function(self, locals){
      var array = [];
      for ( var i = 0; i < elementFns.length; i++) {
        array.push(elementFns[i](self, locals));
      }
      return array;
    }, {
      literal:true,
      constant:allConstant
    });
  }

  function object () {
    var keyValues = [];
    var allConstant = true;
    if (peekToken().text != '}') {
      do {
        var token = expect(),
        key = token.string || token.text;
        consume(":");
        var value = expression();
        keyValues.push({key:key, value:value});
        if (!value.constant) {
          allConstant = false;
        }
      } while (expect(','));
    }
    consume('}');
    return extend(function(self, locals){
      var object = {};
      for ( var i = 0; i < keyValues.length; i++) {
        var keyValue = keyValues[i];
        object[keyValue.key] = keyValue.value(self, locals);
      }
      return object;
    }, {
      literal:true,
      constant:allConstant
    });
  }
}

//////////////////////////////////////////////////
// Parser helper functions
//////////////////////////////////////////////////

function setter(obj, path, setValue, fullExp) {
  var element = path.split('.'), key;
  for (var i = 0; element.length > 1; i++) {
    key = ensureSafeMemberName(element.shift(), fullExp);
    var propertyObj = obj[key];
    if (!propertyObj) {
      propertyObj = {};
      obj[key] = propertyObj;
    }
    obj = propertyObj;
    if (obj.then) {
      if (!("$$v" in obj)) {
        (function(promise) {
          promise.then(function(val) { promise.$$v = val; }); }
        )(obj);
      }
      if (obj.$$v === undefined) {
        obj.$$v = {};
      }
      obj = obj.$$v;
    }
  }
  key = ensureSafeMemberName(element.shift(), fullExp);
  obj[key] = setValue;
  return setValue;
}

var getterFnCache = {};

/**
 * Implementation of the "Black Hole" variant from:
 * - http://jsperf.com/angularjs-parse-getter/4
 * - http://jsperf.com/path-evaluation-simplified/7
 */
function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp) {
  ensureSafeMemberName(key0, fullExp);
  ensureSafeMemberName(key1, fullExp);
  ensureSafeMemberName(key2, fullExp);
  ensureSafeMemberName(key3, fullExp);
  ensureSafeMemberName(key4, fullExp);
  return function(scope, locals) {
    var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope,
        promise;

    if (pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key0];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key1 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key1];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key2 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key2];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key3 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key3];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key4 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key4];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    return pathVal;
  };
}

function getterFn(path, csp, fullExp) {
  if (getterFnCache.hasOwnProperty(path)) {
    return getterFnCache[path];
  }

  var pathKeys = path.split('.'),
      pathKeysLength = pathKeys.length,
      fn;

  if (csp) {
    fn = (pathKeysLength < 6)
        ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp)
        : function(scope, locals) {
          var i = 0, val;
          do {
            val = cspSafeGetterFn(
                    pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp
                  )(scope, locals);

            locals = undefined; // clear after first iteration
            scope = val;
          } while (i < pathKeysLength);
          return val;
        }
  } else {
    var code = 'var l, fn, p;\n';
    forEach(pathKeys, function(key, index) {
      ensureSafeMemberName(key, fullExp);
      code += 'if(s === null || s === undefined) return s;\n' +
              'l=s;\n' +
              's='+ (index
                      // we simply dereference 's' on any .dot notation
                      ? 's'
                      // but if we are first then we check locals first, and if so read it first
                      : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' +
              'if (s && s.then) {\n' +
                ' if (!("$$v" in s)) {\n' +
                  ' p=s;\n' +
                  ' p.$$v = undefined;\n' +
                  ' p.then(function(v) {p.$$v=v;});\n' +
                  '}\n' +
                ' s=s.$$v\n' +
              '}\n';
    });
    code += 'return s;';
    fn = Function('s', 'k', code); // s=scope, k=locals
    fn.toString = function() { return code; };
  }

  return getterFnCache[path] = fn;
}

///////////////////////////////////

/**
 * @ngdoc function
 * @name ng.$parse
 * @function
 *
 * @description
 *
 * Converts Angular {@link guide/expression expression} into a function.
 *
 * <pre>
 *   var getter = $parse('user.name');
 *   var setter = getter.assign;
 *   var context = {user:{name:'angular'}};
 *   var locals = {user:{name:'local'}};
 *
 *   expect(getter(context)).toEqual('angular');
 *   setter(context, 'newValue');
 *   expect(context.user.name).toEqual('newValue');
 *   expect(getter(context, locals)).toEqual('local');
 * </pre>
 *
 *
 * @param {string} expression String expression to compile.
 * @returns {function(context, locals)} a function which represents the compiled expression:
 *
 *    * `context`  `{object}`  an object against which any expressions embedded in the strings
 *      are evaluated against (typically a scope object).
 *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
 *      `context`.
 *
 *    The returned function also has the following properties:
 *      * `literal`  `{boolean}`  whether the expression's top-level node is a JavaScript
 *        literal.
 *      * `constant`  `{boolean}`  whether the expression is made entirely of JavaScript
 *        constant literals.
 *      * `assign`  `{?function(context, value)}`  if the expression is assignable, this will be
 *        set to a function to change its value on the given context.
 *
 */
function $ParseProvider() {
  var cache = {};
  this.$get = ['$filter', '$sniffer', function($filter, $sniffer) {
    return function(exp) {
      switch(typeof exp) {
        case 'string':
          return cache.hasOwnProperty(exp)
            ? cache[exp]
            : cache[exp] =  parser(exp, false, $filter, $sniffer.csp);
        case 'function':
          return exp;
        default:
          return noop;
      }
    };
  }];
}

/**
 * @ngdoc service
 * @name ng.$q
 * @requires $rootScope
 *
 * @description
 * A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).
 *
 * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
 * interface for interacting with an object that represents the result of an action that is
 * performed asynchronously, and may or may not be finished at any given point in time.
 *
 * From the perspective of dealing with error handling, deferred and promise APIs are to
 * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.
 *
 * <pre>
 *   // for the purpose of this example let's assume that variables `$q` and `scope` are
 *   // available in the current lexical scope (they could have been injected or passed in).
 *
 *   function asyncGreet(name) {
 *     var deferred = $q.defer();
 *
 *     setTimeout(function() {
 *       // since this fn executes async in a future turn of the event loop, we need to wrap
 *       // our code into an $apply call so that the model changes are properly observed.
 *       scope.$apply(function() {
 *         deferred.notify('About to greet ' + name + '.');
 *
 *         if (okToGreet(name)) {
 *           deferred.resolve('Hello, ' + name + '!');
 *         } else {
 *           deferred.reject('Greeting ' + name + ' is not allowed.');
 *         }
 *       });
 *     }, 1000);
 *
 *     return deferred.promise;
 *   }
 *
 *   var promise = asyncGreet('Robin Hood');
 *   promise.then(function(greeting) {
 *     alert('Success: ' + greeting);
 *   }, function(reason) {
 *     alert('Failed: ' + reason);
 *   }, function(update) {
 *     alert('Got notification: ' + update);
 *   });
 * </pre>
 *
 * At first it might not be obvious why this extra complexity is worth the trouble. The payoff
 * comes in the way of
 * [guarantees that promise and deferred APIs make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).
 *
 * Additionally the promise api allows for composition that is very hard to do with the
 * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.
 * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the
 * section on serial or parallel joining of promises.
 *
 *
 * # The Deferred API
 *
 * A new instance of deferred is constructed by calling `$q.defer()`.
 *
 * The purpose of the deferred object is to expose the associated Promise instance as well as APIs
 * that can be used for signaling the successful or unsuccessful completion, as well as the status
 * of the task.
 *
 * **Methods**
 *
 * - `resolve(value)`  resolves the derived promise with the `value`. If the value is a rejection
 *   constructed via `$q.reject`, the promise will be rejected instead.
 * - `reject(reason)`  rejects the derived promise with the `reason`. This is equivalent to
 *   resolving it with a rejection constructed via `$q.reject`.
 * - `notify(value)` - provides updates on the status of the promises execution. This may be called
 *   multiple times before the promise is either resolved or rejected.
 *
 * **Properties**
 *
 * - promise  `{Promise}`  promise object associated with this deferred.
 *
 *
 * # The Promise API
 *
 * A new promise instance is created when a deferred instance is created and can be retrieved by
 * calling `deferred.promise`.
 *
 * The purpose of the promise object is to allow for interested parties to get access to the result
 * of the deferred task when it completes.
 *
 * **Methods**
 *
 * - `then(successCallback, errorCallback, notifyCallback)`  regardless of when the promise was or
 *   will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously
 *   as soon as the result is available. The callbacks are called with a single argument: the result
 *   or rejection reason. Additionally, the notify callback may be called zero or more times to
 *   provide a progress indication, before the promise is resolved or rejected.
 *
 *   This method *returns a new promise* which is resolved or rejected via the return value of the
 *   `successCallback`, `errorCallback`. It also notifies via the return value of the `notifyCallback`
 *   method. The promise can not be resolved or rejected from the notifyCallback method.
 *
 * - `catch(errorCallback)`  shorthand for `promise.then(null, errorCallback)`
 *
 * - `finally(callback)`  allows you to observe either the fulfillment or rejection of a promise,
 *   but to do so without modifying the final value. This is useful to release resources or do some
 *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full
 *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for
 *   more information.
 *
 *   Because `finally` is a reserved word in JavaScript and reserved keywords are not supported as
 *   property names by ES3, you'll need to invoke the method like `promise['finally'](callback)` to
 *   make your code IE8 compatible.
 *
 * # Chaining promises
 *
 * Because calling the `then` method of a promise returns a new derived promise, it is easily possible
 * to create a chain of promises:
 *
 * <pre>
 *   promiseB = promiseA.then(function(result) {
 *     return result + 1;
 *   });
 *
 *   // promiseB will be resolved immediately after promiseA is resolved and its value
 *   // will be the result of promiseA incremented by 1
 * </pre>
 *
 * It is possible to create chains of any length and since a promise can be resolved with another
 * promise (which will defer its resolution further), it is possible to pause/defer resolution of
 * the promises at any point in the chain. This makes it possible to implement powerful APIs like
 * $http's response interceptors.
 *
 *
 * # Differences between Kris Kowal's Q and $q
 *
 *  There are three main differences:
 *
 * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation
 *   mechanism in angular, which means faster propagation of resolution or rejection into your
 *   models and avoiding unnecessary browser repaints, which would result in flickering UI.
 * - $q promises are recognized by the templating engine in angular, which means that in templates
 *   you can treat promises attached to a scope as if they were the resulting values.
 * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains
 *   all the important functionality needed for common async tasks.
 *
 *  # Testing
 *
 *  <pre>
 *    it('should simulate promise', inject(function($q, $rootScope) {
 *      var deferred = $q.defer();
 *      var promise = deferred.promise;
 *      var resolvedValue;
 *
 *      promise.then(function(value) { resolvedValue = value; });
 *      expect(resolvedValue).toBeUndefined();
 *
 *      // Simulate resolving of promise
 *      deferred.resolve(123);
 *      // Note that the 'then' function does not get called synchronously.
 *      // This is because we want the promise API to always be async, whether or not
 *      // it got called synchronously or asynchronously.
 *      expect(resolvedValue).toBeUndefined();
 *
 *      // Propagate promise resolution to 'then' functions using $apply().
 *      $rootScope.$apply();
 *      expect(resolvedValue).toEqual(123);
 *    });
 *  </pre>
 */
function $QProvider() {

  this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
    return qFactory(function(callback) {
      $rootScope.$evalAsync(callback);
    }, $exceptionHandler);
  }];
}


/**
 * Constructs a promise manager.
 *
 * @param {function(function)} nextTick Function for executing functions in the next turn.
 * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
 *     debugging purposes.
 * @returns {object} Promise manager.
 */
function qFactory(nextTick, exceptionHandler) {

  /**
   * @ngdoc
   * @name ng.$q#defer
   * @methodOf ng.$q
   * @description
   * Creates a `Deferred` object which represents a task which will finish in the future.
   *
   * @returns {Deferred} Returns a new instance of deferred.
   */
  var defer = function() {
    var pending = [],
        value, deferred;

    deferred = {

      resolve: function(val) {
        if (pending) {
          var callbacks = pending;
          pending = undefined;
          value = ref(val);

          if (callbacks.length) {
            nextTick(function() {
              var callback;
              for (var i = 0, ii = callbacks.length; i < ii; i++) {
                callback = callbacks[i];
                value.then(callback[0], callback[1], callback[2]);
              }
            });
          }
        }
      },


      reject: function(reason) {
        deferred.resolve(reject(reason));
      },


      notify: function(progress) {
        if (pending) {
          var callbacks = pending;

          if (pending.length) {
            nextTick(function() {
              var callback;
              for (var i = 0, ii = callbacks.length; i < ii; i++) {
                callback = callbacks[i];
                callback[2](progress);
              }
            });
          }
        }
      },


      promise: {
        then: function(callback, errback, progressback) {
          var result = defer();

          var wrappedCallback = function(value) {
            try {
              result.resolve((isFunction(callback) ? callback : defaultCallback)(value));
            } catch(e) {
              result.reject(e);
              exceptionHandler(e);
            }
          };

          var wrappedErrback = function(reason) {
            try {
              result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
            } catch(e) {
              result.reject(e);
              exceptionHandler(e);
            }
          };

          var wrappedProgressback = function(progress) {
            try {
              result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress));
            } catch(e) {
              exceptionHandler(e);
            }
          };

          if (pending) {
            pending.push([wrappedCallback, wrappedErrback, wrappedProgressback]);
          } else {
            value.then(wrappedCallback, wrappedErrback, wrappedProgressback);
          }

          return result.promise;
        },

        "catch": function(callback) {
          return this.then(null, callback);
        },

        "finally": function(callback) {

          function makePromise(value, resolved) {
            var result = defer();
            if (resolved) {
              result.resolve(value);
            } else {
              result.reject(value);
            }
            return result.promise;
          }

          function handleCallback(value, isResolved) {
            var callbackOutput = null;
            try {
              callbackOutput = (callback ||defaultCallback)();
            } catch(e) {
              return makePromise(e, false);
            }
            if (callbackOutput && isFunction(callbackOutput.then)) {
              return callbackOutput.then(function() {
                return makePromise(value, isResolved);
              }, function(error) {
                return makePromise(error, false);
              });
            } else {
              return makePromise(value, isResolved);
            }
          }

          return this.then(function(value) {
            return handleCallback(value, true);
          }, function(error) {
            return handleCallback(error, false);
          });
        }
      }
    };

    return deferred;
  };


  var ref = function(value) {
    if (value && isFunction(value.then)) return value;
    return {
      then: function(callback) {
        var result = defer();
        nextTick(function() {
          result.resolve(callback(value));
        });
        return result.promise;
      }
    };
  };


  /**
   * @ngdoc
   * @name ng.$q#reject
   * @methodOf ng.$q
   * @description
   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be
   * used to forward rejection in a chain of promises. If you are dealing with the last promise in
   * a promise chain, you don't need to worry about it.
   *
   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of
   * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via
   * a promise error callback and you want to forward the error to the promise derived from the
   * current promise, you have to "rethrow" the error by returning a rejection constructed via
   * `reject`.
   *
   * <pre>
   *   promiseB = promiseA.then(function(result) {
   *     // success: do something and resolve promiseB
   *     //          with the old or a new result
   *     return result;
   *   }, function(reason) {
   *     // error: handle the error if possible and
   *     //        resolve promiseB with newPromiseOrValue,
   *     //        otherwise forward the rejection to promiseB
   *     if (canHandle(reason)) {
   *      // handle the error and recover
   *      return newPromiseOrValue;
   *     }
   *     return $q.reject(reason);
   *   });
   * </pre>
   *
   * @param {*} reason Constant, message, exception or an object representing the rejection reason.
   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.
   */
  var reject = function(reason) {
    return {
      then: function(callback, errback) {
        var result = defer();
        nextTick(function() {
          try {
            result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
          } catch(e) {
            result.reject(e);
            exceptionHandler(e);
          }
        });
        return result.promise;
      }
    };
  };


  /**
   * @ngdoc
   * @name ng.$q#when
   * @methodOf ng.$q
   * @description
   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.
   * This is useful when you are dealing with an object that might or might not be a promise, or if
   * the promise comes from a source that can't be trusted.
   *
   * @param {*} value Value or a promise
   * @returns {Promise} Returns a promise of the passed value or promise
   */
  var when = function(value, callback, errback, progressback) {
    var result = defer(),
        done;

    var wrappedCallback = function(value) {
      try {
        return (isFunction(callback) ? callback : defaultCallback)(value);
      } catch (e) {
        exceptionHandler(e);
        return reject(e);
      }
    };

    var wrappedErrback = function(reason) {
      try {
        return (isFunction(errback) ? errback : defaultErrback)(reason);
      } catch (e) {
        exceptionHandler(e);
        return reject(e);
      }
    };

    var wrappedProgressback = function(progress) {
      try {
        return (isFunction(progressback) ? progressback : defaultCallback)(progress);
      } catch (e) {
        exceptionHandler(e);
      }
    };

    nextTick(function() {
      ref(value).then(function(value) {
        if (done) return;
        done = true;
        result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback));
      }, function(reason) {
        if (done) return;
        done = true;
        result.resolve(wrappedErrback(reason));
      }, function(progress) {
        if (done) return;
        result.notify(wrappedProgressback(progress));
      });
    });

    return result.promise;
  };


  function defaultCallback(value) {
    return value;
  }


  function defaultErrback(reason) {
    return reject(reason);
  }


  /**
   * @ngdoc
   * @name ng.$q#all
   * @methodOf ng.$q
   * @description
   * Combines multiple promises into a single promise that is resolved when all of the input
   * promises are resolved.
   *
   * @param {Array.<Promise>|Object.<Promise>} promises An array or hash of promises.
   * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,
   *   each value corresponding to the promise at the same index/key in the `promises` array/hash. If any of
   *   the promises is resolved with a rejection, this resulting promise will be resolved with the
   *   same rejection.
   */
  function all(promises) {
    var deferred = defer(),
        counter = 0,
        results = isArray(promises) ? [] : {};

    forEach(promises, function(promise, key) {
      counter++;
      ref(promise).then(function(value) {
        if (results.hasOwnProperty(key)) return;
        results[key] = value;
        if (!(--counter)) deferred.resolve(results);
      }, function(reason) {
        if (results.hasOwnProperty(key)) return;
        deferred.reject(reason);
      });
    });

    if (counter === 0) {
      deferred.resolve(results);
    }

    return deferred.promise;
  }

  return {
    defer: defer,
    reject: reject,
    when: when,
    all: all
  };
}

/**
 * DESIGN NOTES
 *
 * The design decisions behind the scope are heavily favored for speed and memory consumption.
 *
 * The typical use of scope is to watch the expressions, which most of the time return the same
 * value as last time so we optimize the operation.
 *
 * Closures construction is expensive in terms of speed as well as memory:
 *   - No closures, instead use prototypical inheritance for API
 *   - Internal state needs to be stored on scope directly, which means that private state is
 *     exposed as $$____ properties
 *
 * Loop operations are optimized by using while(count--) { ... }
 *   - this means that in order to keep the same order of execution as addition we have to add
 *     items to the array at the beginning (shift) instead of at the end (push)
 *
 * Child scopes are created and removed often
 *   - Using an array would be slow since inserts in middle are expensive so we use linked list
 *
 * There are few watches then a lot of observers. This is why you don't want the observer to be
 * implemented in the same way as watch. Watch requires return of initialization function which
 * are expensive to construct.
 */


/**
 * @ngdoc object
 * @name ng.$rootScopeProvider
 * @description
 *
 * Provider for the $rootScope service.
 */

/**
 * @ngdoc function
 * @name ng.$rootScopeProvider#digestTtl
 * @methodOf ng.$rootScopeProvider
 * @description
 *
 * Sets the number of digest iterations the scope should attempt to execute before giving up and
 * assuming that the model is unstable.
 *
 * The current default is 10 iterations.
 *
 * @param {number} limit The number of digest iterations.
 */


/**
 * @ngdoc object
 * @name ng.$rootScope
 * @description
 *
 * Every application has a single root {@link ng.$rootScope.Scope scope}.
 * All other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide
 * event processing life-cycle. See {@link guide/scope developer guide on scopes}.
 */
function $RootScopeProvider(){
  var TTL = 10;
  var $rootScopeMinErr = minErr('$rootScope');

  this.digestTtl = function(value) {
    if (arguments.length) {
      TTL = value;
    }
    return TTL;
  };

  this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser',
      function( $injector,   $exceptionHandler,   $parse,   $browser) {

    /**
     * @ngdoc function
     * @name ng.$rootScope.Scope
     *
     * @description
     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the
     * {@link AUTO.$injector $injector}. Child scopes are created using the
     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when
     * compiled HTML template is executed.)
     *
     * Here is a simple scope snippet to show how you can interact with the scope.
     * <pre>
     * <file src="./test/ng/rootScopeSpec.js" tag="docs1" />
     * </pre>
     *
     * # Inheritance
     * A scope can inherit from a parent scope, as in this example:
     * <pre>
         var parent = $rootScope;
         var child = parent.$new();

         parent.salutation = "Hello";
         child.name = "World";
         expect(child.salutation).toEqual('Hello');

         child.salutation = "Welcome";
         expect(child.salutation).toEqual('Welcome');
         expect(parent.salutation).toEqual('Hello');
     * </pre>
     *
     *
     * @param {Object.<string, function()>=} providers Map of service factory which need to be provided
     *     for the current scope. Defaults to {@link ng}.
     * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should
     *     append/override services provided by `providers`. This is handy when unit-testing and having
     *     the need to override a default service.
     * @returns {Object} Newly created scope.
     *
     */
    function Scope() {
      this.$id = nextUid();
      this.$$phase = this.$parent = this.$$watchers =
                     this.$$nextSibling = this.$$prevSibling =
                     this.$$childHead = this.$$childTail = null;
      this['this'] = this.$root =  this;
      this.$$destroyed = false;
      this.$$asyncQueue = [];
      this.$$postDigestQueue = [];
      this.$$listeners = {};
      this.$$isolateBindings = {};
    }

    /**
     * @ngdoc property
     * @name ng.$rootScope.Scope#$id
     * @propertyOf ng.$rootScope.Scope
     * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for
     *   debugging.
     */


    Scope.prototype = {
      constructor: Scope,
      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$new
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Creates a new child {@link ng.$rootScope.Scope scope}.
       *
       * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} and
       * {@link ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the scope
       * hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.
       *
       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is desired for
       * the scope and its child scopes to be permanently detached from the parent and thus stop
       * participating in model change detection and listener notification by invoking.
       *
       * @param {boolean} isolate if true then the scope does not prototypically inherit from the
       *         parent scope. The scope is isolated, as it can not see parent scope properties.
       *         When creating widgets it is useful for the widget to not accidentally read parent
       *         state.
       *
       * @returns {Object} The newly created child scope.
       *
       */
      $new: function(isolate) {
        var Child,
            child;

        if (isolate) {
          child = new Scope();
          child.$root = this.$root;
          // ensure that there is just one async queue per $rootScope and it's children
          child.$$asyncQueue = this.$$asyncQueue;
          child.$$postDigestQueue = this.$$postDigestQueue;
        } else {
          Child = function() {}; // should be anonymous; This is so that when the minifier munges
            // the name it does not become random set of chars. These will then show up as class
            // name in the debugger.
          Child.prototype = this;
          child = new Child();
          child.$id = nextUid();
        }
        child['this'] = child;
        child.$$listeners = {};
        child.$parent = this;
        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
        child.$$prevSibling = this.$$childTail;
        if (this.$$childHead) {
          this.$$childTail.$$nextSibling = child;
          this.$$childTail = child;
        } else {
          this.$$childHead = this.$$childTail = child;
        }
        return child;
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$watch
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.
       *
       * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest $digest()} and
       *   should return the value which will be watched. (Since {@link ng.$rootScope.Scope#$digest $digest()}
       *   reruns when it detects changes the `watchExpression` can execute multiple times per
       *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)
       * - The `listener` is called only when the value from the current `watchExpression` and the
       *   previous call to `watchExpression` are not equal (with the exception of the initial run,
       *   see below). The inequality is determined according to
       *   {@link angular.equals} function. To save the value of the object for later comparison, the
       *   {@link angular.copy} function is used. It also means that watching complex options will
       *   have adverse memory and performance implications.
       * - The watch `listener` may change the model, which may trigger other `listener`s to fire. This
       *   is achieved by rerunning the watchers until no changes are detected. The rerun iteration
       *   limit is 10 to prevent an infinite loop deadlock.
       *
       *
       * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,
       * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`
       * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a change is
       * detected, be prepared for multiple calls to your listener.)
       *
       * After a watcher is registered with the scope, the `listener` fn is called asynchronously
       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the
       * watcher. In rare cases, this is undesirable because the listener is called when the result
       * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you
       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the
       * listener was called due to initialization.
       *
       *
       * # Example
       * <pre>
           // let's assume that scope was dependency injected as the $rootScope
           var scope = $rootScope;
           scope.name = 'misko';
           scope.counter = 0;

           expect(scope.counter).toEqual(0);
           scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; });
           expect(scope.counter).toEqual(0);

           scope.$digest();
           // no variable change
           expect(scope.counter).toEqual(0);

           scope.name = 'adam';
           scope.$digest();
           expect(scope.counter).toEqual(1);
       * </pre>
       *
       *
       *
       * @param {(function()|string)} watchExpression Expression that is evaluated on each
       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers a
       *    call to the `listener`.
       *
       *    - `string`: Evaluated as {@link guide/expression expression}
       *    - `function(scope)`: called with current `scope` as a parameter.
       * @param {(function()|string)=} listener Callback called whenever the return value of
       *   the `watchExpression` changes.
       *
       *    - `string`: Evaluated as {@link guide/expression expression}
       *    - `function(newValue, oldValue, scope)`: called with current and previous values as parameters.
       *
       * @param {boolean=} objectEquality Compare object for equality rather than for reference.
       * @returns {function()} Returns a deregistration function for this listener.
       */
      $watch: function(watchExp, listener, objectEquality) {
        var scope = this,
            get = compileToFn(watchExp, 'watch'),
            array = scope.$$watchers,
            watcher = {
              fn: listener,
              last: initWatchVal,
              get: get,
              exp: watchExp,
              eq: !!objectEquality
            };

        // in the case user pass string, we need to compile it, do we really need this ?
        if (!isFunction(listener)) {
          var listenFn = compileToFn(listener || noop, 'listener');
          watcher.fn = function(newVal, oldVal, scope) {listenFn(scope);};
        }

        if (typeof watchExp == 'string' && get.constant) {
          var originalFn = watcher.fn;
          watcher.fn = function(newVal, oldVal, scope) {
            originalFn.call(this, newVal, oldVal, scope);
            arrayRemove(array, watcher);
          };
        }

        if (!array) {
          array = scope.$$watchers = [];
        }
        // we use unshift since we use a while loop in $digest for speed.
        // the while loop reads in reverse order.
        array.unshift(watcher);

        return function() {
          arrayRemove(array, watcher);
        };
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$watchCollection
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Shallow watches the properties of an object and fires whenever any of the properties change
       * (for arrays this implies watching the array items, for object maps this implies watching the properties).
       * If a change is detected the `listener` callback is fired.
       *
       * - The `obj` collection is observed via standard $watch operation and is examined on every call to $digest() to
       *   see if any items have been added, removed, or moved.
       * - The `listener` is called whenever anything within the `obj` has changed. Examples include adding new items
       *   into the object or array, removing and moving items around.
       *
       *
       * # Example
       * <pre>
          $scope.names = ['igor', 'matias', 'misko', 'james'];
          $scope.dataCount = 4;

          $scope.$watchCollection('names', function(newNames, oldNames) {
            $scope.dataCount = newNames.length;
          });

          expect($scope.dataCount).toEqual(4);
          $scope.$digest();

          //still at 4 ... no changes
          expect($scope.dataCount).toEqual(4);

          $scope.names.pop();
          $scope.$digest();

          //now there's been a change
          expect($scope.dataCount).toEqual(3);
       * </pre>
       *
       *
       * @param {string|Function(scope)} obj Evaluated as {@link guide/expression expression}. The expression value
       *    should evaluate to an object or an array which is observed on each
       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the collection will trigger
       *    a call to the `listener`.
       *
       * @param {function(newCollection, oldCollection, scope)} listener a callback function that is fired with both
       *    the `newCollection` and `oldCollection` as parameters.
       *    The `newCollection` object is the newly modified data obtained from the `obj` expression and the
       *    `oldCollection` object is a copy of the former collection data.
       *    The `scope` refers to the current scope.
       *
       * @returns {function()} Returns a de-registration function for this listener. When the de-registration function is executed
       * then the internal watch operation is terminated.
       */
      $watchCollection: function(obj, listener) {
        var self = this;
        var oldValue;
        var newValue;
        var changeDetected = 0;
        var objGetter = $parse(obj);
        var internalArray = [];
        var internalObject = {};
        var oldLength = 0;

        function $watchCollectionWatch() {
          newValue = objGetter(self);
          var newLength, key;

          if (!isObject(newValue)) {
            if (oldValue !== newValue) {
              oldValue = newValue;
              changeDetected++;
            }
          } else if (isArrayLike(newValue)) {
            if (oldValue !== internalArray) {
              // we are transitioning from something which was not an array into array.
              oldValue = internalArray;
              oldLength = oldValue.length = 0;
              changeDetected++;
            }

            newLength = newValue.length;

            if (oldLength !== newLength) {
              // if lengths do not match we need to trigger change notification
              changeDetected++;
              oldValue.length = oldLength = newLength;
            }
            // copy the items to oldValue and look for changes.
            for (var i = 0; i < newLength; i++) {
              if (oldValue[i] !== newValue[i]) {
                changeDetected++;
                oldValue[i] = newValue[i];
              }
            }
          } else {
            if (oldValue !== internalObject) {
              // we are transitioning from something which was not an object into object.
              oldValue = internalObject = {};
              oldLength = 0;
              changeDetected++;
            }
            // copy the items to oldValue and look for changes.
            newLength = 0;
            for (key in newValue) {
              if (newValue.hasOwnProperty(key)) {
                newLength++;
                if (oldValue.hasOwnProperty(key)) {
                  if (oldValue[key] !== newValue[key]) {
                    changeDetected++;
                    oldValue[key] = newValue[key];
                  }
                } else {
                  oldLength++;
                  oldValue[key] = newValue[key];
                  changeDetected++;
                }
              }
            }
            if (oldLength > newLength) {
              // we used to have more keys, need to find them and destroy them.
              changeDetected++;
              for(key in oldValue) {
                if (oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key)) {
                  oldLength--;
                  delete oldValue[key];
                }
              }
            }
          }
          return changeDetected;
        }

        function $watchCollectionAction() {
          listener(newValue, oldValue, self);
        }

        return this.$watch($watchCollectionWatch, $watchCollectionAction);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$digest
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and its children.
       * Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change the model, the
       * `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers} until no more listeners are
       * firing. This means that it is possible to get into an infinite loop. This function will throw
       * `'Maximum iteration limit exceeded.'` if the number of iterations exceeds 10.
       *
       * Usually you don't call `$digest()` directly in
       * {@link ng.directive:ngController controllers} or in
       * {@link ng.$compileProvider#directive directives}.
       * Instead a call to {@link ng.$rootScope.Scope#$apply $apply()} (typically from within a
       * {@link ng.$compileProvider#directive directives}) will force a `$digest()`.
       *
       * If you want to be notified whenever `$digest()` is called,
       * you can register a `watchExpression` function  with {@link ng.$rootScope.Scope#$watch $watch()}
       * with no `listener`.
       *
       * You may have a need to call `$digest()` from within unit-tests, to simulate the scope
       * life-cycle.
       *
       * # Example
       * <pre>
           var scope = ...;
           scope.name = 'misko';
           scope.counter = 0;

           expect(scope.counter).toEqual(0);
           scope.$watch('name', function(newValue, oldValue) {
             scope.counter = scope.counter + 1;
           });
           expect(scope.counter).toEqual(0);

           scope.$digest();
           // no variable change
           expect(scope.counter).toEqual(0);

           scope.name = 'adam';
           scope.$digest();
           expect(scope.counter).toEqual(1);
       * </pre>
       *
       */
      $digest: function() {
        var watch, value, last,
            watchers,
            asyncQueue = this.$$asyncQueue,
            postDigestQueue = this.$$postDigestQueue,
            length,
            dirty, ttl = TTL,
            next, current, target = this,
            watchLog = [],
            logIdx, logMsg;

        beginPhase('$digest');

        do { // "while dirty" loop
          dirty = false;
          current = target;

          while(asyncQueue.length) {
            try {
              current.$eval(asyncQueue.shift());
            } catch (e) {
              $exceptionHandler(e);
            }
          }

          do { // "traverse the scopes" loop
            if ((watchers = current.$$watchers)) {
              // process our watches
              length = watchers.length;
              while (length--) {
                try {
                  watch = watchers[length];
                  // Most common watches are on primitives, in which case we can short
                  // circuit it with === operator, only when === fails do we use .equals
                  if (watch && (value = watch.get(current)) !== (last = watch.last) &&
                      !(watch.eq
                          ? equals(value, last)
                          : (typeof value == 'number' && typeof last == 'number'
                             && isNaN(value) && isNaN(last)))) {
                    dirty = true;
                    watch.last = watch.eq ? copy(value) : value;
                    watch.fn(value, ((last === initWatchVal) ? value : last), current);
                    if (ttl < 5) {
                      logIdx = 4 - ttl;
                      if (!watchLog[logIdx]) watchLog[logIdx] = [];
                      logMsg = (isFunction(watch.exp))
                          ? 'fn: ' + (watch.exp.name || watch.exp.toString())
                          : watch.exp;
                      logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);
                      watchLog[logIdx].push(logMsg);
                    }
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }

            // Insanity Warning: scope depth-first traversal
            // yes, this code is a bit crazy, but it works and we have tests to prove it!
            // this piece should be kept in sync with the traversal in $broadcast
            if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {
              while(current !== target && !(next = current.$$nextSibling)) {
                current = current.$parent;
              }
            }
          } while ((current = next));

          if(dirty && !(ttl--)) {
            clearPhase();
            throw $rootScopeMinErr('infdig',
                '{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}',
                TTL, toJson(watchLog));
          }
        } while (dirty || asyncQueue.length);

        clearPhase();

        while(postDigestQueue.length) {
          try {
            postDigestQueue.shift()();
          } catch (e) {
            $exceptionHandler(e);
          }
        }
      },


      /**
       * @ngdoc event
       * @name ng.$rootScope.Scope#$destroy
       * @eventOf ng.$rootScope.Scope
       * @eventType broadcast on scope being destroyed
       *
       * @description
       * Broadcasted when a scope and its children are being destroyed.
       *
       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
       * clean up DOM bindings before an element is removed from the DOM.
       */

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$destroy
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Removes the current scope (and all of its children) from the parent scope. Removal implies
       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer
       * propagate to the current scope and its children. Removal also implies that the current
       * scope is eligible for garbage collection.
       *
       * The `$destroy()` is usually used by directives such as
       * {@link ng.directive:ngRepeat ngRepeat} for managing the
       * unrolling of the loop.
       *
       * Just before a scope is destroyed a `$destroy` event is broadcasted on this scope.
       * Application code can register a `$destroy` event handler that will give it chance to
       * perform any necessary cleanup.
       *
       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
       * clean up DOM bindings before an element is removed from the DOM.
       */
      $destroy: function() {
        // we can't destroy the root scope or a scope that has been already destroyed
        if ($rootScope == this || this.$$destroyed) return;
        var parent = this.$parent;

        this.$broadcast('$destroy');
        this.$$destroyed = true;

        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;

        // This is bogus code that works around Chrome's GC leak
        // see: https://github.com/angular/angular.js/issues/1313#issuecomment-10378451
        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =
            this.$$childTail = null;
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$eval
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Executes the `expression` on the current scope returning the result. Any exceptions in the
       * expression are propagated (uncaught). This is useful when evaluating Angular expressions.
       *
       * # Example
       * <pre>
           var scope = ng.$rootScope.Scope();
           scope.a = 1;
           scope.b = 2;

           expect(scope.$eval('a+b')).toEqual(3);
           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
       * </pre>
       *
       * @param {(string|function())=} expression An angular expression to be executed.
       *
       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.
       *    - `function(scope)`: execute the function with the current `scope` parameter.
       *
       * @returns {*} The result of evaluating the expression.
       */
      $eval: function(expr, locals) {
        return $parse(expr)(this, locals);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$evalAsync
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Executes the expression on the current scope at a later point in time.
       *
       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only that:
       *
       *   - it will execute after the function that schedule the evaluation is done running (preferably before DOM rendering).
       *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after `expression` execution.
       *
       * Any exceptions from the execution of the expression are forwarded to the
       * {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * __Note:__ if this function is called outside of `$digest` cycle, a new $digest cycle will be scheduled.
       * It is however encouraged to always call code that changes the model from withing an `$apply` call.
       * That includes code evaluated via `$evalAsync`.
       *
       * @param {(string|function())=} expression An angular expression to be executed.
       *
       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.
       *    - `function(scope)`: execute the function with the current `scope` parameter.
       *
       */
      $evalAsync: function(expr) {
        // if we are outside of an $digest loop and this is the first time we are scheduling async task also schedule
        // async auto-flush
        if (!$rootScope.$$phase && !$rootScope.$$asyncQueue.length) {
          $browser.defer(function() {
            if ($rootScope.$$asyncQueue.length) {
              $rootScope.$digest();
            }
          });
        }

        this.$$asyncQueue.push(expr);
      },

      $$postDigest : function(expr) {
        this.$$postDigestQueue.push(expr);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$apply
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * `$apply()` is used to execute an expression in angular from outside of the angular framework.
       * (For example from browser DOM events, setTimeout, XHR or third party libraries).
       * Because we are calling into the angular framework we need to perform proper scope life-cycle
       * of {@link ng.$exceptionHandler exception handling},
       * {@link ng.$rootScope.Scope#$digest executing watches}.
       *
       * ## Life cycle
       *
       * # Pseudo-Code of `$apply()`
       * <pre>
           function $apply(expr) {
             try {
               return $eval(expr);
             } catch (e) {
               $exceptionHandler(e);
             } finally {
               $root.$digest();
             }
           }
       * </pre>
       *
       *
       * Scope's `$apply()` method transitions through the following stages:
       *
       * 1. The {@link guide/expression expression} is executed using the
       *    {@link ng.$rootScope.Scope#$eval $eval()} method.
       * 2. Any exceptions from the execution of the expression are forwarded to the
       *    {@link ng.$exceptionHandler $exceptionHandler} service.
       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the expression
       *    was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.
       *
       *
       * @param {(string|function())=} exp An angular expression to be executed.
       *
       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
       *    - `function(scope)`: execute the function with current `scope` parameter.
       *
       * @returns {*} The result of evaluating the expression.
       */
      $apply: function(expr) {
        try {
          beginPhase('$apply');
          return this.$eval(expr);
        } catch (e) {
          $exceptionHandler(e);
        } finally {
          clearPhase();
          try {
            $rootScope.$digest();
          } catch (e) {
            $exceptionHandler(e);
            throw e;
          }
        }
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$on
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for discussion of
       * event life cycle.
       *
       * The event listener function format is: `function(event, args...)`. The `event` object
       * passed into the listener has the following attributes:
       *
       *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or `$broadcast`-ed.
       *   - `currentScope` - `{Scope}`: the current scope which is handling the event.
       *   - `name` - `{string}`: Name of the event.
       *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel further event
       *     propagation (available only for events that were `$emit`-ed).
       *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag to true.
       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.
       *
       * @param {string} name Event name to listen on.
       * @param {function(event, args...)} listener Function to call when the event is emitted.
       * @returns {function()} Returns a deregistration function for this listener.
       */
      $on: function(name, listener) {
        var namedListeners = this.$$listeners[name];
        if (!namedListeners) {
          this.$$listeners[name] = namedListeners = [];
        }
        namedListeners.push(listener);

        return function() {
          namedListeners[indexOf(namedListeners, listener)] = null;
        };
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$emit
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Dispatches an event `name` upwards through the scope hierarchy notifying the
       * registered {@link ng.$rootScope.Scope#$on} listeners.
       *
       * The event life cycle starts at the scope on which `$emit` was called. All
       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.
       * Afterwards, the event traverses upwards toward the root scope and calls all registered
       * listeners along the way. The event will stop propagating if one of the listeners cancels it.
       *
       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * @param {string} name Event name to emit.
       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
       */
      $emit: function(name, args) {
        var empty = [],
            namedListeners,
            scope = this,
            stopPropagation = false,
            event = {
              name: name,
              targetScope: scope,
              stopPropagation: function() {stopPropagation = true;},
              preventDefault: function() {
                event.defaultPrevented = true;
              },
              defaultPrevented: false
            },
            listenerArgs = concat([event], arguments, 1),
            i, length;

        do {
          namedListeners = scope.$$listeners[name] || empty;
          event.currentScope = scope;
          for (i=0, length=namedListeners.length; i<length; i++) {

            // if listeners were deregistered, defragment the array
            if (!namedListeners[i]) {
              namedListeners.splice(i, 1);
              i--;
              length--;
              continue;
            }
            try {
              namedListeners[i].apply(null, listenerArgs);
              if (stopPropagation) return event;
            } catch (e) {
              $exceptionHandler(e);
            }
          }
          //traverse upwards
          scope = scope.$parent;
        } while (scope);

        return event;
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$broadcast
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the
       * registered {@link ng.$rootScope.Scope#$on} listeners.
       *
       * The event life cycle starts at the scope on which `$broadcast` was called. All
       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.
       * Afterwards, the event propagates to all direct and indirect scopes of the current scope and
       * calls all registered listeners along the way. The event cannot be canceled.
       *
       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * @param {string} name Event name to broadcast.
       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
       */
      $broadcast: function(name, args) {
        var target = this,
            current = target,
            next = target,
            event = {
              name: name,
              targetScope: target,
              preventDefault: function() {
                event.defaultPrevented = true;
              },
              defaultPrevented: false
            },
            listenerArgs = concat([event], arguments, 1),
            listeners, i, length;

        //down while you can, then up and next sibling or up and next sibling until back at root
        do {
          current = next;
          event.currentScope = current;
          listeners = current.$$listeners[name] || [];
          for (i=0, length = listeners.length; i<length; i++) {
            // if listeners were deregistered, defragment the array
            if (!listeners[i]) {
              listeners.splice(i, 1);
              i--;
              length--;
              continue;
            }

            try {
              listeners[i].apply(null, listenerArgs);
            } catch(e) {
              $exceptionHandler(e);
            }
          }

          // Insanity Warning: scope depth-first traversal
          // yes, this code is a bit crazy, but it works and we have tests to prove it!
          // this piece should be kept in sync with the traversal in $digest
          if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {
            while(current !== target && !(next = current.$$nextSibling)) {
              current = current.$parent;
            }
          }
        } while ((current = next));

        return event;
      }
    };

    var $rootScope = new Scope();

    return $rootScope;


    function beginPhase(phase) {
      if ($rootScope.$$phase) {
        throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
      }

      $rootScope.$$phase = phase;
    }

    function clearPhase() {
      $rootScope.$$phase = null;
    }

    function compileToFn(exp, name) {
      var fn = $parse(exp);
      assertArgFn(fn, name);
      return fn;
    }

    /**
     * function used as an initial value for watchers.
     * because it's unique we can easily tell it apart from other values
     */
    function initWatchVal() {}
  }];
}

var $sceMinErr = minErr('$sce');

var SCE_CONTEXTS = {
  HTML: 'html',
  CSS: 'css',
  URL: 'url',
  // RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a
  // url.  (e.g. ng-include, script src, templateUrl)
  RESOURCE_URL: 'resourceUrl',
  JS: 'js'
};


/**
 * @ngdoc service
 * @name ng.$sceDelegate
 * @function
 *
 * @description
 *
 * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict
 * Contextual Escaping (SCE)} services to AngularJS.
 *
 * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of
 * the `$sce` service to customize the way Strict Contextual Escaping works in AngularJS.  This is
 * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to
 * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things
 * work because `$sce` delegates to `$sceDelegate` for these operations.
 *
 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.
 *
 * The default instance of `$sceDelegate` should work out of the box with little pain.  While you
 * can override it completely to change the behavior of `$sce`, the common case would
 * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting
 * your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as
 * templates.  Refer {@link ng.$sceDelegateProvider#resourceUrlWhitelist
 * $sceDelegateProvider.resourceUrlWhitelist} and {@link
 * ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
 */

/**
 * @ngdoc object
 * @name ng.$sceDelegateProvider
 * @description
 *
 * The $sceDelegateProvider provider allows developers to configure the {@link ng.$sceDelegate
 * $sceDelegate} service.  This allows one to get/set the whitelists and blacklists used to ensure
 * that URLs used for sourcing Angular templates are safe.  Refer {@link
 * ng.$sceDelegateProvider#resourceUrlWhitelist $sceDelegateProvider.resourceUrlWhitelist} and
 * {@link ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
 *
 * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.
 */

function $SceDelegateProvider() {
  this.SCE_CONTEXTS = SCE_CONTEXTS;

  // Resource URLs can also be trusted by policy.
  var resourceUrlWhitelist = ['self'],
      resourceUrlBlacklist = [];

  /**
   * @ngdoc function
   * @name ng.sceDelegateProvider#resourceUrlWhitelist
   * @methodOf ng.$sceDelegateProvider
   * @function
   *
   * @param {Array=} whitelist When provided, replaces the resourceUrlWhitelist with the value
   *     provided.  This must be an array.
   *
   *     Each element of this array must either be a regex or the special string `'self'`.
   *
   *     When a regex is used, it is matched against the normalized / absolute URL of the resource
   *     being tested.
   *
   *     The **special string** `'self'` can be used to match against all URLs of the same domain as the
   *     application document with the same protocol (allows sourcing https resources from http documents.)
   *
   *     Please note that **an empty whitelist array will block all URLs**!
   *
   * @return {Array} the currently set whitelist array.
   *
   * The **default value** when no whitelist has been explicitly set is `['self']`.
   *
   * @description
   * Sets/Gets the whitelist of trusted resource URLs.
   */
  this.resourceUrlWhitelist = function (value) {
    if (arguments.length) {
      resourceUrlWhitelist = value;
    }
    return resourceUrlWhitelist;
  };

  /**
   * @ngdoc function
   * @name ng.sceDelegateProvider#resourceUrlBlacklist
   * @methodOf ng.$sceDelegateProvider
   * @function
   *
   * @param {Array=} blacklist When provided, replaces the resourceUrlBlacklist with the value
   *     provided.  This must be an array.
   *
   *     Each element of this array must either be a regex or the special string `'self'` (see
   *     `resourceUrlWhitelist` for meaning - it's only really useful there.)
   *
   *     When a regex is used, it is matched against the normalized / absolute URL of the resource
   *     being tested.
   *
   *     The typical usage for the blacklist is to **block [open redirects](http://cwe.mitre.org/data/definitions/601.html)**
   *     served by your domain as these would otherwise be trusted but actually return content from the redirected
   *     domain.
   *
   *     Finally, **the blacklist overrides the whitelist** and has the final say.
   *
   * @return {Array} the currently set blacklist array.
   *
   * The **default value** when no whitelist has been explicitly set is the empty array (i.e. there is
   * no blacklist.)
   *
   * @description
   * Sets/Gets the blacklist of trusted resource URLs.
   */

  this.resourceUrlBlacklist = function (value) {
    if (arguments.length) {
      resourceUrlBlacklist = value;
    }
    return resourceUrlBlacklist;
  };

  // Helper functions for matching resource urls by policy.
  function isCompatibleProtocol(documentProtocol, resourceProtocol) {
    return ((documentProtocol === resourceProtocol) ||
            (documentProtocol === "http:" && resourceProtocol === "https:"));
  }

  this.$get = ['$log', '$document', '$injector', '$$urlUtils', function(
                $log,   $document,   $injector,   $$urlUtils) {

    var htmlSanitizer = function htmlSanitizer(html) {
      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
    };

    if ($injector.has('$sanitize')) {
      htmlSanitizer = $injector.get('$sanitize');
    }


    function matchUrl(matcher, parsedUrl) {
      if (matcher === 'self') {
        return $$urlUtils.isSameOrigin(parsedUrl);
      } else {
        return !!parsedUrl.href.match(matcher);
      }
    }

    function isResourceUrlAllowedByPolicy(url) {
      var parsedUrl = $$urlUtils.resolve(url.toString(), true);
      var i, n, allowed = false;
      // Ensure that at least one item from the whitelist allows this url.
      for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
        if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
          allowed = true;
          break;
        }
      }
      if (allowed) {
        // Ensure that no item from the blacklist blocked this url.
        for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
          if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
            allowed = false;
            break;
          }
        }
      }
      return allowed;
    }

    function generateHolderType(base) {
      var holderType = function TrustedValueHolderType(trustedValue) {
        this.$$unwrapTrustedValue = function() {
          return trustedValue;
        };
      };
      if (base) {
        holderType.prototype = new base();
      }
      holderType.prototype.valueOf = function sceValueOf() {
        return this.$$unwrapTrustedValue();
      }
      holderType.prototype.toString = function sceToString() {
        return this.$$unwrapTrustedValue().toString();
      }
      return holderType;
    }

    var trustedValueHolderBase = generateHolderType(),
        byType = {};

    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);

    /**
     * @ngdoc method
     * @name ng.$sceDelegate#trustAs
     * @methodOf ng.$sceDelegate
     *
     * @description
     * Returns an object that is trusted by angular for use in specified strict
     * contextual escaping contexts (such as ng-html-bind-unsafe, ng-include, any src
     * attribute interpolation, any dom event binding attribute interpolation
     * such as for onclick,  etc.) that uses the provided value.
     * See {@link ng.$sce $sce} for enabling strict contextual escaping.
     *
     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
     *   resourceUrl, html, js and css.
     * @param {*} value The value that that should be considered trusted/safe.
     * @returns {*} A value that can be used to stand in for the provided `value` in places
     * where Angular expects a $sce.trustAs() return value.
     */
    function trustAs(type, trustedValue) {
      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
      if (!constructor) {
        throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}',
            type, trustedValue);
      }
      if (trustedValue === null || trustedValue === undefined || trustedValue === '') {
        return trustedValue;
      }
      // All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting
      // mutable objects, we ensure here that the value passed in is actually a string.
      if (typeof trustedValue !== 'string') {
        throw $sceMinErr('itype',
            'Attempted to trust a non-string value in a content requiring a string: Context: {0}',
            type);
      }
      return new constructor(trustedValue);
    }

    /**
     * @ngdoc method
     * @name ng.$sceDelegate#valueOf
     * @methodOf ng.$sceDelegate
     *
     * @description
     * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs
     * `$sceDelegate.trustAs`}, returns the value that had been passed to {@link
     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.
     *
     * If the passed parameter is not a value that had been returned by {@link
     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, returns it as-is.
     *
     * @param {*} value The result of a prior {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}
     *      call or anything else.
     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#trustAs
     *     `$sceDelegate.trustAs`} if `value` is the result of such a call.  Otherwise, returns `value`
     *     unchanged.
     */
    function valueOf(maybeTrusted) {
      if (maybeTrusted instanceof trustedValueHolderBase) {
        return maybeTrusted.$$unwrapTrustedValue();
      } else {
        return maybeTrusted;
      }
    }

    /**
     * @ngdoc method
     * @name ng.$sceDelegate#getTrusted
     * @methodOf ng.$sceDelegate
     *
     * @description
     * Takes the result of a {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`} call and returns the
     * originally supplied value if the queried context type is a supertype of the created type.  If
     * this condition isn't satisfied, throws an exception.
     *
     * @param {string} type The kind of context in which this value is to be used.
     * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs
     * `$sceDelegate.trustAs`} call.
     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#trustAs
     *     `$sceDelegate.trustAs`} if valid in this context.  Otherwise, throws an exception.
     */
    function getTrusted(type, maybeTrusted) {
      if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') {
        return maybeTrusted;
      }
      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
      if (constructor && maybeTrusted instanceof constructor) {
        return maybeTrusted.$$unwrapTrustedValue();
      }
      // If we get here, then we may only take one of two actions.
      // 1. sanitize the value for the requested type, or
      // 2. throw an exception.
      if (type === SCE_CONTEXTS.RESOURCE_URL) {
        if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
          return maybeTrusted;
        } else {
          throw $sceMinErr('insecurl',
              'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
        }
      } else if (type === SCE_CONTEXTS.HTML) {
        return htmlSanitizer(maybeTrusted);
      }
      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
    }

    return { trustAs: trustAs,
             getTrusted: getTrusted,
             valueOf: valueOf };
  }];
}


/**
 * @ngdoc object
 * @name ng.$sceProvider
 * @description
 *
 * The $sceProvider provider allows developers to configure the {@link ng.$sce $sce} service.
 * -   enable/disable Strict Contextual Escaping (SCE) in a module
 * -   override the default implementation with a custom delegate
 *
 * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.
 */

/**
 * @ngdoc service
 * @name ng.$sce
 * @function
 *
 * @description
 *
 * `$sce` is a service that provides Strict Contextual Escaping services to AngularJS.
 *
 * # Strict Contextual Escaping
 *
 * Strict Contextual Escaping (SCE) is a mode in which AngularJS requires bindings in certain
 * contexts to result in a value that is marked as safe to use for that context One example of such
 * a context is binding arbitrary html controlled by the user via `ng-bind-html`.  We refer to these
 * contexts as privileged or SCE contexts.
 *
 * As of version 1.2, Angular ships with SCE enabled by default.
 *
 * Note:  When enabled (the default), IE8 in quirks mode is not supported.  In this mode, IE8 allows
 * one to execute arbitrary javascript by the use of the expression() syntax.  Refer
 * <http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx> to learn more about them.
 * You can ensure your document is in standards mode and not quirks mode by adding `<!doctype html>`
 * to the top of your HTML document.
 *
 * SCE assists in writing code in way that (a) is secure by default and (b) makes auditing for
 * security vulnerabilities such as XSS, clickjacking, etc. a lot easier.
 *
 * Here's an example of a binding in a privileged context:
 *
 * <pre class="prettyprint">
 *     <input ng-model="userHtml">
 *     <div ng-bind-html="{{userHtml}}">
 * </pre>
 *
 * Notice that `ng-bind-html` is bound to `{{userHtml}}` controlled by the user.  With SCE
 * disabled, this application allows the user to render arbitrary HTML into the DIV.
 * In a more realistic example, one may be rendering user comments, blog articles, etc. via
 * bindings.  (HTML is just one example of a context where rendering user controlled input creates
 * security vulnerabilities.)
 *
 * For the case of HTML, you might use a library, either on the client side, or on the server side,
 * to sanitize unsafe HTML before binding to the value and rendering it in the document.
 *
 * How would you ensure that every place that used these types of bindings was bound to a value that
 * was sanitized by your library (or returned as safe for rendering by your server?)  How can you
 * ensure that you didn't accidentally delete the line that sanitized the value, or renamed some
 * properties/fields and forgot to update the binding to the sanitized value?
 *
 * To be secure by default, you want to ensure that any such bindings are disallowed unless you can
 * determine that something explicitly says it's safe to use a value for binding in that
 * context.  You can then audit your code (a simple grep would do) to ensure that this is only done
 * for those values that you can easily tell are safe - because they were received from your server,
 * sanitized by your library, etc.  You can organize your codebase to help with this - perhaps
 * allowing only the files in a specific directory to do this.  Ensuring that the internal API
 * exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.
 *
 * In the case of AngularJS' SCE service, one uses {@link ng.$sce#trustAs $sce.trustAs} (and shorthand
 * methods such as {@link ng.$sce#trustAsHtml $sce.trustAsHtml}, etc.) to obtain values that will be
 * accepted by SCE / privileged contexts.
 *
 *
 * ## How does it work?
 *
 * In privileged contexts, directives and code will bind to the result of {@link ng.$sce#getTrusted
 * $sce.getTrusted(context, value)} rather than to the value directly.  Directives use {@link
 * ng.$sce#parse $sce.parseAs} rather than `$parse` to watch attribute bindings, which performs the
 * {@link ng.$sce#getTrusted $sce.getTrusted} behind the scenes on non-constant literals.
 *
 * As an example, {@link ng.directive:ngBindHtml ngBindHtml} uses {@link
 * ng.$sce#parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's the actual code (slightly
 * simplified):
 *
 * <pre class="prettyprint">
 *   var ngBindHtmlDirective = ['$sce', function($sce) {
 *     return function(scope, element, attr) {
 *       scope.$watch($sce.parseAsHtml(attr.ngBindHtml), function(value) {
 *         element.html(value || '');
 *       });
 *     };
 *   }];
 * </pre>
 *
 * ## Impact on loading templates
 *
 * This applies both to the {@link ng.directive:ngInclude `ng-include`} directive as well as
 * `templateUrl`'s specified by {@link guide/directive directives}.
 *
 * By default, Angular only loads templates from the same domain and protocol as the application
 * document.  This is done by calling {@link ng.$sce#getTrustedResourceUrl
 * $sce.getTrustedResourceUrl} on the template URL.  To load templates from other domains and/or
 * protocols, you may either either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist
 * them} or {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted value.
 *
 * *Please note*:
 * The browser's
 * {@link https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest
 * Same Origin Policy} and {@link http://www.w3.org/TR/cors/ Cross-Origin Resource Sharing (CORS)}
 * policy apply in addition to this and may further restrict whether the template is successfully
 * loaded.  This means that without the right CORS policy, loading templates from a different domain
 * won't work on all browsers.  Also, loading templates from `file://` URL does not work on some
 * browsers.
 *
 * ## This feels like too much overhead for the developer?
 *
 * It's important to remember that SCE only applies to interpolation expressions.
 *
 * If your expressions are constant literals, they're automatically trusted and you don't need to
 * call `$sce.trustAs` on them.  (e.g.
 * `<div ng-html-bind-unsafe="'<b>implicitly trusted</b>'"></div>`) just works.
 *
 * Additionally, `a[href]` and `img[src]` automatically sanitize their URLs and do not pass them
 * through {@link ng.$sce#getTrusted $sce.getTrusted}.  SCE doesn't play a role here.
 *
 * The included {@link ng.$sceDelegate $sceDelegate} comes with sane defaults to allow you to load
 * templates in `ng-include` from your application's domain without having to even know about SCE.
 * It blocks loading templates from other domains or loading templates over http from an https
 * served document.  You can change these by setting your own custom {@link
 * ng.$sceDelegateProvider#resourceUrlWhitelist whitelists} and {@link
 * ng.$sceDelegateProvider#resourceUrlBlacklist blacklists} for matching such URLs.
 *
 * This significantly reduces the overhead.  It is far easier to pay the small overhead and have an
 * application that's secure and can be audited to verify that with much more ease than bolting
 * security onto an application later.
 *
 * ## What trusted context types are supported?<a name="contexts"></a>
 *
 * | Context             | Notes          |
 * |---------------------|----------------|
 * | `$sce.HTML`         | For HTML that's safe to source into the application.  The {@link ng.directive:ngBindHtml ngBindHtml} directive uses this context for bindings. |
 * | `$sce.CSS`          | For CSS that's safe to source into the application.  Currently unused.  Feel free to use it in your own directives. |
 * | `$sce.URL`          | For URLs that are safe to follow as links.  Currently unused (`<a href=` and `<img src=` sanitize their urls and don't consititute an SCE context. |
 * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as links, but whose contens are also safe to include in your application.  Examples include `ng-include`, `src` / `ngSrc` bindings for tags other than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  <br><br>Note that `$sce.RESOURCE_URL` makes a stronger statement about the URL than `$sce.URL` does and therefore contexts requiring values trusted for `$sce.RESOURCE_URL` can be used anywhere that values trusted for `$sce.URL` are required. |
 * | `$sce.JS`           | For JavaScript that is safe to execute in your application's context.  Currently unused.  Feel free to use it in your own directives. |
 *
 * ## Show me an example.
 *
 *
 *
 * @example
 <example module="mySceApp">
  <file name="index.html">
    <div ng-controller="myAppController as myCtrl">
      <i ng-bind-html="myCtrl.explicitlyTrustedHtml" id="explicitlyTrustedHtml"></i><br><br>
      <b>User comments</b><br>
      By default, HTML that isn't explicitly trusted (e.g. Alice's comment) is sanitized when $sanitize is available.  If $sanitize isn't available, this results in an error instead of an exploit.
      <div class="well">
        <div ng-repeat="userComment in myCtrl.userComments">
          <b>{{userComment.name}}</b>:
          <span ng-bind-html="userComment.htmlComment" class="htmlComment"></span>
          <br>
        </div>
      </div>
    </div>
  </file>

  <file name="script.js">
    var mySceApp = angular.module('mySceApp', ['ngSanitize']);

    mySceApp.controller("myAppController", function myAppController($http, $templateCache, $sce) {
      var self = this;
      $http.get("test_data.json", {cache: $templateCache}).success(function(userComments) {
        self.userComments = userComments;
      });
      self.explicitlyTrustedHtml = $sce.trustAsHtml(
          '<span onmouseover="this.textContent=&quot;Explicitly trusted HTML bypasses ' +
          'sanitization.&quot;">Hover over this text.</span>');
    });
  </file>

  <file name="test_data.json">
    [
      { "name": "Alice",
        "htmlComment": "<span onmouseover='this.textContent=\"PWN3D!\"'>Is <i>anyone</i> reading this?</span>"
      },
      { "name": "Bob",
        "htmlComment": "<i>Yes!</i>  Am I the only other one?"
      }
    ]
  </file>

  <file name="scenario.js">
    describe('SCE doc demo', function() {
      it('should sanitize untrusted values', function() {
        expect(element('.htmlComment').html()).toBe('<span>Is <i>anyone</i> reading this?</span>');
      });
      it('should NOT sanitize explicitly trusted values', function() {
        expect(element('#explicitlyTrustedHtml').html()).toBe(
            '<span onmouseover="this.textContent=&quot;Explicitly trusted HTML bypasses ' +
            'sanitization.&quot;">Hover over this text.</span>');
      });
    });
  </file>
 </example>
 *
 *
 *
 * ## Can I disable SCE completely?
 *
 * Yes, you can.  However, this is strongly discouraged.  SCE gives you a lot of security benefits
 * for little coding overhead.  It will be much harder to take an SCE disabled application and
 * either secure it on your own or enable SCE at a later stage.  It might make sense to disable SCE
 * for cases where you have a lot of existing code that was written before SCE was introduced and
 * you're migrating them a module at a time.
 *
 * That said, here's how you can completely disable SCE:
 *
 * <pre class="prettyprint">
 *   angular.module('myAppWithSceDisabledmyApp', []).config(function($sceProvider) {
 *     // Completely disable SCE.  For demonstration purposes only!
 *     // Do not use in new projects.
 *     $sceProvider.enabled(false);
 *   });
 * </pre>
 *
 */

function $SceProvider() {
  var enabled = true;

  /**
   * @ngdoc function
   * @name ng.sceProvider#enabled
   * @methodOf ng.$sceProvider
   * @function
   *
   * @param {boolean=} value If provided, then enables/disables SCE.
   * @return {boolean} true if SCE is enabled, false otherwise.
   *
   * @description
   * Enables/disables SCE and returns the current value.
   */
  this.enabled = function (value) {
    if (arguments.length) {
      enabled = !!value;
    }
    return enabled;
  };


  /* Design notes on the default implementation for SCE.
   *
   * The API contract for the SCE delegate
   * -------------------------------------
   * The SCE delegate object must provide the following 3 methods:
   *
   * - trustAs(contextEnum, value)
   *     This method is used to tell the SCE service that the provided value is OK to use in the
   *     contexts specified by contextEnum.  It must return an object that will be accepted by
   *     getTrusted() for a compatible contextEnum and return this value.
   *
   * - valueOf(value)
   *     For values that were not produced by trustAs(), return them as is.  For values that were
   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if
   *     trustAs is wrapping the given values into some type, this operation unwraps it when given
   *     such a value.
   *
   * - getTrusted(contextEnum, value)
   *     This function should return the a value that is safe to use in the context specified by
   *     contextEnum or throw and exception otherwise.
   *
   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be opaque
   * or wrapped in some holder object.  That happens to be an implementation detail.  For instance,
   * an implementation could maintain a registry of all trusted objects by context.  In such a case,
   * trustAs() would return the same object that was passed in.  getTrusted() would return the same
   * object passed in if it was found in the registry under a compatible context or throw an
   * exception otherwise.  An implementation might only wrap values some of the time based on
   * some criteria.  getTrusted() might return a value and not throw an exception for special
   * constants or objects even if not wrapped.  All such implementations fulfill this contract.
   *
   *
   * A note on the inheritance model for SCE contexts
   * ------------------------------------------------
   * I've used inheritance and made RESOURCE_URL wrapped types a subtype of URL wrapped types.  This
   * is purely an implementation details.
   *
   * The contract is simply this:
   *
   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that getTrusted($sce.URL, value)
   *     will also succeed.
   *
   * Inheritance happens to capture this in a natural way.  In some future, we
   * may not use inheritance anymore.  That is OK because no code outside of
   * sce.js and sceSpecs.js would need to be aware of this detail.
   */

  this.$get = ['$parse', '$document', '$sceDelegate', function(
                $parse,   $document,   $sceDelegate) {
    // Prereq: Ensure that we're not running in IE8 quirks mode.  In that mode, IE allows
    // the "expression(javascript expression)" syntax which is insecure.
    if (enabled && msie) {
      var documentMode = $document[0].documentMode;
      if (documentMode !== undefined && documentMode < 8) {
        throw $sceMinErr('iequirks',
          'Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks ' +
          'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' +
          'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
      }
    }

    var sce = copy(SCE_CONTEXTS);

    /**
     * @ngdoc function
     * @name ng.sce#isEnabled
     * @methodOf ng.$sce
     * @function
     *
     * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you
     * have to do it at module config time on {@link ng.$sceProvider $sceProvider}.
     *
     * @description
     * Returns a boolean indicating if SCE is enabled.
     */
    sce.isEnabled = function () {
      return enabled;
    };
    sce.trustAs = $sceDelegate.trustAs;
    sce.getTrusted = $sceDelegate.getTrusted;
    sce.valueOf = $sceDelegate.valueOf;

    if (!enabled) {
      sce.trustAs = sce.getTrusted = function(type, value) { return value; },
      sce.valueOf = identity
    }

    /**
     * @ngdoc method
     * @name ng.$sce#parse
     * @methodOf ng.$sce
     *
     * @description
     * Converts Angular {@link guide/expression expression} into a function.  This is like {@link
     * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it
     * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,
     * *result*)}
     *
     * @param {string} type The kind of SCE context in which this result will be used.
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
     *      `context`.
     */
    sce.parseAs = function sceParseAs(type, expr) {
      var parsed = $parse(expr);
      if (parsed.literal && parsed.constant) {
        return parsed;
      } else {
        return function sceParseAsTrusted(self, locals) {
          return sce.getTrusted(type, parsed(self, locals));
        }
      }
    };

    /**
     * @ngdoc method
     * @name ng.$sce#trustAs
     * @methodOf ng.$sce
     *
     * @description
     * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.  As such, returns an object
     * that is trusted by angular for use in specified strict contextual escaping contexts (such as
     * ng-html-bind-unsafe, ng-include, any src attribute interpolation, any dom event binding
     * attribute interpolation such as for onclick,  etc.) that uses the provided value.  See *
     * {@link ng.$sce $sce} for enabling strict contextual escaping.
     *
     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
     *   resource_url, html, js and css.
     * @param {*} value The value that that should be considered trusted/safe.
     * @returns {*} A value that can be used to stand in for the provided `value` in places
     * where Angular expects a $sce.trustAs() return value.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsHtml
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsHtml(value)`  {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedHtml
     *     $sce.getTrustedHtml(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsUrl(value)`  {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedUrl
     *     $sce.getTrustedUrl(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsResourceUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsResourceUrl(value)`  {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedResourceUrl
     *     $sce.getTrustedResourceUrl(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the return
     *     value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsJs
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsJs(value)`  {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedJs
     *     $sce.getTrustedJs(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrusted
     * @methodOf ng.$sce
     *
     * @description
     * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such, takes
     * the result of a {@link ng.$sce#trustAs `$sce.trustAs`}() call and returns the originally supplied
     * value if the queried context type is a supertype of the created type.  If this condition
     * isn't satisfied, throws an exception.
     *
     * @param {string} type The kind of context in which this value is to be used.
     * @param {*} maybeTrusted The result of a prior {@link ng.$sce#trustAs `$sce.trustAs`} call.
     * @returns {*} The value the was originally provided to {@link ng.$sce#trustAs `$sce.trustAs`} if
     *     valid in this context.  Otherwise, throws an exception.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedHtml
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedHtml(value)`  {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.HTML, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedCss
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedCss(value)`  {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.CSS, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedUrl(value)`  {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.URL, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedResourceUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedResourceUrl(value)`  {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}
     *
     * @param {*} value The value to pass to `$sceDelegate.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedJs
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedJs(value)`  {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.JS, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsHtml
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsHtml(expression string)`  {@link ng.$sce#parse `$sce.parseAs($sce.HTML, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsCss
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsCss(value)`  {@link ng.$sce#parse `$sce.parseAs($sce.CSS, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsUrl(value)`  {@link ng.$sce#parse `$sce.parseAs($sce.URL, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsResourceUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsResourceUrl(value)`  {@link ng.$sce#parse `$sce.parseAs($sce.RESOURCE_URL, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsJs
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsJs(value)`  {@link ng.$sce#parse `$sce.parseAs($sce.JS, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context`  `{object}`  an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals`  `{object=}`  local variables context object, useful for overriding values in
     *      `context`.
     */

    // Shorthand delegations.
    var parse = sce.parseAs,
        getTrusted = sce.getTrusted,
        trustAs = sce.trustAs;

    angular.forEach(SCE_CONTEXTS, function (enumValue, name) {
      var lName = lowercase(name);
      sce[camelCase("parse_as_" + lName)] = function (expr) {
        return parse(enumValue, expr);
      }
      sce[camelCase("get_trusted_" + lName)] = function (value) {
        return getTrusted(enumValue, value);
      }
      sce[camelCase("trust_as_" + lName)] = function (value) {
        return trustAs(enumValue, value);
      }
    });

    return sce;
  }];
}

/**
 * !!! This is an undocumented "private" service !!!
 *
 * @name ng.$sniffer
 * @requires $window
 * @requires $document
 *
 * @property {boolean} history Does the browser support html5 history api ?
 * @property {boolean} hashchange Does the browser support hashchange event ?
 * @property {boolean} transitions Does the browser support CSS transition events ?
 * @property {boolean} animations Does the browser support CSS animation events ?
 *
 * @description
 * This is very simple implementation of testing browser's features.
 */
function $SnifferProvider() {
  this.$get = ['$window', '$document', function($window, $document) {
    var eventSupport = {},
        android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
        document = $document[0] || {},
        vendorPrefix,
        vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,
        bodyStyle = document.body && document.body.style,
        transitions = false,
        animations = false,
        match;

    if (bodyStyle) {
      for(var prop in bodyStyle) {
        if(match = vendorRegex.exec(prop)) {
          vendorPrefix = match[0];
          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
          break;
        }
      }

      if(!vendorPrefix) {
        vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
      }

      transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
      animations  = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));

      if (android && (!transitions||!animations)) {
        transitions = isString(document.body.style.webkitTransition);
        animations = isString(document.body.style.webkitAnimation);
      }
    }


    return {
      // Android has history.pushState, but it does not update location correctly
      // so let's not use the history API at all.
      // http://code.google.com/p/android/issues/detail?id=17471
      // https://github.com/angular/angular.js/issues/904

      // older webit browser (533.9) on Boxee box has exactly the same problem as Android has
      // so let's not use the history API also
      history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
      hashchange: 'onhashchange' in $window &&
                  // IE8 compatible mode lies
                  (!document.documentMode || document.documentMode > 7),
      hasEvent: function(event) {
        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have
        // it. In particular the event is not fired when backspace or delete key are pressed or
        // when cut operation is performed.
        if (event == 'input' && msie == 9) return false;

        if (isUndefined(eventSupport[event])) {
          var divElm = document.createElement('div');
          eventSupport[event] = 'on' + event in divElm;
        }

        return eventSupport[event];
      },
      csp: document.securityPolicy ? document.securityPolicy.isActive : false,
      vendorPrefix: vendorPrefix,
      transitions : transitions,
      animations : animations
    };
  }];
}

function $TimeoutProvider() {
  this.$get = ['$rootScope', '$browser', '$q', '$exceptionHandler',
       function($rootScope,   $browser,   $q,   $exceptionHandler) {
    var deferreds = {};


     /**
      * @ngdoc function
      * @name ng.$timeout
      * @requires $browser
      *
      * @description
      * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
      * block and delegates any exceptions to
      * {@link ng.$exceptionHandler $exceptionHandler} service.
      *
      * The return value of registering a timeout function is a promise, which will be resolved when
      * the timeout is reached and the timeout function is executed.
      *
      * To cancel a timeout request, call `$timeout.cancel(promise)`.
      *
      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to
      * synchronously flush the queue of deferred functions.
      *
      * @param {function()} fn A function, whose execution should be delayed.
      * @param {number=} [delay=0] Delay in milliseconds.
      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.
      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this
      *   promise will be resolved with is the return value of the `fn` function.
      */
    function timeout(fn, delay, invokeApply) {
      var deferred = $q.defer(),
          promise = deferred.promise,
          skipApply = (isDefined(invokeApply) && !invokeApply),
          timeoutId;

      timeoutId = $browser.defer(function() {
        try {
          deferred.resolve(fn());
        } catch(e) {
          deferred.reject(e);
          $exceptionHandler(e);
        }
        finally {
          delete deferreds[promise.$$timeoutId];
        }

        if (!skipApply) $rootScope.$apply();
      }, delay);

      promise.$$timeoutId = timeoutId;
      deferreds[timeoutId] = deferred;

      return promise;
    }


     /**
      * @ngdoc function
      * @name ng.$timeout#cancel
      * @methodOf ng.$timeout
      *
      * @description
      * Cancels a task associated with the `promise`. As a result of this, the promise will be
      * resolved with a rejection.
      *
      * @param {Promise=} promise Promise returned by the `$timeout` function.
      * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
      *   canceled.
      */
    timeout.cancel = function(promise) {
      if (promise && promise.$$timeoutId in deferreds) {
        deferreds[promise.$$timeoutId].reject('canceled');
        delete deferreds[promise.$$timeoutId];
        return $browser.defer.cancel(promise.$$timeoutId);
      }
      return false;
    };

    return timeout;
  }];
}

function $$UrlUtilsProvider() {
  this.$get = [function() {
    var urlParsingNode = document.createElement("a"),
        // NOTE:  The usage of window and document instead of $window and $document here is
        // deliberate.  This service depends on the specific behavior of anchor nodes created by the
        // browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and
        // cause us to break tests.  In addition, when the browser resolves a URL for XHR, it
        // doesn't know about mocked locations and resolves URLs to the real document - which is
        // exactly the behavior needed here.  There is little value is mocking these our for this
        // service.
        originUrl = resolve(window.location.href, true);

    /**
     * @description
     * Normalizes and optionally parses a URL.
     *
     * NOTE:  This is a private service.  The API is subject to change unpredictably in any commit.
     *
     * Implementation Notes for non-IE browsers
     * ----------------------------------------
     * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,
     * results both in the normalizing and parsing of the URL.  Normalizing means that a relative
     * URL will be resolved into an absolute URL in the context of the application document.
     * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related
     * properties are all populated to reflect the normalized URL.  This approach has wide
     * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See
     * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
     *
     * Implementation Notes for IE
     * ---------------------------
     * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other
     * browsers.  However, the parsed components will not be set if the URL assigned did not specify
     * them.  (e.g. if you assign a.href = "foo", then a.protocol, a.host, etc. will be empty.)  We
     * work around that by performing the parsing in a 2nd step by taking a previously normalized
     * URL (e.g. by assining to a.href) and assigning it a.href again.  This correctly populates the
     * properties such as protocol, hostname, port, etc.
     *
     * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one
     * uses the inner HTML approach to assign the URL as part of an HTML snippet -
     * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.
     * Unfortunately, setting img[src] to something like "javascript:foo" on IE throws an exception.
     * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that
     * method and IE < 8 is unsupported.
     *
     * References:
     *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
     *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
     *   http://url.spec.whatwg.org/#urlutils
     *   https://github.com/angular/angular.js/pull/2902
     *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/
     *
     * @param {string} url The URL to be parsed.
     * @param {boolean=} parse When true, returns an object for the parsed URL.  Otherwise, returns
     *   a single string that is the normalized URL.
     * @returns {object|string} When parse is true, returns the normalized URL as a string.
     * Otherwise, returns an object with the following members.
     *
     *   | member name   | Description    |
     *   |---------------|----------------|
     *   | href          | A normalized version of the provided URL if it was not an absolute URL |
     *   | protocol      | The protocol including the trailing colon                              |
     *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |
     *
     * These fields from the UrlUtils interface are currently not needed and hence not returned.
     *
     *   | member name   | Description    |
     *   |---------------|----------------|
     *   | hostname      | The host without the port of the normalizedUrl                         |
     *   | pathname      | The path following the host in the normalizedUrl                       |
     *   | hash          | The URL hash if present                                                |
     *   | search        | The query string                                                       |
     *
     */
    function resolve(url, parse) {
      var href = url;
      if (msie <= 11) {
        // Normalize before parse.  Refer Implementation Notes on why this is
        // done in two steps on IE.
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute('href', href);

      if (!parse) {
        return urlParsingNode.href;
      }
      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol,
        host: urlParsingNode.host
        // Currently unused and hence commented out.
        // hostname: urlParsingNode.hostname,
        // port: urlParsingNode.port,
        // pathname: urlParsingNode.pathname,
        // hash: urlParsingNode.hash,
        // search: urlParsingNode.search
      };
    }

    return {
      resolve: resolve,
      /**
       * Parse a request URL and determine whether this is a same-origin request as the application document.
       *
       * @param {string|object} requestUrl The url of the request as a string that will be resolved
       * or a parsed URL object.
       * @returns {boolean} Whether the request is for the same origin as the application document.
       */
      isSameOrigin: function isSameOrigin(requestUrl) {
        var parsed = (typeof requestUrl === 'string') ? resolve(requestUrl, true) : requestUrl;
        return (parsed.protocol === originUrl.protocol &&
                parsed.host === originUrl.host);
      }
    };
  }];
}

/**
 * @ngdoc object
 * @name ng.$window
 *
 * @description
 * A reference to the browser's `window` object. While `window`
 * is globally available in JavaScript, it causes testability problems, because
 * it is a global variable. In angular we always refer to it through the
 * `$window` service, so it may be overridden, removed or mocked for testing.
 *
 * Expressions, like the one defined for the `ngClick` directive in the example
 * below, are evaluated with respect to the current scope.  Therefore, there is
 * no risk of inadvertently coding in a dependency on a global value in such an
 * expression.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope, $window) {
           $scope.$window = $window;
           $scope.greeting = 'Hello, World!';
         }
       </script>
       <div ng-controller="Ctrl">
         <input type="text" ng-model="greeting" />
         <button ng-click="$window.alert(greeting)">ALERT</button>
       </div>
     </doc:source>
     <doc:scenario>
      it('should display the greeting in the input box', function() {
       input('greeting').enter('Hello, E2E Tests');
       // If we click the button it will block the test runner
       // element(':button').click();
      });
     </doc:scenario>
   </doc:example>
 */
function $WindowProvider(){
  this.$get = valueFn(window);
}

/**
 * @ngdoc object
 * @name ng.$filterProvider
 * @description
 *
 * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To
 * achieve this a filter definition consists of a factory function which is annotated with dependencies and is
 * responsible for creating a filter function.
 *
 * <pre>
 *   // Filter registration
 *   function MyModule($provide, $filterProvider) {
 *     // create a service to demonstrate injection (not always needed)
 *     $provide.value('greet', function(name){
 *       return 'Hello ' + name + '!';
 *     });
 *
 *     // register a filter factory which uses the
 *     // greet service to demonstrate DI.
 *     $filterProvider.register('greet', function(greet){
 *       // return the filter function which uses the greet service
 *       // to generate salutation
 *       return function(text) {
 *         // filters need to be forgiving so check input validity
 *         return text && greet(text) || text;
 *       };
 *     });
 *   }
 * </pre>
 *
 * The filter function is registered with the `$injector` under the filter name suffix with `Filter`.
 * <pre>
 *   it('should be the same instance', inject(
 *     function($filterProvider) {
 *       $filterProvider.register('reverse', function(){
 *         return ...;
 *       });
 *     },
 *     function($filter, reverseFilter) {
 *       expect($filter('reverse')).toBe(reverseFilter);
 *     });
 * </pre>
 *
 *
 * For more information about how angular filters work, and how to create your own filters, see
 * {@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer
 * Guide.
 */
/**
 * @ngdoc method
 * @name ng.$filterProvider#register
 * @methodOf ng.$filterProvider
 * @description
 * Register filter factory function.
 *
 * @param {String} name Name of the filter.
 * @param {function} fn The filter factory function which is injectable.
 */


/**
 * @ngdoc function
 * @name ng.$filter
 * @function
 * @description
 * Filters are used for formatting data displayed to the user.
 *
 * The general syntax in templates is as follows:
 *
 *         {{ expression [| filter_name[:parameter_value] ... ] }}
 *
 * @param {String} name Name of the filter function to retrieve
 * @return {Function} the filter function
 */
$FilterProvider.$inject = ['$provide'];
function $FilterProvider($provide) {
  var suffix = 'Filter';

  function register(name, factory) {
    return $provide.factory(name + suffix, factory);
  }
  this.register = register;

  this.$get = ['$injector', function($injector) {
    return function(name) {
      return $injector.get(name + suffix);
    }
  }];

  ////////////////////////////////////////

  register('currency', currencyFilter);
  register('date', dateFilter);
  register('filter', filterFilter);
  register('json', jsonFilter);
  register('limitTo', limitToFilter);
  register('lowercase', lowercaseFilter);
  register('number', numberFilter);
  register('orderBy', orderByFilter);
  register('uppercase', uppercaseFilter);
}

/**
 * @ngdoc filter
 * @name ng.filter:filter
 * @function
 *
 * @description
 * Selects a subset of items from `array` and returns it as a new array.
 *
 * Note: This function is used to augment the `Array` type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {Array} array The source array.
 * @param {string|Object|function()} expression The predicate to be used for selecting items from
 *   `array`.
 *
 *   Can be one of:
 *
 *   - `string`: Predicate that results in a substring match using the value of `expression`
 *     string. All strings or objects with string properties in `array` that contain this string
 *     will be returned. The predicate can be negated by prefixing the string with `!`.
 *
 *   - `Object`: A pattern object can be used to filter specific properties on objects contained
 *     by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items
 *     which have property `name` containing "M" and property `phone` containing "1". A special
 *     property name `$` can be used (as in `{$:"text"}`) to accept a match against any
 *     property of the object. That's equivalent to the simple substring match with a `string`
 *     as described above.
 *
 *   - `function`: A predicate function can be used to write arbitrary filters. The function is
 *     called for each element of `array`. The final result is an array of those elements that
 *     the predicate returned true for.
 *
 * @param {function(expected, actual)|true|undefined} comparator Comparator which is used in
 *     determining if the expected value (from the filter expression) and actual value (from
 *     the object in the array) should be considered a match.
 *
 *   Can be one of:
 *
 *     - `function(expected, actual)`:
 *       The function will be given the object value and the predicate value to compare and
 *       should return true if the item should be included in filtered result.
 *
 *     - `true`: A shorthand for `function(expected, actual) { return angular.equals(expected, actual)}`.
 *       this is essentially strict comparison of expected and actual.
 *
 *     - `false|undefined`: A short hand for a function which will look for a substring match in case
 *       insensitive way.
 *
 * @example
   <doc:example>
     <doc:source>
       <div ng-init="friends = [{name:'John', phone:'555-1276'},
                                {name:'Mary', phone:'800-BIG-MARY'},
                                {name:'Mike', phone:'555-4321'},
                                {name:'Adam', phone:'555-5678'},
                                {name:'Julie', phone:'555-8765'},
                                {name:'Juliette', phone:'555-5678'}]"></div>

       Search: <input ng-model="searchText">
       <table id="searchTextResults">
         <tr><th>Name</th><th>Phone</th></tr>
         <tr ng-repeat="friend in friends | filter:searchText">
           <td>{{friend.name}}</td>
           <td>{{friend.phone}}</td>
         </tr>
       </table>
       <hr>
       Any: <input ng-model="search.$"> <br>
       Name only <input ng-model="search.name"><br>
       Phone only <input ng-model="search.phone"><br>
       Equality <input type="checkbox" ng-model="strict"><br>
       <table id="searchObjResults">
         <tr><th>Name</th><th>Phone</th></tr>
         <tr ng-repeat="friend in friends | filter:search:strict">
           <td>{{friend.name}}</td>
           <td>{{friend.phone}}</td>
         </tr>
       </table>
     </doc:source>
     <doc:scenario>
       it('should search across all fields when filtering with a string', function() {
         input('searchText').enter('m');
         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Mike', 'Adam']);

         input('searchText').enter('76');
         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).
           toEqual(['John', 'Julie']);
       });

       it('should search in specific fields when filtering with a predicate object', function() {
         input('search.$').enter('i');
         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Mike', 'Julie', 'Juliette']);
       });
       it('should use a equal comparison when comparator is true', function() {
         input('search.name').enter('Julie');
         input('strict').check();
         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Julie']);
       });
     </doc:scenario>
   </doc:example>
 */
function filterFilter() {
  return function(array, expression, comperator) {
    if (!isArray(array)) return array;
    var predicates = [];
    predicates.check = function(value) {
      for (var j = 0; j < predicates.length; j++) {
        if(!predicates[j](value)) {
          return false;
        }
      }
      return true;
    };
    switch(typeof comperator) {
      case "function":
        break;
      case "boolean":
        if(comperator == true) {
          comperator = function(obj, text) {
            return angular.equals(obj, text);
          }
          break;
        }
      default:
        comperator = function(obj, text) {
          text = (''+text).toLowerCase();
          return (''+obj).toLowerCase().indexOf(text) > -1
        };
    }
    var search = function(obj, text){
      if (typeof text == 'string' && text.charAt(0) === '!') {
        return !search(obj, text.substr(1));
      }
      switch (typeof obj) {
        case "boolean":
        case "number":
        case "string":
          return comperator(obj, text);
        case "object":
          switch (typeof text) {
            case "object":
              return comperator(obj, text);
              break;
            default:
              for ( var objKey in obj) {
                if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
                  return true;
                }
              }
              break;
          }
          return false;
        case "array":
          for ( var i = 0; i < obj.length; i++) {
            if (search(obj[i], text)) {
              return true;
            }
          }
          return false;
        default:
          return false;
      }
    };
    switch (typeof expression) {
      case "boolean":
      case "number":
      case "string":
        expression = {$:expression};
      case "object":
        for (var key in expression) {
          if (key == '$') {
            (function() {
              if (!expression[key]) return;
              var path = key
              predicates.push(function(value) {
                return search(value, expression[path]);
              });
            })();
          } else {
            (function() {
              if (typeof(expression[key]) == 'undefined') { return; }
              var path = key;
              predicates.push(function(value) {
                return search(getter(value,path), expression[path]);
              });
            })();
          }
        }
        break;
      case 'function':
        predicates.push(expression);
        break;
      default:
        return array;
    }
    var filtered = [];
    for ( var j = 0; j < array.length; j++) {
      var value = array[j];
      if (predicates.check(value)) {
        filtered.push(value);
      }
    }
    return filtered;
  }
}

/**
 * @ngdoc filter
 * @name ng.filter:currency
 * @function
 *
 * @description
 * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
 * symbol for current locale is used.
 *
 * @param {number} amount Input to filter.
 * @param {string=} symbol Currency symbol or identifier to be displayed.
 * @returns {string} Formatted number.
 *
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.amount = 1234.56;
         }
       </script>
       <div ng-controller="Ctrl">
         <input type="number" ng-model="amount"> <br>
         default currency symbol ($): {{amount | currency}}<br>
         custom currency identifier (USD$): {{amount | currency:"USD$"}}
       </div>
     </doc:source>
     <doc:scenario>
       it('should init with 1234.56', function() {
         expect(binding('amount | currency')).toBe('$1,234.56');
         expect(binding('amount | currency:"USD$"')).toBe('USD$1,234.56');
       });
       it('should update', function() {
         input('amount').enter('-1234');
         expect(binding('amount | currency')).toBe('($1,234.00)');
         expect(binding('amount | currency:"USD$"')).toBe('(USD$1,234.00)');
       });
     </doc:scenario>
   </doc:example>
 */
currencyFilter.$inject = ['$locale'];
function currencyFilter($locale) {
  var formats = $locale.NUMBER_FORMATS;
  return function(amount, currencySymbol){
    if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;
    return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).
                replace(/\u00A4/g, currencySymbol);
  };
}

/**
 * @ngdoc filter
 * @name ng.filter:number
 * @function
 *
 * @description
 * Formats a number as text.
 *
 * If the input is not a number an empty string is returned.
 *
 * @param {number|string} number Number to format.
 * @param {(number|string)=} fractionSize Number of decimal places to round the number to.
 * If this is not provided then the fraction size is computed from the current locale's number
 * formatting pattern. In the case of the default locale, it will be 3.
 * @returns {string} Number rounded to decimalPlaces and places a , after each third digit.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.val = 1234.56789;
         }
       </script>
       <div ng-controller="Ctrl">
         Enter number: <input ng-model='val'><br>
         Default formatting: {{val | number}}<br>
         No fractions: {{val | number:0}}<br>
         Negative number: {{-val | number:4}}
       </div>
     </doc:source>
     <doc:scenario>
       it('should format numbers', function() {
         expect(binding('val | number')).toBe('1,234.568');
         expect(binding('val | number:0')).toBe('1,235');
         expect(binding('-val | number:4')).toBe('-1,234.5679');
       });

       it('should update', function() {
         input('val').enter('3374.333');
         expect(binding('val | number')).toBe('3,374.333');
         expect(binding('val | number:0')).toBe('3,374');
         expect(binding('-val | number:4')).toBe('-3,374.3330');
       });
     </doc:scenario>
   </doc:example>
 */


numberFilter.$inject = ['$locale'];
function numberFilter($locale) {
  var formats = $locale.NUMBER_FORMATS;
  return function(number, fractionSize) {
    return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
      fractionSize);
  };
}

var DECIMAL_SEP = '.';
function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
  if (isNaN(number) || !isFinite(number)) return '';

  var isNegative = number < 0;
  number = Math.abs(number);
  var numStr = number + '',
      formatedText = '',
      parts = [];

  var hasExponent = false;
  if (numStr.indexOf('e') !== -1) {
    var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
    if (match && match[2] == '-' && match[3] > fractionSize + 1) {
      numStr = '0';
    } else {
      formatedText = numStr;
      hasExponent = true;
    }
  }

  if (!hasExponent) {
    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;

    // determine fractionSize if it is not specified
    if (isUndefined(fractionSize)) {
      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
    }

    var pow = Math.pow(10, fractionSize);
    number = Math.round(number * pow) / pow;
    var fraction = ('' + number).split(DECIMAL_SEP);
    var whole = fraction[0];
    fraction = fraction[1] || '';

    var pos = 0,
        lgroup = pattern.lgSize,
        group = pattern.gSize;

    if (whole.length >= (lgroup + group)) {
      pos = whole.length - lgroup;
      for (var i = 0; i < pos; i++) {
        if ((pos - i)%group === 0 && i !== 0) {
          formatedText += groupSep;
        }
        formatedText += whole.charAt(i);
      }
    }

    for (i = pos; i < whole.length; i++) {
      if ((whole.length - i)%lgroup === 0 && i !== 0) {
        formatedText += groupSep;
      }
      formatedText += whole.charAt(i);
    }

    // format fraction part.
    while(fraction.length < fractionSize) {
      fraction += '0';
    }

    if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
  } else {

    if (fractionSize > 0 && number > -1 && number < 1) {
      formatedText = number.toFixed(fractionSize);
    }
  }

  parts.push(isNegative ? pattern.negPre : pattern.posPre);
  parts.push(formatedText);
  parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
  return parts.join('');
}

function padNumber(num, digits, trim) {
  var neg = '';
  if (num < 0) {
    neg =  '-';
    num = -num;
  }
  num = '' + num;
  while(num.length < digits) num = '0' + num;
  if (trim)
    num = num.substr(num.length - digits);
  return neg + num;
}


function dateGetter(name, size, offset, trim) {
  offset = offset || 0;
  return function(date) {
    var value = date['get' + name]();
    if (offset > 0 || value > -offset)
      value += offset;
    if (value === 0 && offset == -12 ) value = 12;
    return padNumber(value, size, trim);
  };
}

function dateStrGetter(name, shortForm) {
  return function(date, formats) {
    var value = date['get' + name]();
    var get = uppercase(shortForm ? ('SHORT' + name) : name);

    return formats[get][value];
  };
}

function timeZoneGetter(date) {
  var zone = -1 * date.getTimezoneOffset();
  var paddedZone = (zone >= 0) ? "+" : "";

  paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +
                padNumber(Math.abs(zone % 60), 2);

  return paddedZone;
}

function ampmGetter(date, formats) {
  return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
}

var DATE_FORMATS = {
  yyyy: dateGetter('FullYear', 4),
    yy: dateGetter('FullYear', 2, 0, true),
     y: dateGetter('FullYear', 1),
  MMMM: dateStrGetter('Month'),
   MMM: dateStrGetter('Month', true),
    MM: dateGetter('Month', 2, 1),
     M: dateGetter('Month', 1, 1),
    dd: dateGetter('Date', 2),
     d: dateGetter('Date', 1),
    HH: dateGetter('Hours', 2),
     H: dateGetter('Hours', 1),
    hh: dateGetter('Hours', 2, -12),
     h: dateGetter('Hours', 1, -12),
    mm: dateGetter('Minutes', 2),
     m: dateGetter('Minutes', 1),
    ss: dateGetter('Seconds', 2),
     s: dateGetter('Seconds', 1),
     // while ISO 8601 requires fractions to be prefixed with `.` or `,`
     // we can be just safely rely on using `sss` since we currently don't support single or two digit fractions
   sss: dateGetter('Milliseconds', 3),
  EEEE: dateStrGetter('Day'),
   EEE: dateStrGetter('Day', true),
     a: ampmGetter,
     Z: timeZoneGetter
};

var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,
    NUMBER_STRING = /^\d+$/;

/**
 * @ngdoc filter
 * @name ng.filter:date
 * @function
 *
 * @description
 *   Formats `date` to a string based on the requested `format`.
 *
 *   `format` string can be composed of the following elements:
 *
 *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
 *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
 *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
 *   * `'MMMM'`: Month in year (January-December)
 *   * `'MMM'`: Month in year (Jan-Dec)
 *   * `'MM'`: Month in year, padded (01-12)
 *   * `'M'`: Month in year (1-12)
 *   * `'dd'`: Day in month, padded (01-31)
 *   * `'d'`: Day in month (1-31)
 *   * `'EEEE'`: Day in Week,(Sunday-Saturday)
 *   * `'EEE'`: Day in Week, (Sun-Sat)
 *   * `'HH'`: Hour in day, padded (00-23)
 *   * `'H'`: Hour in day (0-23)
 *   * `'hh'`: Hour in am/pm, padded (01-12)
 *   * `'h'`: Hour in am/pm, (1-12)
 *   * `'mm'`: Minute in hour, padded (00-59)
 *   * `'m'`: Minute in hour (0-59)
 *   * `'ss'`: Second in minute, padded (00-59)
 *   * `'s'`: Second in minute (0-59)
 *   * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)
 *   * `'a'`: am/pm marker
 *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)
 *
 *   `format` string can also be one of the following predefined
 *   {@link guide/i18n localizable formats}:
 *
 *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale
 *     (e.g. Sep 3, 2010 12:05:08 pm)
 *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)
 *   * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale
 *     (e.g. Friday, September 3, 2010)
 *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010)
 *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)
 *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)
 *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)
 *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)
 *
 *   `format` string can contain literal values. These need to be quoted with single quotes (e.g.
 *   `"h 'in the morning'"`). In order to output single quote, use two single quotes in a sequence
 *   (e.g. `"h 'o''clock'"`).
 *
 * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or
 *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and its
 *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is
 *    specified in the string input, the time is considered to be in the local timezone.
 * @param {string=} format Formatting rules (see Description). If not specified,
 *    `mediumDate` is used.
 * @returns {string} Formatted string or the input if input is not recognized as date/millis.
 *
 * @example
   <doc:example>
     <doc:source>
       <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:
           {{1288323623006 | date:'medium'}}<br>
       <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
          {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}<br>
       <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:
          {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}<br>
     </doc:source>
     <doc:scenario>
       it('should format date', function() {
         expect(binding("1288323623006 | date:'medium'")).
            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);
         expect(binding("1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'")).
            toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} (\-|\+)?\d{4}/);
         expect(binding("'1288323623006' | date:'MM/dd/yyyy @ h:mma'")).
            toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);
       });
     </doc:scenario>
   </doc:example>
 */
dateFilter.$inject = ['$locale'];
function dateFilter($locale) {


  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
                     // 1        2       3         4          5          6          7          8  9     10      11
  function jsonStringToDate(string) {
    var match;
    if (match = string.match(R_ISO8601_STR)) {
      var date = new Date(0),
          tzHour = 0,
          tzMin  = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;

      if (match[9]) {
        tzHour = int(match[9] + match[10]);
        tzMin = int(match[9] + match[11]);
      }
      dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
      var h = int(match[4]||0) - tzHour;
      var m = int(match[5]||0) - tzMin
      var s = int(match[6]||0);
      var ms = Math.round(parseFloat('0.' + (match[7]||0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      return date;
    }
    return string;
  }


  return function(date, format) {
    var text = '',
        parts = [],
        fn, match;

    format = format || 'mediumDate';
    format = $locale.DATETIME_FORMATS[format] || format;
    if (isString(date)) {
      if (NUMBER_STRING.test(date)) {
        date = int(date);
      } else {
        date = jsonStringToDate(date);
      }
    }

    if (isNumber(date)) {
      date = new Date(date);
    }

    if (!isDate(date)) {
      return date;
    }

    while(format) {
      match = DATE_FORMATS_SPLIT.exec(format);
      if (match) {
        parts = concat(parts, match, 1);
        format = parts.pop();
      } else {
        parts.push(format);
        format = null;
      }
    }

    forEach(parts, function(value){
      fn = DATE_FORMATS[value];
      text += fn ? fn(date, $locale.DATETIME_FORMATS)
                 : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
    });

    return text;
  };
}


/**
 * @ngdoc filter
 * @name ng.filter:json
 * @function
 *
 * @description
 *   Allows you to convert a JavaScript object into JSON string.
 *
 *   This filter is mostly useful for debugging. When using the double curly {{value}} notation
 *   the binding is automatically converted to JSON.
 *
 * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.
 * @returns {string} JSON string.
 *
 *
 * @example:
   <doc:example>
     <doc:source>
       <pre>{{ {'name':'value'} | json }}</pre>
     </doc:source>
     <doc:scenario>
       it('should jsonify filtered objects', function() {
         expect(binding("{'name':'value'}")).toMatch(/\{\n  "name": ?"value"\n}/);
       });
     </doc:scenario>
   </doc:example>
 *
 */
function jsonFilter() {
  return function(object) {
    return toJson(object, true);
  };
}


/**
 * @ngdoc filter
 * @name ng.filter:lowercase
 * @function
 * @description
 * Converts string to lowercase.
 * @see angular.lowercase
 */
var lowercaseFilter = valueFn(lowercase);


/**
 * @ngdoc filter
 * @name ng.filter:uppercase
 * @function
 * @description
 * Converts string to uppercase.
 * @see angular.uppercase
 */
var uppercaseFilter = valueFn(uppercase);

/**
 * @ngdoc function
 * @name ng.filter:limitTo
 * @function
 *
 * @description
 * Creates a new array or string containing only a specified number of elements. The elements
 * are taken from either the beginning or the end of the source array or string, as specified by
 * the value and sign (positive or negative) of `limit`.
 *
 * Note: This function is used to augment the `Array` type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {Array|string} input Source array or string to be limited.
 * @param {string|number} limit The length of the returned array or string. If the `limit` number 
 *     is positive, `limit` number of items from the beginning of the source array/string are copied.
 *     If the number is negative, `limit` number  of items from the end of the source array/string 
 *     are copied. The `limit` will be trimmed if it exceeds `array.length`
 * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array
 *     had less than `limit` elements.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.numbers = [1,2,3,4,5,6,7,8,9];
           $scope.letters = "abcdefghi";
           $scope.numLimit = 3;
           $scope.letterLimit = 3;
         }
       </script>
       <div ng-controller="Ctrl">
         Limit {{numbers}} to: <input type="integer" ng-model="numLimit">
         <p>Output numbers: {{ numbers | limitTo:numLimit }}</p>
         Limit {{letters}} to: <input type="integer" ng-model="letterLimit">
         <p>Output letters: {{ letters | limitTo:letterLimit }}</p>
       </div>
     </doc:source>
     <doc:scenario>
       it('should limit the number array to first three items', function() {
         expect(element('.doc-example-live input[ng-model=numLimit]').val()).toBe('3');
         expect(element('.doc-example-live input[ng-model=letterLimit]').val()).toBe('3');
         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('abc');
       });

       it('should update the output when -3 is entered', function() {
         input('numLimit').enter(-3);
         input('letterLimit').enter(-3);
         expect(binding('numbers | limitTo:numLimit')).toEqual('[7,8,9]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('ghi');
       });

       it('should not exceed the maximum size of input array', function() {
         input('numLimit').enter(100);
         input('letterLimit').enter(100);
         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3,4,5,6,7,8,9]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('abcdefghi');
       });
     </doc:scenario>
   </doc:example>
 */
function limitToFilter(){
  return function(input, limit) {
    if (!isArray(input) && !isString(input)) return input;
    
    limit = int(limit);

    if (isString(input)) {
      //NaN check on limit
      if (limit) {
        return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
      } else {
        return "";
      }
    }

    var out = [],
      i, n;

    // if abs(limit) exceeds maximum length, trim it
    if (limit > input.length)
      limit = input.length;
    else if (limit < -input.length)
      limit = -input.length;

    if (limit > 0) {
      i = 0;
      n = limit;
    } else {
      i = input.length + limit;
      n = input.length;
    }

    for (; i<n; i++) {
      out.push(input[i]);
    }

    return out;
  }
}

/**
 * @ngdoc function
 * @name ng.filter:orderBy
 * @function
 *
 * @description
 * Orders a specified `array` by the `expression` predicate.
 *
 * Note: this function is used to augment the `Array` type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {Array} array The array to sort.
 * @param {function(*)|string|Array.<(function(*)|string)>} expression A predicate to be
 *    used by the comparator to determine the order of elements.
 *
 *    Can be one of:
 *
 *    - `function`: Getter function. The result of this function will be sorted using the
 *      `<`, `=`, `>` operator.
 *    - `string`: An Angular expression which evaluates to an object to order by, such as 'name'
 *      to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control
 *      ascending or descending sort order (for example, +name or -name).
 *    - `Array`: An array of function or string predicates. The first predicate in the array
 *      is used for sorting, but when two items are equivalent, the next predicate is used.
 *
 * @param {boolean=} reverse Reverse the order the array.
 * @returns {Array} Sorted copy of the source array.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.friends =
               [{name:'John', phone:'555-1212', age:10},
                {name:'Mary', phone:'555-9876', age:19},
                {name:'Mike', phone:'555-4321', age:21},
                {name:'Adam', phone:'555-5678', age:35},
                {name:'Julie', phone:'555-8765', age:29}]
           $scope.predicate = '-age';
         }
       </script>
       <div ng-controller="Ctrl">
         <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>
         <hr/>
         [ <a href="" ng-click="predicate=''">unsorted</a> ]
         <table class="friend">
           <tr>
             <th><a href="" ng-click="predicate = 'name'; reverse=false">Name</a>
                 (<a href ng-click="predicate = '-name'; reverse=false">^</a>)</th>
             <th><a href="" ng-click="predicate = 'phone'; reverse=!reverse">Phone Number</a></th>
             <th><a href="" ng-click="predicate = 'age'; reverse=!reverse">Age</a></th>
           </tr>
           <tr ng-repeat="friend in friends | orderBy:predicate:reverse">
             <td>{{friend.name}}</td>
             <td>{{friend.phone}}</td>
             <td>{{friend.age}}</td>
           </tr>
         </table>
       </div>
     </doc:source>
     <doc:scenario>
       it('should be reverse ordered by aged', function() {
         expect(binding('predicate')).toBe('-age');
         expect(repeater('table.friend', 'friend in friends').column('friend.age')).
           toEqual(['35', '29', '21', '19', '10']);
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);
       });

       it('should reorder the table when user selects different predicate', function() {
         element('.doc-example-live a:contains("Name")').click();
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);
         expect(repeater('table.friend', 'friend in friends').column('friend.age')).
           toEqual(['35', '10', '29', '19', '21']);

         element('.doc-example-live a:contains("Phone")').click();
         expect(repeater('table.friend', 'friend in friends').column('friend.phone')).
           toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);
       });
     </doc:scenario>
   </doc:example>
 */
orderByFilter.$inject = ['$parse'];
function orderByFilter($parse){
  return function(array, sortPredicate, reverseOrder) {
    if (!isArray(array)) return array;
    if (!sortPredicate) return array;
    sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];
    sortPredicate = map(sortPredicate, function(predicate){
      var descending = false, get = predicate || identity;
      if (isString(predicate)) {
        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
          descending = predicate.charAt(0) == '-';
          predicate = predicate.substring(1);
        }
        get = $parse(predicate);
      }
      return reverseComparator(function(a,b){
        return compare(get(a),get(b));
      }, descending);
    });
    var arrayCopy = [];
    for ( var i = 0; i < array.length; i++) { arrayCopy.push(array[i]); }
    return arrayCopy.sort(reverseComparator(comparator, reverseOrder));

    function comparator(o1, o2){
      for ( var i = 0; i < sortPredicate.length; i++) {
        var comp = sortPredicate[i](o1, o2);
        if (comp !== 0) return comp;
      }
      return 0;
    }
    function reverseComparator(comp, descending) {
      return toBoolean(descending)
          ? function(a,b){return comp(b,a);}
          : comp;
    }
    function compare(v1, v2){
      var t1 = typeof v1;
      var t2 = typeof v2;
      if (t1 == t2) {
        if (t1 == "string") {
           v1 = v1.toLowerCase();
           v2 = v2.toLowerCase();
        }
        if (v1 === v2) return 0;
        return v1 < v2 ? -1 : 1;
      } else {
        return t1 < t2 ? -1 : 1;
      }
    }
  }
}

function ngDirective(directive) {
  if (isFunction(directive)) {
    directive = {
      link: directive
    }
  }
  directive.restrict = directive.restrict || 'AC';
  return valueFn(directive);
}

/**
 * @ngdoc directive
 * @name ng.directive:a
 * @restrict E
 *
 * @description
 * Modifies the default behavior of html A tag, so that the default action is prevented when href
 * attribute is empty.
 *
 * The reasoning for this change is to allow easy creation of action links with `ngClick` directive
 * without changing the location or causing page reloads, e.g.:
 * `<a href="" ng-click="model.$save()">Save</a>`
 */
var htmlAnchorDirective = valueFn({
  restrict: 'E',
  compile: function(element, attr) {

    if (msie <= 8) {

      // turn <a href ng-click="..">link</a> into a stylable link in IE
      // but only if it doesn't have name attribute, in which case it's an anchor
      if (!attr.href && !attr.name) {
        attr.$set('href', '');
      }

      // add a comment node to anchors to workaround IE bug that causes element content to be reset
      // to new attribute content if attribute is updated with value containing @ and element also
      // contains value with @
      // see issue #1949
      element.append(document.createComment('IE fix'));
    }

    return function(scope, element) {
      element.on('click', function(event){
        // if we have no href url, then don't navigate anywhere.
        if (!element.attr('href')) {
          event.preventDefault();
        }
      });
    }
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngHref
 * @restrict A
 *
 * @description
 * Using Angular markup like {{hash}} in an href attribute makes
 * the page open to a wrong URL, if the user clicks that link before
 * angular has a chance to replace the {{hash}} with actual URL, the
 * link will be broken and will most likely return a 404 error.
 * The `ngHref` directive solves this problem.
 *
 * The buggy way to write it:
 * <pre>
 * <a href="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * The correct way to write it:
 * <pre>
 * <a ng-href="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * @element A
 * @param {template} ngHref any string which can contain `{{}}` markup.
 *
 * @example
 * This example uses `link` variable inside `href` attribute:
    <doc:example>
      <doc:source>
        <input ng-model="value" /><br />
        <a id="link-1" href ng-click="value = 1">link 1</a> (link, don't reload)<br />
        <a id="link-2" href="" ng-click="value = 2">link 2</a> (link, don't reload)<br />
        <a id="link-3" ng-href="/{{'123'}}">link 3</a> (link, reload!)<br />
        <a id="link-4" href="" name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
        <a id="link-5" name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
        <a id="link-6" ng-href="{{value}}">link</a> (link, change location)
      </doc:source>
      <doc:scenario>
        it('should execute ng-click but not reload when href without value', function() {
          element('#link-1').click();
          expect(input('value').val()).toEqual('1');
          expect(element('#link-1').attr('href')).toBe("");
        });

        it('should execute ng-click but not reload when href empty string', function() {
          element('#link-2').click();
          expect(input('value').val()).toEqual('2');
          expect(element('#link-2').attr('href')).toBe("");
        });

        it('should execute ng-click and change url when ng-href specified', function() {
          expect(element('#link-3').attr('href')).toBe("/123");

          element('#link-3').click();
          expect(browser().window().path()).toEqual('/123');
        });

        it('should execute ng-click but not reload when href empty string and name specified', function() {
          element('#link-4').click();
          expect(input('value').val()).toEqual('4');
          expect(element('#link-4').attr('href')).toBe('');
        });

        it('should execute ng-click but not reload when no href but name specified', function() {
          element('#link-5').click();
          expect(input('value').val()).toEqual('5');
          expect(element('#link-5').attr('href')).toBe(undefined);
        });

        it('should only change url when only ng-href', function() {
          input('value').enter('6');
          expect(element('#link-6').attr('href')).toBe('6');

          element('#link-6').click();
          expect(browser().location().url()).toEqual('/6');
        });
      </doc:scenario>
    </doc:example>
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngSrc
 * @restrict A
 *
 * @description
 * Using Angular markup like `{{hash}}` in a `src` attribute doesn't
 * work right: The browser will fetch from the URL with the literal
 * text `{{hash}}` until Angular replaces the expression inside
 * `{{hash}}`. The `ngSrc` directive solves this problem.
 *
 * The buggy way to write it:
 * <pre>
 * <img src="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * The correct way to write it:
 * <pre>
 * <img ng-src="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * @element IMG
 * @param {template} ngSrc any string which can contain `{{}}` markup.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngSrcset
 * @restrict A
 *
 * @description
 * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't
 * work right: The browser will fetch from the URL with the literal
 * text `{{hash}}` until Angular replaces the expression inside
 * `{{hash}}`. The `ngSrcset` directive solves this problem.
 *
 * The buggy way to write it:
 * <pre>
 * <img srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
 * </pre>
 *
 * The correct way to write it:
 * <pre>
 * <img ng-srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
 * </pre>
 *
 * @element IMG
 * @param {template} ngSrcset any string which can contain `{{}}` markup.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngDisabled
 * @restrict A
 *
 * @description
 *
 * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:
 * <pre>
 * <div ng-init="scope = { isDisabled: false }">
 *  <button disabled="{{scope.isDisabled}}">Disabled</button>
 * </div>
 * </pre>
 *
 * The HTML specs do not require browsers to preserve the special attributes such as disabled.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the `ngDisabled` directive.
 *
 * @example
    <doc:example>
      <doc:source>
        Click me to toggle: <input type="checkbox" ng-model="checked"><br/>
        <button ng-model="button" ng-disabled="checked">Button</button>
      </doc:source>
      <doc:scenario>
        it('should toggle button', function() {
          expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();
          input('checked').check();
          expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element INPUT
 * @param {expression} ngDisabled Angular expression that will be evaluated.
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngChecked
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as checked.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the `ngChecked` directive.
 * @example
    <doc:example>
      <doc:source>
        Check me to check both: <input type="checkbox" ng-model="master"><br/>
        <input id="checkSlave" type="checkbox" ng-checked="master">
      </doc:source>
      <doc:scenario>
        it('should check both checkBoxes', function() {
          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();
          input('master').check();
          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element INPUT
 * @param {expression} ngChecked Angular expression that will be evaluated.
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngReadonly
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as readonly.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the `ngReadonly` directive.
 * @example
    <doc:example>
      <doc:source>
        Check me to make text readonly: <input type="checkbox" ng-model="checked"><br/>
        <input type="text" ng-readonly="checked" value="I'm Angular"/>
      </doc:source>
      <doc:scenario>
        it('should toggle readonly attr', function() {
          expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();
          input('checked').check();
          expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element INPUT
 * @param {string} expression Angular expression that will be evaluated.
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngSelected
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as selected.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduced the `ngSelected` directive.
 * @example
    <doc:example>
      <doc:source>
        Check me to select: <input type="checkbox" ng-model="selected"><br/>
        <select>
          <option>Hello!</option>
          <option id="greet" ng-selected="selected">Greetings!</option>
        </select>
      </doc:source>
      <doc:scenario>
        it('should select Greetings!', function() {
          expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();
          input('selected').check();
          expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element OPTION
 * @param {string} expression Angular expression that will be evaluated.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngOpen
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as open.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the `ngOpen` directive.
 *
 * @example
     <doc:example>
       <doc:source>
         Check me check multiple: <input type="checkbox" ng-model="open"><br/>
         <details id="details" ng-open="open">
            <summary>Show/Hide me</summary>
         </details>
       </doc:source>
       <doc:scenario>
         it('should toggle open', function() {
           expect(element('#details').prop('open')).toBeFalsy();
           input('open').check();
           expect(element('#details').prop('open')).toBeTruthy();
         });
       </doc:scenario>
     </doc:example>
 *
 * @element DETAILS
 * @param {string} expression Angular expression that will be evaluated.
 */

var ngAttributeAliasDirectives = {};


// boolean attrs are evaluated
forEach(BOOLEAN_ATTR, function(propName, attrName) {
  // binding to multiple is not supported
  if (propName == "multiple") return;

  var normalized = directiveNormalize('ng-' + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      priority: 100,
      compile: function() {
        return function(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        };
      }
    };
  };
});


// ng-src, ng-srcset, ng-href are interpolated
forEach(['src', 'srcset', 'href'], function(attrName) {
  var normalized = directiveNormalize('ng-' + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      priority: 99, // it needs to run after the attributes are interpolated
      link: function(scope, element, attr) {
        attr.$observe(normalized, function(value) {
          if (!value)
             return;

          attr.$set(attrName, value);

          // on IE, if "ng:src" directive declaration is used and "src" attribute doesn't exist
          // then calling element.setAttribute('src', 'foo') doesn't do anything, so we need
          // to set the property as well to achieve the desired effect.
          // we use attr[attrName] value since $set can sanitize the url.
          if (msie) element.prop(attrName, attr[attrName]);
        });
      }
    };
  };
});

var nullFormCtrl = {
  $addControl: noop,
  $removeControl: noop,
  $setValidity: noop,
  $setDirty: noop,
  $setPristine: noop
};

/**
 * @ngdoc object
 * @name ng.directive:form.FormController
 *
 * @property {boolean} $pristine True if user has not interacted with the form yet.
 * @property {boolean} $dirty True if user has already interacted with the form.
 * @property {boolean} $valid True if all of the containing forms and controls are valid.
 * @property {boolean} $invalid True if at least one containing control or form is invalid.
 *
 * @property {Object} $error Is an object hash, containing references to all invalid controls or
 *  forms, where:
 *
 *  - keys are validation tokens (error names)  such as `required`, `url` or `email`),
 *  - values are arrays of controls or forms that are invalid with given error.
 *
 * @description
 * `FormController` keeps track of all its controls and nested forms as well as state of them,
 * such as being valid/invalid or dirty/pristine.
 *
 * Each {@link ng.directive:form form} directive creates an instance
 * of `FormController`.
 *
 */
//asks for $scope to fool the BC controller module
FormController.$inject = ['$element', '$attrs', '$scope'];
function FormController(element, attrs) {
  var form = this,
      parentForm = element.parent().controller('form') || nullFormCtrl,
      invalidCount = 0, // used to easily determine if we are valid
      errors = form.$error = {},
      controls = [];

  // init state
  form.$name = attrs.name || attrs.ngForm;
  form.$dirty = false;
  form.$pristine = true;
  form.$valid = true;
  form.$invalid = false;

  parentForm.$addControl(form);

  // Setup initial state of the control
  element.addClass(PRISTINE_CLASS);
  toggleValidCss(true);

  // convenience method for easy toggling of classes
  function toggleValidCss(isValid, validationErrorKey) {
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
    element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  }

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$addControl
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Register a control with the form.
   *
   * Input elements using ngModelController do this automatically when they are linked.
   */
  form.$addControl = function(control) {
    controls.push(control);

    if (control.$name && !form.hasOwnProperty(control.$name)) {
      form[control.$name] = control;
    }
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$removeControl
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Deregister a control from the form.
   *
   * Input elements using ngModelController do this automatically when they are destroyed.
   */
  form.$removeControl = function(control) {
    if (control.$name && form[control.$name] === control) {
      delete form[control.$name];
    }
    forEach(errors, function(queue, validationToken) {
      form.$setValidity(validationToken, true, control);
    });

    arrayRemove(controls, control);
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$setValidity
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Sets the validity of a form control.
   *
   * This method will also propagate to parent forms.
   */
  form.$setValidity = function(validationToken, isValid, control) {
    var queue = errors[validationToken];

    if (isValid) {
      if (queue) {
        arrayRemove(queue, control);
        if (!queue.length) {
          invalidCount--;
          if (!invalidCount) {
            toggleValidCss(isValid);
            form.$valid = true;
            form.$invalid = false;
          }
          errors[validationToken] = false;
          toggleValidCss(true, validationToken);
          parentForm.$setValidity(validationToken, true, form);
        }
      }

    } else {
      if (!invalidCount) {
        toggleValidCss(isValid);
      }
      if (queue) {
        if (includes(queue, control)) return;
      } else {
        errors[validationToken] = queue = [];
        invalidCount++;
        toggleValidCss(false, validationToken);
        parentForm.$setValidity(validationToken, false, form);
      }
      queue.push(control);

      form.$valid = false;
      form.$invalid = true;
    }
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$setDirty
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Sets the form to a dirty state.
   *
   * This method can be called to add the 'ng-dirty' class and set the form to a dirty
   * state (ng-dirty class). This method will also propagate to parent forms.
   */
  form.$setDirty = function() {
    element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
    form.$dirty = true;
    form.$pristine = false;
    parentForm.$setDirty();
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$setPristine
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Sets the form to its pristine state.
   *
   * This method can be called to remove the 'ng-dirty' class and set the form to its pristine
   * state (ng-pristine class). This method will also propagate to all the controls contained
   * in this form.
   *
   * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after
   * saving or resetting it.
   */
  form.$setPristine = function () {
    element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
    form.$dirty = false;
    form.$pristine = true;
    forEach(controls, function(control) {
      control.$setPristine();
    });
  };
}


/**
 * @ngdoc directive
 * @name ng.directive:ngForm
 * @restrict EAC
 *
 * @description
 * Nestable alias of {@link ng.directive:form `form`} directive. HTML
 * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a
 * sub-group of controls needs to be determined.
 *
 * @param {string=} name|ngForm Name of the form. If specified, the form controller will be published into
 *                       related scope, under this name.
 *
 */

 /**
 * @ngdoc directive
 * @name ng.directive:form
 * @restrict E
 *
 * @description
 * Directive that instantiates
 * {@link ng.directive:form.FormController FormController}.
 *
 * If `name` attribute is specified, the form controller is published onto the current scope under
 * this name.
 *
 * # Alias: {@link ng.directive:ngForm `ngForm`}
 *
 * In angular forms can be nested. This means that the outer form is valid when all of the child
 * forms are valid as well. However browsers do not allow nesting of `<form>` elements, for this
 * reason angular provides {@link ng.directive:ngForm `ngForm`} alias
 * which behaves identical to `<form>` but allows form nesting.
 *
 *
 * # CSS classes
 *  - `ng-valid` Is set if the form is valid.
 *  - `ng-invalid` Is set if the form is invalid.
 *  - `ng-pristine` Is set if the form is pristine.
 *  - `ng-dirty` Is set if the form is dirty.
 *
 *
 * # Submitting a form and preventing default action
 *
 * Since the role of forms in client-side Angular applications is different than in classical
 * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
 * page reload that sends the data to the server. Instead some javascript logic should be triggered
 * to handle the form submission in application specific way.
 *
 * For this reason, Angular prevents the default action (form submission to the server) unless the
 * `<form>` element has an `action` attribute specified.
 *
 * You can use one of the following two ways to specify what javascript method should be called when
 * a form is submitted:
 *
 * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element
 * - {@link ng.directive:ngClick ngClick} directive on the first
  *  button or input field of type submit (input[type=submit])
 *
 * To prevent double execution of the handler, use only one of ngSubmit or ngClick directives. This
 * is because of the following form submission rules coming from the html spec:
 *
 * - If a form has only one input field then hitting enter in this field triggers form submit
 * (`ngSubmit`)
 * - if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter
 * doesn't trigger submit
 * - if a form has one or more input fields and one or more buttons or input[type=submit] then
 * hitting enter in any of the input fields will trigger the click handler on the *first* button or
 * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
 *
 * @param {string=} name Name of the form. If specified, the form controller will be published into
 *                       related scope, under this name.
 *
 * @example
    <doc:example>
      <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.userType = 'guest';
         }
       </script>
       <form name="myForm" ng-controller="Ctrl">
         userType: <input name="input" ng-model="userType" required>
         <span class="error" ng-show="myForm.input.$error.required">Required!</span><br>
         <tt>userType = {{userType}}</tt><br>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
        </form>
      </doc:source>
      <doc:scenario>
        it('should initialize to model', function() {
         expect(binding('userType')).toEqual('guest');
         expect(binding('myForm.input.$valid')).toEqual('true');
        });

        it('should be invalid if empty', function() {
         input('userType').enter('');
         expect(binding('userType')).toEqual('');
         expect(binding('myForm.input.$valid')).toEqual('false');
        });
      </doc:scenario>
    </doc:example>
 */
var formDirectiveFactory = function(isNgForm) {
  return ['$timeout', function($timeout) {
    var formDirective = {
      name: 'form',
      restrict: 'E',
      controller: FormController,
      compile: function() {
        return {
          pre: function(scope, formElement, attr, controller) {
            if (!attr.action) {
              // we can't use jq events because if a form is destroyed during submission the default
              // action is not prevented. see #1238
              //
              // IE 9 is not affected because it doesn't fire a submit event and try to do a full
              // page reload if the form was destroyed by submission of the form via a click handler
              // on a button in the form. Looks like an IE9 specific bug.
              var preventDefaultListener = function(event) {
                event.preventDefault
                  ? event.preventDefault()
                  : event.returnValue = false; // IE
              };

              addEventListenerFn(formElement[0], 'submit', preventDefaultListener);

              // unregister the preventDefault listener so that we don't not leak memory but in a
              // way that will achieve the prevention of the default action.
              formElement.on('$destroy', function() {
                $timeout(function() {
                  removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                }, 0, false);
              });
            }

            var parentFormCtrl = formElement.parent().controller('form'),
                alias = attr.name || attr.ngForm;

            if (alias) {
              setter(scope, alias, controller, alias);
            }
            if (parentFormCtrl) {
              formElement.on('$destroy', function() {
                parentFormCtrl.$removeControl(controller);
                if (alias) {
                  setter(scope, alias, undefined, alias);
                }
                extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
              });
            }
          }
        };
      }
    };

    return isNgForm ? extend(copy(formDirective), {restrict: 'EAC'}) : formDirective;
  }];
};

var formDirective = formDirectiveFactory();
var ngFormDirective = formDirectiveFactory(true);

var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}$/;
var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;

var inputType = {

  /**
   * @ngdoc inputType
   * @name ng.directive:input.text
   *
   * @description
   * Standard HTML text input with angular data binding.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Adds `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trimming the
   *    input.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.text = 'guest';
             $scope.word = /^\s*\w*\s*$/;
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           Single word: <input type="text" name="input" ng-model="text"
                               ng-pattern="word" required ng-trim="false">
           <span class="error" ng-show="myForm.input.$error.required">
             Required!</span>
           <span class="error" ng-show="myForm.input.$error.pattern">
             Single word only!</span>

           <tt>text = {{text}}</tt><br/>
           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
            expect(binding('text')).toEqual('guest');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if multi word', function() {
            input('text').enter('hello world');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should not be trimmed', function() {
            input('text').enter('untrimmed ');
            expect(binding('text')).toEqual('untrimmed ');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });
        </doc:scenario>
      </doc:example>
   */
  'text': textInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.number
   *
   * @description
   * Text input with number validation and transformation. Sets the `number` validation
   * error if not a valid number.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
   * @param {string=} required Sets `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.value = 12;
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           Number: <input type="number" name="input" ng-model="value"
                          min="0" max="99" required>
           <span class="error" ng-show="myForm.input.$error.required">
             Required!</span>
           <span class="error" ng-show="myForm.input.$error.number">
             Not valid number!</span>
           <tt>value = {{value}}</tt><br/>
           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
           expect(binding('value')).toEqual('12');
           expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
           input('value').enter('');
           expect(binding('value')).toEqual('');
           expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if over max', function() {
           input('value').enter('123');
           expect(binding('value')).toEqual('');
           expect(binding('myForm.input.$valid')).toEqual('false');
          });
        </doc:scenario>
      </doc:example>
   */
  'number': numberInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.url
   *
   * @description
   * Text input with URL validation. Sets the `url` validation error key if the content is not a
   * valid URL.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Sets `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.text = 'http://google.com';
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           URL: <input type="url" name="input" ng-model="text" required>
           <span class="error" ng-show="myForm.input.$error.required">
             Required!</span>
           <span class="error" ng-show="myForm.input.$error.url">
             Not valid url!</span>
           <tt>text = {{text}}</tt><br/>
           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
           <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
            expect(binding('text')).toEqual('http://google.com');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if not url', function() {
            input('text').enter('xxx');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });
        </doc:scenario>
      </doc:example>
   */
  'url': urlInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.email
   *
   * @description
   * Text input with email validation. Sets the `email` validation error key if not a valid email
   * address.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Sets `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.text = 'me@example.com';
           }
         </script>
           <form name="myForm" ng-controller="Ctrl">
             Email: <input type="email" name="input" ng-model="text" required>
             <span class="error" ng-show="myForm.input.$error.required">
               Required!</span>
             <span class="error" ng-show="myForm.input.$error.email">
               Not valid email!</span>
             <tt>text = {{text}}</tt><br/>
             <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
             <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
             <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
             <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
             <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>
           </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
            expect(binding('text')).toEqual('me@example.com');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if not email', function() {
            input('text').enter('xxx');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });
        </doc:scenario>
      </doc:example>
   */
  'email': emailInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.radio
   *
   * @description
   * HTML radio button.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string} value The value to which the expression should be set when selected.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.color = 'blue';
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           <input type="radio" ng-model="color" value="red">  Red <br/>
           <input type="radio" ng-model="color" value="green"> Green <br/>
           <input type="radio" ng-model="color" value="blue"> Blue <br/>
           <tt>color = {{color}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should change state', function() {
            expect(binding('color')).toEqual('blue');

            input('color').select('red');
            expect(binding('color')).toEqual('red');
          });
        </doc:scenario>
      </doc:example>
   */
  'radio': radioInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.checkbox
   *
   * @description
   * HTML checkbox.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} ngTrueValue The value to which the expression should be set when selected.
   * @param {string=} ngFalseValue The value to which the expression should be set when not selected.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.value1 = true;
             $scope.value2 = 'YES'
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           Value1: <input type="checkbox" ng-model="value1"> <br/>
           Value2: <input type="checkbox" ng-model="value2"
                          ng-true-value="YES" ng-false-value="NO"> <br/>
           <tt>value1 = {{value1}}</tt><br/>
           <tt>value2 = {{value2}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should change state', function() {
            expect(binding('value1')).toEqual('true');
            expect(binding('value2')).toEqual('YES');

            input('value1').check();
            input('value2').check();
            expect(binding('value1')).toEqual('false');
            expect(binding('value2')).toEqual('NO');
          });
        </doc:scenario>
      </doc:example>
   */
  'checkbox': checkboxInputType,

  'hidden': noop,
  'button': noop,
  'submit': noop,
  'reset': noop
};


function isEmpty(value) {
  return isUndefined(value) || value === '' || value === null || value !== value;
}


function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {

  var listener = function() {
    var value = element.val();

    // By default we will trim the value
    // If the attribute ng-trim exists we will avoid trimming
    // e.g. <input ng-model="foo" ng-trim="false">
    if (toBoolean(attr.ngTrim || 'T')) {
      value = trim(value);
    }

    if (ctrl.$viewValue !== value) {
      scope.$apply(function() {
        ctrl.$setViewValue(value);
      });
    }
  };

  // if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the
  // input event on backspace, delete or cut
  if ($sniffer.hasEvent('input')) {
    element.on('input', listener);
  } else {
    var timeout;

    var deferListener = function() {
      if (!timeout) {
        timeout = $browser.defer(function() {
          listener();
          timeout = null;
        });
      }
    };

    element.on('keydown', function(event) {
      var key = event.keyCode;

      // ignore
      //    command            modifiers                   arrows
      if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;

      deferListener();
    });

    // if user paste into input using mouse, we need "change" event to catch it
    element.on('change', listener);

    // if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it
    if ($sniffer.hasEvent('paste')) {
      element.on('paste cut', deferListener);
    }
  }


  ctrl.$render = function() {
    element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
  };

  // pattern validator
  var pattern = attr.ngPattern,
      patternValidator,
      match;

  var validate = function(regexp, value) {
    if (isEmpty(value) || regexp.test(value)) {
      ctrl.$setValidity('pattern', true);
      return value;
    } else {
      ctrl.$setValidity('pattern', false);
      return undefined;
    }
  };

  if (pattern) {
    match = pattern.match(/^\/(.*)\/([gim]*)$/);
    if (match) {
      pattern = new RegExp(match[1], match[2]);
      patternValidator = function(value) {
        return validate(pattern, value)
      };
    } else {
      patternValidator = function(value) {
        var patternObj = scope.$eval(pattern);

        if (!patternObj || !patternObj.test) {
          throw minErr('ngPattern')('noregexp',
            'Expected {0} to be a RegExp but was {1}. Element: {2}', pattern,
            patternObj, startingTag(element));
        }
        return validate(patternObj, value);
      };
    }

    ctrl.$formatters.push(patternValidator);
    ctrl.$parsers.push(patternValidator);
  }

  // min length validator
  if (attr.ngMinlength) {
    var minlength = int(attr.ngMinlength);
    var minLengthValidator = function(value) {
      if (!isEmpty(value) && value.length < minlength) {
        ctrl.$setValidity('minlength', false);
        return undefined;
      } else {
        ctrl.$setValidity('minlength', true);
        return value;
      }
    };

    ctrl.$parsers.push(minLengthValidator);
    ctrl.$formatters.push(minLengthValidator);
  }

  // max length validator
  if (attr.ngMaxlength) {
    var maxlength = int(attr.ngMaxlength);
    var maxLengthValidator = function(value) {
      if (!isEmpty(value) && value.length > maxlength) {
        ctrl.$setValidity('maxlength', false);
        return undefined;
      } else {
        ctrl.$setValidity('maxlength', true);
        return value;
      }
    };

    ctrl.$parsers.push(maxLengthValidator);
    ctrl.$formatters.push(maxLengthValidator);
  }
}

function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  ctrl.$parsers.push(function(value) {
    var empty = isEmpty(value);
    if (empty || NUMBER_REGEXP.test(value)) {
      ctrl.$setValidity('number', true);
      return value === '' ? null : (empty ? value : parseFloat(value));
    } else {
      ctrl.$setValidity('number', false);
      return undefined;
    }
  });

  ctrl.$formatters.push(function(value) {
    return isEmpty(value) ? '' : '' + value;
  });

  if (attr.min) {
    var min = parseFloat(attr.min);
    var minValidator = function(value) {
      if (!isEmpty(value) && value < min) {
        ctrl.$setValidity('min', false);
        return undefined;
      } else {
        ctrl.$setValidity('min', true);
        return value;
      }
    };

    ctrl.$parsers.push(minValidator);
    ctrl.$formatters.push(minValidator);
  }

  if (attr.max) {
    var max = parseFloat(attr.max);
    var maxValidator = function(value) {
      if (!isEmpty(value) && value > max) {
        ctrl.$setValidity('max', false);
        return undefined;
      } else {
        ctrl.$setValidity('max', true);
        return value;
      }
    };

    ctrl.$parsers.push(maxValidator);
    ctrl.$formatters.push(maxValidator);
  }

  ctrl.$formatters.push(function(value) {

    if (isEmpty(value) || isNumber(value)) {
      ctrl.$setValidity('number', true);
      return value;
    } else {
      ctrl.$setValidity('number', false);
      return undefined;
    }
  });
}

function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  var urlValidator = function(value) {
    if (isEmpty(value) || URL_REGEXP.test(value)) {
      ctrl.$setValidity('url', true);
      return value;
    } else {
      ctrl.$setValidity('url', false);
      return undefined;
    }
  };

  ctrl.$formatters.push(urlValidator);
  ctrl.$parsers.push(urlValidator);
}

function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  var emailValidator = function(value) {
    if (isEmpty(value) || EMAIL_REGEXP.test(value)) {
      ctrl.$setValidity('email', true);
      return value;
    } else {
      ctrl.$setValidity('email', false);
      return undefined;
    }
  };

  ctrl.$formatters.push(emailValidator);
  ctrl.$parsers.push(emailValidator);
}

function radioInputType(scope, element, attr, ctrl) {
  // make the name unique, if not defined
  if (isUndefined(attr.name)) {
    element.attr('name', nextUid());
  }

  element.on('click', function() {
    if (element[0].checked) {
      scope.$apply(function() {
        ctrl.$setViewValue(attr.value);
      });
    }
  });

  ctrl.$render = function() {
    var value = attr.value;
    element[0].checked = (value == ctrl.$viewValue);
  };

  attr.$observe('value', ctrl.$render);
}

function checkboxInputType(scope, element, attr, ctrl) {
  var trueValue = attr.ngTrueValue,
      falseValue = attr.ngFalseValue;

  if (!isString(trueValue)) trueValue = true;
  if (!isString(falseValue)) falseValue = false;

  element.on('click', function() {
    scope.$apply(function() {
      ctrl.$setViewValue(element[0].checked);
    });
  });

  ctrl.$render = function() {
    element[0].checked = ctrl.$viewValue;
  };

  ctrl.$formatters.push(function(value) {
    return value === trueValue;
  });

  ctrl.$parsers.push(function(value) {
    return value ? trueValue : falseValue;
  });
}


/**
 * @ngdoc directive
 * @name ng.directive:textarea
 * @restrict E
 *
 * @description
 * HTML textarea element control with angular data-binding. The data-binding and validation
 * properties of this element are exactly the same as those of the
 * {@link ng.directive:input input element}.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required Sets `required` validation error key if the value is not entered.
 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
 *    `required` when you want to data-bind to the `required` attribute.
 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
 *    minlength.
 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
 *    maxlength.
 * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
 *    patterns defined as scope expressions.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 */


/**
 * @ngdoc directive
 * @name ng.directive:input
 * @restrict E
 *
 * @description
 * HTML input element control with angular data-binding. Input control follows HTML5 input types
 * and polyfills the HTML5 validation behavior for older browsers.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required Sets `required` validation error key if the value is not entered.
 * @param {boolean=} ngRequired Sets `required` attribute if set to true
 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
 *    minlength.
 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
 *    maxlength.
 * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
 *    patterns defined as scope expressions.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 *
 * @example
    <doc:example>
      <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.user = {name: 'guest', last: 'visitor'};
         }
       </script>
       <div ng-controller="Ctrl">
         <form name="myForm">
           User name: <input type="text" name="userName" ng-model="user.name" required>
           <span class="error" ng-show="myForm.userName.$error.required">
             Required!</span><br>
           Last name: <input type="text" name="lastName" ng-model="user.last"
             ng-minlength="3" ng-maxlength="10">
           <span class="error" ng-show="myForm.lastName.$error.minlength">
             Too short!</span>
           <span class="error" ng-show="myForm.lastName.$error.maxlength">
             Too long!</span><br>
         </form>
         <hr>
         <tt>user = {{user}}</tt><br/>
         <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>
         <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>
         <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>
         <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
         <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>
         <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>
       </div>
      </doc:source>
      <doc:scenario>
        it('should initialize to model', function() {
          expect(binding('user')).toEqual('{"name":"guest","last":"visitor"}');
          expect(binding('myForm.userName.$valid')).toEqual('true');
          expect(binding('myForm.$valid')).toEqual('true');
        });

        it('should be invalid if empty when required', function() {
          input('user.name').enter('');
          expect(binding('user')).toEqual('{"last":"visitor"}');
          expect(binding('myForm.userName.$valid')).toEqual('false');
          expect(binding('myForm.$valid')).toEqual('false');
        });

        it('should be valid if empty when min length is set', function() {
          input('user.last').enter('');
          expect(binding('user')).toEqual('{"name":"guest","last":""}');
          expect(binding('myForm.lastName.$valid')).toEqual('true');
          expect(binding('myForm.$valid')).toEqual('true');
        });

        it('should be invalid if less than required min length', function() {
          input('user.last').enter('xx');
          expect(binding('user')).toEqual('{"name":"guest"}');
          expect(binding('myForm.lastName.$valid')).toEqual('false');
          expect(binding('myForm.lastName.$error')).toMatch(/minlength/);
          expect(binding('myForm.$valid')).toEqual('false');
        });

        it('should be invalid if longer than max length', function() {
          input('user.last').enter('some ridiculously long name');
          expect(binding('user'))
            .toEqual('{"name":"guest"}');
          expect(binding('myForm.lastName.$valid')).toEqual('false');
          expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);
          expect(binding('myForm.$valid')).toEqual('false');
        });
      </doc:scenario>
    </doc:example>
 */
var inputDirective = ['$browser', '$sniffer', function($browser, $sniffer) {
  return {
    restrict: 'E',
    require: '?ngModel',
    link: function(scope, element, attr, ctrl) {
      if (ctrl) {
        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,
                                                            $browser);
      }
    }
  };
}];

var VALID_CLASS = 'ng-valid',
    INVALID_CLASS = 'ng-invalid',
    PRISTINE_CLASS = 'ng-pristine',
    DIRTY_CLASS = 'ng-dirty';

/**
 * @ngdoc object
 * @name ng.directive:ngModel.NgModelController
 *
 * @property {string} $viewValue Actual string value in the view.
 * @property {*} $modelValue The value in the model, that the control is bound to.
 * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever
       the control reads value from the DOM.  Each function is called, in turn, passing the value
       through to the next. Used to sanitize / convert the value as well as validation.
       For validation, the parsers should update the validity state using
       {@link ng.directive:ngModel.NgModelController#$setValidity $setValidity()},
       and return `undefined` for invalid values.

 *
 * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever
       the model value changes. Each function is called, in turn, passing the value through to the
       next. Used to format / convert values for display in the control and validation.
 *      <pre>
 *      function formatter(value) {
 *        if (value) {
 *          return value.toUpperCase();
 *        }
 *      }
 *      ngModel.$formatters.push(formatter);
 *      </pre>
 * @property {Object} $error An object hash with all errors as keys.
 *
 * @property {boolean} $pristine True if user has not interacted with the control yet.
 * @property {boolean} $dirty True if user has already interacted with the control.
 * @property {boolean} $valid True if there is no error.
 * @property {boolean} $invalid True if at least one error on the control.
 *
 * @description
 *
 * `NgModelController` provides API for the `ng-model` directive. The controller contains
 * services for data-binding, validation, CSS update, value formatting and parsing. It
 * specifically does not contain any logic which deals with DOM rendering or listening to
 * DOM events. The `NgModelController` is meant to be extended by other directives where, the
 * directive provides DOM manipulation and the `NgModelController` provides the data-binding.
 * Note that you cannot use `NgModelController` in a directive with an isolated scope,
 * as, in that case, the `ng-model` value gets put into the isolated scope and does not get
 * propogated to the parent scope.
 *
 *
 * This example shows how to use `NgModelController` with a custom control to achieve
 * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)
 * collaborate together to achieve the desired result.
 *
 * <example module="customControl">
    <file name="style.css">
      [contenteditable] {
        border: 1px solid black;
        background-color: white;
        min-height: 20px;
      }

      .ng-invalid {
        border: 1px solid red;
      }

    </file>
    <file name="script.js">
      angular.module('customControl', []).
        directive('contenteditable', function() {
          return {
            restrict: 'A', // only activate on element attribute
            require: '?ngModel', // get a hold of NgModelController
            link: function(scope, element, attrs, ngModel) {
              if(!ngModel) return; // do nothing if no ng-model

              // Specify how UI should be updated
              ngModel.$render = function() {
                element.html(ngModel.$viewValue || '');
              };

              // Listen for change events to enable binding
              element.on('blur keyup change', function() {
                scope.$apply(read);
              });
              read(); // initialize

              // Write data to the model
              function read() {
                var html = element.html();
                // When we clear the content editable the browser leaves a <br> behind
                // If strip-br attribute is provided then we strip this out
                if( attrs.stripBr && html == '<br>' ) {
                  html = '';
                }
                ngModel.$setViewValue(html);
              }
            }
          };
        });
    </file>
    <file name="index.html">
      <form name="myForm">
       <div contenteditable
            name="myWidget" ng-model="userContent"
            strip-br="true"
            required>Change me!</div>
        <span ng-show="myForm.myWidget.$error.required">Required!</span>
       <hr>
       <textarea ng-model="userContent"></textarea>
      </form>
    </file>
    <file name="scenario.js">
      it('should data-bind and become invalid', function() {
        var contentEditable = element('[contenteditable]');

        expect(contentEditable.text()).toEqual('Change me!');
        input('userContent').enter('');
        expect(contentEditable.text()).toEqual('');
        expect(contentEditable.prop('className')).toMatch(/ng-invalid-required/);
      });
    </file>
 * </example>
 *
 */
var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse',
    function($scope, $exceptionHandler, $attr, $element, $parse) {
  this.$viewValue = Number.NaN;
  this.$modelValue = Number.NaN;
  this.$parsers = [];
  this.$formatters = [];
  this.$viewChangeListeners = [];
  this.$pristine = true;
  this.$dirty = false;
  this.$valid = true;
  this.$invalid = false;
  this.$name = $attr.name;

  var ngModelGet = $parse($attr.ngModel),
      ngModelSet = ngModelGet.assign;

  if (!ngModelSet) {
    throw minErr('ngModel')('nonassign', "Expression '{0}' is non-assignable. Element: {1}",
        $attr.ngModel, startingTag($element));
  }

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$render
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Called when the view needs to be updated. It is expected that the user of the ng-model
   * directive will implement this method.
   */
  this.$render = noop;

  var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
      invalidCount = 0, // used to easily determine if we are valid
      $error = this.$error = {}; // keep invalid keys here


  // Setup initial state of the control
  $element.addClass(PRISTINE_CLASS);
  toggleValidCss(true);

  // convenience method for easy toggling of classes
  function toggleValidCss(isValid, validationErrorKey) {
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
    $element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  }

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setValidity
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Change the validity state, and notifies the form when the control changes validity. (i.e. it
   * does not notify form if given validator is already marked as invalid).
   *
   * This method should be called by validators - i.e. the parser or formatter functions.
   *
   * @param {string} validationErrorKey Name of the validator. the `validationErrorKey` will assign
   *        to `$error[validationErrorKey]=isValid` so that it is available for data-binding.
   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case
   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`
   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .
   * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).
   */
  this.$setValidity = function(validationErrorKey, isValid) {
    if ($error[validationErrorKey] === !isValid) return;

    if (isValid) {
      if ($error[validationErrorKey]) invalidCount--;
      if (!invalidCount) {
        toggleValidCss(true);
        this.$valid = true;
        this.$invalid = false;
      }
    } else {
      toggleValidCss(false);
      this.$invalid = true;
      this.$valid = false;
      invalidCount++;
    }

    $error[validationErrorKey] = !isValid;
    toggleValidCss(isValid, validationErrorKey);

    parentForm.$setValidity(validationErrorKey, isValid, this);
  };

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setPristine
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Sets the control to its pristine state.
   *
   * This method can be called to remove the 'ng-dirty' class and set the control to its pristine
   * state (ng-pristine class).
   */
  this.$setPristine = function () {
    this.$dirty = false;
    this.$pristine = true;
    $element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
  };

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setViewValue
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Read a value from view.
   *
   * This method should be called from within a DOM event handler.
   * For example {@link ng.directive:input input} or
   * {@link ng.directive:select select} directives call it.
   *
   * It internally calls all `$parsers` (including validators) and updates the `$modelValue` and the actual model path.
   * Lastly it calls all registered change listeners.
   *
   * @param {string} value Value from the view.
   */
  this.$setViewValue = function(value) {
    this.$viewValue = value;

    // change to dirty
    if (this.$pristine) {
      this.$dirty = true;
      this.$pristine = false;
      $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      parentForm.$setDirty();
    }

    forEach(this.$parsers, function(fn) {
      value = fn(value);
    });

    if (this.$modelValue !== value) {
      this.$modelValue = value;
      ngModelSet($scope, value);
      forEach(this.$viewChangeListeners, function(listener) {
        try {
          listener();
        } catch(e) {
          $exceptionHandler(e);
        }
      })
    }
  };

  // model -> value
  var ctrl = this;

  $scope.$watch(function ngModelWatch() {
    var value = ngModelGet($scope);

    // if scope model value and ngModel value are out of sync
    if (ctrl.$modelValue !== value) {

      var formatters = ctrl.$formatters,
          idx = formatters.length;

      ctrl.$modelValue = value;
      while(idx--) {
        value = formatters[idx](value);
      }

      if (ctrl.$viewValue !== value) {
        ctrl.$viewValue = value;
        ctrl.$render();
      }
    }
  });
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngModel
 *
 * @element input
 *
 * @description
 * Is a directive that tells Angular to do two-way data binding. It works together with `input`,
 * `select`, `textarea` and even custom form controls that use {@link ng.directive:ngModel.NgModelController
 * NgModelController} exposed by this directive.
 *
 * `ngModel` is responsible for:
 *
 * - binding the view into the model, which other directives such as `input`, `textarea` or `select`
 *   require,
 * - providing validation behavior (i.e. required, number, email, url),
 * - keeping state of the control (valid/invalid, dirty/pristine, validation errors),
 * - setting related css class onto the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`),
 * - register the control with parent {@link ng.directive:form form}.
 *
 * Note: `ngModel` will try to bind to the property given by evaluating the expression on the
 * current scope. If the property doesn't already exist on this scope, it will be created
 * implicitly and added to the scope.
 *
 * For basic examples, how to use `ngModel`, see:
 *
 *  - {@link ng.directive:input input}
 *    - {@link ng.directive:input.text text}
 *    - {@link ng.directive:input.checkbox checkbox}
 *    - {@link ng.directive:input.radio radio}
 *    - {@link ng.directive:input.number number}
 *    - {@link ng.directive:input.email email}
 *    - {@link ng.directive:input.url url}
 *  - {@link ng.directive:select select}
 *  - {@link ng.directive:textarea textarea}
 *
 */
var ngModelDirective = function() {
  return {
    require: ['ngModel', '^?form'],
    controller: NgModelController,
    link: function(scope, element, attr, ctrls) {
      // notify others, especially parent forms

      var modelCtrl = ctrls[0],
          formCtrl = ctrls[1] || nullFormCtrl;

      formCtrl.$addControl(modelCtrl);

      element.on('$destroy', function() {
        formCtrl.$removeControl(modelCtrl);
      });
    }
  };
};


/**
 * @ngdoc directive
 * @name ng.directive:ngChange
 * @restrict E
 *
 * @description
 * Evaluate given expression when user changes the input.
 * The expression is not evaluated when the value change is coming from the model.
 *
 * Note, this directive requires `ngModel` to be present.
 *
 * @element input
 *
 * @example
 * <doc:example>
 *   <doc:source>
 *     <script>
 *       function Controller($scope) {
 *         $scope.counter = 0;
 *         $scope.change = function() {
 *           $scope.counter++;
 *         };
 *       }
 *     </script>
 *     <div ng-controller="Controller">
 *       <input type="checkbox" ng-model="confirmed" ng-change="change()" id="ng-change-example1" />
 *       <input type="checkbox" ng-model="confirmed" id="ng-change-example2" />
 *       <label for="ng-change-example2">Confirmed</label><br />
 *       debug = {{confirmed}}<br />
 *       counter = {{counter}}
 *     </div>
 *   </doc:source>
 *   <doc:scenario>
 *     it('should evaluate the expression if changing from view', function() {
 *       expect(binding('counter')).toEqual('0');
 *       element('#ng-change-example1').click();
 *       expect(binding('counter')).toEqual('1');
 *       expect(binding('confirmed')).toEqual('true');
 *     });
 *
 *     it('should not evaluate the expression if changing from model', function() {
 *       element('#ng-change-example2').click();
 *       expect(binding('counter')).toEqual('0');
 *       expect(binding('confirmed')).toEqual('true');
 *     });
 *   </doc:scenario>
 * </doc:example>
 */
var ngChangeDirective = valueFn({
  require: 'ngModel',
  link: function(scope, element, attr, ctrl) {
    ctrl.$viewChangeListeners.push(function() {
      scope.$eval(attr.ngChange);
    });
  }
});


var requiredDirective = function() {
  return {
    require: '?ngModel',
    link: function(scope, elm, attr, ctrl) {
      if (!ctrl) return;
      attr.required = true; // force truthy in case we are on non input element

      var validator = function(value) {
        if (attr.required && (isEmpty(value) || value === false)) {
          ctrl.$setValidity('required', false);
          return;
        } else {
          ctrl.$setValidity('required', true);
          return value;
        }
      };

      ctrl.$formatters.push(validator);
      ctrl.$parsers.unshift(validator);

      attr.$observe('required', function() {
        validator(ctrl.$viewValue);
      });
    }
  };
};


/**
 * @ngdoc directive
 * @name ng.directive:ngList
 *
 * @description
 * Text input that converts between comma-separated string into an array of strings.
 *
 * @element input
 * @param {string=} ngList optional delimiter that should be used to split the value. If
 *   specified in form `/something/` then the value will be converted into a regular expression.
 *
 * @example
    <doc:example>
      <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.names = ['igor', 'misko', 'vojta'];
         }
       </script>
       <form name="myForm" ng-controller="Ctrl">
         List: <input name="namesInput" ng-model="names" ng-list required>
         <span class="error" ng-show="myForm.namesInput.$error.required">
           Required!</span>
         <br>
         <tt>names = {{names}}</tt><br/>
         <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>
         <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
        </form>
      </doc:source>
      <doc:scenario>
        it('should initialize to model', function() {
          expect(binding('names')).toEqual('["igor","misko","vojta"]');
          expect(binding('myForm.namesInput.$valid')).toEqual('true');
          expect(element('span.error').css('display')).toBe('none');
        });

        it('should be invalid if empty', function() {
          input('names').enter('');
          expect(binding('names')).toEqual('[]');
          expect(binding('myForm.namesInput.$valid')).toEqual('false');
          expect(element('span.error').css('display')).not().toBe('none');
        });
      </doc:scenario>
    </doc:example>
 */
var ngListDirective = function() {
  return {
    require: 'ngModel',
    link: function(scope, element, attr, ctrl) {
      var match = /\/(.*)\//.exec(attr.ngList),
          separator = match && new RegExp(match[1]) || attr.ngList || ',';

      var parse = function(viewValue) {
        var list = [];

        if (viewValue) {
          forEach(viewValue.split(separator), function(value) {
            if (value) list.push(trim(value));
          });
        }

        return list;
      };

      ctrl.$parsers.push(parse);
      ctrl.$formatters.push(function(value) {
        if (isArray(value)) {
          return value.join(', ');
        }

        return undefined;
      });
    }
  };
};


var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;

var ngValueDirective = function() {
  return {
    priority: 100,
    compile: function(tpl, tplAttr) {
      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
        return function(scope, elm, attr) {
          attr.$set('value', scope.$eval(attr.ngValue));
        };
      } else {
        return function(scope, elm, attr) {
          scope.$watch(attr.ngValue, function valueWatchAction(value) {
            attr.$set('value', value);
          });
        };
      }
    }
  };
};

/**
 * @ngdoc directive
 * @name ng.directive:ngBind
 *
 * @description
 * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element
 * with the value of a given expression, and to update the text content when the value of that
 * expression changes.
 *
 * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like
 * `{{ expression }}` which is similar but less verbose.
 *
 * It is preferrable to use `ngBind` instead of `{{ expression }}` when a template is momentarily 
 * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an 
 * element attribute, it makes the bindings invisible to the user while the page is loading.
 *
 * An alternative solution to this problem would be using the
 * {@link ng.directive:ngCloak ngCloak} directive.
 *
 *
 * @element ANY
 * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
 *
 * @example
 * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.name = 'Whirled';
         }
       </script>
       <div ng-controller="Ctrl">
         Enter name: <input type="text" ng-model="name"><br>
         Hello <span ng-bind="name"></span>!
       </div>
     </doc:source>
     <doc:scenario>
       it('should check ng-bind', function() {
         expect(using('.doc-example-live').binding('name')).toBe('Whirled');
         using('.doc-example-live').input('name').enter('world');
         expect(using('.doc-example-live').binding('name')).toBe('world');
       });
     </doc:scenario>
   </doc:example>
 */
var ngBindDirective = ngDirective(function(scope, element, attr) {
  element.addClass('ng-binding').data('$binding', attr.ngBind);
  scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
    element.text(value == undefined ? '' : value);
  });
});


/**
 * @ngdoc directive
 * @name ng.directive:ngBindTemplate
 *
 * @description
 * The `ngBindTemplate` directive specifies that the element
 * text content should be replaced with the interpolation of the template
 * in the `ngBindTemplate` attribute.
 * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`
 * expressions. This directive is needed since some HTML elements
 * (such as TITLE and OPTION) cannot contain SPAN elements.
 *
 * @element ANY
 * @param {string} ngBindTemplate template of form
 *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.
 *
 * @example
 * Try it here: enter text in text box and watch the greeting change.
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.salutation = 'Hello';
           $scope.name = 'World';
         }
       </script>
       <div ng-controller="Ctrl">
        Salutation: <input type="text" ng-model="salutation"><br>
        Name: <input type="text" ng-model="name"><br>
        <pre ng-bind-template="{{salutation}} {{name}}!"></pre>
       </div>
     </doc:source>
     <doc:scenario>
       it('should check ng-bind', function() {
         expect(using('.doc-example-live').binding('salutation')).
           toBe('Hello');
         expect(using('.doc-example-live').binding('name')).
           toBe('World');
         using('.doc-example-live').input('salutation').enter('Greetings');
         using('.doc-example-live').input('name').enter('user');
         expect(using('.doc-example-live').binding('salutation')).
           toBe('Greetings');
         expect(using('.doc-example-live').binding('name')).
           toBe('user');
       });
     </doc:scenario>
   </doc:example>
 */
var ngBindTemplateDirective = ['$interpolate', function($interpolate) {
  return function(scope, element, attr) {
    // TODO: move this to scenario runner
    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
    element.addClass('ng-binding').data('$binding', interpolateFn);
    attr.$observe('ngBindTemplate', function(value) {
      element.text(value);
    });
  }
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngBindHtml
 *
 * @description
 * Creates a binding that will innerHTML the result of evaluating the `expression` into the current
 * element in a secure way.  By default, the innerHTML-ed content will be sanitized using the {@link
 * ngSanitize.$sanitize $sanitize} service.  To utilize this functionality, ensure that `$sanitize`
 * is available, for example, by including {@link ngSanitize} in your module's dependencies (not in
 * core Angular.)  You may also bypass sanitization for values you know are safe. To do so, bind to
 * an explicitly trusted value via {@link ng.$sce#trustAsHtml $sce.trustAsHtml}.  See the example
 * under {@link ng.$sce#Example Strict Contextual Escaping (SCE)}.
 *
 * Note: If a `$sanitize` service is unavailable and the bound value isn't explicitly trusted, you
 * will have an exception (instead of an exploit.)
 *
 * @element ANY
 * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.
 */
var ngBindHtmlDirective = ['$sce', function($sce) {
  return function(scope, element, attr) {
    element.addClass('ng-binding').data('$binding', attr.ngBindHtml);
    scope.$watch(attr.ngBindHtml, function ngBindHtmlWatchAction(value) {
      element.html($sce.getTrustedHtml(value) || '');
    });
  };
}];

function classDirective(name, selector) {
  name = 'ngClass' + name;
  return function() {
    return {
      restrict: 'AC',
      link: function(scope, element, attr) {
        var oldVal = undefined;

        scope.$watch(attr[name], ngClassWatchAction, true);

        attr.$observe('class', function(value) {
          ngClassWatchAction(scope.$eval(attr[name]));
        });


        if (name !== 'ngClass') {
          scope.$watch('$index', function($index, old$index) {
            var mod = $index & 1;
            if (mod !== old$index & 1) {
              if (mod === selector) {
                addClass(scope.$eval(attr[name]));
              } else {
                removeClass(scope.$eval(attr[name]));
              }
            }
          });
        }


        function ngClassWatchAction(newVal) {
          if (selector === true || scope.$index % 2 === selector) {
            if (oldVal && !equals(newVal,oldVal)) {
              removeClass(oldVal);
            }
            addClass(newVal);
          }
          oldVal = copy(newVal);
        }


        function removeClass(classVal) {
          attr.$removeClass(flattenClasses(classVal));
        }


        function addClass(classVal) {
          attr.$addClass(flattenClasses(classVal));
        }

        function flattenClasses(classVal) {
          if(isArray(classVal)) {
            return classVal.join(' ');
          } else if (isObject(classVal)) {
            var classes = [], i = 0;
            forEach(classVal, function(v, k) {
              if (v) {
                classes.push(k);
              }
            });
            return classes.join(' ');
          }

          return classVal;
        };
      }
    };
  };
}

/**
 * @ngdoc directive
 * @name ng.directive:ngClass
 *
 * @description
 * The `ngClass` allows you to set CSS classes on HTML an element, dynamically, by databinding
 * an expression that represents all classes to be added.
 *
 * The directive won't add duplicate classes if a particular class was already set.
 *
 * When the expression changes, the previously added classes are removed and only then the
 * new classes are added.
 *
 * @animations
 * add - happens just before the class is applied to the element
 * remove - happens just before the class is removed from the element
 *
 * @element ANY
 * @param {expression} ngClass {@link guide/expression Expression} to eval. The result
 *   of the evaluation can be a string representing space delimited class
 *   names, an array, or a map of class names to boolean values. In the case of a map, the
 *   names of the properties whose values are truthy will be added as css classes to the
 *   element.
 *
 * @example Example that demostrates basic bindings via ngClass directive.
   <example>
     <file name="index.html">
       <p ng-class="{strike: strike, bold: bold, red: red}">Map Syntax Example</p>
       <input type="checkbox" ng-model="bold"> bold
       <input type="checkbox" ng-model="strike"> strike
       <input type="checkbox" ng-model="red"> red
       <hr>
       <p ng-class="style">Using String Syntax</p>
       <input type="text" ng-model="style" placeholder="Type: bold strike red">
       <hr>
       <p ng-class="[style1, style2, style3]">Using Array Syntax</p>
       <input ng-model="style1" placeholder="Type: bold"><br>
       <input ng-model="style2" placeholder="Type: strike"><br>
       <input ng-model="style3" placeholder="Type: red"><br>
     </file>
     <file name="style.css">
       .strike {
         text-decoration: line-through;
       }
       .bold {
           font-weight: bold;
       }
       .red {
           color: red;
       }
     </file>
     <file name="scenario.js">
       it('should let you toggle the class', function() {

         expect(element('.doc-example-live p:first').prop('className')).not().toMatch(/bold/);
         expect(element('.doc-example-live p:first').prop('className')).not().toMatch(/red/);

         input('bold').check();
         expect(element('.doc-example-live p:first').prop('className')).toMatch(/bold/);

         input('red').check();
         expect(element('.doc-example-live p:first').prop('className')).toMatch(/red/);
       });

       it('should let you toggle string example', function() {
         expect(element('.doc-example-live p:nth-of-type(2)').prop('className')).toBe('');
         input('style').enter('red');
         expect(element('.doc-example-live p:nth-of-type(2)').prop('className')).toBe('red');
       });

       it('array example should have 3 classes', function() {
         expect(element('.doc-example-live p:last').prop('className')).toBe('');
         input('style1').enter('bold');
         input('style2').enter('strike');
         input('style3').enter('red');
         expect(element('.doc-example-live p:last').prop('className')).toBe('bold strike red');
       });
     </file>
   </example>

   ## Animations

   The example below demonstrates how to perform animations using ngClass.

   <example animations="true">
     <file name="index.html">
      <input type="button" value="set" ng-click="myVar='my-class'">
      <input type="button" value="clear" ng-click="myVar=''">
      <br>
      <span ng-class="myVar">Sample Text</span>
     </file>
     <file name="style.css">
       .my-class-add, .my-class-remove {
         -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
         -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
         -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
         transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
       }

       .my-class,
       .my-class-add.my-class-add-active {
         color: red;
         font-size:3em;
       }

       .my-class-remove.my-class-remove-active {
         font-size:1.0em;
         color:black;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-class', function() {
         expect(element('.doc-example-live span').prop('className')).not().
           toMatch(/my-class/);

         using('.doc-example-live').element(':button:first').click();

         expect(element('.doc-example-live span').prop('className')).
           toMatch(/my-class/);

         using('.doc-example-live').element(':button:last').click();

         expect(element('.doc-example-live span').prop('className')).not().
           toMatch(/my-class/);
       });
     </file>
   </example>


   ## ngClass and pre-existing CSS3 Transitions/Animations
   The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure.
   Therefore, if any CSS3 Transition/Animation styles (outside of ngAnimate) are set on the element, then, if a ngClass animation
   is triggered, the ngClass animation will be skipped so that ngAnimate can allow for the pre-existing transition or animation to
   take over. This restriction allows for ngClass to still work with standard CSS3 Transitions/Animations that are defined
   outside of ngAnimate.
 */
var ngClassDirective = classDirective('', true);

/**
 * @ngdoc directive
 * @name ng.directive:ngClassOdd
 *
 * @description
 * The `ngClassOdd` and `ngClassEven` directives work exactly as
 * {@link ng.directive:ngClass ngClass}, except it works in
 * conjunction with `ngRepeat` and takes affect only on odd (even) rows.
 *
 * This directive can be applied only within a scope of an
 * {@link ng.directive:ngRepeat ngRepeat}.
 *
 * @element ANY
 * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result
 *   of the evaluation can be a string representing space delimited class names or an array.
 *
 * @example
   <example>
     <file name="index.html">
        <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
          <li ng-repeat="name in names">
           <span ng-class-odd="'odd'" ng-class-even="'even'">
             {{name}}
           </span>
          </li>
        </ol>
     </file>
     <file name="style.css">
       .odd {
         color: red;
       }
       .even {
         color: blue;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-class-odd and ng-class-even', function() {
         expect(element('.doc-example-live li:first span').prop('className')).
           toMatch(/odd/);
         expect(element('.doc-example-live li:last span').prop('className')).
           toMatch(/even/);
       });
     </file>
   </example>
 */
var ngClassOddDirective = classDirective('Odd', 0);

/**
 * @ngdoc directive
 * @name ng.directive:ngClassEven
 *
 * @description
 * The `ngClassOdd` and `ngClassEven` directives work exactly as
 * {@link ng.directive:ngClass ngClass}, except it works in
 * conjunction with `ngRepeat` and takes affect only on odd (even) rows.
 *
 * This directive can be applied only within a scope of an
 * {@link ng.directive:ngRepeat ngRepeat}.
 *
 * @element ANY
 * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The
 *   result of the evaluation can be a string representing space delimited class names or an array.
 *
 * @example
   <example>
     <file name="index.html">
        <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
          <li ng-repeat="name in names">
           <span ng-class-odd="'odd'" ng-class-even="'even'">
             {{name}} &nbsp; &nbsp; &nbsp;
           </span>
          </li>
        </ol>
     </file>
     <file name="style.css">
       .odd {
         color: red;
       }
       .even {
         color: blue;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-class-odd and ng-class-even', function() {
         expect(element('.doc-example-live li:first span').prop('className')).
           toMatch(/odd/);
         expect(element('.doc-example-live li:last span').prop('className')).
           toMatch(/even/);
       });
     </file>
   </example>
 */
var ngClassEvenDirective = classDirective('Even', 1);

/**
 * @ngdoc directive
 * @name ng.directive:ngCloak
 *
 * @description
 * The `ngCloak` directive is used to prevent the Angular html template from being briefly
 * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this
 * directive to avoid the undesirable flicker effect caused by the html template display.
 *
 * The directive can be applied to the `<body>` element, but typically a fine-grained application is
 * preferred in order to benefit from progressive rendering of the browser view.
 *
 * `ngCloak` works in cooperation with a css rule that is embedded within `angular.js` and
 *  `angular.min.js` files. Following is the css rule:
 *
 * <pre>
 * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
 *   display: none !important;
 * }
 * </pre>
 *
 * When this css rule is loaded by the browser, all html elements (including their children) that
 * are tagged with the `ng-cloak` directive are hidden. When Angular comes across this directive
 * during the compilation of the template it deletes the `ngCloak` element attribute, which
 * makes the compiled element visible.
 *
 * For the best result, `angular.js` script must be loaded in the head section of the html file;
 * alternatively, the css rule (above) must be included in the external stylesheet of the
 * application.
 *
 * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they
 * cannot match the `[ng\:cloak]` selector. To work around this limitation, you must add the css
 * class `ngCloak` in addition to `ngCloak` directive as shown in the example below.
 *
 * @element ANY
 *
 * @example
   <doc:example>
     <doc:source>
        <div id="template1" ng-cloak>{{ 'hello' }}</div>
        <div id="template2" ng-cloak class="ng-cloak">{{ 'hello IE7' }}</div>
     </doc:source>
     <doc:scenario>
       it('should remove the template directive and css class', function() {
         expect(element('.doc-example-live #template1').attr('ng-cloak')).
           not().toBeDefined();
         expect(element('.doc-example-live #template2').attr('ng-cloak')).
           not().toBeDefined();
       });
     </doc:scenario>
   </doc:example>
 *
 */
var ngCloakDirective = ngDirective({
  compile: function(element, attr) {
    attr.$set('ngCloak', undefined);
    element.removeClass('ng-cloak');
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngController
 *
 * @description
 * The `ngController` directive assigns behavior to a scope. This is a key aspect of how angular
 * supports the principles behind the Model-View-Controller design pattern.
 *
 * MVC components in angular:
 *
 * * Model  The Model is data in scope properties; scopes are attached to the DOM.
 * * View  The template (HTML with data bindings) is rendered into the View.
 * * Controller  The `ngController` directive specifies a Controller class; the class has
 *   methods that typically express the business logic behind the application.
 *
 * Note that an alternative way to define controllers is via the {@link ngRoute.$route $route} service.
 *
 * @element ANY
 * @scope
 * @param {expression} ngController Name of a globally accessible constructor function or an
 *     {@link guide/expression expression} that on the current scope evaluates to a
 *     constructor function. The controller instance can further be published into the scope
 *     by adding `as localName` the controller name attribute.
 *
 * @example
 * Here is a simple form for editing user contact information. Adding, removing, clearing, and
 * greeting are methods declared on the controller (see source tab). These methods can
 * easily be called from the angular markup. Notice that the scope becomes the `this` for the
 * controller's instance. This allows for easy access to the view data from the controller. Also
 * notice that any changes to the data are automatically reflected in the View without the need
 * for a manual update. The example is included in two different declaration styles based on
 * your style preferences.
   <doc:example>
     <doc:source>
      <script>
        function SettingsController1() {
          this.name = "John Smith";
          this.contacts = [
            {type: 'phone', value: '408 555 1212'},
            {type: 'email', value: 'john.smith@example.org'} ];
          };

        SettingsController1.prototype.greet = function() {
          alert(this.name);
        };

        SettingsController1.prototype.addContact = function() {
          this.contacts.push({type: 'email', value: 'yourname@example.org'});
        };

        SettingsController1.prototype.removeContact = function(contactToRemove) {
         var index = this.contacts.indexOf(contactToRemove);
          this.contacts.splice(index, 1);
        };

        SettingsController1.prototype.clearContact = function(contact) {
          contact.type = 'phone';
          contact.value = '';
        };
      </script>
      <div id="ctrl-as-exmpl" ng-controller="SettingsController1 as settings">
        Name: <input type="text" ng-model="settings.name"/>
        [ <a href="" ng-click="settings.greet()">greet</a> ]<br/>
        Contact:
        <ul>
          <li ng-repeat="contact in settings.contacts">
            <select ng-model="contact.type">
               <option>phone</option>
               <option>email</option>
            </select>
            <input type="text" ng-model="contact.value"/>
            [ <a href="" ng-click="settings.clearContact(contact)">clear</a>
            | <a href="" ng-click="settings.removeContact(contact)">X</a> ]
          </li>
          <li>[ <a href="" ng-click="settings.addContact()">add</a> ]</li>
       </ul>
      </div>
     </doc:source>
     <doc:scenario>
       it('should check controller as', function() {
         expect(element('#ctrl-as-exmpl>:input').val()).toBe('John Smith');
         expect(element('#ctrl-as-exmpl li:nth-child(1) input').val())
           .toBe('408 555 1212');
         expect(element('#ctrl-as-exmpl li:nth-child(2) input').val())
           .toBe('john.smith@example.org');

         element('#ctrl-as-exmpl li:first a:contains("clear")').click();
         expect(element('#ctrl-as-exmpl li:first input').val()).toBe('');

         element('#ctrl-as-exmpl li:last a:contains("add")').click();
         expect(element('#ctrl-as-exmpl li:nth-child(3) input').val())
           .toBe('yourname@example.org');
       });
     </doc:scenario>
   </doc:example>
    <doc:example>
     <doc:source>
      <script>
        function SettingsController2($scope) {
          $scope.name = "John Smith";
          $scope.contacts = [
            {type:'phone', value:'408 555 1212'},
            {type:'email', value:'john.smith@example.org'} ];

          $scope.greet = function() {
           alert(this.name);
          };

          $scope.addContact = function() {
           this.contacts.push({type:'email', value:'yourname@example.org'});
          };

          $scope.removeContact = function(contactToRemove) {
           var index = this.contacts.indexOf(contactToRemove);
           this.contacts.splice(index, 1);
          };

          $scope.clearContact = function(contact) {
           contact.type = 'phone';
           contact.value = '';
          };
        }
      </script>
      <div id="ctrl-exmpl" ng-controller="SettingsController2">
        Name: <input type="text" ng-model="name"/>
        [ <a href="" ng-click="greet()">greet</a> ]<br/>
        Contact:
        <ul>
          <li ng-repeat="contact in contacts">
            <select ng-model="contact.type">
               <option>phone</option>
               <option>email</option>
            </select>
            <input type="text" ng-model="contact.value"/>
            [ <a href="" ng-click="clearContact(contact)">clear</a>
            | <a href="" ng-click="removeContact(contact)">X</a> ]
          </li>
          <li>[ <a href="" ng-click="addContact()">add</a> ]</li>
       </ul>
      </div>
     </doc:source>
     <doc:scenario>
       it('should check controller', function() {
         expect(element('#ctrl-exmpl>:input').val()).toBe('John Smith');
         expect(element('#ctrl-exmpl li:nth-child(1) input').val())
           .toBe('408 555 1212');
         expect(element('#ctrl-exmpl li:nth-child(2) input').val())
           .toBe('john.smith@example.org');

         element('#ctrl-exmpl li:first a:contains("clear")').click();
         expect(element('#ctrl-exmpl li:first input').val()).toBe('');

         element('#ctrl-exmpl li:last a:contains("add")').click();
         expect(element('#ctrl-exmpl li:nth-child(3) input').val())
           .toBe('yourname@example.org');
       });
     </doc:scenario>
   </doc:example>

 */
var ngControllerDirective = [function() {
  return {
    scope: true,
    controller: '@'
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngCsp
 * @priority 1000
 *
 * @element html
 * @description
 * Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.
 * 
 * This is necessary when developing things like Google Chrome Extensions.
 * 
 * CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).
 * For us to be compatible, we just need to implement the "getterFn" in $parse without violating
 * any of these restrictions.
 * 
 * AngularJS uses `Function(string)` generated functions as a speed optimization. By applying `ngCsp`
 * it is be possible to opt into the CSP compatible mode. When this mode is on AngularJS will
 * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will
 * be raised.
 * 
 * In order to use this feature put `ngCsp` directive on the root element of the application.
 * 
 * @example
 * This example shows how to apply the `ngCsp` directive to the `html` tag.
   <pre>
     <!doctype html>
     <html ng-app ng-csp>
     ...
     ...
     </html>
   </pre>
 */

var ngCspDirective = ['$sniffer', function($sniffer) {
  return {
    priority: 1000,
    compile: function() {
      $sniffer.csp = true;
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngClick
 *
 * @description
 * The ngClick allows you to specify custom behavior when
 * element is clicked.
 *
 * @element ANY
 * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon
 * click. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <button ng-click="count = count + 1" ng-init="count=0">
        Increment
      </button>
      count: {{count}}
     </doc:source>
     <doc:scenario>
       it('should check ng-click', function() {
         expect(binding('count')).toBe('0');
         element('.doc-example-live :button').click();
         expect(binding('count')).toBe('1');
       });
     </doc:scenario>
   </doc:example>
 */
/*
 * A directive that allows creation of custom onclick handlers that are defined as angular
 * expressions and are compiled and executed within the current scope.
 *
 * Events that are handled via these handler are always configured not to propagate further.
 */
var ngEventDirectives = {};
forEach(
  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur'.split(' '),
  function(name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = ['$parse', function($parse) {
      return function(scope, element, attr) {
        var fn = $parse(attr[directiveName]);
        element.on(lowercase(name), function(event) {
          scope.$apply(function() {
            fn(scope, {$event:event});
          });
        });
      };
    }];
  }
);

/**
 * @ngdoc directive
 * @name ng.directive:ngDblclick
 *
 * @description
 * The `ngDblclick` directive allows you to specify custom behavior on dblclick event.
 *
 * @element ANY
 * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
 * dblclick. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMousedown
 *
 * @description
 * The ngMousedown directive allows you to specify custom behavior on mousedown event.
 *
 * @element ANY
 * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
 * mousedown. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseup
 *
 * @description
 * Specify custom behavior on mouseup event.
 *
 * @element ANY
 * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
 * mouseup. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngMouseover
 *
 * @description
 * Specify custom behavior on mouseover event.
 *
 * @element ANY
 * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
 * mouseover. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseenter
 *
 * @description
 * Specify custom behavior on mouseenter event.
 *
 * @element ANY
 * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
 * mouseenter. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseleave
 *
 * @description
 * Specify custom behavior on mouseleave event.
 *
 * @element ANY
 * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
 * mouseleave. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMousemove
 *
 * @description
 * Specify custom behavior on mousemove event.
 *
 * @element ANY
 * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
 * mousemove. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeydown
 *
 * @description
 * Specify custom behavior on keydown event.
 *
 * @element ANY
 * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
 * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeyup
 *
 * @description
 * Specify custom behavior on keyup event.
 *
 * @element ANY
 * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
 * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeypress
 *
 * @description
 * Specify custom behavior on keypress event.
 *
 * @element ANY
 * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
 * keypress. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngSubmit
 *
 * @description
 * Enables binding angular expressions to onsubmit events.
 *
 * Additionally it prevents the default action (which for form means sending the request to the
 * server and reloading the current page) **but only if the form does not contain an `action`
 * attribute**.
 *
 * @element form
 * @param {expression} ngSubmit {@link guide/expression Expression} to eval. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <script>
        function Ctrl($scope) {
          $scope.list = [];
          $scope.text = 'hello';
          $scope.submit = function() {
            if (this.text) {
              this.list.push(this.text);
              this.text = '';
            }
          };
        }
      </script>
      <form ng-submit="submit()" ng-controller="Ctrl">
        Enter text and hit enter:
        <input type="text" ng-model="text" name="text" />
        <input type="submit" id="submit" value="Submit" />
        <pre>list={{list}}</pre>
      </form>
     </doc:source>
     <doc:scenario>
       it('should check ng-submit', function() {
         expect(binding('list')).toBe('[]');
         element('.doc-example-live #submit').click();
         expect(binding('list')).toBe('["hello"]');
         expect(input('text').val()).toBe('');
       });
       it('should ignore empty strings', function() {
         expect(binding('list')).toBe('[]');
         element('.doc-example-live #submit').click();
         element('.doc-example-live #submit').click();
         expect(binding('list')).toBe('["hello"]');
       });
     </doc:scenario>
   </doc:example>
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngFocus
 *
 * @description
 * Specify custom behavior on focus event.
 *
 * @element window, input, select, textarea, a
 * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon
 * focus. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngBlur
 *
 * @description
 * Specify custom behavior on blur event.
 *
 * @element window, input, select, textarea, a
 * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon
 * blur. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngIf
 * @restrict A
 *
 * @description
 * The `ngIf` directive removes and recreates a portion of the DOM tree (HTML)
 * conditionally based on **"falsy"** and **"truthy"** values, respectively, evaluated within
 * an {expression}. In other words, if the expression assigned to **ngIf evaluates to a false
 * value** then **the element is removed from the DOM** and **if true** then **a clone of the
 * element is reinserted into the DOM**.
 *
 * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the
 * element in the DOM rather than changing its visibility via the `display` css property.  A common
 * case when this difference is significant is when using css selectors that rely on an element's
 * position within the DOM (HTML), such as the `:first-child` or `:last-child` pseudo-classes.
 *
 * Note that **when an element is removed using ngIf its scope is destroyed** and **a new scope
 * is created when the element is restored**.  The scope created within `ngIf` inherits from 
 * its parent scope using
 * {@link https://github.com/angular/angular.js/wiki/The-Nuances-of-Scope-Prototypal-Inheritance prototypal inheritance}.
 * An important implication of this is if `ngModel` is used within `ngIf` to bind to
 * a javascript primitive defined in the parent scope. In this case any modifications made to the
 * variable within the child scope will override (hide) the value in the parent scope.
 *
 * Also, `ngIf` recreates elements using their compiled state. An example scenario of this behavior
 * is if an element's class attribute is directly modified after it's compiled, using something like 
 * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element
 * the added class will be lost because the original compiled state is used to regenerate the element.
 *
 * Additionally, you can provide animations via the ngAnimate module to animate the **enter**
 * and **leave** effects.
 *
 * @animations
 * enter - happens just after the ngIf contents change and a new DOM element is created and injected into the ngIf container
 * leave - happens just before the ngIf contents are removed from the DOM
 *
 * @element ANY
 * @scope
 * @param {expression} ngIf If the {@link guide/expression expression} is falsy then
 *     the element is removed from the DOM tree (HTML).
 *
 * @example
  <example animations="true">
    <file name="index.html">
      Click me: <input type="checkbox" ng-model="checked" ng-init="checked=true" /><br/>
      Show when checked:
      <span ng-if="checked" class="animate-if">
        I'm removed when the checkbox is unchecked.
      </span>
    </file>
    <file name="animations.css">
      .animate-if {
        background:white;
        border:1px solid black;
        padding:10px;
      }

      .animate-if.ng-enter, .animate-if.ng-leave {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
      }

      .animate-if.ng-enter,
      .animate-if.ng-leave.ng-leave-active {
        opacity:0;
      }

      .animate-if.ng-enter.ng-enter-active,
      .animate-if.ng-leave {
        opacity:1;
      }
    </file>
  </example>
 */
var ngIfDirective = ['$animate', function($animate) {
  return {
    transclude: 'element',
    priority: 1000,
    terminal: true,
    restrict: 'A',
    compile: function (element, attr, transclude) {
      return function ($scope, $element, $attr) {
        var childElement, childScope;
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
          if (childElement) {
            $animate.leave(childElement);
            childElement = undefined;
          }
          if (childScope) {
            childScope.$destroy();
            childScope = undefined;
          }
          if (toBoolean(value)) {
            childScope = $scope.$new();
            transclude(childScope, function (clone) {
              childElement = clone;
              $animate.enter(clone, $element.parent(), $element);
            });
          }
        });
      }
    }
  }
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngInclude
 * @restrict ECA
 *
 * @description
 * Fetches, compiles and includes an external HTML fragment.
 *
 * Keep in mind that:
 *
 * -    by default, the template URL is restricted to the same domain and protocol as the
 *      application document.  This is done by calling {@link ng.$sce#getTrustedResourceUrl
 *      $sce.getTrustedResourceUrl} on it.  To load templates from other domains and/or protocols,
 *      you may either either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist them} or
 *      {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted value.  Refer Angular's {@link
 *      ng.$sce Strict Contextual Escaping}.
 * -    in addition, the browser's
 *      {@link https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest
 *      Same Origin Policy} and {@link http://www.w3.org/TR/cors/ Cross-Origin Resource Sharing
 *      (CORS)} policy apply that may further restrict whether the template is successfully loaded.
 *      (e.g.  ngInclude won't work for cross-domain requests on all browsers and for `file://`
 *      access on some browsers)
 *
 * @animations
 * enter - animation is used to bring new content into the browser.
 * leave - animation is used to animate existing content away.
 *
 * The enter and leave animation occur concurrently.
 *
 * @scope
 *
 * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,
 *                 make sure you wrap it in quotes, e.g. `src="'myPartialTemplate.html'"`.
 * @param {string=} onload Expression to evaluate when a new partial is loaded.
 *
 * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll
 *                  $anchorScroll} to scroll the viewport after the content is loaded.
 *
 *                  - If the attribute is not set, disable scrolling.
 *                  - If the attribute is set without value, enable scrolling.
 *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
 *
 * @example
  <example animations="true">
    <file name="index.html">
     <div ng-controller="Ctrl">
       <select ng-model="template" ng-options="t.name for t in templates">
        <option value="">(blank)</option>
       </select>
       url of the template: <tt>{{template.url}}</tt>
       <hr/>
       <div class="example-animate-container">
         <div class="include-example" ng-include="template.url"></div>
       </div>
     </div>
    </file>
    <file name="script.js">
      function Ctrl($scope) {
        $scope.templates =
          [ { name: 'template1.html', url: 'template1.html'}
          , { name: 'template2.html', url: 'template2.html'} ];
        $scope.template = $scope.templates[0];
      }
     </file>
    <file name="template1.html">
      Content of template1.html
    </file>
    <file name="template2.html">
      Content of template2.html
    </file>
    <file name="animations.css">
      .example-animate-container {
        position:relative;
        background:white;
        border:1px solid black;
        height:40px;
        overflow:hidden;
      }

      .example-animate-container > div {
        padding:10px;
      }

      .include-example.ng-enter, .include-example.ng-leave {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
        display:block;
        padding:10px;
      }

      .include-example.ng-enter {
        top:-50px;
      }
      .include-example.ng-enter.ng-enter-active {
        top:0;
      }

      .include-example.ng-leave {
        top:0;
      }
      .include-example.ng-leave.ng-leave-active {
        top:50px;
      }
    </file>
    <file name="scenario.js">
      it('should load template1.html', function() {
       expect(element('.doc-example-live [ng-include]').text()).
         toMatch(/Content of template1.html/);
      });
      it('should load template2.html', function() {
       select('template').option('1');
       expect(element('.doc-example-live [ng-include]').text()).
         toMatch(/Content of template2.html/);
      });
      it('should change to blank', function() {
       select('template').option('');
       expect(element('.doc-example-live [ng-include]')).toBe(undefined);
      });
    </file>
  </example>
 */


/**
 * @ngdoc event
 * @name ng.directive:ngInclude#$includeContentRequested
 * @eventOf ng.directive:ngInclude
 * @eventType emit on the scope ngInclude was declared in
 * @description
 * Emitted every time the ngInclude content is requested.
 */


/**
 * @ngdoc event
 * @name ng.directive:ngInclude#$includeContentLoaded
 * @eventOf ng.directive:ngInclude
 * @eventType emit on the current ngInclude scope
 * @description
 * Emitted every time the ngInclude content is reloaded.
 */
var ngIncludeDirective = ['$http', '$templateCache', '$anchorScroll', '$compile', '$animate', '$sce',
                  function($http,   $templateCache,   $anchorScroll,   $compile,   $animate,   $sce) {
  return {
    restrict: 'ECA',
    terminal: true,
    transclude: 'element',
    compile: function(element, attr, transclusion) {
      var srcExp = attr.ngInclude || attr.src,
          onloadExp = attr.onload || '',
          autoScrollExp = attr.autoscroll;

      return function(scope, $element) {
        var changeCounter = 0,
            currentScope,
            currentElement;

        var cleanupLastIncludeContent = function() {
          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if(currentElement) {
            $animate.leave(currentElement);
            currentElement = null;
          }
        };

        scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
          var thisChangeId = ++changeCounter;

          if (src) {
            $http.get(src, {cache: $templateCache}).success(function(response) {
              if (thisChangeId !== changeCounter) return;
              var newScope = scope.$new();

              transclusion(newScope, function(clone) {
                cleanupLastIncludeContent();

                currentScope = newScope;
                currentElement = clone;

                currentElement.html(response);
                $animate.enter(currentElement, null, $element);
                $compile(currentElement.contents())(currentScope);

                if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }

                currentScope.$emit('$includeContentLoaded');
                scope.$eval(onloadExp);
              });
            }).error(function() {
              if (thisChangeId === changeCounter) cleanupLastIncludeContent();
            });
            scope.$emit('$includeContentRequested');
          } else {
            cleanupLastIncludeContent();
          }
        });
      };
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngInit
 *
 * @description
 * The `ngInit` directive specifies initialization tasks to be executed
 *  before the template enters execution mode during bootstrap.
 *
 * @element ANY
 * @param {expression} ngInit {@link guide/expression Expression} to eval.
 *
 * @example
   <doc:example>
     <doc:source>
    <div ng-init="greeting='Hello'; person='World'">
      {{greeting}} {{person}}!
    </div>
     </doc:source>
     <doc:scenario>
       it('should check greeting', function() {
         expect(binding('greeting')).toBe('Hello');
         expect(binding('person')).toBe('World');
       });
     </doc:scenario>
   </doc:example>
 */
var ngInitDirective = ngDirective({
  compile: function() {
    return {
      pre: function(scope, element, attrs) {
        scope.$eval(attrs.ngInit);
      }
    }
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngNonBindable
 * @priority 1000
 *
 * @description
 * Sometimes it is necessary to write code which looks like bindings but which should be left alone
 * by angular. Use `ngNonBindable` to make angular ignore a chunk of HTML.
 *
 * @element ANY
 *
 * @example
 * In this example there are two location where a simple binding (`{{}}`) is present, but the one
 * wrapped in `ngNonBindable` is left alone.
 *
 * @example
    <doc:example>
      <doc:source>
        <div>Normal: {{1 + 2}}</div>
        <div ng-non-bindable>Ignored: {{1 + 2}}</div>
      </doc:source>
      <doc:scenario>
       it('should check ng-non-bindable', function() {
         expect(using('.doc-example-live').binding('1 + 2')).toBe('3');
         expect(using('.doc-example-live').element('div:last').text()).
           toMatch(/1 \+ 2/);
       });
      </doc:scenario>
    </doc:example>
 */
var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });

/**
 * @ngdoc directive
 * @name ng.directive:ngPluralize
 * @restrict EA
 *
 * @description
 * # Overview
 * `ngPluralize` is a directive that displays messages according to en-US localization rules.
 * These rules are bundled with angular.js, but can be overridden
 * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive
 * by specifying the mappings between
 * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
 * plural categories} and the strings to be displayed.
 *
 * # Plural categories and explicit number rules
 * There are two
 * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
 * plural categories} in Angular's default en-US locale: "one" and "other".
 *
 * While a plural category may match many numbers (for example, in en-US locale, "other" can match
 * any number that is not 1), an explicit number rule can only match one number. For example, the
 * explicit number rule for "3" matches the number 3. There are examples of plural categories
 * and explicit number rules throughout the rest of this documentation.
 *
 * # Configuring ngPluralize
 * You configure ngPluralize by providing 2 attributes: `count` and `when`.
 * You can also provide an optional attribute, `offset`.
 *
 * The value of the `count` attribute can be either a string or an {@link guide/expression
 * Angular expression}; these are evaluated on the current scope for its bound value.
 *
 * The `when` attribute specifies the mappings between plural categories and the actual
 * string to be displayed. The value of the attribute should be a JSON object.
 *
 * The following example shows how to configure ngPluralize:
 *
 * <pre>
 * <ng-pluralize count="personCount"
                 when="{'0': 'Nobody is viewing.',
 *                      'one': '1 person is viewing.',
 *                      'other': '{} people are viewing.'}">
 * </ng-pluralize>
 *</pre>
 *
 * In the example, `"0: Nobody is viewing."` is an explicit number rule. If you did not
 * specify this rule, 0 would be matched to the "other" category and "0 people are viewing"
 * would be shown instead of "Nobody is viewing". You can specify an explicit number rule for
 * other numbers, for example 12, so that instead of showing "12 people are viewing", you can
 * show "a dozen people are viewing".
 *
 * You can use a set of closed braces(`{}`) as a placeholder for the number that you want substituted
 * into pluralized strings. In the previous example, Angular will replace `{}` with
 * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder
 * for <span ng-non-bindable>{{numberExpression}}</span>.
 *
 * # Configuring ngPluralize with offset
 * The `offset` attribute allows further customization of pluralized text, which can result in
 * a better user experience. For example, instead of the message "4 people are viewing this document",
 * you might display "John, Kate and 2 others are viewing this document".
 * The offset attribute allows you to offset a number by any desired value.
 * Let's take a look at an example:
 *
 * <pre>
 * <ng-pluralize count="personCount" offset=2
 *               when="{'0': 'Nobody is viewing.',
 *                      '1': '{{person1}} is viewing.',
 *                      '2': '{{person1}} and {{person2}} are viewing.',
 *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',
 *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
 * </ng-pluralize>
 * </pre>
 *
 * Notice that we are still using two plural categories(one, other), but we added
 * three explicit number rules 0, 1 and 2.
 * When one person, perhaps John, views the document, "John is viewing" will be shown.
 * When three people view the document, no explicit number rule is found, so
 * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.
 * In this case, plural category 'one' is matched and "John, Marry and one other person are viewing"
 * is shown.
 *
 * Note that when you specify offsets, you must provide explicit number rules for
 * numbers from 0 up to and including the offset. If you use an offset of 3, for example,
 * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for
 * plural categories "one" and "other".
 *
 * @param {string|expression} count The variable to be bounded to.
 * @param {string} when The mapping between plural category to its corresponding strings.
 * @param {number=} offset Offset to deduct from the total number.
 *
 * @example
    <doc:example>
      <doc:source>
        <script>
          function Ctrl($scope) {
            $scope.person1 = 'Igor';
            $scope.person2 = 'Misko';
            $scope.personCount = 1;
          }
        </script>
        <div ng-controller="Ctrl">
          Person 1:<input type="text" ng-model="person1" value="Igor" /><br/>
          Person 2:<input type="text" ng-model="person2" value="Misko" /><br/>
          Number of People:<input type="text" ng-model="personCount" value="1" /><br/>

          <!--- Example with simple pluralization rules for en locale --->
          Without Offset:
          <ng-pluralize count="personCount"
                        when="{'0': 'Nobody is viewing.',
                               'one': '1 person is viewing.',
                               'other': '{} people are viewing.'}">
          </ng-pluralize><br>

          <!--- Example with offset --->
          With Offset(2):
          <ng-pluralize count="personCount" offset=2
                        when="{'0': 'Nobody is viewing.',
                               '1': '{{person1}} is viewing.',
                               '2': '{{person1}} and {{person2}} are viewing.',
                               'one': '{{person1}}, {{person2}} and one other person are viewing.',
                               'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
          </ng-pluralize>
        </div>
      </doc:source>
      <doc:scenario>
        it('should show correct pluralized string', function() {
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                             toBe('1 person is viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                                                toBe('Igor is viewing.');

          using('.doc-example-live').input('personCount').enter('0');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                               toBe('Nobody is viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                                              toBe('Nobody is viewing.');

          using('.doc-example-live').input('personCount').enter('2');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('2 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor and Misko are viewing.');

          using('.doc-example-live').input('personCount').enter('3');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('3 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor, Misko and one other person are viewing.');

          using('.doc-example-live').input('personCount').enter('4');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('4 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor, Misko and 2 other people are viewing.');
        });

        it('should show data-binded names', function() {
          using('.doc-example-live').input('personCount').enter('4');
          expect(element('.doc-example-live ng-pluralize:last').text()).
              toBe('Igor, Misko and 2 other people are viewing.');

          using('.doc-example-live').input('person1').enter('Di');
          using('.doc-example-live').input('person2').enter('Vojta');
          expect(element('.doc-example-live ng-pluralize:last').text()).
              toBe('Di, Vojta and 2 other people are viewing.');
        });
      </doc:scenario>
    </doc:example>
 */
var ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {
  var BRACE = /{}/g;
  return {
    restrict: 'EA',
    link: function(scope, element, attr) {
      var numberExp = attr.count,
          whenExp = attr.$attr.when && element.attr(attr.$attr.when), // we have {{}} in attrs
          offset = attr.offset || 0,
          whens = scope.$eval(whenExp) || {},
          whensExpFns = {},
          startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          isWhen = /^when(Minus)?(.+)$/;

      forEach(attr, function(expression, attributeName) {
        if (isWhen.test(attributeName)) {
          whens[lowercase(attributeName.replace('when', '').replace('Minus', '-'))] =
            element.attr(attr.$attr[attributeName]);
        }
      });
      forEach(whens, function(expression, key) {
        whensExpFns[key] =
          $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' +
            offset + endSymbol));
      });

      scope.$watch(function ngPluralizeWatch() {
        var value = parseFloat(scope.$eval(numberExp));

        if (!isNaN(value)) {
          //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,
          //check it against pluralization rules in $locale service
          if (!(value in whens)) value = $locale.pluralCat(value - offset);
           return whensExpFns[value](scope, element, true);
        } else {
          return '';
        }
      }, function ngPluralizeWatchAction(newVal) {
        element.text(newVal);
      });
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngRepeat
 *
 * @description
 * The `ngRepeat` directive instantiates a template once per item from a collection. Each template
 * instance gets its own scope, where the given loop variable is set to the current collection item,
 * and `$index` is set to the item index or key.
 *
 * Special properties are exposed on the local scope of each template instance, including:
 *
 * | Variable  | Type            | Details                                                                     |
 * |-----------|-----------------|-----------------------------------------------------------------------------|
 * | `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |
 * | `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |
 * | `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |
 * | `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |
 * | `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |
 * | `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |
 *
 *
 * # Special repeat start and end points
 * To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending
 * the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.
 * The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it's defined on)
 * up to and including the ending HTML tag where **ng-repeat-end** is placed.
 *
 * The example below makes use of this feature:
 * <pre>
 *   <header ng-repeat-start="item in items">
 *     Header {{ item }}
 *   </header>
 *   <div class="body">
 *     Body {{ item }}
 *   </div>
 *   <footer ng-repeat-end>
 *     Footer {{ item }}
 *   </footer>
 * </pre>
 *
 * And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:
 * <pre>
 *   <header>
 *     Header A
 *   </header>
 *   <div class="body">
 *     Body A
 *   </div>
 *   <footer>
 *     Footer A
 *   </footer>
 *   <header>
 *     Header B
 *   </header>
 *   <div class="body">
 *     Body B
 *   </div>
 *   <footer>
 *     Footer B
 *   </footer>
 * </pre>
 *
 * The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such
 * as **data-ng-repeat-start**, **x-ng-repeat-start** and **ng:repeat-start**).
 *
 * @animations
 * enter - when a new item is added to the list or when an item is revealed after a filter
 * leave - when an item is removed from the list or when an item is filtered out
 * move - when an adjacent item is filtered out causing a reorder or when the item contents are reordered
 *
 * @element ANY
 * @scope
 * @priority 1000
 * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These
 *   formats are currently supported:
 *
 *   * `variable in expression`  where variable is the user defined loop variable and `expression`
 *     is a scope expression giving the collection to enumerate.
 *
 *     For example: `album in artist.albums`.
 *
 *   * `(key, value) in expression`  where `key` and `value` can be any user defined identifiers,
 *     and `expression` is the scope expression giving the collection to enumerate.
 *
 *     For example: `(name, age) in {'adam':10, 'amalie':12}`.
 *
 *   * `variable in expression track by tracking_expression`  You can also provide an optional tracking function
 *     which can be used to associate the objects in the collection with the DOM elements. If no tracking function
 *     is specified the ng-repeat associates elements by identity in the collection. It is an error to have
 *     more than one tracking function to resolve to the same key. (This would mean that two distinct objects are
 *     mapped to the same DOM element, which is not possible.)  Filters should be applied to the expression,
 *     before specifying a tracking expression.
 *
 *     For example: `item in items` is equivalent to `item in items track by $id(item)'. This implies that the DOM elements
 *     will be associated by item identity in the array.
 *
 *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique
 *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements
 *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM
 *     element in the same way ian the DOM.
 *
 *     For example: `item in items track by item.id` is a typical pattern when the items come from the database. In this
 *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`
 *     property is same.
 *
 *     For example: `item in items | filter:searchText track by item.id` is a pattern that might be used to apply a filter
 *     to items in conjunction with a tracking expression.
 *
 * @example
 * This example initializes the scope to a list of names and
 * then uses `ngRepeat` to display every person:
  <example animations="true">
    <file name="index.html">
      <div ng-init="friends = [
        {name:'John', age:25, gender:'boy'},
        {name:'Jessie', age:30, gender:'girl'},
        {name:'Johanna', age:28, gender:'girl'},
        {name:'Joy', age:15, gender:'girl'},
        {name:'Mary', age:28, gender:'girl'},
        {name:'Peter', age:95, gender:'boy'},
        {name:'Sebastian', age:50, gender:'boy'},
        {name:'Erika', age:27, gender:'girl'},
        {name:'Patrick', age:40, gender:'boy'},
        {name:'Samantha', age:60, gender:'girl'}
      ]">
        I have {{friends.length}} friends. They are:
        <input type="search" ng-model="q" placeholder="filter friends..." />
        <ul class="example-animate-container">
          <li class="animate-repeat" ng-repeat="friend in friends | filter:q">
            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
          </li>
        </ul>
      </div>
    </file>
    <file name="animations.css">
      .example-animate-container {
        background:white;
        border:1px solid black;
        list-style:none;
        margin:0;
        padding:0;
      }

      .example-animate-container > li {
        padding:10px;
        list-style:none;
      }

      .animate-repeat.ng-enter,
      .animate-repeat.ng-leave,
      .animate-repeat.ng-move {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
      }

      .animate-repeat.ng-enter {
        line-height:0;
        opacity:0;
        padding-top:0;
        padding-bottom:0;
      }
      .animate-repeat.ng-enter.ng-enter-active {
        line-height:20px;
        opacity:1;
        padding:10px;
      }

      .animate-repeat.ng-leave {
        opacity:1;
        line-height:20px;
        padding:10px;
      }
      .animate-repeat.ng-leave.ng-leave-active {
        opacity:0;
        line-height:0;
        padding-top:0;
        padding-bottom:0;
      }

      .animate-repeat.ng-move { }
      .animate-repeat.ng-move.ng-move-active { }
    </file>
    <file name="scenario.js">
       it('should render initial data set', function() {
         var r = using('.doc-example-live').repeater('ul li');
         expect(r.count()).toBe(10);
         expect(r.row(0)).toEqual(["1","John","25"]);
         expect(r.row(1)).toEqual(["2","Jessie","30"]);
         expect(r.row(9)).toEqual(["10","Samantha","60"]);
         expect(binding('friends.length')).toBe("10");
       });

       it('should update repeater when filter predicate changes', function() {
         var r = using('.doc-example-live').repeater('ul li');
         expect(r.count()).toBe(10);

         input('q').enter('ma');

         expect(r.count()).toBe(2);
         expect(r.row(0)).toEqual(["1","Mary","28"]);
         expect(r.row(1)).toEqual(["2","Samantha","60"]);
       });
      </file>
    </example>
 */
var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
  var NG_REMOVED = '$$NG_REMOVED';
  var ngRepeatMinErr = minErr('ngRepeat');
  return {
    transclude: 'element',
    priority: 1000,
    terminal: true,
    compile: function(element, attr, linker) {
      return function($scope, $element, $attr){
        var expression = $attr.ngRepeat;
        var match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s*(\s+track\s+by\s+(.+)\s*)?$/),
          trackByExp, trackByExpGetter, trackByIdFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier,
          hashFnLocals = {$id: hashKey};

        if (!match) {
          throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
            expression);
        }

        lhs = match[1];
        rhs = match[2];
        trackByExp = match[4];

        if (trackByExp) {
          trackByExpGetter = $parse(trackByExp);
          trackByIdFn = function(key, value, index) {
            // assign key, value, and $index to the locals so that they can be used in hash functions
            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
            hashFnLocals[valueIdentifier] = value;
            hashFnLocals.$index = index;
            return trackByExpGetter($scope, hashFnLocals);
          };
        } else {
          trackByIdArrayFn = function(key, value) {
            return hashKey(value);
          }
          trackByIdObjFn = function(key) {
            return key;
          }
        }

        match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
        if (!match) {
          throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
                                                                    lhs);
        }
        valueIdentifier = match[3] || match[1];
        keyIdentifier = match[2];

        // Store a list of elements from previous run. This is a hash where key is the item from the
        // iterator, and the value is objects with following properties.
        //   - scope: bound scope
        //   - element: previous element.
        //   - index: position
        var lastBlockMap = {};

        //watch props
        $scope.$watchCollection(rhs, function ngRepeatAction(collection){
          var index, length,
              previousNode = $element[0],     // current position of the node
              nextNode,
              // Same as lastBlockMap but it has the current state. It will become the
              // lastBlockMap on the next iteration.
              nextBlockMap = {},
              arrayLength,
              childScope,
              key, value, // key/value of iteration
              trackById,
              collectionKeys,
              block,       // last object information {scope, element, id}
              nextBlockOrder = [];


          if (isArrayLike(collection)) {
            collectionKeys = collection;
            trackByIdFn = trackByIdFn || trackByIdArrayFn;
          } else {
            trackByIdFn = trackByIdFn || trackByIdObjFn;
            // if object, extract keys, sort them and use to determine order of iteration over obj props
            collectionKeys = [];
            for (key in collection) {
              if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                collectionKeys.push(key);
              }
            }
            collectionKeys.sort();
          }

          arrayLength = collectionKeys.length;

          // locate existing items
          length = nextBlockOrder.length = collectionKeys.length;
          for(index = 0; index < length; index++) {
           key = (collection === collectionKeys) ? index : collectionKeys[index];
           value = collection[key];
           trackById = trackByIdFn(key, value, index);
           if(lastBlockMap.hasOwnProperty(trackById)) {
             block = lastBlockMap[trackById]
             delete lastBlockMap[trackById];
             nextBlockMap[trackById] = block;
             nextBlockOrder[index] = block;
           } else if (nextBlockMap.hasOwnProperty(trackById)) {
             // restore lastBlockMap
             forEach(nextBlockOrder, function(block) {
               if (block && block.startNode) lastBlockMap[block.id] = block;
             });
             // This is a duplicate and we need to throw an error
             throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}",
                                                                                                                                                    expression,       trackById);
           } else {
             // new never before seen block
             nextBlockOrder[index] = { id: trackById };
             nextBlockMap[trackById] = false;
           }
         }

          // remove existing items
          for (key in lastBlockMap) {
            if (lastBlockMap.hasOwnProperty(key)) {
              block = lastBlockMap[key];
              $animate.leave(block.elements);
              forEach(block.elements, function(element) { element[NG_REMOVED] = true});
              block.scope.$destroy();
            }
          }

          // we are not using forEach for perf reasons (trying to avoid #call)
          for (index = 0, length = collectionKeys.length; index < length; index++) {
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            block = nextBlockOrder[index];

            if (block.startNode) {
              // if we have already seen this object, then we need to reuse the
              // associated scope/element
              childScope = block.scope;

              nextNode = previousNode;
              do {
                nextNode = nextNode.nextSibling;
              } while(nextNode && nextNode[NG_REMOVED]);

              if (block.startNode == nextNode) {
                // do nothing
              } else {
                // existing item which got moved
                $animate.move(block.elements, null, jqLite(previousNode));
              }
              previousNode = block.endNode;
            } else {
              // new item which we don't know about
              childScope = $scope.$new();
            }

            childScope[valueIdentifier] = value;
            if (keyIdentifier) childScope[keyIdentifier] = key;
            childScope.$index = index;
            childScope.$first = (index === 0);
            childScope.$last = (index === (arrayLength - 1));
            childScope.$middle = !(childScope.$first || childScope.$last);
            childScope.$odd = !(childScope.$even = index%2==0);

            if (!block.startNode) {
              linker(childScope, function(clone) {
                $animate.enter(clone, null, jqLite(previousNode));
                previousNode = clone;
                block.scope = childScope;
                block.startNode = clone[0];
                block.elements = clone;
                block.endNode = clone[clone.length - 1];
                nextBlockMap[block.id] = block;
              });
            }
          }
          lastBlockMap = nextBlockMap;
        });
      };
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngShow
 *
 * @description
 * The `ngShow` directive shows and hides the given HTML element conditionally based on the expression
 * provided to the ngShow attribute. The show and hide mechanism is a achieved by removing and adding
 * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is a predefined CSS class present
 * in AngularJS which sets the display style to none (using an !important flag).
 *
 * <pre>
 * <!-- when $scope.myValue is truthy (element is visible) -->
 * <div ng-show="myValue"></div>
 *
 * <!-- when $scope.myValue is falsy (element is hidden) -->
 * <div ng-show="myValue" class="ng-hide"></div>
 * </pre>
 *
 * When the ngShow expression evaluates to false then the ng-hide CSS class is added to the class attribute
 * on the element causing it to become hidden. When true, the ng-hide CSS class is removed
 * from the element causing the element not to appear hidden.
 *
 * ## Why is !important used?
 *
 * You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector
 * can be easily overridden by heavier selectors. For example, something as simple
 * as changing the display style on a HTML list item would make hidden elements appear visible.
 * This also becomes a bigger issue when dealing with CSS frameworks.
 *
 * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
 * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
 * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
 *
 * ### Overriding .ng-hide
 *
 * If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by
 * restating the styles for the .ng-hide class in CSS:
 * <pre>
 * .ng-hide {
 *   //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...
 *   display:block!important;
 *
 *   //this is just another form of hiding an element
 *   position:absolute;
 *   top:-9999px;
 *   left:-9999px;
 * }
 * </pre>
 *
 * Just remember to include the important flag so the CSS override will function.
 *
 * ## A note about animations with ngShow
 *
 * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
 * is true and false. This system works similar to the animation system present with ngClass, however, the
 * only difference is that you must also include the !important flag to override the display property so
 * that you can perform an animation when the element is hidden during the time of the animation.
 *
 * <pre>
 * //
 * //a working example can be found at the bottom of this page
 * //
 * .my-element.ng-hide-add, .my-element.ng-hide-remove {
 *   transition:0.5s linear all;
 *   display:block!important;
 * }
 *
 * .my-element.ng-hide-add { ... }
 * .my-element.ng-hide-add.ng-hide-add-active { ... }
 * .my-element.ng-hide-remove { ... }
 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
 * </pre>
 *
 * @animations
 * addClass: .ng-hide - happens after the ngShow expression evaluates to a truthy value and the just before contents are set to visible
 * removeClass: .ng-hide - happens after the ngShow expression evaluates to a non truthy value and just before the contents are set to hidden
 *
 * @element ANY
 * @param {expression} ngShow If the {@link guide/expression expression} is truthy
 *     then the element is shown or hidden respectively.
 *
 * @example
  <example animations="true">
    <file name="index.html">
      Click me: <input type="checkbox" ng-model="checked"><br/>
      <div>
        Show:
        <div class="check-element animate-show" ng-show="checked">
          <span class="icon-thumbs-up"></span> I show up when your checkbox is checked.
        </div>
      </div>
      <div>
        Hide:
        <div class="check-element animate-show" ng-hide="checked">
          <span class="icon-thumbs-down"></span> I hide when your checkbox is checked.
        </div>
      </div>
    </file>
    <file name="animations.css">
      .animate-show.ng-hide-add, 
      .animate-show.ng-hide-remove {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
        display:block!important;
      }

      .animate-show.ng-hide-add.ng-hide-add-active,
      .animate-show.ng-hide-remove {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }

      .animate-show.ng-hide-add,
      .animate-show.ng-hide-remove.ng-hide-remove-active {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }

      .check-element {
        padding:10px;
        border:1px solid black;
        background:white;
      }
    </file>
    <file name="scenario.js">
       it('should check ng-show / ng-hide', function() {
         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);
         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);

         input('checked').check();

         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);
         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);
       });
    </file>
  </example>
 */
var ngShowDirective = ['$animate', function($animate) {
  return function(scope, element, attr) {
    scope.$watch(attr.ngShow, function ngShowWatchAction(value){
      $animate[toBoolean(value) ? 'removeClass' : 'addClass'](element, 'ng-hide');
    });
  };
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngHide
 *
 * @description
 * The `ngHide` directive shows and hides the given HTML element conditionally based on the expression
 * provided to the ngHide attribute. The show and hide mechanism is a achieved by removing and adding
 * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is a predefined CSS class present
 * in AngularJS which sets the display style to none (using an !important flag).
 *
 * <pre>
 * <!-- when $scope.myValue is truthy (element is hidden) -->
 * <div ng-hide="myValue"></div>
 *
 * <!-- when $scope.myValue is falsy (element is visible) -->
 * <div ng-hide="myValue" class="ng-hide"></div>
 * </pre>
 *
 * When the ngHide expression evaluates to true then the .ng-hide CSS class is added to the class attribute
 * on the element causing it to become hidden. When false, the ng-hide CSS class is removed
 * from the element causing the element not to appear hidden.
 *
 * ## Why is !important used?
 *
 * You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector
 * can be easily overridden by heavier selectors. For example, something as simple
 * as changing the display style on a HTML list item would make hidden elements appear visible.
 * This also becomes a bigger issue when dealing with CSS frameworks.
 *
 * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
 * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
 * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
 *
 * ### Overriding .ng-hide
 *
 * If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by
 * restating the styles for the .ng-hide class in CSS:
 * <pre>
 * .ng-hide {
 *   //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...
 *   display:block!important;
 *
 *   //this is just another form of hiding an element
 *   position:absolute;
 *   top:-9999px;
 *   left:-9999px;
 * }
 * </pre>
 *
 * Just remember to include the important flag so the CSS override will function.
 *
 * ## A note about animations with ngHide
 *
 * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
 * is true and false. This system works similar to the animation system present with ngClass, however, the
 * only difference is that you must also include the !important flag to override the display property so
 * that you can perform an animation when the element is hidden during the time of the animation.
 *
 * <pre>
 * //
 * //a working example can be found at the bottom of this page
 * //
 * .my-element.ng-hide-add, .my-element.ng-hide-remove {
 *   transition:0.5s linear all;
 *   display:block!important;
 * }
 *
 * .my-element.ng-hide-add { ... }
 * .my-element.ng-hide-add.ng-hide-add-active { ... }
 * .my-element.ng-hide-remove { ... }
 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
 * </pre>
 *
 * @animations
 * removeClass: .ng-hide - happens after the ngHide expression evaluates to a truthy value and just before the contents are set to hidden
 * addClass: .ng-hide - happens after the ngHide expression evaluates to a non truthy value and just before the contents are set to visible
 *
 * @element ANY
 * @param {expression} ngHide If the {@link guide/expression expression} is truthy then
 *     the element is shown or hidden respectively.
 *
 * @example
  <example animations="true">
    <file name="index.html">
      Click me: <input type="checkbox" ng-model="checked"><br/>
      <div>
        Show:
        <div class="check-element animate-hide" ng-show="checked">
          <span class="icon-thumbs-up"></span> I show up when your checkbox is checked.
        </div>
      </div>
      <div>
        Hide:
        <div class="check-element animate-hide" ng-hide="checked">
          <span class="icon-thumbs-down"></span> I hide when your checkbox is checked.
        </div>
      </div>
    </file>
    <file name="animations.css">
      .animate-hide.ng-hide-add, 
      .animate-hide.ng-hide-remove {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
        display:block!important;
      }

      .animate-hide.ng-hide-add.ng-hide-add-active,
      .animate-hide.ng-hide-remove {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }

      .animate-hide.ng-hide-add,
      .animate-hide.ng-hide-remove.ng-hide-remove-active {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }

      .check-element {
        padding:10px;
        border:1px solid black;
        background:white;
      }
    </file>
    <file name="scenario.js">
       it('should check ng-show / ng-hide', function() {
         expect(element('.doc-example-live .check-element:first:hidden').count()).toEqual(1);
         expect(element('.doc-example-live .check-element:last:visible').count()).toEqual(1);

         input('checked').check();

         expect(element('.doc-example-live .check-element:first:visible').count()).toEqual(1);
         expect(element('.doc-example-live .check-element:last:hidden').count()).toEqual(1);
       });
    </file>
  </example>
 */
var ngHideDirective = ['$animate', function($animate) {
  return function(scope, element, attr) {
    scope.$watch(attr.ngHide, function ngHideWatchAction(value){
      $animate[toBoolean(value) ? 'addClass' : 'removeClass'](element, 'ng-hide');
    });
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngStyle
 *
 * @description
 * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.
 *
 * @element ANY
 * @param {expression} ngStyle {@link guide/expression Expression} which evals to an
 *      object whose keys are CSS style names and values are corresponding values for those CSS
 *      keys.
 *
 * @example
   <example>
     <file name="index.html">
        <input type="button" value="set" ng-click="myStyle={color:'red'}">
        <input type="button" value="clear" ng-click="myStyle={}">
        <br/>
        <span ng-style="myStyle">Sample Text</span>
        <pre>myStyle={{myStyle}}</pre>
     </file>
     <file name="style.css">
       span {
         color: black;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-style', function() {
         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');
         element('.doc-example-live :button[value=set]').click();
         expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');
         element('.doc-example-live :button[value=clear]').click();
         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');
       });
     </file>
   </example>
 */
var ngStyleDirective = ngDirective(function(scope, element, attr) {
  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
    if (oldStyles && (newStyles !== oldStyles)) {
      forEach(oldStyles, function(val, style) { element.css(style, '');});
    }
    if (newStyles) element.css(newStyles);
  }, true);
});

/**
 * @ngdoc directive
 * @name ng.directive:ngSwitch
 * @restrict EA
 *
 * @description
 * The ngSwitch directive is used to conditionally swap DOM structure on your template based on a scope expression.
 * Elements within ngSwitch but without ngSwitchWhen or ngSwitchDefault directives will be preserved at the location
 * as specified in the template.
 *
 * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it
 * from the template cache), ngSwitch simply choses one of the nested elements and makes it visible based on which element
 * matches the value obtained from the evaluated expression. In other words, you define a container element
 * (where you place the directive), place an expression on the **on="..." attribute**
 * (or the **ng-switch="..." attribute**), define any inner elements inside of the directive and place
 * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
 * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
 * attribute is displayed.
 *
 * @animations
 * enter - happens after the ngSwtich contents change and the matched child element is placed inside the container
 * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM
 *
 * @usage
 * <ANY ng-switch="expression">
 *   <ANY ng-switch-when="matchValue1">...</ANY>
 *   <ANY ng-switch-when="matchValue2">...</ANY>
 *   <ANY ng-switch-default>...</ANY>
 * </ANY>
 *
 * @scope
 * @param {*} ngSwitch|on expression to match against <tt>ng-switch-when</tt>.
 * @paramDescription
 * On child elements add:
 *
 * * `ngSwitchWhen`: the case statement to match against. If match then this
 *   case will be displayed. If the same match appears multiple times, all the
 *   elements will be displayed.
 * * `ngSwitchDefault`: the default case when no other case match. If there
 *   are multiple default cases, all of them will be displayed when no other
 *   case match.
 *
 *
 * @example
  <example animations="true">
    <file name="index.html">
      <div ng-controller="Ctrl">
        <select ng-model="selection" ng-options="item for item in items">
        </select>
        <tt>selection={{selection}}</tt>
        <hr/>
        <div class="animate-switch-container"
          ng-switch on="selection">
            <div ng-switch-when="settings">Settings Div</div>
            <div ng-switch-when="home">Home Span</div>
            <div ng-switch-default>default</div>
        </div>
      </div>
    </file>
    <file name="script.js">
      function Ctrl($scope) {
        $scope.items = ['settings', 'home', 'other'];
        $scope.selection = $scope.items[0];
      }
    </file>
    <file name="animations.css">
      .animate-switch-container {
        position:relative;
        background:white;
        border:1px solid black;
        height:40px;
        overflow:hidden;
      }

      .animate-switch-container > div {
        padding:10px;
      }

      .animate-switch-container > .ng-enter,
      .animate-switch-container > .ng-leave {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
      }

      .animate-switch-container > .ng-enter {
        top:-50px;
      }
      .animate-switch-container > .ng-enter.ng-enter-active {
        top:0;
      }

      .animate-switch-container > .ng-leave {
        top:0;
      }
      .animate-switch-container > .ng-leave.ng-leave-active {
        top:50px;
      }
    </file>
    <file name="scenario.js">
      it('should start in settings', function() {
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);
      });
      it('should change to home', function() {
        select('selection').option('home');
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);
      });
      it('should select default', function() {
        select('selection').option('other');
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);
      });
    </file>
  </example>
 */
var ngSwitchDirective = ['$animate', function($animate) {
  return {
    restrict: 'EA',
    require: 'ngSwitch',

    // asks for $scope to fool the BC controller module
    controller: ['$scope', function ngSwitchController() {
     this.cases = {};
    }],
    link: function(scope, element, attr, ngSwitchController) {
      var watchExpr = attr.ngSwitch || attr.on,
          selectedTranscludes,
          selectedElements,
          selectedScopes = [];

      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
        for (var i= 0, ii=selectedScopes.length; i<ii; i++) {
          selectedScopes[i].$destroy();
          $animate.leave(selectedElements[i]);
        }

        selectedElements = [];
        selectedScopes = [];

        if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
          scope.$eval(attr.change);
          forEach(selectedTranscludes, function(selectedTransclude) {
            var selectedScope = scope.$new();
            selectedScopes.push(selectedScope);
            selectedTransclude.transclude(selectedScope, function(caseElement) {
              var anchor = selectedTransclude.element;

              selectedElements.push(caseElement);
              $animate.enter(caseElement, anchor.parent(), anchor);
            });
          });
        }
      });
    }
  }
}];

var ngSwitchWhenDirective = ngDirective({
  transclude: 'element',
  priority: 500,
  require: '^ngSwitch',
  compile: function(element, attrs, transclude) {
    return function(scope, element, attr, ctrl) {
      ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
      ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude: transclude, element: element });
    };
  }
});

var ngSwitchDefaultDirective = ngDirective({
  transclude: 'element',
  priority: 500,
  require: '^ngSwitch',
  compile: function(element, attrs, transclude) {
    return function(scope, element, attr, ctrl) {
      ctrl.cases['?'] = (ctrl.cases['?'] || []);
      ctrl.cases['?'].push({ transclude: transclude, element: element });
    };
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngTransclude
 *
 * @description
 * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.
 *
 * Any existing content of the element that this directive is placed on will be removed before the transcluded content is inserted.
 *
 * @element ANY
 *
 * @example
   <doc:example module="transclude">
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.title = 'Lorem Ipsum';
           $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';
         }

         angular.module('transclude', [])
          .directive('pane', function(){
             return {
               restrict: 'E',
               transclude: true,
               scope: { title:'@' },
               template: '<div style="border: 1px solid black;">' +
                           '<div style="background-color: gray">{{title}}</div>' +
                           '<div ng-transclude></div>' +
                         '</div>'
             };
         });
       </script>
       <div ng-controller="Ctrl">
         <input ng-model="title"><br>
         <textarea ng-model="text"></textarea> <br/>
         <pane title="{{title}}">{{text}}</pane>
       </div>
     </doc:source>
     <doc:scenario>
        it('should have transcluded', function() {
          input('title').enter('TITLE');
          input('text').enter('TEXT');
          expect(binding('title')).toEqual('TITLE');
          expect(binding('text')).toEqual('TEXT');
        });
     </doc:scenario>
   </doc:example>
 *
 */
var ngTranscludeDirective = ngDirective({
  controller: ['$transclude', function($transclude) {
    // remember the transclusion fn but call it during linking so that we don't process transclusion before directives on
    // the parent element even when the transclusion replaces the current element. (we can't use priority here because
    // that applies only to compile fns and not controllers
    this.$transclude = $transclude;
  }],

  link: function($scope, $element, $attrs, controller) {
    controller.$transclude(function(clone) {
      $element.html('');
      $element.append(clone);
    });
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:script
 *
 * @description
 * Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the
 * template can be used by `ngInclude`, `ngView` or directive templates.
 *
 * @restrict E
 * @param {'text/ng-template'} type must be set to `'text/ng-template'`
 *
 * @example
  <doc:example>
    <doc:source>
      <script type="text/ng-template" id="/tpl.html">
        Content of the template.
      </script>

      <a ng-click="currentTpl='/tpl.html'" id="tpl-link">Load inlined template</a>
      <div id="tpl-content" ng-include src="currentTpl"></div>
    </doc:source>
    <doc:scenario>
      it('should load template defined inside script tag', function() {
        element('#tpl-link').click();
        expect(element('#tpl-content').text()).toMatch(/Content of the template/);
      });
    </doc:scenario>
  </doc:example>
 */
var scriptDirective = ['$templateCache', function($templateCache) {
  return {
    restrict: 'E',
    terminal: true,
    compile: function(element, attr) {
      if (attr.type == 'text/ng-template') {
        var templateUrl = attr.id,
            // IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent
            text = element[0].text;

        $templateCache.put(templateUrl, text);
      }
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:select
 * @restrict E
 *
 * @description
 * HTML `SELECT` element with angular data-binding.
 *
 * # `ngOptions`
 *
 * Optionally `ngOptions` attribute can be used to dynamically generate a list of `<option>`
 * elements for a `<select>` element using an array or an object obtained by evaluating the
 * `ngOptions` expression.
 *
 * When an item in the `<select>` menu is selected, the value of array element or object property
 * represented by the selected option will be bound to the model identified by the `ngModel`
 * directive of the parent select element.
 *
 * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can
 * be nested into the `<select>` element. This element will then represent `null` or "not selected"
 * option. See example below for demonstration.
 *
 * Note: `ngOptions` provides iterator facility for `<option>` element which should be used instead
 * of {@link ng.directive:ngRepeat ngRepeat} when you want the
 * `select` model to be bound to a non-string value. This is because an option element can currently
 * be bound to string values only.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required The control is considered valid only if value is entered.
 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
 *    `required` when you want to data-bind to the `required` attribute.
 * @param {comprehension_expression=} ngOptions in one of the following forms:
 *
 *   * for array data sources:
 *     * `label` **`for`** `value` **`in`** `array`
 *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`
 *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`
 *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`
 *   * for object data sources:
 *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
 *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
 *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`
 *     * `select` **`as`** `label` **`group by`** `group`
 *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`
 *
 * Where:
 *
 *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
 *   * `value`: local variable which will refer to each item in the `array` or each property value
 *      of `object` during iteration.
 *   * `key`: local variable which will refer to a property name in `object` during iteration.
 *   * `label`: The result of this expression will be the label for `<option>` element. The
 *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).
 *   * `select`: The result of this expression will be bound to the model of the parent `<select>`
 *      element. If not specified, `select` expression will default to `value`.
 *   * `group`: The result of this expression will be used to group options using the `<optgroup>`
 *      DOM element.
 *   * `trackexpr`: Used when working with an array of objects. The result of this expression will be
 *      used to identify the objects in the array. The `trackexpr` will most likely refer to the
 *     `value` variable (e.g. `value.propertyName`).
 *
 * @example
    <doc:example>
      <doc:source>
        <script>
        function MyCntrl($scope) {
          $scope.colors = [
            {name:'black', shade:'dark'},
            {name:'white', shade:'light'},
            {name:'red', shade:'dark'},
            {name:'blue', shade:'dark'},
            {name:'yellow', shade:'light'}
          ];
          $scope.color = $scope.colors[2]; // red
        }
        </script>
        <div ng-controller="MyCntrl">
          <ul>
            <li ng-repeat="color in colors">
              Name: <input ng-model="color.name">
              [<a href ng-click="colors.splice($index, 1)">X</a>]
            </li>
            <li>
              [<a href ng-click="colors.push({})">add</a>]
            </li>
          </ul>
          <hr/>
          Color (null not allowed):
          <select ng-model="color" ng-options="c.name for c in colors"></select><br>

          Color (null allowed):
          <span  class="nullable">
            <select ng-model="color" ng-options="c.name for c in colors">
              <option value="">-- chose color --</option>
            </select>
          </span><br/>

          Color grouped by shade:
          <select ng-model="color" ng-options="c.name group by c.shade for c in colors">
          </select><br/>


          Select <a href ng-click="color={name:'not in list'}">bogus</a>.<br>
          <hr/>
          Currently selected: {{ {selected_color:color}  }}
          <div style="border:solid 1px black; height:20px"
               ng-style="{'background-color':color.name}">
          </div>
        </div>
      </doc:source>
      <doc:scenario>
         it('should check ng-options', function() {
           expect(binding('{selected_color:color}')).toMatch('red');
           select('color').option('0');
           expect(binding('{selected_color:color}')).toMatch('black');
           using('.nullable').select('color').option('');
           expect(binding('{selected_color:color}')).toMatch('null');
         });
      </doc:scenario>
    </doc:example>
 */

var ngOptionsDirective = valueFn({ terminal: true });
var selectDirective = ['$compile', '$parse', function($compile,   $parse) {
                         //0000111110000000000022220000000000000000000000333300000000000000444444444444444440000000005555555555555555500000006666666666666666600000000000000007777000000000000000000088888
  var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/,
      nullModelCtrl = {$setViewValue: noop};

  return {
    restrict: 'E',
    require: ['select', '?ngModel'],
    controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
      var self = this,
          optionsMap = {},
          ngModelCtrl = nullModelCtrl,
          nullOption,
          unknownOption;


      self.databound = $attrs.ngModel;


      self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
        ngModelCtrl = ngModelCtrl_;
        nullOption = nullOption_;
        unknownOption = unknownOption_;
      }


      self.addOption = function(value) {
        optionsMap[value] = true;

        if (ngModelCtrl.$viewValue == value) {
          $element.val(value);
          if (unknownOption.parent()) unknownOption.remove();
        }
      };


      self.removeOption = function(value) {
        if (this.hasOption(value)) {
          delete optionsMap[value];
          if (ngModelCtrl.$viewValue == value) {
            this.renderUnknownOption(value);
          }
        }
      };


      self.renderUnknownOption = function(val) {
        var unknownVal = '? ' + hashKey(val) + ' ?';
        unknownOption.val(unknownVal);
        $element.prepend(unknownOption);
        $element.val(unknownVal);
        unknownOption.prop('selected', true); // needed for IE
      }


      self.hasOption = function(value) {
        return optionsMap.hasOwnProperty(value);
      }

      $scope.$on('$destroy', function() {
        // disable unknown option so that we don't do work when the whole select is being destroyed
        self.renderUnknownOption = noop;
      });
    }],

    link: function(scope, element, attr, ctrls) {
      // if ngModel is not defined, we don't need to do anything
      if (!ctrls[1]) return;

      var selectCtrl = ctrls[0],
          ngModelCtrl = ctrls[1],
          multiple = attr.multiple,
          optionsExp = attr.ngOptions,
          nullOption = false, // if false, user will not be able to select it (used by ngOptions)
          emptyOption,
          // we can't just jqLite('<option>') since jqLite is not smart enough
          // to create it in <select> and IE barfs otherwise.
          optionTemplate = jqLite(document.createElement('option')),
          optGroupTemplate =jqLite(document.createElement('optgroup')),
          unknownOption = optionTemplate.clone();

      // find "null" option
      for(var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
        if (children[i].value == '') {
          emptyOption = nullOption = children.eq(i);
          break;
        }
      }

      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);

      // required validator
      if (multiple && (attr.required || attr.ngRequired)) {
        var requiredValidator = function(value) {
          ngModelCtrl.$setValidity('required', !attr.required || (value && value.length));
          return value;
        };

        ngModelCtrl.$parsers.push(requiredValidator);
        ngModelCtrl.$formatters.unshift(requiredValidator);

        attr.$observe('required', function() {
          requiredValidator(ngModelCtrl.$viewValue);
        });
      }

      if (optionsExp) Options(scope, element, ngModelCtrl);
      else if (multiple) Multiple(scope, element, ngModelCtrl);
      else Single(scope, element, ngModelCtrl, selectCtrl);


      ////////////////////////////



      function Single(scope, selectElement, ngModelCtrl, selectCtrl) {
        ngModelCtrl.$render = function() {
          var viewValue = ngModelCtrl.$viewValue;

          if (selectCtrl.hasOption(viewValue)) {
            if (unknownOption.parent()) unknownOption.remove();
            selectElement.val(viewValue);
            if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy
          } else {
            if (isUndefined(viewValue) && emptyOption) {
              selectElement.val('');
            } else {
              selectCtrl.renderUnknownOption(viewValue);
            }
          }
        };

        selectElement.on('change', function() {
          scope.$apply(function() {
            if (unknownOption.parent()) unknownOption.remove();
            ngModelCtrl.$setViewValue(selectElement.val());
          });
        });
      }

      function Multiple(scope, selectElement, ctrl) {
        var lastView;
        ctrl.$render = function() {
          var items = new HashMap(ctrl.$viewValue);
          forEach(selectElement.find('option'), function(option) {
            option.selected = isDefined(items.get(option.value));
          });
        };

        // we have to do it on each watch since ngModel watches reference, but
        // we need to work of an array, so we need to see if anything was inserted/removed
        scope.$watch(function selectMultipleWatch() {
          if (!equals(lastView, ctrl.$viewValue)) {
            lastView = copy(ctrl.$viewValue);
            ctrl.$render();
          }
        });

        selectElement.on('change', function() {
          scope.$apply(function() {
            var array = [];
            forEach(selectElement.find('option'), function(option) {
              if (option.selected) {
                array.push(option.value);
              }
            });
            ctrl.$setViewValue(array);
          });
        });
      }

      function Options(scope, selectElement, ctrl) {
        var match;

        if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {
          throw minErr('ngOptions')('iexp',
            "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}",
            optionsExp, startingTag(selectElement));
        }

        var displayFn = $parse(match[2] || match[1]),
            valueName = match[4] || match[6],
            keyName = match[5],
            groupByFn = $parse(match[3] || ''),
            valueFn = $parse(match[2] ? match[1] : valueName),
            valuesFn = $parse(match[7]),
            track = match[8],
            trackFn = track ? $parse(match[8]) : null,
            // This is an array of array of existing option groups in DOM. We try to reuse these if possible
            // optionGroupsCache[0] is the options with no option group
            // optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element
            optionGroupsCache = [[{element: selectElement, label:''}]];

        if (nullOption) {
          // compile the element since there might be bindings in it
          $compile(nullOption)(scope);

          // remove the class, which is added automatically because we recompile the element and it
          // becomes the compilation root
          nullOption.removeClass('ng-scope');

          // we need to remove it before calling selectElement.html('') because otherwise IE will
          // remove the label from the element. wtf?
          nullOption.remove();
        }

        // clear contents, we'll add what's needed based on the model
        selectElement.html('');

        selectElement.on('change', function() {
          scope.$apply(function() {
            var optionGroup,
                collection = valuesFn(scope) || [],
                locals = {},
                key, value, optionElement, index, groupIndex, length, groupLength;

            if (multiple) {
              value = [];
              for (groupIndex = 0, groupLength = optionGroupsCache.length;
                   groupIndex < groupLength;
                   groupIndex++) {
                // list of options for that group. (first item has the parent)
                optionGroup = optionGroupsCache[groupIndex];

                for(index = 1, length = optionGroup.length; index < length; index++) {
                  if ((optionElement = optionGroup[index].element)[0].selected) {
                    key = optionElement.val();
                    if (keyName) locals[keyName] = key;
                    if (trackFn) {
                      for (var trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                        locals[valueName] = collection[trackIndex];
                        if (trackFn(scope, locals) == key) break;
                      }
                    } else {
                      locals[valueName] = collection[key];
                    }
                    value.push(valueFn(scope, locals));
                  }
                }
              }
            } else {
              key = selectElement.val();
              if (key == '?') {
                value = undefined;
              } else if (key == ''){
                value = null;
              } else {
                if (trackFn) {
                  for (var trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                    locals[valueName] = collection[trackIndex];
                    if (trackFn(scope, locals) == key) {
                      value = valueFn(scope, locals);
                      break;
                    }
                  }
                } else {
                  locals[valueName] = collection[key];
                  if (keyName) locals[keyName] = key;
                  value = valueFn(scope, locals);
                }
              }
            }
            ctrl.$setViewValue(value);
          });
        });

        ctrl.$render = render;

        // TODO(vojta): can't we optimize this ?
        scope.$watch(render);

        function render() {
          var optionGroups = {'':[]}, // Temporary location for the option groups before we render them
              optionGroupNames = [''],
              optionGroupName,
              optionGroup,
              option,
              existingParent, existingOptions, existingOption,
              modelValue = ctrl.$modelValue,
              values = valuesFn(scope) || [],
              keys = keyName ? sortedKeys(values) : values,
              groupLength, length,
              groupIndex, index,
              locals = {},
              selected,
              selectedSet = false, // nothing is selected yet
              lastElement,
              element,
              label;

          if (multiple) {
            if (trackFn && isArray(modelValue)) {
              selectedSet = new HashMap([]);
              for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) {
                locals[valueName] = modelValue[trackIndex];
                selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
              }
            } else {
              selectedSet = new HashMap(modelValue);
            }
          }

          // We now build up the list of options we need (we merge later)
          for (index = 0; length = keys.length, index < length; index++) {
               locals[valueName] = values[keyName ? locals[keyName]=keys[index]:index];
               optionGroupName = groupByFn(scope, locals) || '';
            if (!(optionGroup = optionGroups[optionGroupName])) {
              optionGroup = optionGroups[optionGroupName] = [];
              optionGroupNames.push(optionGroupName);
            }
            if (multiple) {
              selected = selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)) != undefined;
            } else {
              if (trackFn) {
                var modelCast = {};
                modelCast[valueName] = modelValue;
                selected = trackFn(scope, modelCast) === trackFn(scope, locals);
              } else {
                selected = modelValue === valueFn(scope, locals);
              }
              selectedSet = selectedSet || selected; // see if at least one item is selected
            }
            label = displayFn(scope, locals); // what will be seen by the user
            label = label === undefined ? '' : label; // doing displayFn(scope, locals) || '' overwrites zero values
            optionGroup.push({
              id: trackFn ? trackFn(scope, locals) : (keyName ? keys[index] : index),   // either the index into array or key from object
              label: label,
              selected: selected                   // determine if we should be selected
            });
          }
          if (!multiple) {
            if (nullOption || modelValue === null) {
              // insert null option if we have a placeholder, or the model is null
              optionGroups[''].unshift({id:'', label:'', selected:!selectedSet});
            } else if (!selectedSet) {
              // option could not be found, we have to insert the undefined item
              optionGroups[''].unshift({id:'?', label:'', selected:true});
            }
          }

          // Now we need to update the list of DOM nodes to match the optionGroups we computed above
          for (groupIndex = 0, groupLength = optionGroupNames.length;
               groupIndex < groupLength;
               groupIndex++) {
            // current option group name or '' if no group
            optionGroupName = optionGroupNames[groupIndex];

            // list of options for that group. (first item has the parent)
            optionGroup = optionGroups[optionGroupName];

            if (optionGroupsCache.length <= groupIndex) {
              // we need to grow the optionGroups
              existingParent = {
                element: optGroupTemplate.clone().attr('label', optionGroupName),
                label: optionGroup.label
              };
              existingOptions = [existingParent];
              optionGroupsCache.push(existingOptions);
              selectElement.append(existingParent.element);
            } else {
              existingOptions = optionGroupsCache[groupIndex];
              existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element

              // update the OPTGROUP label if not the same.
              if (existingParent.label != optionGroupName) {
                existingParent.element.attr('label', existingParent.label = optionGroupName);
              }
            }

            lastElement = null;  // start at the beginning
            for(index = 0, length = optionGroup.length; index < length; index++) {
              option = optionGroup[index];
              if ((existingOption = existingOptions[index+1])) {
                // reuse elements
                lastElement = existingOption.element;
                if (existingOption.label !== option.label) {
                  lastElement.text(existingOption.label = option.label);
                }
                if (existingOption.id !== option.id) {
                  lastElement.val(existingOption.id = option.id);
                }
                // lastElement.prop('selected') provided by jQuery has side-effects
                if (lastElement[0].selected !== option.selected) {
                  lastElement.prop('selected', (existingOption.selected = option.selected));
                }
              } else {
                // grow elements

                // if it's a null option
                if (option.id === '' && nullOption) {
                  // put back the pre-compiled element
                  element = nullOption;
                } else {
                  // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but
                  // in this version of jQuery on some browser the .text() returns a string
                  // rather then the element.
                  (element = optionTemplate.clone())
                      .val(option.id)
                      .attr('selected', option.selected)
                      .text(option.label);
                }

                existingOptions.push(existingOption = {
                    element: element,
                    label: option.label,
                    id: option.id,
                    selected: option.selected
                });
                if (lastElement) {
                  lastElement.after(element);
                } else {
                  existingParent.element.append(element);
                }
                lastElement = element;
              }
            }
            // remove any excessive OPTIONs in a group
            index++; // increment since the existingOptions[0] is parent element not OPTION
            while(existingOptions.length > index) {
              existingOptions.pop().element.remove();
            }
          }
          // remove any excessive OPTGROUPs from select
          while(optionGroupsCache.length > groupIndex) {
            optionGroupsCache.pop()[0].element.remove();
          }
        }
      }
    }
  }
}];

var optionDirective = ['$interpolate', function($interpolate) {
  var nullSelectCtrl = {
    addOption: noop,
    removeOption: noop
  };

  return {
    restrict: 'E',
    priority: 100,
    compile: function(element, attr) {
      if (isUndefined(attr.value)) {
        var interpolateFn = $interpolate(element.text(), true);
        if (!interpolateFn) {
          attr.$set('value', element.text());
        }
      }

      return function (scope, element, attr) {
        var selectCtrlName = '$selectController',
            parent = element.parent(),
            selectCtrl = parent.data(selectCtrlName) ||
              parent.parent().data(selectCtrlName); // in case we are in optgroup

        if (selectCtrl && selectCtrl.databound) {
          // For some reason Opera defaults to true and if not overridden this messes up the repeater.
          // We don't want the view to drive the initialization of the model anyway.
          element.prop('selected', false);
        } else {
          selectCtrl = nullSelectCtrl;
        }

        if (interpolateFn) {
          scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
            attr.$set('value', newVal);
            if (newVal !== oldVal) selectCtrl.removeOption(oldVal);
            selectCtrl.addOption(newVal);
          });
        } else {
          selectCtrl.addOption(attr.value);
        }

        element.on('$destroy', function() {
          selectCtrl.removeOption(attr.value);
        });
      };
    }
  }
}];

var styleDirective = valueFn({
  restrict: 'E',
  terminal: true
});

  //try to bind to jquery now so that one can write angular.element().read()
  //but we will rebind on bootstrap again.
  bindJQuery();

  publishExternalAPI(angular);

  jqLite(document).ready(function() {
    angularInit(document, bootstrap);
  });

})(window, document);
angular.element(document).find('head').prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}</style>');
},{}],20:[function(require,module,exports){
/**
 * Operative
 * ---
 * Operative is a small JS utility for seamlessly creating Web Worker scripts.
 * ---
 * @author James Padolsey http://james.padolsey.com
 * @repo http://github.com/padolsey/operative
 * @version 0.2.1
 * @license MIT
 */
(function() {

	if (typeof window == 'undefined' && self.importScripts) {
		// I'm a worker! Run the boiler-script:
		// (Operative itself is called in IE10 as a worker,
		//  to avoid SecurityErrors)
		workerBoilerScript();
		return;
	}

	var slice = [].slice;
	var hasOwn = {}.hasOwnProperty;

	var scripts = document.getElementsByTagName('script');
	var opScript = scripts[scripts.length - 1];
	var opScriptURL = /operative/.test(opScript.src) && opScript.src;

	// Default base URL (to be prepended to relative dependency URLs)
	// is current page's parent dir:
	var baseURL = (
		location.protocol + '//' +
		location.hostname +
		(location.port?':'+location.port:'') +
		location.pathname
	).replace(/[^\/]+$/, '');

	var URL = window.URL || window.webkitURL;
	var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;

	var workerViaBlobSupport = (function() {
		try {
			new Worker(makeBlobURI(';'));
		} catch(e) {
			return false;
		}
		return true;
	}());

	/**
	 * Provide Object.create shim
	 */
	var objCreate = Object.create || function(o) {
		function F() {}
		F.prototype = o;
		return new F();
	};

	function makeBlobURI(script) {
		var blob;

		try {
			blob = new Blob([script], { type: 'text/javascript' });
		} catch (e) { 
			blob = new BlobBuilder();
			blob.append(script);
			blob = blob.getBlob();
		}

		return URL.createObjectURL(blob);
	}

	// Indicates whether operatives will run within workers:
	operative.hasWorkerSupport = !!window.Worker;

	operative.Promise = window.Promise;

	// Expose:
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = operative;
	} else {
		window.operative = operative;
	}
	

	operative.setSelfURL = function(url) {
		opScriptURL = url;
	};

	operative.setBaseURL = function(base) {
		baseURL = base;
	};

	operative.getBaseURL = function() {
		return baseURL;
	};

	/**
	 * Operative: Exposed Operative Constructor
	 * @param {Object} module Object containing methods/properties
	 */
	function Operative(module, dependencies) {

		var _self = this;

		module.get = module.get || function(prop) {
			return this[prop];
		};

		module.set = module.set || function(prop, value) {
			return this[prop] = value;
		};

		this._curToken = 0;
		this._queue = [];

		this.isDestroyed = false;
		this.isContextReady = false;

		this.module = module;
		this.dependencies = dependencies || [];

		this.dataProperties = {};
		this.api = {};
		this.callbacks = {};
		this.deferreds = {};

		this._fixDependencyURLs();
		this._setup();

		for (var methodName in module) {
			if (hasOwn.call(module, methodName)) {
				this._createExposedMethod(methodName);
			}
		}

		this.api.__operative__ = this;

		// Provide the instance's destroy method on the exposed API:
		this.api.destroy = function() {
			return _self.destroy();
		};

	}

	Operative.prototype = {

		_marshal: function(v) {
			return v;
		},

		_demarshal: function(v) {
			return v;
		},

		_enqueue: function(fn) {
			this._queue.push(fn);
		},

		_fixDependencyURLs: function() {
			var deps = this.dependencies;
			for (var i = 0, l = deps.length; i < l; ++i) {
				var dep = deps[i];
				if (!/\/\//.test(dep)) {
					deps[i] = dep.replace(/^\/?/, baseURL);
				}
			}
		},

		_dequeueAll: function() {
			for (var i = 0, l = this._queue.length; i < l; ++i) {
				this._queue[i].call(this);
			}
			this._queue = [];
		},

		_buildContextScript: function(boilerScript) {

			var script = [];
			var module = this.module;
			var dataProperties = this.dataProperties;
			var property;

			for (var i in module) {
				property = module[i];
				if (typeof property == 'function') {
					script.push('   self["' + i.replace(/"/g, '\\"') + '"] = ' + property.toString() + ';');
				} else {
					dataProperties[i] = property;
				}
			}

			return script.join('\n') + (
				boilerScript ? '\n(' + boilerScript.toString() + '());' : ''
			);

		},

		_createExposedMethod: function(methodName) {

			var self = this;

			this.api[methodName] = function() {

				if (self.isDestroyed) {
					throw new Error('Operative: Cannot run method. Operative has already been destroyed');
				}

				var token = ++self._curToken;
				var args = slice.call(arguments);
				var cb = typeof args[args.length - 1] == 'function' && args.pop();

				if (!cb && !operative.Promise) {
					throw new Error(
						'Operative: No callback has been passed. Assumed that you want a promise. ' +
						'But `operative.Promise` is null. Please provide Promise polyfill/lib.'
					);
				}

				if (cb) {

					self.callbacks[token] = cb;

					// Ensure either context runs the method async:
					setTimeout(function() {
						runMethod();
					}, 1);

				} else if (operative.Promise) {

					// No Callback -- Promise used:

					return new operative.Promise(function(deferred) {
						deferred.fulfil = deferred.fulfill;
						self.deferreds[token] = deferred;
						runMethod();
					});

				}

				function runMethod() {
					if (self.isContextReady) {
						self._runMethod(methodName, token, args);
					} else {
						self._enqueue(runMethod);
					}
				}

			};

		},

		destroy: function() {
			this.isDestroyed = true;
		}
	};


	/**
	 * Operative Worker
	 */
	Operative.Worker = function Worker(module) {
		this._msgQueue = [];
		Operative.apply(this, arguments);
	};

	var WorkerProto = Operative.Worker.prototype = objCreate(Operative.prototype);

	WorkerProto._onWorkerMessage = function(e) {
		var data = e.data;

		if (typeof data === 'string' && data.indexOf('pingback') === 0) {
			if (data === 'pingback:structuredCloningSupport=NO') {
				// No structuredCloningSupport support (marshal JSON from now on):
				this._marshal = function(o) { return JSON.stringify(o); };
				this._demarshal = function(o) { return JSON.parse(o); };
			}

			this.isContextReady = true;
			this._postMessage({
				definitions: this.dataProperties
			});
			this._dequeueAll();
			return;

		}

		data = this._demarshal(data);

		switch (data.cmd) {
			case 'console':
				window.console && window.console[data.method].apply(window.console, data.args);
				break;
			case 'result':

				var callback = this.callbacks[data.token];
				var deferred = this.deferreds[data.token];

				delete this.callbacks[data.token];
				delete this.deferreds[data.token];

				var deferredAction = data.result && data.result.isDeferred && data.result.action;

				if (deferred && deferredAction) {
					deferred[deferredAction](data.result.args[0]);
				} else if (callback) {
					callback.apply(this, data.result.args);
				}

				break;
		}
	};

	WorkerProto._setup = function() {
		var self = this;

		var worker;
		var script = this._buildContextScript(
			// The script is not included if we're Eval'ing this file directly:
			workerViaBlobSupport ? workerBoilerScript : ''
		);

		if (this.dependencies.length) {
			script = 'importScripts("' + this.dependencies.join('", "') + '");\n' + script;
		}

		if (workerViaBlobSupport) {
			worker = this.worker = new Worker( makeBlobURI(script) );
		}  else {
			if (!opScriptURL) {
				throw new Error('Operaritve: No operative.js URL available. Please set via operative.setSelfURL(...)');
			}
			worker = this.worker = new Worker( opScriptURL );
			// Marshal-agnostic initial message is boiler-code:
			// (We don't yet know if structured-cloning is supported so we send a string)
			worker.postMessage('EVAL|' + script);
		}

		worker.postMessage(['PING']); // Initial PING

		worker.addEventListener('message', function(e) {
			self._onWorkerMessage(e);
		});
	};

	WorkerProto._postMessage = function(msg) {
		return this.worker.postMessage(this._marshal(msg));
	};

	WorkerProto._runMethod = function(methodName, token, args) {
		this._postMessage({
			method: methodName,
			args: args,
			token: token
		});
	};

	WorkerProto.destroy = function() {
		this.worker.terminate();
		Operative.prototype.destroy.call(this);
	};


	/**
	 * Operative IFrame
	 */
	Operative.Iframe = function Iframe(module) {
		Operative.apply(this, arguments);
	};

	var IframeProto = Operative.Iframe.prototype = objCreate(Operative.prototype);

	var _loadedMethodNameI = 0;

	IframeProto._setup = function() {

		var self = this;
		var loadedMethodName = '__operativeIFrameLoaded' + ++_loadedMethodNameI;

		this.module.isWorker = false;

		var iframe = this.iframe = document.body.appendChild(
			document.createElement('iframe')
		);

		iframe.style.display = 'none';

		var iWin = this.iframeWindow = iframe.contentWindow;
		var iDoc = iWin.document;

		// Cross browser (tested in IE8,9) way to call method from within
		// IFRAME after all <Script>s have loaded:
		window[loadedMethodName] = function() {

			window[loadedMethodName] = null;

			var script = iDoc.createElement('script');
			var js = self._buildContextScript(iframeBoilerScript);

			if (script.text !== void 0) {
				script.text = js;
			} else {
				script.innerHTML = js;
			}

			iDoc.documentElement.appendChild(script);

			for (var i in self.dataProperties) {
				iWin[i] = self.dataProperties[i];
			}

			self.isContextReady = true;
			self._dequeueAll();

		};

		iDoc.open();
		if (this.dependencies.length) {
			iDoc.write(
				'<script src="' + this.dependencies.join('"></script><script src="') + '"></script>'
			);
		}
		// Place <script> at bottom to tell parent-page when dependencies are loaded:
		iDoc.write('<script>window.top.' + loadedMethodName + '();</script>');
		iDoc.close();

	};

	IframeProto._runMethod = function(methodName, token, args) {
		var self = this;
		var callback = this.callbacks[token];
		var deferred = this.deferreds[token];
		delete this.callbacks[token];
		delete this.deferreds[token];
		this.iframeWindow.__run__(methodName, args, function() {
			var cb = callback;
			if (cb) {
				callback = null;
				cb.apply(self, arguments);
			} else {
				throw new Error('Operative: You have already returned.');
			}
		}, deferred);
	};

	IframeProto.destroy = function() {
		this.iframe.parentNode.removeChild(this.iframe);
		Operative.prototype.destroy.call(this);
	};

	operative.Operative = Operative;

	/**
	 * Exposed operative factory
	 */
	function operative(module, dependencies) {

		var OperativeContext = operative.hasWorkerSupport ?
			Operative.Worker : Operative.Iframe;

		if (typeof module == 'function') {
			// Allow a single function to be passed.
			var o = new OperativeContext({ main: module }, dependencies);
			return function() {
				return o.api.main.apply(o, arguments);
			};
		}

		return new OperativeContext(module, dependencies).api;

	}

/**
 * The boilerplate for the Iframe Context
 * NOTE:
 *  this'll be executed within an iframe, not here.
 *  Indented @ Zero to make nicer debug code within worker
 */
function iframeBoilerScript() {

	// Called from parent-window:
	window.__run__ = function(methodName, args, cb, deferred) {

		var isAsync = false;
		var isDeferred = false;

		window.async = function() {
			isAsync = true;
			return cb;
		};

		window.deferred = function() {
			isDeferred = true;
			return deferred;
		};

		if (cb) {
			args.push(cb);
		}

		var result = window[methodName].apply(window, args);

		window.async = function() {
			throw new Error('Operative: async() called at odd time');
		};

		window.deferred = function() {
			throw new Error('Operative: deferred() called at odd time');
		};


		if (!isDeferred && !isAsync && result !== void 0) {
			// Deprecated direct-returning as of 0.2.0
			cb(result);
		}
	};
}

/**
 * The boilerplate for the Worker Blob
 * NOTE:
 *  this'll be executed within an iframe, not here.
 *  Indented @ Zero to make nicer debug code within worker
 */
function workerBoilerScript() {

	var postMessage = self.postMessage;
	var structuredCloningSupport = null;

	self.console = {};
	self.isWorker = true;

	// Provide basic console interface:
	['log', 'debug', 'error', 'info', 'warn', 'time', 'timeEnd'].forEach(function(meth) {
		self.console[meth] = function() {
			postMessage({
				cmd: 'console',
				method: meth,
				args: [].slice.call(arguments)
			});
		};
	});

	self.addEventListener('message', function(e) {

		var data = e.data;

		if (typeof data == 'string' && data.indexOf('EVAL|') === 0) {
			eval(data.substring(5));
			return;
		}

		if (structuredCloningSupport == null) {

			// e.data of ['PING'] (An array) indicates transferrableObjSupport
			// e.data of '"PING"' (A string) indicates no support (Array has been serialized)
			structuredCloningSupport = e.data[0] === 'PING';

			// Pingback to parent page:
			self.postMessage(
				structuredCloningSupport ?
					'pingback:structuredCloningSupport=YES' :
					'pingback:structuredCloningSupport=NO'
			);

			if (!structuredCloningSupport) {
				postMessage = function(msg) {
					// Marshal before sending
					return self.postMessage(JSON.stringify(msg));
				};
			}

			return;
		}

		if (!structuredCloningSupport) {
			// Demarshal:
			data = JSON.parse(data);
		}

		var defs = data.definitions;
		var isDeferred = false;
		var isAsync = false;
		var args = data.args;

		if (defs) {
			// Initial definitions:
			for (var i in defs) {
				self[i] = defs[i];
			}
			return;
		}

		args.push(function() {
			// Callback function to be passed to operative method
			returnResult({
				args: [].slice.call(arguments)
			});
		});

		self.async = function() { // Async deprecated as of 0.2.0
			isAsync = true;
			return function() { returnResult({ args: [].slice.call(arguments) }); };
		};

		self.deferred = function() {
			isDeferred = true;
			var def = {};
			function fulfill(r) {
				returnResult({
					isDeferred: true,
					action: 'fulfill',
					args: [r]
				});
				return def;
			}
			function reject(r) {
				returnResult({
					isDeferred: true,
					action: 'reject',
					args: [r]
				});
			}
			def.fulfil = def.fulfill = fulfill;
			def.reject = reject;
			return def;
		};

		// Call actual operative method:
		var result = self[data.method].apply(self, args);

		if (!isDeferred && !isAsync && result !== void 0) {
			// Deprecated direct-returning as of 0.2.0
			returnResult({
				args: [result]
			});
		}

		self.deferred = function() {
			throw new Error('Operative: deferred() called at odd time');
		};

		self.async = function() { // Async deprecated as of 0.2.0
			throw new Error('Operative: async() called at odd time');
		};

		function returnResult(res) {
			postMessage({
				cmd: 'result',
				token: data.token,
				result: res
			});
			// Override with error-thrower if we've already returned:
			returnResult = function() {
				throw new Error('Operative: You have already returned.');
			};
		}
	});
}

}());
},{}],21:[function(require,module,exports){
// This is a prelude which comes before the JS blob of each JS type for the web.
(function(){
  var module = {exports:{}};
  var exports = module.exports;

// These methods let you build a transform function from a transformComponent
// function for OT types like JSON0 in which operations are lists of components
// and transforming them reqreuires N^2 work. I find it kind of nasty that I need
// this, but I'm not really sure what a better solution is. Maybe I should do
// this automatically to types that don't have a compose function defined.

// Add transform and transformX functions for an OT type which has
// transformComponent defined.  transformComponent(destination array,
// component, other component, side)
exports._bootstrapTransform = function(type, transformComponent, checkValidOp, append) {
  var transformComponentX = function(left, right, destLeft, destRight) {
    transformComponent(destLeft, left, right, 'left');
    transformComponent(destRight, right, left, 'right');
  };

  var transformX = type.transformX = function(leftOp, rightOp) {
    checkValidOp(leftOp);
    checkValidOp(rightOp);
    var newRightOp = [];

    for (var i = 0; i < rightOp.length; i++) {
      var rightComponent = rightOp[i];

      // Generate newLeftOp by composing leftOp by rightComponent
      var newLeftOp = [];
      var k = 0;
      while (k < leftOp.length) {
        var nextC = [];
        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
        k++;

        if (nextC.length === 1) {
          rightComponent = nextC[0];
        } else if (nextC.length === 0) {
          for (var j = k; j < leftOp.length; j++) {
            append(newLeftOp, leftOp[j]);
          }
          rightComponent = null;
          break;
        } else {
          // Recurse.
          var pair = transformX(leftOp.slice(k), nextC);
          for (var l = 0; l < pair[0].length; l++) {
            append(newLeftOp, pair[0][l]);
          }
          for (var r = 0; r < pair[1].length; r++) {
            append(newRightOp, pair[1][r]);
          }
          rightComponent = null;
          break;
        }
      }

      if (rightComponent != null) {
        append(newRightOp, rightComponent);
      }
      leftOp = newLeftOp;
    }
    return [leftOp, newRightOp];
  };

  // Transforms op with specified type ('left' or 'right') by otherOp.
  type.transform = type['transform'] = function(op, otherOp, type) {
    if (!(type === 'left' || type === 'right'))
      throw new Error("type must be 'left' or 'right'");

    if (otherOp.length === 0) return op;

    if (op.length === 1 && otherOp.length === 1)
      return transformComponent([], op[0], otherOp[0], type);

    if (type === 'left')
      return transformX(op, otherOp)[0];
    else
      return transformX(otherOp, op)[1];
  };
};
// DEPRECATED!
//
// This type works, but is not exported, and will be removed in a future version of this library.


// A simple text implementation
//
// Operations are lists of components.
// Each component either inserts or deletes at a specified position in the document.
//
// Components are either:
//  {i:'str', p:100}: Insert 'str' at position 100 in the document
//  {d:'str', p:100}: Delete 'str' at position 100 in the document
//
// Components in an operation are executed sequentially, so the position of components
// assumes previous components have already executed.
//
// Eg: This op:
//   [{i:'abc', p:0}]
// is equivalent to this op:
//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]

// NOTE: The global scope here is shared with other sharejs files when built with closure.
// Be careful what ends up in your namespace.

var text = module.exports = {
  name: 'text0',
  uri: 'http://sharejs.org/types/textv0',
  create: function(initial) {
    if ((initial != null) && typeof initial !== 'string') {
      throw new Error('Initial data must be a string');
    }
    return initial || '';
  }
};

/** Insert s2 into s1 at pos. */
var strInject = function(s1, pos, s2) {
  return s1.slice(0, pos) + s2 + s1.slice(pos);
};

/** Check that an operation component is valid. Throws if its invalid. */
var checkValidComponent = function(c) {
  if (typeof c.p !== 'number')
    throw new Error('component missing position field');

  if ((typeof c.i === 'string') === (typeof c.d === 'string'))
    throw new Error('component needs an i or d field');

  if (c.p < 0)
    throw new Error('position cannot be negative');
};

/** Check that an operation is valid */
var checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
    checkValidComponent(op[i]);
  }
};

/** Apply op to snapshot */
text.apply = function(snapshot, op) {
  var deleted;

  checkValidOp(op);
  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    if (component.i != null) {
      snapshot = strInject(snapshot, component.p, component.i);
    } else {
      deleted = snapshot.slice(component.p, component.p + component.d.length);
      if (component.d !== deleted)
        throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");

      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
    }
  }
  return snapshot;
};

/**
 * Append a component to the end of newOp. Exported for use by the random op
 * generator and the JSON0 type.
 */
var append = text._append = function(newOp, c) {
  if (c.i === '' || c.d === '') return;

  if (newOp.length === 0) {
    newOp.push(c);
  } else {
    var last = newOp[newOp.length - 1];

    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {
      // Compose the insert into the previous insert
      newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};

    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {
      // Compose the deletes together
      newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};

    } else {
      newOp.push(c);
    }
  }
};

/** Compose op1 and op2 together */
text.compose = function(op1, op2) {
  checkValidOp(op1);
  checkValidOp(op2);
  var newOp = op1.slice();
  for (var i = 0; i < op2.length; i++) {
    append(newOp, op2[i]);
  }
  return newOp;
};

/** Clean up an op */
text.normalize = function(op) {
  var newOp = [];

  // Normalize should allow ops which are a single (unwrapped) component:
  // {i:'asdf', p:23}.
  // There's no good way to test if something is an array:
  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
  // so this is probably the least bad solution.
  if (op.i != null || op.p != null) op = [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = 0;

    append(newOp, c);
  }

  return newOp;
};

// This helper method transforms a position by an op component.
//
// If c is an insert, insertAfter specifies whether the transform
// is pushed after the insert (true) or before it (false).
//
// insertAfter is optional for deletes.
var transformPosition = function(pos, c, insertAfter) {
  // This will get collapsed into a giant ternary by uglify.
  if (c.i != null) {
    if (c.p < pos || (c.p === pos && insertAfter)) {
      return pos + c.i.length;
    } else {
      return pos;
    }
  } else {
    // I think this could also be written as: Math.min(c.p, Math.min(c.p -
    // otherC.p, otherC.d.length)) but I think its harder to read that way, and
    // it compiles using ternary operators anyway so its no slower written like
    // this.
    if (pos <= c.p) {
      return pos;
    } else if (pos <= c.p + c.d.length) {
      return c.p;
    } else {
      return pos - c.d.length;
    }
  }
};

// Helper method to transform a cursor position as a result of an op.
//
// Like transformPosition above, if c is an insert, insertAfter specifies
// whether the cursor position is pushed after an insert (true) or before it
// (false).
text.transformCursor = function(position, op, side) {
  var insertAfter = side === 'right';
  for (var i = 0; i < op.length; i++) {
    position = transformPosition(position, op[i], insertAfter);
  }

  return position;
};

// Transform an op component by another op component. Asymmetric.
// The result will be appended to destination.
//
// exported for use in JSON type
var transformComponent = text._tc = function(dest, c, otherC, side) {
  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;

  checkValidComponent(c);
  checkValidComponent(otherC);

  if (c.i != null) {
    // Insert.
    append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});
  } else {
    // Delete
    if (otherC.i != null) {
      // Delete vs insert
      var s = c.d;
      if (c.p < otherC.p) {
        append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});
        s = s.slice(otherC.p - c.p);
      }
      if (s !== '')
        append(dest, {d: s, p: c.p + otherC.i.length});

    } else {
      // Delete vs delete
      if (c.p >= otherC.p + otherC.d.length)
        append(dest, {d: c.d, p: c.p - otherC.d.length});
      else if (c.p + c.d.length <= otherC.p)
        append(dest, c);
      else {
        // They overlap somewhere.
        var newC = {d: '', p: c.p};

        if (c.p < otherC.p)
          newC.d = c.d.slice(0, otherC.p - c.p);

        if (c.p + c.d.length > otherC.p + otherC.d.length)
          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);

        // This is entirely optional - I'm just checking the deleted text in
        // the two ops matches
        var intersectStart = Math.max(c.p, otherC.p);
        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
        if (cIntersect !== otherIntersect)
          throw new Error('Delete ops delete different text in the same region of the document');

        if (newC.d !== '') {
          newC.p = transformPosition(newC.p, otherC);
          append(dest, newC);
        }
      }
    }
  }

  return dest;
};

var invertComponent = function(c) {
  return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};
};

// No need to use append for invert, because the components won't be able to
// cancel one another.
text.invert = function(op) {
  // Shallow copy & reverse that sucka.
  op = op.slice().reverse();
  for (var i = 0; i < op.length; i++) {
    op[i] = invertComponent(op[i]);
  }
  return op;
};

exports._bootstrapTransform(text, transformComponent, checkValidOp, append);

/*
 This is the implementation of the JSON OT type.

 Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations

 Note: This is being made obsolete. It will soon be replaced by the JSON2 type.
*/

/**
 * UTILITY FUNCTIONS
 */

/**
 * Checks if the passed object is an Array instance. Can't use Array.isArray
 * yet because its not supported on IE8.
 *
 * @param obj
 * @returns {boolean}
 */
var isArray = function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

/**
 * Clones the passed object using JSON serialization (which is slow).
 *
 * hax, copied from test/types/json. Apparently this is still the fastest way
 * to deep clone an object, assuming we have browser support for JSON.  @see
 * http://jsperf.com/cloning-an-object/12
 */
var clone = function(o) {
  return JSON.parse(JSON.stringify(o));
};

/**
 * Reference to the Text OT type. This is used for the JSON String operations.
 * @type {*}
 */
if (typeof text === 'undefined')
  var text = window.ottypes.text;

/**
 * JSON OT Type
 * @type {*}
 */
var json = { 
  name: 'json0',
  uri: 'http://sharejs.org/types/JSONv0'
};

json.create = function(data) {
  // Null instead of undefined if you don't pass an argument.
  return data === undefined ? null : data;
};

json.invertComponent = function(c) {
  var c_ = {p: c.p};

  if (c.si !== void 0) c_.sd = c.si;
  if (c.sd !== void 0) c_.si = c.sd;
  if (c.oi !== void 0) c_.od = c.oi;
  if (c.od !== void 0) c_.oi = c.od;
  if (c.li !== void 0) c_.ld = c.li;
  if (c.ld !== void 0) c_.li = c.ld;
  if (c.na !== void 0) c_.na = -c.na;

  if (c.lm !== void 0) {
    c_.lm = c.p[c.p.length-1];
    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);
  }

  return c_;
};

json.invert = function(op) {
  var op_ = op.slice().reverse();
  var iop = [];
  for (var i = 0; i < op_.length; i++) {
    iop.push(json.invertComponent(op_[i]));
  }
  return iop;
};

json.checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
  if (!isArray(op[i].p))
    throw new Error('Missing path');
  }
};

json.checkList = function(elem) {
  if (!isArray(elem))
    throw new Error('Referenced element not a list');
};

json.checkObj = function(elem) {
  if (elem.constructor !== Object) {
    throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
  }
};

json.apply = function(snapshot, op) {
  json.checkValidOp(op);

  op = clone(op);

  var container = {
    data: snapshot
  };

  for (var i = 0; i < op.length; i++) {
    var c = op[i];

    var parent = null;
    var parentKey = null;
    var elem = container;
    var key = 'data';

    for (var j = 0; j < c.p.length; j++) {
      var p = c.p[j];

      parent = elem;
      parentKey = key;
      elem = elem[key];
      key = p;

      if (parent == null)
        throw new Error('Path invalid');
    }

    // Number add
    if (c.na !== void 0) {
      if (typeof elem[key] != 'number')
        throw new Error('Referenced element not a number');

      elem[key] += c.na;
    }

    // String insert
    else if (c.si !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string (it was '+JSON.stringify(elem)+')');

      parent[parentKey] = elem.slice(0,key) + c.si + elem.slice(key);
    }

    // String delete
    else if (c.sd !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string');

      if (elem.slice(key,key + c.sd.length) !== c.sd)
        throw new Error('Deleted string does not match');

      parent[parentKey] = elem.slice(0,key) + elem.slice(key + c.sd.length);
    }

    // List replace
    else if (c.li !== void 0 && c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld
      elem[key] = c.li;
    }

    // List insert
    else if (c.li !== void 0) {
      json.checkList(elem);
      elem.splice(key,0, c.li);
    }

    // List delete
    else if (c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld here too.
      elem.splice(key,1);
    }

    // List move
    else if (c.lm !== void 0) {
      json.checkList(elem);
      if (c.lm != key) {
        var e = elem[key];
        // Remove it...
        elem.splice(key,1);
        // And insert it back.
        elem.splice(c.lm,0,e);
      }
    }

    // Object insert / replace
    else if (c.oi !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      elem[key] = c.oi;
    }

    // Object delete
    else if (c.od !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      delete elem[key];
    }

    else {
      throw new Error('invalid / missing instruction in op');
    }
  }

  return container.data;
};

// Helper for incrementally applying an operation to a snapshot. Calls yield
// after each op component has been applied.
json.incrementalApply = function(snapshot, op, _yield) {
  for (var i = 0; i < op.length; i++) {
    var smallOp = [op[i]];
    snapshot = json.apply(snapshot, smallOp);
    // I'd just call this yield, but thats a reserved keyword. Bah!
    _yield(smallOp, snapshot);
  }
  
  return snapshot;
};

// Checks if two paths, p1 and p2 match.
var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
  if (p1.length != p2.length)
    return false;

  for (var i = 0; i < p1.length; i++) {
    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
      return false;
  }

  return true;
};

var _convertToTextComponent = function(component) {
  var newC = {p: component.p[component.p.length - 1]};
  if (component.si != null) {
    newC.i = component.si;
  } else {
    newC.d = component.sd;
  }
  return newC;
};

json.append = function(dest,c) {
  c = clone(c);

  var last;

  if (dest.length != 0 && pathMatches(c.p, (last = dest[dest.length - 1]).p)) {
    if (last.na != null && c.na != null) {
      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};
    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {
      // insert immediately followed by delete becomes a noop.
      if (last.ld !== undefined) {
        // leave the delete part of the replace
        delete last.li;
      } else {
        dest.pop();
      }
    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {
      last.oi = c.oi;
    } else if (last.oi !== undefined && c.od !== undefined) {
      // The last path component inserted something that the new component deletes (or replaces).
      // Just merge them.
      if (c.oi !== undefined) {
        last.oi = c.oi;
      } else if (last.od !== undefined) {
        delete last.oi;
      } else {
        // An insert directly followed by a delete turns into a no-op and can be removed.
        dest.pop();
      }
    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {
      // don't do anything
    } else {
      dest.push(c);
    }
  } else if (dest.length != 0 && pathMatches(c.p, last.p, true)) {
    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
      // Try to compose the string ops together using text's equivalent methods
      var textOp = [_convertToTextComponent(last)];
      text._append(textOp, _convertToTextComponent(c));
      
      // Then convert back.
      if (textOp.length !== 1) {
        dest.push(c);
      } else {
        var textC = textOp[0];
        last.p[last.p.length - 1] = textC.p;
        if (textC.i != null)
          last.si = textC.i;
        else
          last.sd = textC.d;
      }
    } else {
      dest.push(c);
    }
  } else {
    dest.push(c);
  }
};

json.compose = function(op1,op2) {
  json.checkValidOp(op1);
  json.checkValidOp(op2);

  var newOp = clone(op1);

  for (var i = 0; i < op2.length; i++) {
    json.append(newOp,op2[i]);
  }

  return newOp;
};

json.normalize = function(op) {
  var newOp = [];

  op = isArray(op) ? op : [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = [];

    json.append(newOp,c);
  }

  return newOp;
};

// Returns true if an op at otherPath may affect an op at path
json.canOpAffectOp = function(otherPath,path) {
  if (otherPath.length === 0) return true;
  if (path.length === 0) return false;

  path = path.slice(0,path.length - 1);
  otherPath = otherPath.slice(0,otherPath.length - 1);

  for (var i = 0; i < otherPath.length; i++) {
    var p = otherPath[i];
    if (i >= path.length || p != path[i]) return false;
  }

  // Same
  return true;
};

// transform c so it applies to a document with otherC applied.
json.transformComponent = function(dest, c, otherC, type) {
  c = clone(c);

  if (c.na !== void 0)
    c.p.push(0);

  if (otherC.na !== void 0)
    otherC.p.push(0);

  var common;
  if (json.canOpAffectOp(otherC.p, c.p))
    common = otherC.p.length - 1;

  var common2;
  if (json.canOpAffectOp(c.p,otherC.p))
    common2 = c.p.length - 1;

  var cplength = c.p.length;
  var otherCplength = otherC.p.length;

  if (c.na !== void 0) // hax
    c.p.pop();

  if (otherC.na !== void 0)
    otherC.p.pop();

  if (otherC.na) {
    if (common2 != null && otherCplength >= cplength && otherC.p[common2] == c.p[common2]) {
      if (c.ld !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.ld = json.apply(clone(c.ld),[oc]);
      } else if (c.od !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.od = json.apply(clone(c.od),[oc]);
      }
    }
    json.append(dest,c);
    return dest;
  }

  // if c is deleting something, and that thing is changed by otherC, we need to
  // update c to reflect that change for invertibility.
  // TODO this is probably not needed since we don't have invertibility
  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
    if (c.ld !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.ld = json.apply(clone(c.ld),[oc]);
    } else if (c.od !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.od = json.apply(clone(c.od),[oc]);
    }
  }

  if (common != null) {
    var commonOperand = cplength == otherCplength;

    // transform based on otherC
    if (otherC.na !== void 0) {
      // this case is handled above due to icky path hax
    } else if (otherC.si !== void 0 || otherC.sd !== void 0) {
      // String op vs string op - pass through to text type
      if (c.si !== void 0 || c.sd !== void 0) {
        if (!commonOperand) throw new Error('must be a string?');

        // Convert an op component to a text op component so we can use the
        // text type's transform function
        var tc1 = _convertToTextComponent(c);
        var tc2 = _convertToTextComponent(otherC);

        var res = [];

        // actually transform
        text._tc(res, tc1, tc2, type);
        
        // .... then convert the result back into a JSON op again.
        for (var i = 0; i < res.length; i++) {
          // Text component
          var tc = res[i];
          // JSON component
          var jc = {p: c.p.slice(0, common)};
          jc.p.push(tc.p);

          if (tc.i != null) jc.si = tc.i;
          if (tc.d != null) jc.sd = tc.d;
          json.append(dest, jc);
        }
        return dest;
      }
    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
      if (otherC.p[common] === c.p[common]) {
        // noop

        if (!commonOperand) {
          return dest;
        } else if (c.ld !== void 0) {
          // we're trying to delete the same element, -> noop
          if (c.li !== void 0 && type === 'left') {
            // we're both replacing one element with another. only one can survive
            c.ld = clone(otherC.li);
          } else {
            return dest;
          }
        }
      }
    } else if (otherC.li !== void 0) {
      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {
        // in li vs. li, left wins.
        if (type === 'right')
          c.p[common]++;
      } else if (otherC.p[common] <= c.p[common]) {
        c.p[common]++;
      }

      if (c.lm !== void 0) {
        if (commonOperand) {
          // otherC edits the same list we edit
          if (otherC.p[common] <= c.lm)
            c.lm++;
          // changing c.from is handled above.
        }
      }
    } else if (otherC.ld !== void 0) {
      if (c.lm !== void 0) {
        if (commonOperand) {
          if (otherC.p[common] === c.p[common]) {
            // they deleted the thing we're trying to move
            return dest;
          }
          // otherC edits the same list we edit
          var p = otherC.p[common];
          var from = c.p[common];
          var to = c.lm;
          if (p < to || (p === to && from < to))
            c.lm--;

        }
      }

      if (otherC.p[common] < c.p[common]) {
        c.p[common]--;
      } else if (otherC.p[common] === c.p[common]) {
        if (otherCplength < cplength) {
          // we're below the deleted element, so -> noop
          return dest;
        } else if (c.ld !== void 0) {
          if (c.li !== void 0) {
            // we're replacing, they're deleting. we become an insert.
            delete c.ld;
          } else {
            // we're trying to delete the same element, -> noop
            return dest;
          }
        }
      }

    } else if (otherC.lm !== void 0) {
      if (c.lm !== void 0 && cplength === otherCplength) {
        // lm vs lm, here we go!
        var from = c.p[common];
        var to = c.lm;
        var otherFrom = otherC.p[common];
        var otherTo = otherC.lm;
        if (otherFrom !== otherTo) {
          // if otherFrom == otherTo, we don't need to change our op.

          // where did my thing go?
          if (from === otherFrom) {
            // they moved it! tie break.
            if (type === 'left') {
              c.p[common] = otherTo;
              if (from === to) // ugh
                c.lm = otherTo;
            } else {
              return dest;
            }
          } else {
            // they moved around it
            if (from > otherFrom) c.p[common]--;
            if (from > otherTo) c.p[common]++;
            else if (from === otherTo) {
              if (otherFrom > otherTo) {
                c.p[common]++;
                if (from === to) // ugh, again
                  c.lm++;
              }
            }

            // step 2: where am i going to put it?
            if (to > otherFrom) {
              c.lm--;
            } else if (to === otherFrom) {
              if (to > from)
                c.lm--;
            }
            if (to > otherTo) {
              c.lm++;
            } else if (to === otherTo) {
              // if we're both moving in the same direction, tie break
              if ((otherTo > otherFrom && to > from) ||
                  (otherTo < otherFrom && to < from)) {
                if (type === 'right') c.lm++;
              } else {
                if (to > from) c.lm++;
                else if (to === otherFrom) c.lm--;
              }
            }
          }
        }
      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {
        // li
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p > from) c.p[common]--;
        if (p > to) c.p[common]++;
      } else {
        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath
        // the lm
        //
        // i.e. things care about where their item is after the move.
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p === from) {
          c.p[common] = to;
        } else {
          if (p > from) c.p[common]--;
          if (p > to) c.p[common]++;
          else if (p === to && from > to) c.p[common]++;
        }
      }
    }
    else if (otherC.oi !== void 0 && otherC.od !== void 0) {
      if (c.p[common] === otherC.p[common]) {
        if (c.oi !== void 0 && commonOperand) {
          // we inserted where someone else replaced
          if (type === 'right') {
            // left wins
            return dest;
          } else {
            // we win, make our op replace what they inserted
            c.od = otherC.oi;
          }
        } else {
          // -> noop if the other component is deleting the same object (or any parent)
          return dest;
        }
      }
    } else if (otherC.oi !== void 0) {
      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
        // left wins if we try to insert at the same place
        if (type === 'left') {
          json.append(dest,{p: c.p, od:otherC.oi});
        } else {
          return dest;
        }
      }
    } else if (otherC.od !== void 0) {
      if (c.p[common] == otherC.p[common]) {
        if (!commonOperand)
          return dest;
        if (c.oi !== void 0) {
          delete c.od;
        } else {
          return dest;
        }
      }
    }
  }

  json.append(dest,c);
  return dest;
};

exports._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);


module.exports = json;
// This is included after the JS for each type when we build for the web.

  var _types = window.ottypes = window.ottypes || {};
  var _t = module.exports;
  _types[_t.name] = _t;

  if (_t.uri) _types[_t.uri] = _t;
})();

},{}],22:[function(require,module,exports){
module.exports = function genid(len, prefix, keyspace) {
  if (len == null) {
    len = 32;
  }
  if (prefix == null) {
    prefix = "";
  }
  if (keyspace == null) {
    keyspace = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  }
  while (len-- > 0) {
    prefix += keyspace.charAt(Math.floor(Math.random() * keyspace.length));
  }
  return prefix;
};
},{}],23:[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.0.0 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var isFunction = require('lodash.isfunction'),
    isObject = require('lodash.isobject'),
    reNative = require('lodash._renative');

/** Used as a safe reference for `undefined` in pre ES5 environments */
var undefined;

/** Used for native method references */
var objectProto = Object.prototype;

/** Native method shortcuts */
var now = reNative.test(now = Date.now) && now || function() { return +new Date; };

/* Native method shortcuts for methods with the same name as other `lodash` methods */
var nativeMax = Math.max;

/**
 * Creates a function that will delay the execution of `func` until after
 * `wait` milliseconds have elapsed since the last time it was invoked.
 * Provide an options object to indicate that `func` should be invoked on
 * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
 * to the debounced function will return the result of the last `func` call.
 *
 * Note: If `leading` and `trailing` options are `true` `func` will be called
 * on the trailing edge of the timeout only if the the debounced function is
 * invoked more than once during the `wait` timeout.
 *
 * @static
 * @memberOf _
 * @category Functions
 * @param {Function} func The function to debounce.
 * @param {number} wait The number of milliseconds to delay.
 * @param {Object} [options] The options object.
 * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
 * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
 * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // avoid costly calculations while the window size is in flux
 * var lazyLayout = _.debounce(calculateLayout, 150);
 * jQuery(window).on('resize', lazyLayout);
 *
 * // execute `sendMail` when the click event is fired, debouncing subsequent calls
 * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * });
 *
 * // ensure `batchLog` is executed once after 1 second of debounced calls
 * var source = new EventSource('/stream');
 * source.addEventListener('message', _.debounce(batchLog, 250, {
 *   'maxWait': 1000
 * }, false);
 */
function debounce(func, wait, options) {
  var args,
      maxTimeoutId,
      result,
      stamp,
      thisArg,
      timeoutId,
      trailingCall,
      lastCalled = 0,
      maxWait = false,
      trailing = true;

  if (!isFunction(func)) {
    throw new TypeError;
  }
  wait = nativeMax(0, wait) || 0;
  if (options === true) {
    var leading = true;
    trailing = false;
  } else if (isObject(options)) {
    leading = options.leading;
    maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  var delayed = function() {
    var remaining = wait - (now() - stamp);
    if (remaining <= 0) {
      if (maxTimeoutId) {
        clearTimeout(maxTimeoutId);
      }
      var isCalled = trailingCall;
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if (isCalled) {
        lastCalled = now();
        result = func.apply(thisArg, args);
      }
    } else {
      timeoutId = setTimeout(delayed, remaining);
    }
  };

  var maxDelayed = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    maxTimeoutId = timeoutId = trailingCall = undefined;
    if (trailing || (maxWait !== wait)) {
      lastCalled = now();
      result = func.apply(thisArg, args);
    }
  };

  return function() {
    args = arguments;
    stamp = now();
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading);

    if (maxWait === false) {
      var leadingCall = leading && !timeoutId;
    } else {
      if (!maxTimeoutId && !leading) {
        lastCalled = stamp;
      }
      var remaining = maxWait - (stamp - lastCalled);
      if (remaining <= 0) {
        if (maxTimeoutId) {
          maxTimeoutId = clearTimeout(maxTimeoutId);
        }
        lastCalled = stamp;
        result = func.apply(thisArg, args);
      }
      else if (!maxTimeoutId) {
        maxTimeoutId = setTimeout(maxDelayed, remaining);
      }
    }
    if (!timeoutId && wait !== maxWait) {
      timeoutId = setTimeout(delayed, wait);
    }
    if (leadingCall) {
      result = func.apply(thisArg, args);
    }
    return result;
  };
}

module.exports = debounce;

},{"lodash._renative":24,"lodash.isfunction":25,"lodash.isobject":26}],24:[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.0.0 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */

/** Used for native method references */
var objectProto = Object.prototype;

/** Used to detect if a method is native */
var reNative = RegExp('^' +
  String(objectProto.valueOf)
    .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
    .replace(/valueOf|for [^\]]+/g, '.+?') + '$'
);

module.exports = reNative;

},{}],25:[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.0.0 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */

/**
 * Checks if `value` is a function.
 *
 * @static
 * @memberOf _
 * @category Objects
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 */
function isFunction(value) {
  return typeof value == 'function';
}

module.exports = isFunction;

},{}],26:[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.0.0 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var objectTypes = require('lodash._objecttypes');

/**
 * Checks if `value` is the language type of Object.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Objects
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // check if the value is the ECMAScript language type of Object
  // http://es5.github.io/#x8
  // and avoid a V8 bug
  // http://code.google.com/p/v8/issues/detail?id=2291
  return !!(value && objectTypes[typeof value]);
}

module.exports = isObject;

},{"lodash._objecttypes":27}],27:[function(require,module,exports){
/**
 * @license
 * Lo-Dash 2.0.0 <http://lodash.com/>
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */

/** Used to determine if values are of the language type Object */
var objectTypes = {
  'boolean': false,
  'function': true,
  'object': true,
  'number': false,
  'string': false,
  'undefined': false
};

module.exports = objectTypes;

},{}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvanMvYXBwcy9lZGl0b3IuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL2RpcmVjdGl2ZXMvYm9yZGVyTGF5b3V0LmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9kaXJlY3RpdmVzL2NvZGVFZGl0b3IuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL2RpcmVjdGl2ZXMvcHJldmlld2VyLmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9kaXJlY3RpdmVzL3Rvb2xiYXIuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL3NlcnZpY2VzL2Fubm90YXRpb25zLmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9zZXJ2aWNlcy9iYXNlUGx1bmsuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL3NlcnZpY2VzL2Rpc2FibGVyLmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9zZXJ2aWNlcy9sYXlvdXQuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL3NlcnZpY2VzL25vdGlmaWVyLmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9zZXJ2aWNlcy9zZXNzaW9uLmNvZmZlZSIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy9qcy9zZXJ2aWNlcy9zZXR0aW5ncy5jb2ZmZWUiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvanMvc2VydmljZXMvdHlwZXMuY29mZmVlIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL2pzL3NlcnZpY2VzL3VybC5jb2ZmZWUiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvdmVuZG9yL2FuZ3VsYXItZ3Jvd2wvYW5ndWxhci1ncm93bC5qcyIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy92ZW5kb3IvYW5ndWxhci11aS91aS1ib290c3RyYXAuanMiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvdmVuZG9yL2FuZ3VsYXItdWkvdWktcm91dGVyLmpzIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL3ZlbmRvci9hbmd1bGFyL2FuZ3VsYXItY29va2llcy5qcyIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL2Fzc2V0cy92ZW5kb3IvYW5ndWxhci9hbmd1bGFyLmpzIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvYXNzZXRzL3ZlbmRvci9vcGVyYXRpdmUuanMiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9hc3NldHMvdmVuZG9yL290dHlwZXMvd2ViY2xpZW50L2pzb24wLnVuY29tcHJlc3NlZC5qcyIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL25vZGVfbW9kdWxlcy9nZW5pZC9pbmRleC5qcyIsIi92YXIvbGliL3N0aWNrc2hpZnQvNTIyOWY3NjY1MDA0NDZjMDAzMDAwMDgwL2FwcC1yb290L2RhdGEvNjA1NjQzL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanMiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL25vZGVfbW9kdWxlcy9sb2Rhc2guX3JlbmF0aXZlL2luZGV4LmpzIiwiL3Zhci9saWIvc3RpY2tzaGlmdC81MjI5Zjc2NjUwMDQ0NmMwMDMwMDAwODAvYXBwLXJvb3QvZGF0YS82MDU2NDMvbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9ub2RlX21vZHVsZXMvbG9kYXNoLmlzZnVuY3Rpb24vaW5kZXguanMiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNvYmplY3QvaW5kZXguanMiLCIvdmFyL2xpYi9zdGlja3NoaWZ0LzUyMjlmNzY2NTAwNDQ2YzAwMzAwMDA4MC9hcHAtcm9vdC9kYXRhLzYwNTY0My9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNvYmplY3Qvbm9kZV9tb2R1bGVzL2xvZGFzaC5fb2JqZWN0dHlwZXMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0NBQUEsS0FBQTs7Q0FBQSxDQUFBLEtBQUEsdUJBQUE7O0NBQUEsQ0FDQSxLQUFBLCtCQUFBOztDQURBLENBRUEsS0FBQSwrQkFBQTs7Q0FGQSxDQUdBLEtBQUEsNEJBQUE7O0NBSEEsQ0FNQSxLQUFBLHFCQUFBOztDQU5BLENBT0EsS0FBQSxzQkFBQTs7Q0FQQSxDQVFBLEtBQUEsc0JBQUE7O0NBUkEsQ0FTQSxLQUFBLHVCQUFBOztDQVRBLENBVUEsS0FBQSxvQkFBQTs7Q0FWQSxDQVlBLEtBQUEsNEJBQUE7O0NBWkEsQ0FhQSxLQUFBLDBCQUFBOztDQWJBLENBY0EsS0FBQSx5QkFBQTs7Q0FkQSxDQWVBLEtBQUEsdUJBQUE7O0NBZkEsQ0FrQkEsQ0FBUyxHQUFULENBQWdCLElBQThCLEdBQUEsR0FBQSxHQUFyQyxJQUFxQyxDQUFBLENBQUEsQ0FBQSxFQUFBLENBQUE7O0NBbEI5QyxDQW1DQSxJQUFNO0VBQTJCLENBQTJDLEVBQTdELElBQThELEtBQUQsRUFBOUQsQ0FBOEQsQ0FBQSxDQUE5RCxDQUFBO0NBQ1osR0FBQSxFQUFBLEdBQUEsUUFBaUI7Q0FBakIsQ0FFaUMsRUFBakMsRUFBQSxDQUFBLENBQUEsVUFBa0I7Q0FFQyxPQUFuQixDQUFBLElBQUEsS0FBa0I7Q0FMTixJQUE4RDtDQW5DNUUsR0FtQ0E7O0NBbkNBLENBMkNBLElBQU07RUFBMkIsQ0FBc0IsRUFBeEMsSUFBeUMsS0FBRCxFQUF6QyxFQUF5QyxFQUF6QztDQUVaLENBQ0UsR0FERixDQUFBLEVBQUEsTUFBYztDQUNaLENBQUssQ0FBTCxJQUFBLENBQUE7Q0FBQSxDQUNVLE1BQVYsc0JBREE7Q0FBQSxDQUlZLE1BQVosRUFBQTtFQUF1QixDQUFVLEdBQUEsRUFBckIsQ0FBc0IsRUFBckI7Q0FDWCxFQUEwQixDQUExQixFQUFNLE1BQU4sSUFBQTtDQUFBLEVBQ3lCLEVBRHpCLENBQ00sTUFBTixHQUFBO0NBQ0EsQ0FBNEIsRUFBQSxFQUFNLEVBQU4sSUFBNUI7Q0FBTyxDQUFQLElBQU0sUUFBTixPQUFBO2NBSCtCO0NBQXJCLFVBQXFCO1VBSmpDO0NBREYsT0FBQTtDQUFBLENBWUUsR0FERixDQUFBLFFBQWM7Q0FDWixDQUFLLENBQUwsS0FBQTtDQUFBLENBRUUsR0FERixHQUFBO0NBQ0UsQ0FDRSxJQURGLElBQUE7Q0FDRSxDQUFhLFNBQWIsQ0FBQSxXQUFBO0NBQUEsQ0FDWSxRQUFaLEVBQUE7RUFBdUIsQ0FBb0MsR0FBQSxDQUFBLENBQS9DLENBQUEsQ0FBQSxDQUFBLElBQUM7Q0FDWCxVQUFBLFNBQUE7Q0FBQSxFQUFTLEdBQVQsQ0FBZ0IsS0FBUCxJQUFUO0NBQUEsSUFFQSxDQUFNLEdBQU4sT0FBQTtDQUZBLEVBRzRCLENBQUEsRUFBdEIsTUFBNEIsRUFBbEMsRUFBQTtDQUVTLE1BQVQsQ0FBUSxLQUFSLFVBQUE7Q0FOVSxjQUErQztjQUQzRDtZQURGO1VBRkY7Q0FaRixPQVdBO0NBZ0JlLENBQ2IsR0FERixRQUFBLENBQWM7Q0FDWixDQUFLLENBQUwsS0FBQSw0QkFBQTtDQUFBLENBRUUsR0FERixHQUFBO0NBQ0UsQ0FDRSxJQURGLElBQUE7Q0FDRSxDQUFhLFNBQWIsQ0FBQSxXQUFBO0NBQUEsQ0FDWSxRQUFaLEVBQUE7RUFBNkIsQ0FBa0YsQ0FBbkcsQ0FBbUcsQ0FBQSxDQUFuRyxDQUFBLENBQUEsQ0FBQSxFQUFtRyxFQUFuRyxDQUFDO0NBRVgsbUJBQUEsR0FBQTtDQUFBLEVBQVMsR0FBVCxDQUFnQixJQUFQLENBQUEsSUFBVDtDQUFBLENBRTJCLENBQVUsRUFBSyxDQUFRLENBQWxELENBQVEsSUFBb0YsSUFBNUYsU0FBcUMsTUFBYTtDQUZsRCxFQUlTLENBQUEsRUFBVCxDQUFnQixDQUFNLENBQUMsT0FBdkI7Q0FDRSxxQkFBQSx1QkFBQTtDQUFBLEVBQUEsQ0FBRyxFQUFBLEVBQVEsVUFBWDtDQUF5QyxDQUFTLElBQUYsVUFBQSxXQUFBO29CQUFoRDtDQUFBLEVBRU8sQ0FBUCxJQUFlLFVBQWY7Q0FGQSxFQUlFLENBREYsY0FBQTtDQUNFLENBQVcsRUFBWCxLQUFBLFdBQUE7Q0FBQSxDQUNPLEdBQVAsZUFBQTtDQUxGLG1CQUFBO0NBT0EsRUFBYyxDQUFYLENBQXNCLEdBQXRCLE1BQXNCLElBQXpCO0NBQ0U7Q0FDRSxDQUFxQixFQUFyQixFQUFBLENBQU8sQ0FBYyxjQUFyQjtNQURGLGdCQUFBO0NBR0UsS0FBQSxnQkFESTtDQUNKLEdBQUEsSUFBUSxjQUFSLGlCQUFBO3NCQUpKO29CQVBBO0NBQUEsRUFhbUIsQ0FBZixFQUFtQyxLQUF2QyxDQUE2RSxNQUE3RSxRQUF3QztDQUV4QztDQUFBLGVBQUEsT0FBQTsyQ0FBQTtDQUNFLEdBQU8sQ0FBWSxHQUFaLE1BQVAsTUFBQTtDQUNFLEdBQUksQ0FBTSxpQkFBVjtDQUNFLENBQVUsTUFBVixnQkFBQTtDQUFBLENBQ1MsRUFBSSxHQUFiLGlCQUFBO0NBRkYsdUJBQUE7c0JBRko7Q0FBQSxrQkFmQTtDQURvQix3QkFzQnBCO0NBdEJPLENBdUJQLENBQUEsRUFBQSxJQUFDLFFBdkJtQjtDQXdCcEIsQ0FBa0MsQ0FBbEMsRUFBQSxFQUFPLFdBQVAsRUFBQTtDQUVHLENBQUQsSUFBRixlQUFBLElBQUE7Q0ExQk8sZ0JBdUJQO0NBS0ssRUFBSyxDQUFaLEVBQU0sR0FBTyxjQUFiO0NBQ0UsRUFBQSxtQkFBQTtDQUFBLEVBQTBCLEVBQTFCLENBQU0sVUFBTixFQUFBO0NBQUEsR0FDQSxDQUFBLENBQU0sWUFBTjtDQURBLEVBRTRCLENBQUEsRUFBdEIsTUFBNEIsRUFBbEMsSUFBQTtDQUNTLE1BQVQsQ0FBUSxRQUFSLFNBQUE7Q0FKRixDQUtFLENBQUEsTUFBQyxRQUxTO0NBTVYsQ0FBQSxJQUFNLFFBQU4sSUFBQTtDQUNTLElBQVQsR0FBUSxDQUFSLGdCQUFBO0NBUEYsZ0JBS0U7Q0F2Q1EsY0FBbUc7Y0FEL0c7WUFERjtVQUZGO0NBOUJtRCxPQTZCckQ7Q0E3QlksSUFBeUM7Q0EzQ3ZELEdBMkNBOztDQTNDQSxDQTBIQSxJQUFNLElBQU4sU0FBQTtFQUFrRCxDQUFXLEVBQXJCLENBQXFCLENBQUEsQ0FBdEIsQ0FBQTtDQUNyQyxLQUFBLElBQUE7Q0FBQSxFQUFpQixHQUFqQixDQUFBLEtBQTBCLE9BQUE7Q0FBMUIsRUFFaUIsR0FBakIsQ0FBQSxFQUFpQjtDQUNmLE9BQUEsSUFBQTtDQUFBLEVBQWMsQ0FBWCxFQUFXLEVBQWQsR0FBYztDQUNaLEtBQU0sRUFBTixFQUFBO0NBQ08sS0FBRCxFQUFOLEtBQUEsSUFBQTtVQUhhO0NBRmpCLE1BRWlCO0NBRmpCLEVBT29CLEdBQXBCLEdBQXFCLENBQXJCLEVBQW9CO0NBQ2xCLE9BQUEsSUFBQTtDQUFBLENBQW1FLENBQXBCLENBQTVDLEVBQU0sQ0FBTixDQUFILEdBQStDLENBQTVDO0NBQ00sQ0FBeUIsSUFBMUIsRUFBTixFQUFBLEVBQUEsS0FBQTtVQUZnQjtDQVBwQixNQU9vQjtDQVBwQixFQVdvQixHQUFwQixFQUFvQixDQUFDLENBQXJCO0NBQ0UsRUFBZ0YsQ0FBN0UsRUFBTSxDQUFOLENBQUgsZ0NBQXlDO0NBQ2hDLEtBQUQsRUFBTixFQUFBLE9BQUE7VUFGZ0I7Q0FYcEIsTUFXb0I7Q0FJYixFQUFTLEdBQVYsRUFBVSxDQUFDLElBQWpCO0NBQ1MsS0FBRCxFQUFOLEtBQUEsRUFBQTtDQWpCeUQsTUFnQjNDO0NBaEJxQixJQUFzQjtDQTFIN0QsR0EwSEE7O0NBMUhBLENBK0lBLElBQU0sSUFBTixRQUFBO0VBQWlELENBQVUsRUFBcEIsQ0FBb0IsRUFBckIsQ0FBc0I7Q0FDMUQsRUFBZ0IsR0FBaEI7Q0FDTyxFQUFvQixHQUFyQixHQUFxQixJQUEzQixJQUFBO0FBQzRCLENBQW5CLEVBQWtCLEdBQW5CLFNBQU47Q0FIdUQsTUFFOUI7Q0FGUyxJQUFxQjtDQS9JM0QsR0ErSUE7Q0EvSUE7Ozs7O0FDQUE7Q0FBQSxLQUFBLGtCQUFBO0tBQUEsYUFBQTs7Q0FBQSxDQUFBLENBQVMsR0FBVCxDQUFnQixVQUFQOztDQUFULENBR0EsQ0FBVyxFQUFBLEdBQVgsQ0FBWTtDQUNWLE9BQUEsQ0FBQTtDQUFBLEVBQVksQ0FBWixDQUFBLElBQUE7R0FDQSxNQUFBLEVBQUE7Q0FDRSxHQUFVLEVBQVYsR0FBQTtDQUFBLGFBQUE7UUFBQTtDQUFBLEVBRVksQ0FGWixFQUVBLEdBQUE7Q0FGQSxFQUdXLEdBQVgsR0FBVyxDQUFYO0NBQVcsRUFDRyxNQUFaLE1BQUE7Q0FERixDQUVFLEdBRkYsRUFBVztDQUlSLENBQUQsRUFBRixLQUFXLEVBQUgsRUFBUjtDQVZPLElBRVQ7Q0FMRixFQUdXOztDQUhYLENBZU07Q0FDUyxDQUFjLENBQWQsQ0FBQSxDQUFBLENBQUEsVUFBRTtDQUNiLEVBRGEsQ0FBQSxFQUFEO0NBQ1osRUFEeUIsQ0FBQSxFQUFEO0NBQ3hCLEVBQUEsQ0FBQyxFQUFEO0NBQUEsRUFDUyxDQUFSLENBQUQsQ0FBQTtDQURBLEVBRVUsQ0FBVCxFQUFEO0NBRkEsRUFHUSxDQUFQLEVBQUQ7Q0FKRixJQUFhOztDQUFiLENBTTZCLENBQWQsR0FBQSxHQUFDLEVBQUQsRUFBZjtDQUNFLFNBQUEsc0JBQUE7O0dBRG9DLEtBQVQ7UUFDM0I7Q0FBQSxFQUFRLENBQUMsQ0FBVCxDQUFBLENBQVEsSUFBQTtDQUFSLEVBQ1ksQ0FBQyxFQUFiLEdBQUEsRUFBWSxLQUFBO0NBRVosR0FBRyxFQUFILENBQVUsQ0FBUDtDQUNELEdBQUcsRUFBQSxFQUFIO0NBQW9CLEdBQVcsQ0FBSixDQUFBLFdBQUE7VUFBM0I7Q0FDQSxHQUFHLEVBQUEsRUFBSDtDQUFvQixFQUEyQixDQUFoQixDQUFKLENBQVcsV0FBWDtVQUQzQjtDQUdBLGNBQU87UUFQVDtDQUFBLENBVWlDLENBQXhCLEdBQVQsQ0FBUztDQUdULEVBQVksQ0FBVCxDQUFDLENBQUo7Q0FBK0MsQ0FBbUMsQ0FBaUIsQ0FBNUMsQ0FBZ0MsTUFBakMsRUFBQSxFQUFBO1FBYnREO0NBY0EsRUFBWSxDQUFULENBQUMsQ0FBSjtDQUErQyxDQUFtQyxDQUFpQixDQUE1QyxDQUFnQyxNQUFqQyxFQUFBLEVBQUE7UUFkdEQ7Q0FnQkEsRUFBYSxDQUFWLENBQVUsQ0FBYixDQUFHLElBQVU7Q0FBOEIsQ0FBNEIsS0FBSixDQUFqQixPQUFBO1FBaEJsRDtDQWlCQSxFQUFhLENBQVYsQ0FBVSxDQUFiLENBQUcsYUFBVTtDQUF1QyxFQUE4QixDQUFuQixDQUFKLEVBQTBDLEVBQS9CLENBQVksS0FBdkI7UUFqQjNEO0NBa0JBLEVBQWEsQ0FBVixDQUFVLENBQWIsQ0FBRyxhQUFVO0NBQXVDLEVBQTBCLENBQWYsQ0FBSixFQUFzQyxHQUFuQixLQUFuQjtRQWxCM0Q7Q0FvQkEsRUFBb0MsQ0FBMUIsQ0FBQSxDQUFBLE1BQUEsUUFBTztDQTNCbkIsSUFNZTs7Q0FOZixDQTZCa0IsQ0FBVCxDQUFBLEVBQUEsQ0FBVCxFQUFVO0NBQ1IsSUFBQSxLQUFBOztHQUR1QixLQUFQO1FBQ2hCO0NBQUEsS0FBQSxRQUFPO0NBQVAsTUFBQSxNQUNPO0NBQ0gsRUFBUSxFQUFSLEtBQUE7Q0FBUSxDQUFPLENBQUwsQ0FBUSxRQUFSO0NBQUYsQ0FBMkIsQ0FBRSxDQUFDLENBQVYsT0FBQTtDQUFwQixDQUFnRCxDQUFFLENBQVIsUUFBQTtDQUExQyxDQUFzRSxDQUFFLENBQUYsRUFBUixNQUFBO0NBQXRFLFdBQUE7Q0FBQSxFQUNBLENBQUMsTUFBRDtDQUZHO0NBRFAsS0FBQSxPQUlPO0NBQ0gsRUFBUSxFQUFSLEtBQUE7Q0FBUSxDQUFPLENBQUwsQ0FBUSxRQUFSO0NBQUYsQ0FBMkIsQ0FBRSxDQUFDLENBQVYsT0FBQTtDQUFwQixDQUFrRCxDQUFFLENBQUMsRUFBWCxNQUFBO0NBQTFDLENBQXlFLENBQUUsQ0FBRixDQUFQLE9BQUE7Q0FBMUUsV0FBQTtDQUFBLEdBQ0MsQ0FBRCxLQUFBO0NBRkc7Q0FKUCxNQUFBLE1BT087Q0FDSCxFQUFRLEVBQVIsS0FBQTtDQUFRLENBQVMsQ0FBRSxDQUFDLENBQVYsT0FBQTtDQUFGLENBQWdDLENBQUUsQ0FBQyxFQUFYLE1BQUE7Q0FBeEIsQ0FBc0QsQ0FBRSxDQUFSLFFBQUE7Q0FBaEQsQ0FBNEUsQ0FBRSxDQUFGLEVBQVIsTUFBQTtDQUE1RSxXQUFBO0NBQUEsR0FDQyxFQUFELElBQUE7Q0FGRztDQVBQLEtBQUEsT0FVTztDQUNILEVBQVEsRUFBUixLQUFBO0NBQVEsQ0FBTyxDQUFMLENBQVEsUUFBUjtDQUFGLENBQTRCLENBQUUsQ0FBQyxFQUFYLE1BQUE7Q0FBcEIsQ0FBa0QsQ0FBRSxDQUFSLFFBQUE7Q0FBNUMsQ0FBdUUsQ0FBRSxDQUFGLENBQVAsT0FBQTtDQUF4RSxXQUFBO0NBQUEsR0FDQyxNQUFEO0NBWkosTUFBQTtDQURPLFlBZVA7Q0E1Q0YsSUE2QlM7O0NBN0JULEVBOENnQixNQUFBLEtBQWhCO0NBQ2EsQ0FBeUIsQ0FBaEIsQ0FBaEIsQ0FBTyxDQUFQLE9BQUE7Q0EvQ04sSUE4Q2dCOztDQTlDaEIsRUFpRFMsSUFBVCxFQUFVLEVBQUQ7Q0FDUCxVQUFBLEdBQU87Q0FBUCxTQUFBLEdBQ087Q0FBaUIsR0FBQSxhQUFEO0NBRHZCLFdBQUEsQ0FFTztDQUFtQixHQUFBLGFBQUQ7Q0FGekIsTUFETztDQWpEVCxJQWlEUzs7Q0FqRFQsRUFzRGtCLE1BQUMsRUFBRCxLQUFsQjtDQUNFLFVBQUEsR0FBTztDQUFQLFNBQUEsR0FDTztDQUFpQixFQUFTLENBQVQsRUFBRCxXQUFBO0NBRHZCLFdBQUEsQ0FFTztDQUFtQixFQUFRLENBQVIsQ0FBRCxZQUFBO0NBRnpCLE1BRGdCO0NBdERsQixJQXNEa0I7O0NBdERsQjs7Q0FoQkY7O0NBQUEsQ0E2RUEsSUFBTSxHQUFOO0dBQTJCLEVBQUEsSUFBQTthQUN6QjtDQUFBLENBQVUsQ0FBVixLQUFBO0NBQUEsQ0FDUyxFQURULEdBQ0EsQ0FBQTtDQURBLENBRVMsSUFBQSxDQUFULENBQUEsT0FBUztDQUZULENBR1ksRUFIWixJQUdBLEVBQUE7Q0FIQSxDQUlPLEVBSlAsQ0FJQSxHQUFBO0NBSkEsQ0FLVSxNQUFWLHlTQUxBO0NBQUEsQ0FZWSxNQUFaLEVBQUE7RUFBdUIsQ0FBc0IsR0FBQSxFQUFqQyxDQUFrQyxDQUFsQyxDQUFDO0NBQ1gsZUFBQSx3QkFBQTtDQUFBLEVBQU8sQ0FBUCxRQUFBO0NBQUEsQ0FFQyxLQUFnQyxDQUFRLElBQXpDO0NBRkEsQ0FJMEIsQ0FBQSxHQUFwQixFQUFOLENBQTJCLEdBQTNCO0NBQ0UsR0FBQSxjQUFBO0NBQUEsRUFBTyxDQUFQLEVBQUEsUUFBQTtDQUFBLEVBRWMsQ0FBVixFQUFKLFFBQUE7Q0FGQSxFQUdtQixDQUFmLEVBQWUsS0FBbkIsR0FBQTtDQUVBLEdBQUcsVUFBSDtDQUNPLEdBQUQsRUFBTyxpQkFBWDtnQkFQc0I7Q0FBMUIsWUFBMEI7Q0FKMUIsQ0Fhd0IsQ0FBQSxDQUFBLEVBQWxCLEVBQU4sQ0FBeUIsR0FBekI7Q0FDRSxFQUFjLENBQVYsRUFBSixRQUFBO0NBRUssR0FBRCxFQUFPLGVBQVg7Q0FIRixZQUF3QjtDQWJ4QixDQWtCd0IsQ0FBQSxDQUFBLEVBQWxCLENBQWtCLENBQXhCLENBQXlCLEdBQXpCOztHQUFnQyxhQUFQO2dCQUN2QjtDQUFBLEdBQWdCLENBQVEsRUFBeEIsT0FBQTtDQUFBLEVBQU8sQ0FBUCxDQUFBLFdBQUE7Z0JBQUE7Q0FDQSxHQUFHLFVBQUg7Q0FBYSxPQUFRLEdBQVIsS0FBQTtNQUFiLFVBQUE7Q0FDSyxPQUFRLFFBQVI7Z0JBRkw7Q0FJSyxHQUFELEVBQUosZUFBQTtDQUxGLFlBQXdCO0NBbEJ4QixDQXlCeUIsQ0FBQSxDQUFBLENBQUEsQ0FBbkIsQ0FBTixDQUFBLENBQTBCLEdBQTFCOztHQUFrQyxhQUFSO2dCQUN4QjtDQUFBLENBQWtDLENBQXJCLENBQVQsQ0FBSixHQUFhLE1BQWI7Q0FFSyxHQUFELEVBQU8sZUFBWDtDQUhGLFlBQXlCO0NBekJ6QixDQUFBLENBOEJZLENBQVgsSUFBRCxJQUFBO0NBOUJBLEVBK0JZLENBQVgsSUFBRCxJQUFBO0NBL0JBLEVBaUNlLENBQWQsQ0FBYyxJQUFDLEVBQWhCLENBQUE7Q0FBMkIsR0FBQSxDQUFELEdBQVMsYUFBVDtDQWpDMUIsWUFpQ2U7Q0FqQ2YsRUFtQ2tCLENBQWpCLEVBQWlCLEdBQUMsR0FBbkIsRUFBQTs7Q0FBbUMsRUFBUCxHQUFNLFVBQWY7Z0JBQ2pCO0NBQUEsS0FBQSxnQkFBTztDQUFQLE1BQUEsY0FDTztDQURQLE1BQUEsY0FDZ0I7Q0FEaEIsd0JBQzZCO0NBRDdCLEtBQUEsZUFFTztDQUZQLEtBQUEsZUFFZTtDQUZmLHdCQUUyQjtDQUYzQixjQURnQjtDQW5DbEIsWUFtQ2tCO0NBbkNsQixDQXdDNEIsQ0FBVCxDQUFsQixFQUFrQixHQUFDLENBQUQsRUFBbkIsR0FBQTtDQUNFLElBQUEsYUFBQTtDQUFBLEVBQ0UsRUFERixTQUFBO0NBQ0UsQ0FBSyxDQUFMLGFBQUE7Q0FBQSxDQUNPLEdBQVAsV0FBQTtDQURBLENBRVEsSUFBUixVQUFBO0NBRkEsQ0FHTSxFQUFOLFlBQUE7Q0FKRixlQUFBO0NBTUEsS0FBQSxnQkFBTztDQUFQLE1BQUEsY0FDTztDQUFhLENBQWUsQ0FBQSxDQUFmLENBQUssQ0FBTCxJQUFlLFFBQWY7Q0FBYjtDQURQLEtBQUEsZUFFTztDQUFZLENBQWEsQ0FBQSxDQUFiLENBQUssS0FBUSxRQUFiO0NBQVo7Q0FGUCxNQUFBLGNBR087Q0FBYSxDQUFZLENBQVosQ0FBQSxDQUFLLEtBQU8sUUFBWjtDQUFiO0NBSFAsS0FBQSxlQUlPO0NBQVksQ0FBYyxDQUFBLENBQWQsQ0FBSyxLQUFTLFFBQWQ7Q0FKbkIsY0FOQTtDQURpQixvQkFhakI7Q0FyREYsWUF3Q21CO0NBeENuQixDQXVEMkIsQ0FBVCxDQUFqQixFQUFpQixHQUFDLENBQUQsRUFBbEIsRUFBQTtDQUVFLEtBQUEsZ0JBQU87Q0FBUCxNQUFBLGNBQ087eUJBQ0g7Q0FBQSxDQUFRLENBQUUsQ0FBVixFQUFBLElBQVUsR0FBQSxPQUFWO0NBQUEsQ0FDTyxHQUFQLGVBQUE7Q0FEQSxDQUVNLEVBQU4sZ0JBQUE7Q0FGQSxDQUdRLElBQVIsY0FBQTtDQUxKO0NBQUEsTUFBQSxjQU1PO3lCQUNIO0NBQUEsQ0FBUSxDQUFFLENBQVYsRUFBQSxJQUFVLEdBQUEsT0FBVjtDQUFBLENBQ08sR0FBUCxlQUFBO0NBREEsQ0FFTSxFQUFOLGdCQUFBO0NBRkEsQ0FHSyxDQUFMLGlCQUFBO0NBVko7Q0FBQSxLQUFBLGVBV087eUJBQ0g7Q0FBQSxDQUFPLENBQUUsQ0FBVCxDQUFBLENBQWUsSUFBTixFQUFBLENBQUEsT0FBVDtDQUFBLENBQ0ssQ0FBTCxpQkFBQTtDQURBLENBRVEsSUFBUixjQUFBO0NBRkEsQ0FHTSxFQUFOLGdCQUFBO0NBZko7Q0FBQSxLQUFBLGVBZ0JPO3lCQUNIO0NBQUEsQ0FBTyxDQUFFLENBQVQsQ0FBQSxDQUFlLElBQU4sRUFBQSxDQUFBLE9BQVQ7Q0FBQSxDQUNLLENBQUwsaUJBQUE7Q0FEQSxDQUVRLElBQVIsY0FBQTtDQUZBLENBR08sR0FBUCxlQUFBO0NBcEJKO0NBQUEsY0FGZ0I7Q0F2RGxCLFlBdURrQjtDQXZEbEIsRUErRWdCLENBQWYsS0FBZSxHQUFoQjtDQUNFLE9BQVEsTUFBUjtDQUNDLEdBQUEsRUFBTSxNQUFQLFNBQUE7Q0FqRkYsWUErRWdCO0NBL0VoQixFQWtGYyxDQUFiLEtBQWEsQ0FBZCxFQUFBO0NBQ0UsT0FBUSxHQUFSLEdBQUE7Q0FDQyxHQUFBLEVBQU0sSUFBUCxXQUFBO0NBcEZGLFlBa0ZjO0NBbEZkLEVBc0ZVLENBQVQsRUFBRCxHQUFXLEdBQVg7O0FBQW1CLENBQUQsRUFBQSxDQUFLLFlBQVo7Z0JBQ1Q7Q0FBQSxFQUFZLENBQVIsVUFBSjtBQUVJLENBQUosR0FBRyxVQUFIO0NBQWMsRUFBWSxDQUFYLElBQUQsUUFBQTtNQUFkLFVBQUE7Q0FDSyxFQUFRLENBQVAsSUFBRCxRQUFBO2dCQUhMO0NBS0EsR0FBRyxVQUFIO0NBQWEsT0FBUSxHQUFSLEtBQUE7TUFBYixVQUFBO0NBQ0ssT0FBUSxRQUFSO2dCQU5MO0NBUUMsR0FBQSxFQUFNLGVBQVA7Q0EvRkYsWUFzRlU7Q0F0RlYsQ0FpR21CLENBQVQsQ0FBVCxFQUFELEdBQVcsR0FBWDtDQUNFLGlCQUFBLHVHQUFBOztDQUQrQixFQUFMLENBQUksWUFBYjtnQkFDakI7Q0FBQSxFQUFTLENBQUksRUFBYixRQUFBO0NBRUEsR0FBRyxDQUFVLENBQVYsRUFBSCxNQUFBO0NBQ0UsRUFBQSxLQUFRLFFBQVI7Q0FDRSxDQUFLLENBQUwsQ0FBQSxFQUFhLFlBQWI7Q0FBQSxDQUNPLENBQUUsQ0FEVCxDQUNBLENBQWUsWUFBZjtDQURBLENBRVEsQ0FBRSxDQUZWLEVBRUEsWUFBQTtDQUZBLENBR00sQ0FBRSxDQUFSLEVBQWMsWUFBZDtDQUpGLGlCQUFBO0lBS00sQ0FBVyxDQU5uQixDQU1RLFNBTlI7Q0FPRSxFQUFjLENBQUMsRUFBRCxLQUFkLEdBQWMsRUFBZDtDQUFBLENBQytDLENBQWxDLENBQW1ELEVBQTdDLElBQW5CLENBQWEsRUFBQSxHQUFiO0FBRUksQ0FBSixHQUFHLFlBQUg7Q0FDRSxFQUFPLENBQVAsTUFBQSxRQUFBO01BREYsWUFBQTtDQUdFLENBQXlDLENBQWxDLENBQVAsRUFBYSxLQUFOLEVBQUEsS0FBUDtDQUFBLEVBQ0EsQ0FBb0IsRUFBUixHQURaLFNBQ0E7Q0FEQSxFQUVBLENBQW9CLEVBQVIsWUFBWjtDQUZBLENBS3NCLENBQWYsQ0FBUCxFQUE0QixLQUFOLEVBQUEsS0FBdEI7Q0FMQSxDQU1zQixDQUFmLENBQVAsRUFBNEIsS0FBTixFQUFBLEtBQXRCO0NBTkEsQ0FPc0IsQ0FBZixDQUFQLEVBQTRCLEtBQU4sS0FBQSxFQUF0QjtDQVBBLENBUXNCLENBQWYsQ0FBUCxNQUFzQixRQUF0QjtrQkFkRjtDQUFBLEVBZ0JRLENBQVAsWUFBRDtDQWhCQSxDQWtCd0MsQ0FBdkIsQ0FBQSxFQUFNLENBQU4sT0FBakIsRUFBQTtDQWxCQSxDQW1Cd0MsQ0FBekIsQ0FBQyxFQUFELElBQUEsRUFBZixHQUFlLENBQWY7Q0FuQkEsQ0FvQnNDLENBQXhCLENBQUMsRUFBRCxJQUFBLENBQWQsR0FBYyxFQUFkO0NBcEJBLENBc0J1QixDQUF2QixDQUFBLEdBQUEsQ0FBUSxNQUFSLEVBQUE7Q0F0QkEsQ0F3QndDLENBQXhDLENBQUEsR0FBTyxDQUFQLElBQUEsSUFBQTtDQXhCQSxDQXlCeUMsQ0FBekMsQ0FBQSxHQUFPLEVBQVAsR0FBQSxJQUFBO0NBekJBLENBMEJ1QyxDQUF2QyxDQUFBLEdBQU8sSUFBUCxLQUFBO2dCQW5DRjtDQXFDQSxHQUFHLEVBQUgsRUFBWSxNQUFaO0NBQ0UsRUFBUSxFQUFSLENBQWMsUUFBTixFQUFSO0NBQ0E7Q0FBQSxvQkFBQSx1QkFBQTtxQ0FBQTtDQUFBLEVBQVEsRUFBUixDQUFRLFlBQVI7Q0FBQSxnQkFGRjtnQkFyQ0E7Q0F5Q0EsS0FBQSxlQUFPO0NBM0lULFlBaUdVO0NBNENULEVBQVMsQ0FBVCxFQUFELEdBQVcsVUFBWDtDQUNFLENBQW9CLEVBQXBCLEVBQU0sUUFBTjtDQUVDLEdBQUEsRUFBTSxlQUFQO0NBakp5QyxZQThJakM7Q0E5SUEsVUFBaUM7VUFaN0M7Q0FBQSxDQWdLTSxDQUFBLENBQU4sRUFBTSxFQUFOLENBQU87Q0FDTCxXQUFBLEVBQUE7Q0FBQSxDQURpQyxRQUFOO0NBQzNCLEVBQWMsQ0FBVixFQUFKLElBQUE7Q0FBQSxHQUNBLEVBQU0sSUFBTixDQUFBO0NBREEsRUFHNEIsQ0FBNUIsRUFBTSxJQUFOLEdBQW9CO0NBRWIsQ0FBc0IsQ0FBQSxHQUF2QixHQUF3QixFQUFELEVBQTdCLElBQUE7Q0FDRSxHQUFHLE9BQUgsQ0FBQTtDQUF3QixFQUFELEtBQUgsYUFBQSxNQUFBO01BQXBCLFFBQUE7Q0FDUyxFQUFELFFBQUgsVUFBQSxNQUFBO2NBRnNCO0NBQTdCLFVBQTZCO0NBdEsvQixRQWdLTTtDQWpLbUI7Q0FBRixJQUFFO0NBN0UzQixHQTZFQTs7Q0E3RUEsQ0F5UEEsSUFBTSxHQUFOLEtBQUE7RUFBOEMsQ0FBQSxFQUFYLEVBQVcsRUFBYjthQUMvQjtDQUFBLENBQVUsQ0FBVixLQUFBO0NBQUEsQ0FDUyxLQUFULENBQUEsUUFBUztDQURULENBRU0sQ0FBQSxDQUFOLEVBQU0sRUFBTixDQUFPO0NBQ0wsYUFBQSwwQkFBQTtDQUFBLENBRHNDLFFBQU47QUFDbEIsQ0FBZCxHQUFBLE1BQUE7Q0FBQSxpQkFBQTtZQUFBO0NBQUEsQ0FFQSxDQUFLLEtBQVMsRUFBZDtDQUZBLEVBSWMsT0FBZCxDQUFBO0NBSkEsRUFLWSxNQUFaLENBQUE7Q0FMQSxFQU9nQixHQUFWLEdBQVUsQ0FBaEI7Q0FBd0IsR0FBRCxVQUFKLEtBQUE7Q0FBTCxDQUE4QixDQUFBLE1BQUMsRUFBN0I7Q0FDZCxPQUFRLEVBQVIsQ0FBQSxDQUFBO0NBQUEsT0FDUSxHQUFSLENBQUE7Q0FDQSxVQUFBLFNBQU87Q0FBUCxTQUFBLFNBQ087Q0FBeUIsT0FBRCxFQUFSLGFBQUE7Q0FEdkIsV0FBQSxPQUVPO0NBQTJCLE9BQUQsSUFBUixXQUFBO0NBRnpCLFlBSDBDO0NBQTVDLFVBQTRDO0NBT3pDLENBQUQsQ0FBK0IsTUFBQyxFQUFsQyxLQUFBLENBQUE7Q0FDRSxlQUFBLHVIQUFBO0NBQUEsR0FBYyxDQUFZLENBQVosTUFBZDtDQUFBLG1CQUFBO2NBQUE7Q0FBQSxFQUVTLENBQUksRUFBYixNQUFBO0NBRUEsR0FBRyxDQUFXLENBQVgsQ0FBQSxLQUFIO0NBQXFDLEVBQVEsRUFBUixJQUFBLEtBQUE7SUFDN0IsQ0FBVyxDQURuQixRQUFBO0NBQ3dDLEVBQVEsRUFBUixJQUFBLEtBQUE7Y0FMeEM7Q0FPQSxHQUFHLENBQVcsQ0FBWCxDQUFBLEtBQUg7Q0FBb0MsRUFBUSxFQUFSLFNBQUE7SUFDNUIsQ0FBVyxDQURuQixDQUNRLE9BRFI7QUFDa0QsQ0FBVCxFQUFRLEVBQVIsU0FBQTtjQVJ6QztDQUFBLEVBVVcsS0FBWCxJQUFBO0NBQVcsQ0FBSSxLQUFKLE9BQUM7Q0FBRCxDQUFrQixLQUFsQixPQUFlO0NBVjFCLGFBQUE7Q0FBQSxFQVdhLEVBQUUsS0FBZixFQUFBO0NBWEEsRUFZWSxDQUFJLEtBQWhCLEdBQUE7Q0FaQSxFQWFZLENBQUksS0FBaEIsR0FBQTtDQWJBLEdBZUksUUFBSjtDQWZBLENBa0JFLENBQWdCLENBbEJsQixRQWtCQTtDQWxCQSxDQW1CRSxDQUFpQixNQUFBLEdBQW5CLENBQUE7Q0FBbUIsb0JBQUc7Q0FuQnRCLFlBbUJtQjtDQW5CbkIsQ0FvQkUsQ0FBb0IsRUFBZCxDQXBCUixJQW9CQSxFQUFBLENBQXNCO0NBcEJ0QixXQXdCQSxFQUFBO0NBeEJBLEVBeUJxQixDQXpCckIsUUF5QkEsSUFBQTtDQXpCQSxFQTBCSSxDQTFCSixRQTBCQTtDQTFCQSxFQTRCYyxNQUFDLEVBQWYsQ0FBQTtDQUNTLEVBQU8sR0FBUixHQUFRLFlBQWQ7Q0FBc0IsR0FBRCxFQUFKLGlCQUFBO0NBQWpCLGNBQWM7Q0E3QmhCLFlBNEJjO0NBNUJkLEVBK0JrQixNQUFDLEdBQW5CLEdBQUE7Q0FDRSxPQUFRLE1BQVIsYUFBQTtDQUFBLEVBS2MsR0FBUixHQUFRLEtBQWQ7Q0FBaUIsU0FBQSxVQUFBO0NBQUssRUFBb0IsQ0FBckIsQ0FBaUMsQ0FBckMsR0FBeUIsQ0FBYixhQUFaO0NBQWpCLGNBQWM7Q0FMZCxhQVNBO0NBVEEsRUFVcUIsQ0FWckIsVUFVQSxFQUFBO0NBQ0EsRUFBSSxrQkFBSjtDQTNDRixZQStCa0I7Q0EvQmxCLEVBNkNnQixNQUFDLEdBQWpCLENBQUE7Q0FDRSxpQkFBQSxrQkFBQTtDQUFBLENBQWtELENBQWpDLENBQUksR0FBSyxDQUFvQixNQUE5QztDQUFBLEVBQ2MsQ0FBSSxLQURsQixFQUNBLEdBQUE7Q0FEQSxDQUd5QyxFQUF6QyxHQUFPLElBQVAsR0FBQSxLQUFBLEtBQUE7Q0FIQSxDQUl1QyxFQUF2QyxHQUFPLEVBQVAsSUFBQSxDQUFBLEtBQUE7Q0FKQSxFQU1VLElBQVYsRUFBVSxLQUFWO0NBR0UsYUFBQSxFQUFBO0NBQUEsRUFDcUIsQ0FEckIsWUFDQTtDQURBLEVBRUksQ0FGSixZQUVBO0NBRUssR0FBRCxNQUFKLGFBQUE7Q0FiRixjQU1VO0NBVVYsQ0FBMkMsQ0FBdEIsQ0FBbEIsS0FBSCxFQUFxQixHQUFyQjtDQUNFLFVBQUEsS0FBQTtDQUFBLE1BQ0EsU0FBQTtDQUNBLHFCQUFBO2dCQW5CRjtDQUFBLGFBc0JBLENBQUE7Q0FFQSxNQUFBLGNBQUE7Q0F0RUYsWUE2Q2dCO0NBN0NoQixDQTBFMkIsQ0FBQSxLQUFBLElBQTNCLEdBQTJCLFNBQTNCO0NBMUVBLENBNEVzQyxFQUF0QyxHQUFPLElBQVAsQ0FBQSxJQUFBLFFBQUE7Q0FDUSxDQUE0QixFQUFwQyxHQUFPLEVBQVAsSUFBQSxHQUFBLEdBQUE7Q0E5RUYsVUFBaUM7Q0FqQm5DLFFBRU07Q0FIc0M7Q0FBYixJQUFhO0NBelA5QyxHQXlQQTs7Q0F6UEEsQ0E4VkEsSUFBTSxHQUFOLEtBQUE7RUFBOEMsQ0FBWSxFQUF2QixFQUF1QixDQUFBLENBQXpCLENBQUE7YUFDL0I7Q0FBQSxDQUFVLENBQVYsS0FBQTtDQUFBLENBQ1MsRUFEVCxHQUNBLENBQUE7Q0FEQSxDQUVTLEtBQVQsQ0FBQSxNQUFTO0NBRlQsQ0FHWSxFQUhaLElBR0EsRUFBQTtDQUhBLENBSVUsTUFBViw2Q0FKQTtDQUFBLENBUVksTUFBWixFQUFBO0VBQXVCLENBQXNCLEdBQUEsRUFBakMsQ0FBa0MsQ0FBbEMsQ0FBQztDQUNYLEtBQUEsVUFBQTtDQUFBLEVBQVMsQ0FBVCxFQUFBLE1BQUE7Q0FBQSxDQUFBLENBRVksQ0FBWCxJQUFELElBQUE7Q0FGQSxFQUllLENBQWQsQ0FBYyxJQUFDLEVBQWhCLENBQUE7Q0FDRyxHQUFBLENBQUQsR0FBUyxhQUFUO0NBTEYsWUFJZTtDQUpmLEVBT2dCLENBQWYsS0FBZSxHQUFoQjtDQUE0QixPQUFELGFBQVI7Q0FQbkIsWUFPZ0I7Q0FQaEIsRUFRYyxDQUFiLEtBQWEsQ0FBZCxFQUFBO0NBQ0UsT0FBUSxHQUFSLEdBQUE7Q0FDTyxLQUFELElBQU4sV0FBQSxDQUFBO0NBVkYsWUFRYztDQUliLEVBQVMsQ0FBVCxFQUFELEdBQVcsVUFBWDtDQUNFLGlCQUFBLDRCQUFBO0NBQUEsRUFBUSxFQUFSLEdBQWlCLEdBQWpCLEdBQUE7Q0FBQSxFQUNTLEdBQVQsRUFBa0IsSUFEbEIsRUFDQTtDQURBLENBRzZCLENBQWQsQ0FBQSxDQUFBLENBQUEsUUFBZjtDQUhBLENBS21CLENBQUosQ0FBZCxJQUFRLENBQU8sS0FBaEI7Q0FBMEIsRUFBUyxFQUFWLGtCQUFBO0NBQXpCLGNBQWU7Q0FFZjtDQUFBO29CQUFBLHVCQUFBO2tDQUFBO0NBQUEsRUFBUyxFQUFLLENBQWQ7Q0FBQTsrQkFSUTtDQWJpQyxZQWFqQztDQWJBLFVBQWlDO1VBUjdDO0NBQUEsQ0FnQ00sQ0FBQSxDQUFOLEVBQU0sRUFBTixDQUFPO0NBQ0wsYUFBQTtDQUFBLENBRG1DLFFBQVI7Q0FDM0IsR0FBOEIsRUFBOUIsSUFBQTtDQUFBLEtBQU0sS0FBTixDQUFBO1lBQUE7Q0FBQSxDQUVxQixDQUFyQixHQUFNLEVBQU4sQ0FBcUIsQ0FBckI7QUFDeUIsQ0FBdkIsR0FBQSxFQUFBLE1BQUE7Q0FBTyxLQUFELGVBQU47Y0FEbUI7Q0FBckIsVUFBcUI7Q0FGckIsQ0FLbUMsQ0FBQSxJQUE1QixDQUFQLENBQW9DLENBQXBDLE1BQUE7Q0FDRSxXQUFBLEdBQUE7Q0FDTyxFQUFPLEdBQVIsR0FBUSxVQUFkO0NBQXdCLEtBQUQsSUFBTixXQUFBLENBQUE7Q0FBakIsWUFBYztDQUZoQixVQUFtQztDQUkxQixFQUFBLEtBQVQsQ0FBUyxRQUFUO0FBQW1DLENBQXZCLEdBQUEsRUFBQSxNQUFBO0NBQU8sS0FBRCxlQUFOO2NBQUg7Q0FBVCxVQUFTO0NBMUNYLFFBZ0NNO0NBakNrRDtDQUF6QixJQUF5QjtDQTlWMUQsR0E4VkE7Q0E5VkE7Ozs7O0FDQUE7Q0FBQSxLQUFBOztDQUFBLENBQUEsS0FBQSxxQkFBQTs7Q0FBQSxDQUNBLEtBQUEsbUJBQUE7O0NBREEsQ0FFQSxLQUFBLHNCQUFBOztDQUZBLENBR0EsS0FBQSx5QkFBQTs7Q0FIQSxDQUtBLENBQVMsR0FBVCxDQUFnQixnQkFBd0MsRUFBQSxDQUFBLEdBQUEsQ0FBL0M7O0NBTFQsQ0FZQSxJQUFNLEdBQU4sR0FBQTtFQUErQyxDQUEyRCxFQUF6RSxFQUFGLENBQTJFLENBQTNFLENBQUEsQ0FBMkUsQ0FBM0UsQ0FBQTtDQUM3QixTQUFBLGtEQUFBO0NBQUEsRUFBWSxHQUFaLENBQVksRUFBWixHQUFZO0NBQVosRUFDVyxHQUFYLENBQVcsQ0FBWCxPQURBLE9BQ1c7Q0FEWCxFQUVjLEdBQWQsQ0FBYyxJQUFkLE9BQWM7Q0FGZCxFQUdjLEdBQWQsQ0FBYyxJQUFkLE1BQWM7Q0FIZCxFQUlRLEVBQVIsQ0FBQSxDQUFRLElBQUE7Q0FKUixFQU1TLEdBQVQsQ0FBUyxLQUFBO2FBRVQ7Q0FBQSxDQUFVLENBQVYsS0FBQTtDQUFBLENBQ1MsRUFEVCxHQUNBLENBQUE7Q0FEQSxDQUdFLEdBREYsR0FBQTtDQUNFLENBQVEsQ0FBUixHQUFBLElBQUE7VUFIRjtDQUFBLENBSVUsTUFBViw2QkFKQTtDQUFBLENBUU0sQ0FBQSxDQUFOLENBQU0sQ0FBQSxFQUFOLENBQU87Q0FDTCxhQUFBLDJIQUFBO0NBQUEsQ0FBNkMsQ0FBaEMsQ0FBQSxDQUFjLENBQTNCLEVBQTJCLENBQWQsQ0FBYixFQUE2QztDQUE3QyxFQUNTLEdBQVQsQ0FBZ0IsR0FBaEIsRUFBUyxDQUFBO0NBRFQsRUFFaUIsQ0FGakIsTUFFQSxJQUFBO0NBRkEsQ0FBQSxDQUdVLElBQVYsR0FBQTtDQUhBLENBS2dELENBQTdDLEdBQU8sR0FBc0MsQ0FBaEQsY0FBQTtDQUNFLEtBQU0sSUFBTixFQUFBO0NBQ0UsQ0FBMkIsRUFBM0IsVUFBQSxXQUFBO0NBQUEsQ0FDZ0IsRUFEaEIsVUFDQTtDQUZGLGFBQUE7Q0FJcUIsRUFBSixJQUFBLE9BQWpCLEtBQUE7Q0FMRixVQUFnRDtDQUxoRCxFQVlnQixHQUFWLEdBQVUsQ0FBaEI7Q0FBNEIsS0FBTSxFQUFQLFdBQVI7Q0FBTCxDQUE4QixDQUFBLEVBQUEsSUFBQyxFQUE3QjtDQUNkLEdBQXlDLENBQXpDLE9BQUE7Q0FBTyxFQUFxQixFQUE1QixDQUFNLEVBQU4sSUFBaUIsU0FBakI7Y0FEMEM7Q0FBNUMsVUFBNEM7Q0FaNUMsRUFnQlksS0FBQSxDQUFaLENBQUE7Q0FBOEMsRUFBTixFQUFLLEdBQUwsR0FBZCxFQUFjLE1BQWQ7Q0FoQjFCLFVBZ0JZO0NBaEJaLEVBa0JpQixFQUFBLElBQUMsQ0FBbEIsSUFBQTtDQUNFLElBQTBCLENBQXBCLENBQW9CLEdBQTFCLEVBQUE7Q0FDTyxJQUFQLENBQU0sYUFBTjtDQXBCRixVQWtCaUI7Q0FsQmpCLEVBc0JhLEdBQUEsR0FBQyxDQUFkO0NBQ0UsRUFBQSxhQUFBO0NBQUEsRUFBQSxHQUFZLENBQVEsS0FBcEI7Q0FDTyxFQUF3QixHQUF6QixTQUFzQixJQUE1QixDQUFBO0NBeEJGLFVBc0JhO0NBdEJiLENBMEJ3QixDQUFSLENBQUEsQ0FBQSxJQUFDLENBQWpCLEdBQUE7Q0FDRSxlQUFBLCtDQUFBO0NBQUEsQ0FBaUIsQ0FBQSxDQUFBLEdBQVksR0FBN0IsQ0FBaUIsQ0FBakI7Q0FBQSxHQUM4QixNQUFwQixDQUFvQixDQUE5QixFQUFBO0NBREEsR0FFQSxNQUFVLEVBQVY7Q0FGQSxLQUdxQyxFQUFQLEVBQXBCLEVBQVY7QUFDMkIsQ0FKM0IsR0FJZ0QsRUFBTCxDQUEzQyxDQUFvQyxFQUExQixFQUFWLEVBQUE7Q0FKQSxDQUs2RCxDQUE3RCxDQUFpRCxDQUFNLENBQVgsRUFBUCxFQUEzQixFQUFWLEtBQUE7Q0FMQSxHQU1pQyxHQUFqQyxDQUFtQixDQUFBLENBQVQsRUFBVjtDQU5BLEVBU0EsT0FBZ0IsQ0FBVixDQUFOO0NBVEEsRUFXb0IsTUFBQyxHQUFyQixLQUFBO0FBQ1MsQ0FBUCxHQUFBLEdBQUEsR0FBaUIsSUFBakI7Q0FBc0MsRUFBTyxHQUFSLEdBQVEsY0FBZDtDQUM3QixDQUFBLG9CQUFBO0NBQUEsQ0FBQSxDQUFLLGVBQUwsQ0FBSztDQUVMLEdBQWEsRUFBYixvQkFBTztDQUFQLFdBQUEsYUFDTztDQUF5QixDQUEwQixDQUFHLENBQWQsQ0FBMkMsQ0FBM0QsRUFBTixFQUFBLEtBQWlDLGNBQWpDO0NBRHpCLFlBQUEsWUFFTztDQUEwQixDQUEwQixDQUFHLENBQWQsQ0FBMkMsQ0FBM0QsRUFBTixFQUFBLEtBQWlDLGNBQWpDO0NBRjFCLFdBQUEsYUFHTztDQUF5QixDQUEwQixDQUFHLENBQWQsQ0FBMkMsQ0FBM0QsRUFBTixFQUFBLEtBQWlDLGNBQWpDO0NBSHpCLFlBQUEsWUFJTztDQUEwQixDQUEwQixDQUFHLENBQWQsQ0FBMkMsQ0FBM0QsRUFBTixFQUFBLEtBQWlDLGNBQWpDO0NBSjFCLGtCQUgyQztDQUFkLGdCQUFjO2dCQUQzQjtDQVhwQixZQVdvQjtDQVhwQixFQXFCOEIsTUFBQyxHQUEvQixlQUFBO0FBQ1MsQ0FBUCxHQUFBLEdBQUEsR0FBaUIsSUFBakI7Q0FBc0MsRUFBTyxHQUFSLEdBQVEsY0FBZDtDQUM3QixFQUFBLG1CQUFBO0NBQUEsRUFBSSxDQUFELEVBQWEsRUFBTixJQUFBLE1BQVY7Q0FDRSxFQUEyRCxDQUFqRCxDQUFBLEdBQUEsa0JBQUEsaUJBQU87b0JBRG5CO0NBQUEsQ0FHa0MsRUFBWCxFQUF2QixFQUFBLEVBQTRDLENBQWpDLEdBQXVCLElBQWxDO0NBRVcsQ0FBZ0MsRUFBM0MsTUFBVSxJQUF1QyxLQUFqRCxNQUFBO0NBTjZCLGdCQUFjO2dCQURqQjtDQXJCOUIsWUFxQjhCO0NBckI5QixFQThCaUIsRUFBVCxFQUFBLEdBOUJSLEVBOEJBO0NBOUJBLENBZ0NrQyxFQUFYLEVBQXZCLEVBQUEsRUFBNEMsQ0FBakMsQ0FBWCxFQUFrQztDQWhDbEMsQ0FrQ0EsTUFBQSxFQUFVLEVBQVYsS0FBQTtDQWxDQSxDQW1DQSxRQUFVLEVBQVYsTUFBQSxTQUFBO0NBRVcsRUFBVSxJQUFyQixFQUFxQixDQUFYLFNBQVY7Q0FDRSxDQUF5QixDQUF6QixLQUFBLEVBQVUsSUFBVixHQUFBO0NBQ1csQ0FBd0IsQ0FBbkMsT0FBVSxRQUFWLEdBQUEsTUFBQTtDQXhDWSxZQXNDTztDQWhFdkIsVUEwQmdCO0NBMUJoQixFQW9FbUIsRUFBQSxJQUFDLENBQXBCLE1BQUE7Q0FDRSxHQUFBLFlBQUE7QUFBTyxDQUFQLEdBQUEsQ0FBZSxFQUFBLEtBQWY7Q0FBMkIsc0JBQTNCO2NBQUE7Q0FBQSxJQUNRLEVBQUEsS0FBUjtDQURBLENBRXNCLEdBQXRCLENBQUEsQ0FBTyxLQUFQO0NBRUEsRUFBVSxDQUFQLENBQU8sQ0FBTSxNQUFoQixFQUFVO0NBQ0ksR0FBVyxFQUF2QixFQUFBLEdBQVcsVUFBWDtjQU5lO0NBcEVuQixVQW9FbUI7Q0FwRW5CLEVBNEVRLEVBQVIsR0FBUSxDQUFDLENBQVQ7Q0FDRSxlQUFBLDhCQUFBO0FBQUEsQ0FBQSxFQUFBLGNBQWlDLDRDQUFqQztDQUFBLEVBQUEsV0FBQSxFQUFBO0NBQUEsWUFBQTtDQUNBO0NBQUE7a0JBQUEsc0NBQUE7aUNBQUE7Q0FBQSxDQUFtQixDQUFuQixDQUFBLFNBQUE7Q0FBQTs2QkFGTTtDQTVFUixVQTRFUTtDQTVFUixDQWdGNEIsQ0FBUixFQUFBLEdBQUEsQ0FBQyxDQUFyQixPQUFBO0NBQ0UsS0FBQSxVQUFBO0NBQUEsRUFBZ0QsQ0FBVCxDQUFpQixDQUFqQixDQUFpQixLQUF4RDtDQUFPLEtBQUQsQ0FBTixDQUFlLENBQUEsWUFBZjtjQURrQjtDQWhGcEIsVUFnRm9CO0NBaEZwQixDQW1GQSxDQUFtQixHQUFiLENBQU4sQ0FBbUIsQ0FBQyxDQUFwQjtDQUEwQyxJQUFOLEdBQUEsV0FBQTtDQUFwQyxVQUFtQjtDQW5GbkIsQ0FxRkEsQ0FBMkIsR0FBckIsRUFBcUIsQ0FBQyxDQUE1QixLQUFBO0NBQ2lCLElBQWYsU0FBQSxLQUFBO0NBREYsVUFBMkI7Q0FyRjNCLENBd0ZBLENBQTZCLEdBQXZCLEVBQXVCLENBQUMsQ0FBOUIsT0FBQTtDQUNhLEtBQVgsSUFBQSxTQUFBO0NBREYsVUFBNkI7Q0F4RjdCLENBMkZBLENBQXdCLEdBQWxCLEVBQWtCLENBQUMsQ0FBekIsRUFBQTtDQUNnQixDQUFTLEdBQXZCLEdBQStCLEtBQS9CLE1BQUE7Q0FERixVQUF3QjtDQTNGeEIsQ0E4RkEsQ0FBd0IsR0FBbEIsRUFBa0IsQ0FBQyxDQUF6QixFQUFBO0NBQ0UsSUFBQSxPQUFBLElBQUE7Q0FDWSxLQUFaLEVBQUEsR0FBVyxRQUFYO0NBRkYsVUFBd0I7Q0E5RnhCLENBa0dBLENBQXdCLEdBQWxCLEVBQWtCLENBQUMsQ0FBekIsRUFBQTtDQUNFLENBQTJCLEdBQTNCLEdBQUEsSUFBQSxLQUFBO0NBQ1ksQ0FBbUIsSUFBL0IsRUFBQSxHQUFXLENBQVgsT0FBQTtDQUZGLFVBQXdCO0NBbEd4QixDQXNHQSxDQUF3QixHQUFsQixFQUFrQixDQUFDLENBQXpCLEVBQUE7Q0FDRSxTQUFBLE1BQUE7QUFBaUYsQ0FBakYsRUFBOEYsQ0FBOUYsQ0FBc0csRUFBQSxHQUFyQixFQUFqRjtDQUFBLEdBQVUsQ0FBQSxlQUFBLG9DQUFBO2NBQVY7Q0FDVyxDQUFxRCxDQUFsRCxDQUFkLEVBQUEsSUFBVSxLQUFZLElBQXRCO0NBRkYsVUFBd0I7Q0F0R3hCLENBMEdBLENBQXdCLEdBQWxCLEVBQWtCLENBQUMsQ0FBekIsRUFBQTtDQUNFLFNBQUEsTUFBQTtBQUFpRixDQUFqRixFQUE4RixDQUE5RixDQUFzRyxFQUFBLEdBQXJCLEVBQWpGO0NBQUEsR0FBVSxDQUFBLGVBQUEsb0NBQUE7Y0FBVjtDQUNXLENBQXNFLENBQW5FLENBQW1ILENBQXRHLENBQTNCLElBQVUsS0FBNkIsSUFBdkM7Q0FGRixVQUF3QjtDQTFHeEIsSUE4R0EsQ0FBWSxJQUFaLENBQU07Q0E5R04sS0ErR3FCLElBQXJCLElBQUEsSUFBZTtDQS9HZixLQWdIaUIsSUFBakIsU0FBVztDQWhIWCxDQW1IbUMsQ0FBbkMsR0FBTSxHQUE2QixDQUFuQyxZQUFBO0NBQTZDLEtBQUQsYUFBTjtDQUF0QyxVQUFtQztDQUUxQixFQUFBLEtBQVQsQ0FBUyxRQUFUO0NBQ1MsS0FBRCxhQUFOO0NBREYsQ0FFRSxDQUZGLFFBQVM7Q0E5SFgsUUFRTTtDQWpCa0c7Q0FBM0UsSUFBMkU7Q0FaMUcsR0FZQTtDQVpBOzs7OztBQ0FBO0NBQUEsS0FBQSxpQkFBQTs7Q0FBQSxDQUFBLENBQVEsRUFBUixFQUFROztDQUFSLENBQ0EsQ0FBVyxJQUFBLENBQVgsU0FBVzs7Q0FEWCxDQUdBLEtBQUEsb0JBQUE7O0NBSEEsQ0FLQSxLQUFBLHFCQUFBOztDQUxBLENBTUEsS0FBQSxtQkFBQTs7Q0FOQSxDQU9BLEtBQUEsaUJBQUE7O0NBUEEsQ0FRQSxLQUFBLHNCQUFBOztDQVJBLENBU0EsS0FBQSx5QkFBQTs7Q0FUQSxDQVdBLENBQVMsR0FBVCxDQUFnQixjQUF1QyxJQUFBLENBQUEsR0FBOUM7O0NBWFQsQ0FrQkEsSUFBTSxHQUFOLEVBQUE7RUFBNEMsQ0FBNkMsRUFBekQsRUFBeUQsQ0FBQSxDQUEzRCxDQUFBLENBQTJELEVBQTNEO2FBQzVCO0NBQUEsQ0FBVSxDQUFWLEtBQUE7Q0FBQSxDQUNTLEVBRFQsR0FDQSxDQUFBO0NBREEsQ0FHRSxHQURGLEdBQUE7Q0FDRSxDQUFTLENBQVQsSUFBQSxHQUFBO1VBSEY7Q0FBQSxDQUlVLE1BQVYsc2NBSkE7Q0FBQSxDQWVNLENBQUEsQ0FBTixDQUFNLENBQUEsRUFBTixDQUFPO0NBQ0wsYUFBQSxDQUFBO0NBQUEsQ0FBc0IsQ0FBQSxFQUFhLENBQTdCLElBQU47Q0FBQSxFQUVTLEdBQVQsQ0FBZ0IsR0FBaEIsQ0FBUyxDQUFBO0NBRlQsRUFJVSxJQUFWLENBQVUsQ0FBQyxDQUFYO0NBQStCLEVBQU8sR0FBUixHQUFRLFVBQWQ7Q0FDdEIsaUJBQUEseUJBQUE7Q0FBQSxHQUFVLENBQWUsQ0FBVCxJQUFoQixJQUFBO0NBQUEscUJBQUE7Z0JBQUE7Q0FFQSxFQUFjLENBQVgsSUFBQSxHQUFzQixHQUF6QjtDQUNFLEVBQWtCLEdBQVosQ0FBTixDQUFBLFFBQUEsdUNBQWtCO0NBQ2xCLHFCQUFBO01BRkYsVUFBQTtDQUlFLENBQUEsQ0FBaUIsR0FBWCxDQUFOLFNBQUE7Z0JBTkY7Q0FBQSxFQVFPLENBQVAsRUFBTyxFQUFRLEtBQVIsQ0FBUDtDQVJBLEVBU3FCLENBQWpCLENBQU0sQ0FUVixDQVNBLE9BQUE7Q0FUQSxDQVU0QixFQUF4QixFQUFKLEVBQUEsSUFBQSxFQUFBO0NBVkEsQ0FXNEIsRUFBeEIsRUFBOEIsRUFBbEMsRUFBQSxFQUFBLEVBQUE7Q0FYQSxDQVk0QixFQUF4QixJQUFKLElBQUEsRUFBQSxRQUFBO0NBRUE7Q0FBQSxrQkFBQSx3QkFBQTtpQ0FBQTtDQUNFLEVBQVEsRUFBUixFQUFRLENBQVEsS0FBUixHQUFSO0NBQUEsQ0FDMkIsR0FBdEIsQ0FBTCxFQUFBLElBQUEsSUFBQTtDQURBLENBRTRCLENBQU8sQ0FBSSxDQUFsQyxDQUFMLEVBQTRCLElBQTVCLElBQUE7Q0FGQSxDQUc0QixFQUFJLENBQTNCLEVBQUwsS0FBQSxJQUFBO0NBSEEsR0FLSSxDQUFKLE1BQUEsS0FBQTtDQU5GLGNBZEE7Q0FBQSxHQXNCYSxJQUFMLEdBQVIsR0FBQTtDQXRCQSxHQXdCSSxFQUFKLFFBQUE7Q0FFUyxHQUFJLElBQUwsR0FBUixVQUFBO0NBM0JzQixZQUFjO0NBSnRDLFVBSVU7Q0FKVixFQW1DZ0IsR0FBVixHQUFVLENBQWhCO0NBQTRCLE9BQUQsQ0FBVSxVQUFsQjtDQUFMLENBQWdDLENBQUEsRUFBQSxJQUFDLEVBQS9CO0NBQ0ssQ0FBUyxDQUFsQixFQUFBLEVBQVYsQ0FBVSxXQUFWO0NBREYsVUFBOEM7Q0FuQzlDLENBc0NBLENBQW1CLEdBQWIsQ0FBTixDQUFtQixDQUFDLENBQXBCO0NBQTRDLE1BQVIsQ0FBQSxXQUFBO0NBQXBDLFVBQW1CO0NBdENuQixDQXdDQSxDQUF3QixHQUFsQixFQUFrQixDQUFDLENBQXpCLEVBQUE7Q0FBaUQsTUFBUixDQUFBLFdBQUE7Q0FBekMsVUFBd0I7Q0F4Q3hCLENBeUNBLENBQXdCLEdBQWxCLEVBQWtCLENBQUMsQ0FBekIsRUFBQTtDQUFpRCxNQUFSLENBQUEsV0FBQTtDQUF6QyxVQUF3QjtDQXpDeEIsQ0EwQ0EsQ0FBd0IsR0FBbEIsRUFBa0IsQ0FBQyxDQUF6QixFQUFBO0NBQWlELE1BQVIsQ0FBQSxXQUFBO0NBQXpDLFVBQXdCO0NBMUN4QixDQTRDQSxDQUF3QixHQUFsQixFQUFrQixDQUFDLENBQXpCLEVBQUE7Q0FBaUQsTUFBUixDQUFBLFdBQUE7Q0FBekMsVUFBd0I7Q0E1Q3hCLENBNkNBLENBQXdCLEdBQWxCLEVBQWtCLENBQUMsQ0FBekIsRUFBQTtDQUFpRCxNQUFSLENBQUEsV0FBQTtDQUF6QyxVQUF3QjtDQUVmLEVBQUEsS0FBVCxDQUFTLFFBQVQ7Q0FBb0IsS0FBTSxDQUFkLElBQVEsUUFBUjtDQUFaLFVBQVM7Q0EvRFgsUUFlTTtDQWhCaUY7Q0FBM0QsSUFBMkQ7Q0FsQnpGLEdBa0JBO0NBbEJBOzs7OztBQ0FBO0NBQUEsS0FBQTs7Q0FBQSxDQUFBLEtBQUEsK0JBQUE7O0NBQUEsQ0FFQSxLQUFBLHNCQUFBOztDQUZBLENBSUEsQ0FBUyxHQUFULENBQWdCLE9BQXFDLFlBQUEsQ0FBNUM7O0NBSlQsQ0FVQSxJQUFNLEdBQU4sT0FBQTtFQUErQyxDQUF1QixFQUFqQyxDQUFpQyxDQUFBLENBQW5DLENBQUEsQ0FBQTthQUNqQztDQUFBLENBQVUsQ0FBVixLQUFBO0NBQUEsQ0FDUyxFQURULEdBQ0EsQ0FBQTtDQURBLENBRU8sRUFGUCxDQUVBLEdBQUE7Q0FGQSxDQUdVLE1BQVYsdXhCQUhBO0NBQUEsQ0EwQk0sQ0FBQSxDQUFOLEVBQU0sRUFBTixDQUFPO0NBQ0wsS0FBQSxRQUFBO0NBQUEsRUFBUyxHQUFULENBQWdCLEdBQWhCLEVBQVMsT0FBQTtDQUVGLEVBQU8sQ0FBZCxFQUFNLEdBQVEsUUFBZDtDQUNXLEdBQVQsSUFBUSxXQUFSLFVBQUE7Q0FKRSxVQUdVO0NBN0JoQixRQTBCTTtDQTNCOEQ7Q0FBbkMsSUFBbUM7Q0FWdEUsR0FVQTtDQVZBOzs7OztBQ0FBO0NBQUEsS0FBQTs7Q0FBQSxDQUFBLENBQVMsR0FBVCxDQUFnQixzQkFBUDs7Q0FBVCxDQUVBLENBQThCLEdBQXhCLENBQU4sRUFBOEIsSUFBOUI7V0FDRTtDQUFBLENBQWEsSUFBYixLQUFBO0NBQUEsQ0FFUSxDQUFBLEdBQVIsRUFBUSxDQUFDLEVBQUQ7Q0FDTixJQUFBLE9BQUE7O0dBRCtCLE9BQWQ7VUFDakI7Q0FBUSxDQUFrQixDQUFDLENBQTNCLENBQXdDLEVBQWpDLENBQWlDLEdBQXhDLElBQUE7Q0FIRixNQUVRO0NBRlIsQ0FLUSxDQUFBLEdBQVIsR0FBUyxHQUFEO0NBQ04sQ0FBQSxDQUE2QixDQUE1QixJQUFELEdBQWEsQ0FBQTtBQUNiLENBQUEsR0FBUSxFQUFSLEtBQW9CLENBQUEsR0FBcEI7Q0FQRixNQUtRO0NBTFIsQ0FTUSxDQUFBLEdBQVIsRUFBUSxDQUFDO0FBQ1AsQ0FBQSxHQUFRLEVBQVIsRUFBb0IsR0FBQSxJQUFwQjtDQVZGLE1BU1E7Q0FUUixDQVlVLENBQUEsR0FBVixFQUFBLENBQVU7Q0FDUixXQUFBLHFDQUFBO0NBQUE7Q0FBQSxZQUFBLEdBQUE7d0NBQUE7QUFFRSxDQUFBLGNBQUEsbUNBQUE7MENBQUE7Q0FBOEQsR0FBWCxDQUFtQixLQUFUO0NBQTdELE9BQUEsYUFBTztjQUFQO0NBQUEsVUFGRjtDQUFBLFFBQUE7Q0FJQSxJQUFBLFVBQU87Q0FqQlQsTUFZVTtDQWJrQjtDQUE5QixFQUE4QjtDQUY5Qjs7Ozs7QUNBQTtDQUFBLEtBQUE7O0NBQUEsQ0FBQSxDQUFTLEdBQVQsQ0FBZ0Isb0JBQVA7O0NBQVQsQ0FFQSxHQUFBLENBQU0sS0FBTjtDQUNFLENBQU8sRUFBUCxDQUFBO09BQ0U7Q0FBQSxDQUFVLE1BQVYsSUFBQTtDQUFBLENBQ1MsS0FBVCxDQUFBLHVkQURBO0VBa0JBLE1BbkJLO0NBbUJMLENBQVUsTUFBVjtDQUFBLENBQ1MsS0FBVCxDQUFBLG1IQURBO0VBU0EsTUE1Qks7Q0E0QkwsQ0FBVSxNQUFWLEdBQUE7Q0FBQSxDQUNTLEtBQVQsQ0FBQSxlQURBO1FBNUJLO01BQVA7Q0FIRixHQUVBO0NBRkE7Ozs7O0FDQUE7Q0FBQSxLQUFBOztDQUFBLENBQUEsQ0FBUyxHQUFULENBQWdCLG1CQUFQOztDQUFULENBRUEsSUFBTSxHQUFOLFFBQUE7RUFBaUQsQ0FBQSxFQUFaLEdBQVksQ0FBQyxDQUFkO2FBQ2xDO0NBQUEsQ0FBTSxDQUFBLENBQU4sRUFBTSxFQUFOLENBQU87Q0FDTCxHQUFBLFVBQUE7Q0FBQSxFQUFPLENBQVAsR0FBYyxHQUFkLDhCQUFPO0NBSUEsRUFBUyxHQUFWLEdBQVUsUUFBaEI7Q0FBNEIsSUFBTSxDQUFNLEVBQWIsT0FBTyxJQUFmO0NBQUwsQ0FBOEMsQ0FBQSxDQUFBLENBQUEsSUFBQyxFQUE3QztDQUNkLEdBQUcsQ0FBSCxPQUFBO0NBQXVCLEdBQVQsRUFBQSxFQUFRLGFBQVI7TUFBZCxRQUFBO0NBQ1UsR0FBRCxFQUFKLGVBQUE7Y0FGcUQ7Q0FBNUQsVUFBNEQ7Q0FMOUQsUUFBTTtDQUR5QztDQUFiLElBQWE7Q0FGakQsR0FFQTs7Q0FGQSxDQWFBLElBQU0sQ0FBTixHQUFBO0VBQW1DLENBQUEsQ0FBUixDQUFFLElBQU87Q0FDbEMsS0FBQSxJQUFBO0NBQUEsQ0FBQSxDQUFTLEdBQVQ7Q0FBQSxDQUFBLENBRVMsQ0FBUixDQUFELENBQUE7Q0FDQyxDQUFpQixDQUFQLENBQVYsR0FBRCxFQUFZLElBQVosQ0FBVztDQUNULE9BQUEsSUFBQTtDQUFBLEVBQVcsQ0FBWCxJQUFBO0NBQUEsRUFFdUIsQ0FBUixDQUFBLEdBQWY7Q0FDRyxDQUFELENBQThCLENBQWhDLEtBQXVCLEtBQXZCLENBQUE7Q0FDVyxFQUFjLENBQVIsQ0FBQSxHQUFQLFNBQVI7Q0FERixRQUFnQztDQVJELE1BSXRCO0NBSmMsSUFBUTtDQWJuQyxHQWFBO0NBYkE7Ozs7O0FDQUE7Q0FBQSxLQUFBOztDQUFBLENBQUEsQ0FBUyxHQUFULENBQWdCLGlCQUFQOztDQUFULENBR0EsSUFBTSxDQUFOLENBQUE7RUFBd0MsQ0FBQSxFQUFkLElBQWUsQ0FBRCxFQUFmO0NBQ3ZCLFNBQUEsTUFBQTtDQUFBLEVBQVUsR0FBVixDQUFBO1NBQ0U7Q0FBQSxDQUFNLEVBQU4sTUFBQSxZQUFBO0NBQUEsQ0FFRSxJQURGLElBQUE7Q0FDRSxDQUNFLEtBREYsS0FBQTtDQUNFLENBQVEsSUFBUixRQUFBO0NBQUEsQ0FDTyxHQUFQLFNBQUE7Q0FEQSxDQUVNLEVBQU4sT0FGQSxHQUVBO0NBRkEsQ0FHTSxFQUFOLFVBQUE7Y0FKRjtDQUFBLENBTUUsT0FERixHQUFBO0NBQ0UsQ0FBUSxJQUFSLFFBQUE7Q0FBQSxDQUNPLEdBQVAsU0FBQTtDQURBLENBRU0sRUFBTixHQUZBLE9BRUE7Y0FSRjtZQUZGO0VBWUEsUUFiUTtDQWFSLENBQU0sRUFBTixNQUFBLGFBQUE7Q0FBQSxDQUVFLElBREYsSUFBQTtDQUNFLENBQ0UsS0FERixLQUFBO0NBQ0UsQ0FBUSxJQUFSLENBQUEsT0FBQTtDQUFBLENBQ08sR0FBUCxTQUFBO0NBREEsQ0FFTSxFQUFOLE9BRkEsR0FFQTtDQUZBLENBR00sRUFBTixVQUFBO2NBSkY7Q0FBQSxDQU1FLE9BREYsR0FBQTtDQUNFLENBQVEsSUFBUixRQUFBO0NBQUEsQ0FDTyxHQUFQLFNBQUE7Q0FEQSxDQUVNLEVBQU4sR0FGQSxPQUVBO2NBUkY7WUFGRjtVQWJRO0NBQVYsT0FBQTtDQUFBLEVBMkJFLEdBREYsQ0FBQTtDQUNFLENBQVMsRUFBVCxHQUFBLENBQUE7Q0FBQSxDQUNTLEtBQVQsQ0FBQTtDQURBLENBRVEsQ0FBQSxHQUFSLEVBQUEsQ0FBUztDQUFXLFVBQUEsR0FBQTtDQUFrQixJQUFBLENBQUE7Q0FGdEMsUUFFUTtDQUZSLENBR1EsQ0FBQSxHQUFSLEVBQUEsQ0FBUztDQUFXLFVBQUEsR0FBQTtBQUFrQyxDQUFoQixFQUFlLENBQWpDLENBQWtCLENBQUEsQ0FBd0I7Q0FIOUQsUUFHUTtDQUhSLENBS1csQ0FBQSxLQUFYLENBQUE7Q0FDRSxFQUF3RCxDQUFSLEdBQVEsR0FBeEQ7Q0FBQSxFQUFXLENBQVYsRUFBVSxDQUFYLEtBQUE7WUFBQTtDQUFBLE9BQ0EsRUFBQTtDQUNDLEdBQUEsYUFBRDtDQVJGLFFBS1c7Q0FoQ2IsT0FBQTtDQUFBLEtBcUNBLENBQU8sRUFBUDtDQXRDc0MsWUF3Q3RDO0NBeEN1QixJQUFlO0NBSHhDLEdBR0E7Q0FIQTs7Ozs7QUNBQTtDQUFBLEtBQUE7S0FBQSxhQUFBOztDQUFBLENBQUEsS0FBQSxtQ0FBQTs7Q0FBQSxDQUdBLENBQVMsR0FBVCxDQUFnQixRQUFvQyxXQUEzQzs7Q0FIVCxDQU9BLElBQU07RUFBMEIsQ0FBQSxFQUFqQixJQUFrQixJQUFELEVBQWxCO0NBQ0ksR0FBZCxTQUFBLEdBQUE7Q0FEVSxJQUFrQjtDQVBoQyxHQU9BOztDQVBBLENBV0EsSUFBTSxDQUFOLEdBQUE7RUFBcUMsQ0FBQSxFQUFULEVBQUQsRUFBVzthQUNwQztDQUFBLENBQU8sQ0FBQSxFQUFQLEVBQU8sQ0FBUCxDQUFRO0NBQ04sRUFBQSxJQUFPLEVBQWMsQ0FBckIsR0FBcUIsR0FBVDtDQUNOLElBQUQsRUFBTCxRQUFBLEVBQUE7Q0FGRixRQUFPO0NBQVAsQ0FHTSxDQUFBLENBQU4sR0FBTSxDQUFOLENBQU87Q0FDTCxFQUFBLElBQU8sQ0FBZSxDQUFBLENBQXRCLEdBQXNCLEdBQVY7Q0FDTixJQUFELEVBQUwsT0FBQSxHQUFBO0NBTEYsUUFHTTtDQUhOLENBTVMsQ0FBQSxJQUFULENBQUEsQ0FBVTtDQUNSLEVBQUEsR0FBb0IsQ0FBYixFQUFhLENBQXBCLEdBQW9CLEdBQVI7Q0FDTixJQUFELEVBQUwsVUFBQTtDQVJGLFFBTVM7Q0FQMEI7Q0FBVixJQUFVO0NBWHJDLEdBV0E7Q0FYQTs7Ozs7QUNBQTtDQUFBLEtBQUEsU0FBQTs7Q0FBQSxDQUFBLEtBQUEsK0NBQUE7O0NBQUEsQ0FFQSxDQUFTLEdBQVQsQ0FBZ0Isa0JBQVA7O0NBRlQsQ0FLQSxJQUFNLENBQU4sRUFBQTtDQUVFLE9BQUEsS0FBQTs7Q0FBQSxHQUFNO0NBQ1MsQ0FBUyxDQUFULENBQUEsRUFBQSxDQUFBLGdCQUFFO0NBQ2IsRUFEYSxDQUFBLElBQUQ7Q0FDWixFQURvQixDQUFBLEdBQ3BCLENBRG1CO0NBQ25CLENBQUEsQ0FBYSxDQUFaLElBQUQsQ0FBQTtDQURGLE1BQWE7O0NBQWIsQ0FHQSxDQUFJLEtBQUEsQ0FBQztDQUF3QixJQUFBLE9BQUE7Q0FBRSxFQUFELENBQUMsQ0FBVSxHQUFaLENBQVksTUFBWjtDQUg3QixNQUdJOztDQUhKLENBSWlCLENBQWpCLEtBQUssQ0FBQztDQUF3QixFQUFBLFNBQUE7QUFBQSxDQUFBLEVBQXFDLENBQXJDLEdBQTRDLENBQTVDLENBQXNEO0NBQXJELENBQXNCLENBQXZCLENBQUMsRUFBRCxHQUFVLFFBQVY7VUFBekI7Q0FKTCxNQUlLOztDQUpMLENBTVUsQ0FBQSxLQUFWLENBQVc7Q0FBUSxDQUFVLEVBQVYsS0FBRCxNQUFBO0NBTmxCLE1BTVU7O0NBTlYsRUFPVyxNQUFYO0NBQXFCLENBQXdCLENBQXpCLENBQUMsR0FBTyxDQUFSLE9BQUE7Q0FQcEIsTUFPVzs7Q0FQWCxDQVM4QixDQUFuQixLQUFBLENBQVgsT0FBVztDQUNULE9BQUEsSUFBQTtDQUFBLENBQUssRUFBRixDQUFlLENBQWYsRUFBSDtDQUNHLENBQ0MsRUFERCxDQUFELEVBQUEsVUFBQTtDQUNFLENBQVUsTUFBVixJQUFBO0NBQUEsQ0FDYyxVQUFkO0NBSEosV0FDRTtNQURGLElBQUE7Q0FLRSxDQUFTLGdCQUFGO0NBQVAsT0FBQSxTQUNPO0NBQ0gsQ0FBSyxFQUFGLENBQVcsTUFBZCxHQUFBO0NBQWdDLENBQzlCLEVBRDhCLENBQUQsVUFBQSxRQUFBO0NBQzdCLENBQVUsR0FBZSxHQUF6QixVQUFBO0NBQUEsQ0FDZSxHQUFlLEdBQVAsS0FBdkIsS0FBQTtDQURBLENBRU8sR0FBUCxhQUFBO0NBRkEsQ0FHWSxRQUFaLFFBQUE7Q0FKRixpQkFBK0I7Q0FLcEIsQ0FBRCxFQUFGLENBQVcsQ0FMbkIsTUFBQSxJQUFBO0NBS3NDLENBQ3BDLEVBRG9DLENBQUQsWUFBQSxNQUFBO0NBQ25DLENBQVEsSUFBUixZQUFBO0NBQUEsQ0FDYSxTQUFiLE9BQUE7Q0FQRixpQkFLcUM7Z0JBUHpDO0NBQ087Q0FEUCxZQUFBLElBVU87Q0FFSCxDQUFnQixFQUFGLENBQVcsU0FBekI7Q0FBQSxxQkFBQTtnQkFBQTtBQUNBLENBQUEsQ0FBZ0IsRUFBaEIsVUFBQTtDQUFBLHFCQUFBO2dCQURBO0NBR0MsQ0FDQyxFQURELENBQUQsV0FBQSxLQUFBO0NBQ0UsQ0FBYSxTQUFiLEtBQUE7Q0FBQSxDQUNpQixhQUFqQixDQUFBO0NBakJOLGVBZUk7Q0FmSixLQUFBLFdBa0JPO0FBQ0gsQ0FBQSxDQUFnQixFQUFoQixVQUFBO0NBQUEscUJBQUE7Z0JBQUE7Q0FDQSxDQUFZLEVBQUYsQ0FBZSxDQUFmLFFBQVY7Q0FBQSxxQkFBQTtnQkFEQTtDQUdBLENBQUssRUFBRixVQUFIO0NBQWUsQ0FDYixFQURhLENBQUQsR0FBQSxlQUFBO0NBQ1osQ0FBUyxLQUFULFdBQUE7Q0FBQSxDQUNPLEdBQVAsYUFBQTtDQUZGLGlCQUFjO0NBR0gsQ0FBRCxFQUFGLEVBSFIsVUFBQTtDQUdvQixDQUNsQixFQURrQixDQUFELE1BQUEsWUFBQTtDQUNqQixDQUFTLEtBQVQsV0FBQTtDQUFBLENBQ08sR0FBUCxhQUFBO0NBTEYsaUJBR21CO2dCQXpCdkI7Q0FrQk87Q0FsQlAsTUFBQSxVQTRCTztDQUVILENBQUssRUFBRixDQUFlLENBQWYsUUFBSDtDQUNFLENBQUssRUFBRixZQUFIO0NBQWUsQ0FDYixFQURhLENBQUQsT0FBQSxhQUFBO0NBQ1osQ0FBVSxNQUFWLFlBQUE7Q0FBQSxDQUNPLEdBQVAsZUFBQTtDQURBLENBRVMsS0FBVCxhQUFBO0NBSEYsbUJBQWM7Q0FJSCxDQUFELEVBQUYsRUFKUixZQUFBO0NBSW9CLENBQ2xCLEVBRGtCLENBQUQsT0FBQSxhQUFBO0NBQ2pCLENBQVUsTUFBVixZQUFBO0NBQUEsQ0FDTyxHQUFQLGVBQUE7Q0FEQSxDQUVTLEtBQVQsYUFBQTtDQVBGLG1CQUltQjtrQkFMckI7Q0FVVyxDQUFELEVBQUYsQ0FBVyxDQVZuQixJQUFBLE1BQUE7Q0FXRyxDQUNDLEVBREQsQ0FBRCxPQUFBLFdBQUE7Q0FDRSxDQUFVLE1BQVYsVUFBQTtDQUFBLENBQ08sR0FBUCxhQUFBO0NBREEsQ0FFYyxVQUFkLE1BQUE7Q0FkSixpQkFXRTtDQUtTLENBQUQsRUFBRixDQUFXLENBaEJuQixHQUFBLE9BQUE7Q0FpQkUsQ0FBNEIsQ0FBakIsRUFBZSxHQUExQixRQUFBO0NBRUEsQ0FBSyxFQUFGLFlBQUg7Q0FBYyxDQUNaLEVBRGEsQ0FBRCxPQUFBLE1BQUE7Q0FDWixDQUFVLE1BQVYsWUFBQTtDQUFBLENBQ08sR0FBUCxlQUFBO0NBREEsQ0FFTSxFQUFOLGdCQUFBO0NBRkEsQ0FHUSxJQUFSLGNBQUE7Q0FKWSxtQkFBQTtrQkFGZDtDQU9BLENBQUssRUFBRixZQUFIO0NBQWUsQ0FDYixFQURhLENBQUQsT0FBQSxhQUFBO0NBQ1osQ0FBVSxNQUFWLFlBQUE7Q0FBQSxDQUNPLEdBQVAsZUFBQTtDQURBLENBRU0sRUFBTixnQkFBQTtDQUZBLENBR1EsSUFBUixjQUFBO0NBSkYsbUJBQWM7a0JBeEJoQjtnQkE5Qko7Q0FBQSxVQUxGO1VBRFM7Q0FUWCxNQVNXOztDQVRYLENBMkVtQixDQUFaLEVBQVAsSUFBUTtDQUNOLFdBQUEsZ0NBQUE7Q0FBQSxFQUFXLENBQUMsSUFBWixHQUFXO0NBQVgsRUFDYyxLQUFkLENBQUE7Q0FFQSxHQUErRCxJQUEvRCxDQUEwRTtDQUExRTtDQUFBO2dCQUFBLDJCQUFBO2lDQUFBO0NBQUEsQ0FBWSxNQUFaO0NBQUE7MkJBQUE7VUFKSztDQTNFUCxNQTJFTzs7Q0EzRVAsRUFpRm9CLE1BQUEsU0FBcEI7Q0FBd0IsR0FBQSxFQUF1QixDQUFoQixDQUFTLE9BQWpCO0NBakZ2QixNQWlGb0I7O0NBakZwQixFQW1GcUIsTUFBQSxVQUFyQjtDQUF5QixHQUFBLEVBQXVCLENBQWhCLENBQVMsT0FBakI7Q0FuRnhCLE1BbUZxQjs7Q0FuRnJCLEVBcUZnQixNQUFBLEtBQWhCO0NBQW9CLEdBQUEsR0FBTyxDQUFTLE9BQWpCO0NBckZuQixNQXFGZ0I7O0NBckZoQixFQXdGYyxLQUFBLENBQUMsR0FBZjtDQUNFLFdBQUEsYUFBQTtDQUFBO0NBQUEsWUFBQSwwQ0FBQTs0QkFBQTtDQUE4RCxHQUFMLENBQWlCLEdBQWpCO0NBQXpELEVBQUEsZ0JBQU87WUFBUDtDQUFBLFFBQUE7QUFDUSxDQUFSLGNBQU87Q0ExRlQsTUF3RmM7O0NBeEZkLEVBNEZnQixNQUFDLEtBQWpCO0NBQ0UsRUFBRyxDQUFBLEdBQU8sQ0FBVjtDQUE4QixFQUFBLENBQU8sTUFBUCxFQUFNO1VBQXBDO0NBRUMsRUFBdUIsQ0FBdkIsQ0FBdUIsRUFBaEIsQ0FBUyxPQUFqQjtDQS9GRixNQTRGZ0I7O0NBNUZoQixFQWlHUyxJQUFULENBQVMsQ0FBQztDQUNSLFdBQUEsUUFBQTtDQUFBO0NBQUEsWUFBQSw4QkFBQTsyQkFBQTtDQUEwRCxHQUFMLENBQWlCLEdBQWpCO0NBQXJELEdBQUEsZUFBTztZQUFQO0NBQUEsUUFETztDQWpHVCxNQWlHUzs7Q0FqR1QsRUFvR2EsTUFBQSxFQUFiO0NBQWdCLEdBQUEsUUFBQTtDQUFBLEdBQThCO0NBcEc5QyxNQW9HYTs7Q0FwR2IsRUFzR1ksTUFBQSxDQUFaO0NBQWUsR0FBQSxRQUFBO0NBQUEsR0FBNkI7Q0F0RzVDLE1Bc0dZOztDQXRHWixFQXdHYSxNQUFBLEVBQWI7Q0FBZ0IsR0FBUSxHQUFPLENBQWYsT0FBTztDQXhHdkIsTUF3R2E7O0NBeEdiLEVBMkdhLElBQUEsRUFBQyxFQUFkO0NBQ0UsV0FBQSxZQUFBO0NBQUE7Q0FBQSxZQUFBLDBDQUFBOzJCQUFBO0dBQXVELENBQUEsQ0FBTztDQUE5RCxFQUFBLGdCQUFPO1lBQVA7Q0FBQSxRQUFBO0FBQ1EsQ0FBUixjQUFPO0NBN0dULE1BMkdhOztDQTNHYixFQStHUyxJQUFULENBQVMsQ0FBQztDQUFhLEdBQVEsSUFBRCxJQUFBLEdBQUE7Q0EvRzlCLE1BK0dTOztDQS9HVCxFQWlIYyxNQUFDLEdBQWY7Q0FBdUIsY0FBTyxpQkFBUDtDQWpIdkIsTUFpSGM7O0NBakhkLEVBbUhRLEdBQVIsQ0FBUSxFQUFDO0NBQVksR0FBUSxHQUFELElBQUEsSUFBQTtDQW5INUIsTUFtSFE7O0NBbkhSLEVBcUhZLElBQUEsRUFBQyxDQUFiO0NBQXlCLEdBQU8sR0FBQSxRQUFBLE9BQXNCO0NBckh0RCxNQXFIWTs7Q0FySFosRUF1SGEsQ0FBQSxLQUFDLEVBQWQ7Q0FBdUIsR0FBUSxHQUF5QyxDQUExQyxPQUFBO0NBdkg5QixNQXVIYTs7Q0F2SGIsRUF5SGlCLEtBQUEsQ0FBQyxNQUFsQjtDQUErQixHQUFPLElBQUEsT0FBQSxPQUFzQjtDQXpINUQsTUF5SGlCOztDQXpIakIsRUE2SE8sQ0FBQSxDQUFQLElBQVE7Q0FDTixXQUFBLG1DQUFBOztHQURhLE9BQVA7VUFDTjtDQUFBLEVBQXFCLENBQWpCLElBQUo7Q0FBQSxFQUNjLENBQVYsSUFBSjtDQURBLEVBRWdCLENBQVosSUFBSjtDQUFnQixDQUFhLE9BQVgsQ0FBQTtDQUFGLENBQTRCLFFBQVo7Q0FGaEM7QUFJc0UsQ0FBdEUsR0FBQSxHQUE2RSxDQUE3RSxHQUFzRTtDQUF0RSxHQUFVLENBQUEsV0FBQSw2QkFBQTtVQUpWO0FBSytELENBQS9ELEdBQUEsR0FBc0UsQ0FBdEU7Q0FBQSxHQUFVLENBQUEsV0FBQSxzQkFBQTtVQUxWO0NBTUE7Q0FBQSxZQUFBLDhCQUFBOzhCQUFBO0FBQXlGLENBQUQsR0FBQSxHQUFDLEdBQUE7Q0FBekYsRUFBNkMsQ0FBbkMsQ0FBQSxFQUFPLFdBQVAsV0FBTztZQUFqQjtDQUFBLFFBTkE7QUFPZ0UsQ0FBaEUsR0FBQSxDQUFnRSxFQUFPLENBQXZFO0NBQUEsR0FBVSxDQUFBLFdBQUEsdUJBQUE7VUFQVjtDQVFBO0NBQUEsWUFBQSxpQ0FBQTs0QkFBQTtBQUFxRyxDQUFELEdBQUEsT0FBQztDQUFyRyxFQUE4QyxDQUFwQyxDQUFBLElBQW9DLFNBQXBDLFlBQU87WUFBakI7Q0FBQSxRQVJBO0FBU3lFLENBQXpFLEdBQUEsQ0FBbUYsQ0FBbkYsRUFBQTtDQUFBLEdBQVUsQ0FBQSxXQUFBLGdDQUFBO1VBVFY7Q0FXQyxHQUFBLElBQUQsT0FBQTtDQUNFLENBQUcsUUFBSDtDQUFBLENBQ0EsRUFBSSxHQUFPLEdBQVgsQ0FBaUI7Q0FEakIsQ0FFQSxFQUZBLE1BRUE7Q0FmRyxTQVlMO0NBeklGLE1BNkhPOztDQTdIUCxFQThJZSxLQUFBLENBQUMsSUFBaEI7Q0FDRSxFQUFBLFNBQUE7QUFBdUYsQ0FBdkYsR0FBQSxHQUF1RixDQUF2RjtDQUFBLEVBQW1FLENBQXpELENBQUEsR0FBQSxRQUFBLG1DQUFPO1VBQWpCO0NBQUEsRUFFQSxDQUFPLElBQVAsSUFBTTtDQUVMLEdBQUEsSUFBRCxPQUFBO0NBQ0UsQ0FBRyxNQUFBLEVBQUgsQ0FBRztDQUFILENBQ0EsRUFBSyxNQUFMLFFBQUk7Q0FESixDQUVBLENBRkEsT0FFQTtDQVJXLFNBS2I7Q0FuSkYsTUE4SWU7O0NBOUlmLEVBd0pnQixNQUFDLEtBQWpCO0FBQ29GLENBQWxGLEVBQWtGLENBQWxGLElBQUEsSUFBa0Y7Q0FBbEYsRUFBbUUsQ0FBekQsQ0FBQSxXQUFBLG1DQUFPO1VBQWpCO0NBRUMsR0FBQSxJQUFELE9BQUE7Q0FDRSxDQUFHLE1BQUEsRUFBSCxDQUFHO0NBQUgsQ0FDQSxFQUFLLE1BQUwsUUFBSTtDQURKLENBRUEsQ0FGQSxPQUVBO0NBTlksU0FHZDtDQTNKRixNQXdKZ0I7O0NBeEpoQixFQWdLaUIsR0FBQSxHQUFDLE1BQWxCO0NBQ0csR0FBQSxJQUFELE9BQUE7Q0FDRSxDQUFHLE1BQUEsRUFBSCxFQUFHO0NBQUgsQ0FDQSxFQUFLLE1BQUwsU0FBSTtDQURKLENBRUEsSUFGQSxJQUVBO0NBSmEsU0FDZjtDQWpLRixNQWdLaUI7O0NBaEtqQixFQXNLZ0IsTUFBQyxFQUFELEdBQWhCOztHQUErQixPQUFkO1VBQ2Y7Q0FBQyxHQUFBLElBQUQsT0FBQTtDQUNFLENBQUcsUUFBSCxHQUFHO0NBQUgsQ0FDQSxFQUFLLE1BQUwsSUFBSTtDQURKLENBRUEsUUFBQSxDQUZBO0NBRlksU0FDZDtDQXZLRixNQXNLZ0I7O0NBdEtoQixDQThLdUIsQ0FBWCxJQUFBLENBQUEsQ0FBQyxDQUFiO0NBQ0UsRUFBQSxTQUFBOztHQUQrQixPQUFWO1VBQ3JCO0FBQStFLENBQS9FLEdBQUEsSUFBQSxPQUErRTtDQUEvRSxFQUEyRCxDQUFqRCxDQUFBLEdBQUEsUUFBQSwyQkFBTztVQUFqQjtDQUNBLEdBQThFLEdBQUEsQ0FBOUU7Q0FBQSxFQUE4RCxDQUFwRCxDQUFBLEdBQUEsUUFBQSw4QkFBTztVQURqQjtDQUFBLEVBR0EsQ0FBTyxJQUFQLEdBQU07Q0FFTCxHQUFBLElBQUQsT0FBQTtDQUNFLENBQUcsQ0FBQSxJQUFBLEdBQUg7Q0FBQSxDQUNBLFFBQUE7Q0FBSSxDQUFDLE1BQUQsSUFBQztDQUFELENBQVcsS0FBWCxLQUFXO1lBRGY7Q0FQUSxTQU1WO0NBcExGLE1BOEtZOztDQTlLWixDQXdMdUIsQ0FBWCxLQUFBLENBQUMsQ0FBYixFQUFZO0NBQ1YsRUFBQSxTQUFBO0FBQW1GLENBQW5GLEdBQUEsSUFBQSxJQUFtRixHQUFBO0NBQW5GLEVBQTJELENBQWpELENBQUEsT0FBQSxJQUFBLDJCQUFPO1VBQWpCO0FBQ2tGLENBQWxGLEdBQUEsR0FBa0YsQ0FBbEY7Q0FBQSxFQUE4RCxDQUFwRCxDQUFBLEdBQUEsUUFBQSw4QkFBTztVQURqQjtDQUVBLEdBQTBGLEdBQUEsQ0FBMUYsSUFBMEY7Q0FBMUYsRUFBc0UsQ0FBNUQsQ0FBQSxPQUFBLElBQUEsc0NBQU87VUFGakI7Q0FBQSxFQUlBLENBQU8sSUFBUCxJQUFNO0NBRUwsR0FBQSxJQUFELE9BQUE7Q0FDRSxDQUFHLENBQUEsSUFBQSxHQUFIO0NBQUEsQ0FDQSxNQURBLEVBQ0E7Q0FEQSxDQUVBLFFBQUEsRUFGQTtDQVJRLFNBT1Y7Q0EvTEYsTUF3TFk7O0NBeExaLEVBb01ZLEtBQUEsQ0FBQyxDQUFiO0NBQ0UsRUFBQSxTQUFBO0FBQWtGLENBQWxGLEdBQUEsR0FBa0YsQ0FBbEY7Q0FBQSxFQUE4RCxDQUFwRCxDQUFBLEdBQUEsUUFBQSw4QkFBTztVQUFqQjtDQUNBLEdBQTJFLElBQTNFLEdBQTJFO0NBQTNFLEdBQVUsQ0FBQSxXQUFBLHNDQUFBO1VBRFY7Q0FBQSxFQUdBLENBQU8sSUFBUCxJQUFNO0NBSE4sR0FLQyxJQUFELE1BQUE7Q0FFQyxHQUFBLElBQUQsT0FBQTtDQUNFLENBQUcsQ0FBQSxJQUFBLEdBQUg7Q0FBQSxDQUNBLEVBQUssR0FBRCxDQUFBLEVBQUo7Q0FWUSxTQVFWO0NBNU1GLE1Bb01ZOztDQXBNWixDQWtOdUIsQ0FBWCxDQUFBLEVBQUEsRUFBQSxDQUFDLENBQWI7Q0FDRSxFQUFBLFNBQUE7QUFBa0YsQ0FBbEYsR0FBQSxHQUFrRixDQUFsRjtDQUFBLEVBQThELENBQXBELENBQUEsR0FBQSxRQUFBLDhCQUFPO1VBQWpCO0NBQUEsRUFFQSxDQUFPLElBQVAsSUFBTTtDQUVMLEdBQUEsSUFBRCxPQUFBO0NBQ0UsQ0FBRyxDQUFBLEdBQUEsQ0FBQSxFQUFBLENBQUg7Q0FBQSxDQUNBLEVBREEsTUFDQTtDQVBRLFNBS1Y7Q0F2TkYsTUFrTlk7O0NBbE5aLENBMk51QixDQUFYLENBQUEsRUFBQSxFQUFBLENBQUMsQ0FBYjtDQUNFLEVBQUEsU0FBQTtBQUFrRixDQUFsRixHQUFBLEdBQWtGLENBQWxGO0NBQUEsRUFBOEQsQ0FBcEQsQ0FBQSxHQUFBLFFBQUEsOEJBQU87VUFBakI7Q0FBQSxFQUVBLENBQU8sSUFBUCxJQUFNO0NBRUwsR0FBQSxJQUFELE9BQUE7Q0FDRSxDQUFHLENBQUEsR0FBQSxDQUFBLEVBQUEsQ0FBSDtDQUFBLENBQ0EsRUFEQSxNQUNBO0NBUFEsU0FLVjtDQWhPRixNQTJOWTs7Q0EzTlosRUFzT1EsR0FBUixDQUFRLEVBQUM7Q0FDUCxFQUFBLFNBQUE7QUFBcUUsQ0FBckUsR0FBQSxHQUFxRSxDQUFyRSxFQUFxRTtDQUFyRSxFQUFrRCxDQUF4QyxDQUFBLEVBQUEsU0FBQSxrQkFBTztVQUFqQjtDQUNBLEdBQXdFLEVBQUEsQ0FBQSxDQUF4RTtDQUFBLEVBQXlELENBQS9DLENBQUEsRUFBQSxTQUFBLHlCQUFPO1VBRGpCO0NBQUEsRUFHQSxDQUFPLElBQVAsRUFBTTtDQUVMLEdBQUEsSUFBRCxPQUFBO0NBQ0UsQ0FBRyxDQUFBLEdBQUEsSUFBSDtDQUFBLENBQ0EsS0FEQSxHQUNBO0NBUkksU0FNTjtDQTVPRixNQXNPUTs7Q0F0T1IsRUFnUFcsSUFBQSxFQUFYO0NBQ0UsRUFBQSxTQUFBO0FBQTBFLENBQTFFLEdBQUEsRUFBMEUsQ0FBQSxDQUExRTtDQUFBLEVBQXVELENBQTdDLENBQUEsRUFBQSxTQUFBLHVCQUFPO1VBQWpCO0NBQUEsRUFFQSxDQUFPLEdBQUQsQ0FBTixHQUFNO0NBRUwsR0FBQSxJQUFELE9BQUE7Q0FDRSxDQUFHLENBQUEsR0FBQSxJQUFIO0NBQUEsQ0FDQSxLQURBLEdBQ0E7Q0FQTyxTQUtUO0NBclBGLE1BZ1BXOztDQWhQWDs7Q0FERjs7Q0EyUGEsRUFBQSxDQUFBLGFBQUE7Q0FDWCxDQUFBLENBQVksQ0FBWCxFQUFELEVBQUE7Q0FBQSxDQUFBLENBRVksQ0FBWCxFQUFELEVBQUE7Q0FGQSxFQUdTLENBQVIsQ0FBRCxDQUFBLEdBQVMsR0FBQTtDQUhULEdBS0MsQ0FBSyxDQUFOO0NBQ0UsQ0FBTyxHQUFQLEdBQUE7V0FDRTtDQUFBLENBQVUsTUFBVixJQUFBO0NBQUEsQ0FDUyxLQUFULEtBQUE7WUFGSztVQUFQO0NBTkYsT0FLQTtDQWpRRixJQTJQYTs7Q0EzUGIsRUF1UWMsTUFBQyxDQUFELEVBQWQ7Q0FHRSxTQUFBLElBQUE7Q0FBQSxFQUFVLENBQVYsRUFBQSxDQUFBO0NBRUMsQ0FBdUQsQ0FBeEQsQ0FBQyxDQUFTLEVBQW9CLEdBQXBCLEdBQW9CO0NBNVFoQyxJQXVRYzs7Q0F2UWQsQ0E4UTZCLENBQW5CLEtBQVYsQ0FBVyxPQUFEO0NBQ1IsU0FBQSxvREFBQTtDQUFBLENBQThDLENBQS9CLENBQXFCLENBQVIsQ0FBNUIsQ0FBc0IsQ0FBUCxJQUFmO0FBRUEsQ0FBQSxVQUFBLCtCQUFBO3NCQUFBO0NBQUEsQ0FBdUIsQ0FBdkIsSUFBTyxDQUFQLENBQUE7Q0FBQSxNQUZBO0NBQUEsQ0FHNkIsQ0FBN0IsQ0FBNkIsRUFBN0IsQ0FBTyxDQUFzQixPQUE3QjtDQUVBLEdBQTRDLENBQWEsQ0FBekQsRUFBNEMsSUFBNUM7Q0FBQSxDQUEyQixFQUEzQixHQUFPLENBQVAsSUFBQTtRQUxBO0NBT0E7Q0FBQTtZQUFBLE1BQUE7bUNBQUE7SUFBeUMsQ0FBYyxLQUFkO0NBQ3ZDOztBQUFBLENBQUE7a0JBQUEsMEJBQUE7NEJBQUE7Q0FBQSxDQUFtQyxFQUFLLEVBQWxDLEVBQU4sQ0FBQSxPQUFBO0NBQUE7O0NBQUE7VUFERjtDQUFBO3VCQVJRO0NBOVFWLElBOFFVOztDQTlRVjs7Q0FGRjtDQUxBOzs7OztBQ0FBO0NBQUEsS0FBQTs7Q0FBQSxDQUFBLENBQVMsR0FBVCxDQUFnQixtQkFBUDs7Q0FBVCxDQUVBLElBQU0sQ0FBTixHQUFBO0dBQTZCLEVBQUEsSUFBQTtDQUUzQixTQUFBLFFBQUE7Q0FBQSxFQUNFLEdBREYsRUFBQTtDQUNFLENBQ0UsTUFERixDQUFBO0NBQ0UsQ0FBTyxFQUFQLENBQUEsS0FBQTtDQUFBLENBQ2MsRUFEZCxNQUNBLEVBQUE7VUFGRjtDQUFBLENBSUUsSUFERixFQUFBO0NBQ0UsQ0FBVSxNQUFWLEVBQUE7Q0FBQSxDQUNXLEVBRFgsS0FDQSxDQUFBO0NBREEsQ0FFTyxHQUFQLEtBQUE7Q0FGQSxDQUlFLEVBREYsTUFBQTtDQUNFLENBQ0UsR0FERixPQUFBO0NBQ0UsQ0FBSyxDQUFMLFdBQUE7Q0FBQSxDQUNLLENBQUwsV0FBQTtjQUZGO0NBQUEsQ0FHUyxHQUhULEVBR0EsS0FBQTtZQVBGO1VBSkY7Q0FERixPQUFBO0NBZ0JBLEdBQUcsRUFBSCxzREFBQTtDQUNFLEVBQVcsQ0FBUixDQUFBLEVBQVEsQ0FBWCxJQUF1QixJQUFaO0NBQ1Q7Q0FDRSxFQUFRLENBQUksQ0FBWixPQUFBO01BREYsTUFBQTtDQUdFLEtBQUEsTUFESTtDQUNKLENBQUEsQ0FBUSxFQUFSLE9BQUE7WUFKSjtVQUFBO0NBQUEsRUFNWSxLQUFaLENBQVksRUFBWjtDQUNlLENBQTBCLEVBQUksR0FBM0MsQ0FBdUMsQ0FBQSxHQUEzQixJQUFaLENBQUE7Q0FERixDQUVFLEVBRkYsS0FBWTtRQXZCZDtDQTJCUSxDQUFpQixHQUF6QixDQUFBLENBQU8sQ0FBUCxLQUFBO0NBN0J5QixJQUFFO0NBRjdCLEdBRUE7Q0FGQTs7Ozs7QUNBQTtDQUFBLEtBQUE7O0NBQUEsQ0FBQSxDQUFTLEdBQVQsQ0FBZ0IsZ0JBQVA7O0NBQVQsQ0FJQSxDQUF3QixHQUFsQixDQUFOLEVBQXdCO0NBQ3RCLE9BQUEsU0FBQTtDQUFBLEVBQ0UsQ0FERixDQUFBO0NBQ0UsQ0FDRSxFQURGLEVBQUE7Q0FDRSxDQUFPLEdBQVAsR0FBQSxFQUFBO0NBQUEsQ0FDTSxFQUFOLElBQUEsR0FEQTtRQURGO0NBQUEsQ0FJRSxJQURGLElBQUE7Q0FDRSxDQUFPLEdBQVAsR0FBQTtDQUFBLENBQ00sRUFBTixJQUFBLFNBREE7UUFKRjtDQUFBLENBT0UsSUFERjtDQUNFLENBQU8sR0FBUCxHQUFBLElBQUE7Q0FBQSxDQUNNLEVBQU4sSUFBQSxLQURBO1FBUEY7Q0FBQSxDQVVFLENBREYsR0FBQTtDQUNFLENBQU8sR0FBUCxHQUFBLENBQUE7Q0FBQSxDQUNNLEVBQU4sSUFBQSxFQURBO1FBVkY7Q0FBQSxDQWFFLEVBREYsRUFBQTtDQUNFLENBQU8sR0FBUCxHQUFBO0NBQUEsQ0FDTSxFQUFOLElBQUEsSUFEQTtRQWJGO0NBREYsS0FBQTtBQWlCQSxDQUFBLFFBQUEsSUFBQTswQkFBQTtDQUNFLEVBQVksQ0FBUixFQUFKO0NBREYsSUFqQkE7V0FvQkE7Q0FBQSxDQUFPLEdBQVAsQ0FBQTtDQUFBLENBQ2UsQ0FBQSxHQUFmLEVBQWUsQ0FBQyxJQUFoQjtDQUNFLEdBQUEsUUFBQTtBQUFBLENBQUEsWUFBQTs4QkFBQTtDQUNFLEdBQUcsQ0FBVSxHQUFWLEVBQUg7Q0FBa0MsR0FBQSxlQUFPO1lBRDNDO0NBQUEsUUFBQTtDQUdBLEdBQUEsQ0FBWSxVQUFMO0NBTFQsTUFDZTtDQXRCTztDQUF4QixFQUF3QjtDQUp4Qjs7Ozs7QUNBQTtDQUFBLEtBQUE7O0NBQUEsQ0FBQSxDQUFTLEdBQVQsQ0FBZ0IsY0FBUDs7Q0FBVCxDQUVBLENBQUEsRUFBQSxDQUFNLEVBQU47Q0FGQTs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3AvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbm1qQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25wQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6OUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgXCIuLi8uLi92ZW5kb3IvYW5ndWxhci9hbmd1bGFyXCJcclxucmVxdWlyZSBcIi4uLy4uL3ZlbmRvci9hbmd1bGFyL2FuZ3VsYXItY29va2llc1wiXHJcbnJlcXVpcmUgXCIuLi8uLi92ZW5kb3IvYW5ndWxhci11aS91aS1ib290c3RyYXBcIlxyXG5yZXF1aXJlIFwiLi4vLi4vdmVuZG9yL2FuZ3VsYXItdWkvdWktcm91dGVyXCJcclxuXHJcblxyXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvc2Vzc2lvbi5jb2ZmZWVcIlxyXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvbm90aWZpZXIuY29mZmVlXCJcclxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL2Rpc2FibGVyLmNvZmZlZVwiXHJcbnJlcXVpcmUgXCIuLi9zZXJ2aWNlcy9iYXNlUGx1bmsuY29mZmVlXCJcclxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL2xheW91dC5jb2ZmZWVcIlxyXG5cclxucmVxdWlyZSBcIi4uL2RpcmVjdGl2ZXMvYm9yZGVyTGF5b3V0LmNvZmZlZVwiXHJcbnJlcXVpcmUgXCIuLi9kaXJlY3RpdmVzL2NvZGVFZGl0b3IuY29mZmVlXCJcclxucmVxdWlyZSBcIi4uL2RpcmVjdGl2ZXMvcHJldmlld2VyLmNvZmZlZVwiXHJcbnJlcXVpcmUgXCIuLi9kaXJlY3RpdmVzL3Rvb2xiYXIuY29mZmVlXCJcclxuXHJcblxyXG5tb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuYXBwLmVkaXRvclwiLCBbXHJcbiAgXCJ1aS5ib290c3RyYXBcIlxyXG4gIFwidWkucm91dGVyXCJcclxuICBcclxuICBcImZhLmJvcmRlckxheW91dFwiXHJcbiAgXHJcbiAgXCJwbHVua2VyLnNlcnZpY2Uuc2Vzc2lvblwiXHJcbiAgXCJwbHVua2VyLnNlcnZpY2Uubm90aWZpZXJcIlxyXG4gIFwicGx1bmtlci5zZXJ2aWNlLmRpc2FibGVyXCJcclxuICBcInBsdW5rZXIuc2VydmljZS5iYXNlUGx1bmtcIlxyXG4gIFwicGx1bmtlci5zZXJ2aWNlLmxheW91dFwiXHJcbiAgXHJcbiAgXCJwbHVua2VyLmRpcmVjdGl2ZS5jb2RlRWRpdG9yXCJcclxuICBcInBsdW5rZXIuZGlyZWN0aXZlLnByZXZpZXdlclwiXHJcbiAgXCJwbHVua2VyLmRpcmVjdGl2ZS50b29sYmFyXCJcclxuXVxyXG5cclxubW9kdWxlLmNvbmZpZyBbXCIkc3RhdGVQcm92aWRlclwiLCBcIiR1cmxSb3V0ZXJQcm92aWRlclwiLCBcIiRsb2NhdGlvblByb3ZpZGVyXCIsICgkc3RhdGVQcm92aWRlciwgJHVybFJvdXRlclByb3ZpZGVyLCAkbG9jYXRpb25Qcm92aWRlcikgLT5cclxuICAkbG9jYXRpb25Qcm92aWRlci5odG1sNU1vZGUgdHJ1ZVxyXG4gIFxyXG4gICR1cmxSb3V0ZXJQcm92aWRlci53aGVuIFwiL2VkaXRcIiwgXCIvZWRpdC9cIlxyXG4gIFxyXG4gICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoXCIvZWRpdC9cIilcclxuXVxyXG5cclxubW9kdWxlLmNvbmZpZyBbXCIkc3RhdGVQcm92aWRlclwiLCBcIiR1cmxSb3V0ZXJQcm92aWRlclwiLCAoJHN0YXRlUHJvdmlkZXIsICR1cmxSb3V0ZXJQcm92aWRlcikgLT5cclxuICBcclxuICAkc3RhdGVQcm92aWRlci5zdGF0ZSBcImVkaXRvclwiLFxyXG4gICAgdXJsOiBcIi9lZGl0XCJcclxuICAgIHRlbXBsYXRlOiBcIlwiXCJcclxuICAgICAgPGRpdiB1aS12aWV3PVwiYm9keVwiPjwvZGl2PlxyXG4gICAgXCJcIlwiXHJcbiAgICBjb250cm9sbGVyOiBbXCIkc3RhdGVcIiwgXCIkc2NvcGVcIiwgKCRzdGF0ZSwgJHNjb3BlKSAtPlxyXG4gICAgICAkc2NvcGUuc2hvd1RlbXBsYXRlUGFuZSA9IHRydWVcclxuICAgICAgJHNjb3BlLnNob3dQcmV2aWV3UGFuZSA9IGZhbHNlXHJcbiAgICAgICRzdGF0ZS5nbyBcImVkaXRvci5ibGFua1wiIGlmICRzdGF0ZS5pcyhcImVkaXRvclwiKVxyXG4gICAgXVxyXG4gICAgXHJcbiAgJHN0YXRlUHJvdmlkZXIuc3RhdGUgXCJlZGl0b3IuYmxhbmtcIixcclxuICAgIHVybDogXCIvXCJcclxuICAgIHZpZXdzOlxyXG4gICAgICBcImJvZHlcIjogXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6IFwiL3BhcnRpYWxzL2VkaXRvci5odG1sXCJcclxuICAgICAgICBjb250cm9sbGVyOiBbXCIkc2NvcGVcIiwgXCJzZXNzaW9uXCIsIFwiYmFzZVBsdW5rXCIsIFwibm90aWZpZXJcIiwgKCRzY29wZSwgc2Vzc2lvbiwgYmFzZVBsdW5rLCBub3RpZmllcikgLT5cclxuICAgICAgICAgIGNsaWVudCA9IHNlc3Npb24uY3JlYXRlQ2xpZW50KFwiZWRpdC5ibGFua1wiKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjbGllbnQucmVzZXQgYmFzZVBsdW5rXHJcbiAgICAgICAgICBjbGllbnQuY3Vyc29yU2V0SW5kZXggKDAgPD0gaWR4ID0gY2xpZW50LmdldEZpbGVJbmRleChcImluZGV4Lmh0bWxcIikpIGFuZCBpZHggb3IgMFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBub3RpZmllci5zdWNjZXNzIFwiUGx1bmsgcmVzZXRcIlxyXG4gICAgICAgIF1cclxuXHJcblxyXG4gICAgICAgIFxyXG4gICRzdGF0ZVByb3ZpZGVyLnN0YXRlIFwiZWRpdG9yLmdpc3RcIixcclxuICAgIHVybDogXCIvZ2lzdDp7Z2lzdElkOlswLTldK3xbMC05YS16XXsyMH19XCJcclxuICAgIHZpZXdzOlxyXG4gICAgICBcImJvZHlcIjogXHJcbiAgICAgICAgdGVtcGxhdGVVcmw6IFwiL3BhcnRpYWxzL2VkaXRvci5odG1sXCJcclxuICAgICAgICBjb250cm9sbGVyOiBbXCIkc3RhdGVQYXJhbXNcIiwgXCIkcVwiLCBcIiRodHRwXCIsIFwiJHNjb3BlXCIsIFwiJHN0YXRlXCIsIFwiJHRpbWVvdXRcIiwgXCJzZXNzaW9uXCIsIFwibm90aWZpZXJcIiwgXCJkaXNhYmxlclwiLCAoJHN0YXRlUGFyYW1zLCAkcSwgJGh0dHAsICRzY29wZSwgJHN0YXRlLCAkdGltZW91dCwgc2Vzc2lvbiwgbm90aWZpZXIsIGRpc2FibGVyKSAtPlxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjbGllbnQgPSBzZXNzaW9uLmNyZWF0ZUNsaWVudChcImVkaXQuZ2lzdFwiKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBkaXNhYmxlci5lbnF1ZXVlIFwiZWRpdG9yXCIsIHJlcXVlc3QgPSAkaHR0cC5qc29ucChcImh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vZ2lzdHMvI3skc3RhdGVQYXJhbXMuZ2lzdElkfT9jYWxsYmFjaz1KU09OX0NBTExCQUNLXCIpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHBhcnNlciA9IHJlcXVlc3QudGhlbiAocmVzcG9uc2UpIC0+XHJcbiAgICAgICAgICAgIGlmIHJlc3BvbnNlLmRhdGEubWV0YS5zdGF0dXMgPj0gNDAwIHRoZW4gcmV0dXJuICRxLnJlamVjdChcIkdpc3Qgbm90IGZvdW5kXCIpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBnaXN0ID0gcmVzcG9uc2UuZGF0YS5kYXRhXHJcbiAgICAgICAgICAgIGpzb24gPSBcclxuICAgICAgICAgICAgICAncHJpdmF0ZSc6IHRydWVcclxuICAgICAgICAgICAgICBmaWxlczogW11cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIG1hbmlmZXN0ID0gZ2lzdC5maWxlc1tcInBsdW5rZXIuanNvblwiXVxyXG4gICAgICAgICAgICAgIHRyeVxyXG4gICAgICAgICAgICAgICAgYW5ndWxhci5leHRlbmQganNvbiwgYW5ndWxhci5mcm9tSnNvbihtYW5pZmVzdC5jb250ZW50KVxyXG4gICAgICAgICAgICAgIGNhdGNoIGVcclxuICAgICAgICAgICAgICAgIG5vdGlmaWVyLndhcm4gXCJVbmFibGUgdG8gcGFyc2UgdGhlIHBsdW5rZXIuanNvbiBmaWxlXCJcclxuICAgIFxyXG4gICAgICAgICAgICBqc29uLmRlc2NyaXB0aW9uID0gZ2lzdC5kZXNjcmlwdGlvbiBvciBcImh0dHBzOi8vZ2lzdC5naXRodWIuY29tLyN7JHN0YXRlUGFyYW1zLmdpc3RJZH1cIlxyXG4gIFxyXG4gICAgICAgICAgICBmb3IgZmlsZW5hbWUsIGZpbGUgb2YgZ2lzdC5maWxlc1xyXG4gICAgICAgICAgICAgIHVubGVzcyBmaWxlbmFtZSA9PSBcInBsdW5rZXIuanNvblwiXHJcbiAgICAgICAgICAgICAgICBqc29uLmZpbGVzLnB1c2hcclxuICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lXHJcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZpbGUuY29udGVudCBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGpzb25cclxuICAgICAgICAgICwgKGVycm9yKSAtPlxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyBcIltFUlJdIFB1bGxpbmcgZ2lzdFwiLCBlcnJvclxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgJHEucmVqZWN0KFwiVW5hYmxlIHRvIGxvYWQgZ2lzdFwiKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgIHBhcnNlci50aGVuIChqc29uKSAtPlxyXG4gICAgICAgICAgICAkc2NvcGUuc2hvd1RlbXBsYXRlUGFuZSA9IGZhbHNlXHJcbiAgICAgICAgICAgIGNsaWVudC5yZXNldCBqc29uXHJcbiAgICAgICAgICAgIGNsaWVudC5jdXJzb3JTZXRJbmRleCAoMCA8PSBpZHggPSBjbGllbnQuZ2V0RmlsZUluZGV4KFwiaW5kZXguaHRtbFwiKSkgYW5kIGlkeCBvciAwXHJcbiAgICAgICAgICAgIG5vdGlmaWVyLnN1Y2Nlc3MgXCJJbXBvcnRlZCBwbHVua1wiXHJcbiAgICAgICAgICAsIChlcnJvclRleHQpIC0+XHJcbiAgICAgICAgICAgICRzdGF0ZS5nbyBcImVkaXRvci5ibGFua1wiXHJcbiAgICAgICAgICAgIG5vdGlmaWVyLmVycm9yIGVycm9yVGV4dFxyXG4gICAgICAgIF1cclxuXVxyXG5cclxubW9kdWxlLmNvbnRyb2xsZXIgXCJTaWRlYmFyQ29udHJvbGxlclwiLCBbXCIkc2NvcGVcIiwgXCJzZXNzaW9uXCIsICgkc2NvcGUsIHNlc3Npb24pIC0+XHJcbiAgJHNjb3BlLnNlc3Npb24gPSBjbGllbnQgPSBzZXNzaW9uLmNyZWF0ZUNsaWVudChcIlNpZGViYXJDb250cm9sbGVyXCIpXHJcbiAgXHJcbiAgJHNjb3BlLmFkZEZpbGUgPSAtPlxyXG4gICAgaWYgZmlsZW5hbWUgPSBwcm9tcHQoXCJGaWxlbmFtZT9cIilcclxuICAgICAgY2xpZW50LmZpbGVDcmVhdGUoZmlsZW5hbWUpXHJcbiAgICAgIGNsaWVudC5jdXJzb3JTZXRGaWxlKGZpbGVuYW1lKVxyXG4gIFxyXG4gICRzY29wZS5yZW5hbWVGaWxlID0gKG9sZF9maWxlbmFtZSkgLT5cclxuICAgIGlmIGNsaWVudC5oYXNGaWxlKG9sZF9maWxlbmFtZSkgYW5kIGZpbGVuYW1lID0gcHJvbXB0KFwiRmlsZW5hbWU/XCIsIG9sZF9maWxlbmFtZSlcclxuICAgICAgY2xpZW50LmZpbGVSZW5hbWUob2xkX2ZpbGVuYW1lLCBmaWxlbmFtZSkgICAgXHJcbiAgXHJcbiAgJHNjb3BlLnJlbW92ZUZpbGUgPSAoZmlsZW5hbWUpIC0+XHJcbiAgICBpZiBjbGllbnQuaGFzRmlsZShmaWxlbmFtZSkgYW5kIGNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlICN7ZmlsZW5hbWV9P1wiKVxyXG4gICAgICBjbGllbnQuZmlsZVJlbW92ZShmaWxlbmFtZSlcclxuICBcclxuICAkc2NvcGUubW92ZVRvID0gKGZpbGVuYW1lKSAtPlxyXG4gICAgY2xpZW50LmN1cnNvclNldEZpbGUoZmlsZW5hbWUpXHJcbl1cclxuXHJcblxyXG5tb2R1bGUuY29udHJvbGxlciBcIkxheW91dENvbnRyb2xsZXJcIiwgW1wiJHNjb3BlXCIsIFwibGF5b3V0XCIsICgkc2NvcGUsIGxheW91dCkgLT5cclxuICAkc2NvcGUubGF5b3V0ID0gbGF5b3V0XHJcbiAgJHNjb3BlLnRvZ2dsZVByZXZpZXdQYW5lID0gLT5cclxuICAgICRzY29wZS5zaG93UHJldmlld1BhbmUgPSAhJHNjb3BlLnNob3dQcmV2aWV3UGFuZVxyXG5dIiwibW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJmYS5ib3JkZXJMYXlvdXRcIiwgW1xuXVxuXG50aHJvdHRsZSA9IChkZWxheSwgZm4pIC0+XG4gIHRocm90dGxlZCA9IGZhbHNlXG4gIC0+XG4gICAgcmV0dXJuIGlmIHRocm90dGxlZFxuICAgIFxuICAgIHRocm90dGxlZCA9IHRydWVcbiAgICBzZXRUaW1lb3V0IC0+XG4gICAgICB0aHJvdHRsZWQgPSBmYWxzZVxuICAgICwgZGVsYXlcbiAgICBcbiAgICBmbi5jYWxsKEAsIGFyZ3VtZW50cy4uLilcblxuY2xhc3MgUmVnaW9uXG4gIGNvbnN0cnVjdG9yOiAoQHdpZHRoID0gMCwgQGhlaWdodCA9IDApIC0+XG4gICAgQHRvcCA9IDBcbiAgICBAcmlnaHQgPSAwXG4gICAgQGJvdHRvbSA9IDBcbiAgICBAbGVmdCA9IDBcbiAgICBcbiAgY2FsY3VsYXRlU2l6ZTogKG9yaWVudGF0aW9uLCB0YXJnZXQgPSAwKSAtPlxuICAgIHRvdGFsID0gQGdldFNpemUob3JpZW50YXRpb24pXG4gICAgYXZhaWxhYmxlID0gQGdldEF2YWlsYWJsZVNpemUob3JpZW50YXRpb24pXG4gICAgXG4gICAgaWYgYW5ndWxhci5pc051bWJlcih0YXJnZXQpXG4gICAgICBpZiB0YXJnZXQgPj0gMSB0aGVuIHJldHVybiBNYXRoLnJvdW5kKHRhcmdldClcbiAgICAgIGlmIHRhcmdldCA+PSAwIHRoZW4gcmV0dXJuIE1hdGgucm91bmQodGFyZ2V0ICogdG90YWwpXG4gICAgICBcbiAgICAgIHJldHVybiAwXG4gICAgXG4gICAgIyBLaWxsIHdoaXRlc3BhY2VcbiAgICB0YXJnZXQgPSB0YXJnZXQucmVwbGFjZSAvXFxzKy9tZywgXCJcIlxuICAgIFxuICAgICMgQWxsb3cgZm9yIGNvbXBsZXggc2l6ZXMsIGUuZy46IDUwJSAtIDRweFxuICAgIGlmICh0ZXJtcyA9IHRhcmdldC5zcGxpdChcIi1cIikpLmxlbmd0aCA+IDEgdGhlbiByZXR1cm4gQGNhbGN1bGF0ZVNpemUob3JpZW50YXRpb24sIHRlcm1zLnNoaWZ0KCkpIC0gQGNhbGN1bGF0ZVNpemUob3JpZW50YXRpb24sIHRlcm1zLmpvaW4oXCIrXCIpKVxuICAgIGlmICh0ZXJtcyA9IHRhcmdldC5zcGxpdChcIitcIikpLmxlbmd0aCA+IDEgdGhlbiByZXR1cm4gQGNhbGN1bGF0ZVNpemUob3JpZW50YXRpb24sIHRlcm1zLnNoaWZ0KCkpICsgQGNhbGN1bGF0ZVNpemUob3JpZW50YXRpb24sIHRlcm1zLmpvaW4oXCIrXCIpKVxuICAgICAgXG4gICAgaWYgbWF0Y2hlcyA9IHRhcmdldC5tYXRjaCAvXihcXGQrKXB4JC8gdGhlbiByZXR1cm4gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApXG4gICAgaWYgbWF0Y2hlcyA9IHRhcmdldC5tYXRjaCAvXihcXGQrKD86XFwuXFxkKyk/KSYkLyB0aGVuIHJldHVybiBNYXRoLnJvdW5kKGF2YWlsYWJsZSAqIHBhcnNlRmxvYXQobWF0Y2hlc1sxXSkgLyAxMDApXG4gICAgaWYgbWF0Y2hlcyA9IHRhcmdldC5tYXRjaCAvXihcXGQrKD86XFwuXFxkKyk/KSUkLyB0aGVuIHJldHVybiBNYXRoLnJvdW5kKHRvdGFsICogcGFyc2VGbG9hdChtYXRjaGVzWzFdKSAvIDEwMClcbiAgICBcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzaXplOiAje3RhcmdldH1cIilcbiAgXG4gIGNvbnN1bWU6IChhbmNob3IsIHNpemUgPSAwKSAtPlxuICAgIHN3aXRjaCBhbmNob3JcbiAgICAgIHdoZW4gXCJub3J0aFwiXG4gICAgICAgIHN0eWxlID0geyB0b3A6IFwiI3tAdG9wfXB4XCIsIHJpZ2h0OiBcIiN7QHJpZ2h0fXB4XCIsIGxlZnQ6IFwiI3tAbGVmdH1weFwiLCBoZWlnaHQ6IFwiI3tzaXplfXB4XCIgfVxuICAgICAgICBAdG9wICs9IHNpemVcbiAgICAgIHdoZW4gXCJlYXN0XCJcbiAgICAgICAgc3R5bGUgPSB7IHRvcDogXCIje0B0b3B9cHhcIiwgcmlnaHQ6IFwiI3tAcmlnaHR9cHhcIiwgYm90dG9tOiBcIiN7QGJvdHRvbX1weFwiLCB3aWR0aDogXCIje3NpemV9cHhcIiB9XG4gICAgICAgIEByaWdodCArPSBzaXplXG4gICAgICB3aGVuIFwic291dGhcIlxuICAgICAgICBzdHlsZSA9IHsgcmlnaHQ6IFwiI3tAcmlnaHR9cHhcIiwgYm90dG9tOiBcIiN7QGJvdHRvbX1weFwiLCBsZWZ0OiBcIiN7QGxlZnR9cHhcIiwgaGVpZ2h0OiBcIiN7c2l6ZX1weFwiIH1cbiAgICAgICAgQGJvdHRvbSArPSBzaXplXG4gICAgICB3aGVuIFwid2VzdFwiXG4gICAgICAgIHN0eWxlID0geyB0b3A6IFwiI3tAdG9wfXB4XCIsIGJvdHRvbTogXCIje0Bib3R0b219cHhcIiwgbGVmdDogXCIje0BsZWZ0fXB4XCIsIHdpZHRoOiBcIiN7c2l6ZX1weFwiIH1cbiAgICAgICAgQGxlZnQgKz0gc2l6ZVxuICAgICAgXG4gICAgc3R5bGVcbiAgICBcbiAgZ2V0SW5uZXJSZWdpb246IC0+XG4gICAgbmV3IFJlZ2lvbiBAd2lkdGggLSBAcmlnaHQgLSBAbGVmdCwgQGhlaWdodCAtIEB0b3AgLSBAYm90dG9tXG4gIFxuICBnZXRTaXplOiAob3JpZW50YXRpb24pIC0+XG4gICAgc3dpdGNoIG9yaWVudGF0aW9uXG4gICAgICB3aGVuIFwidmVydGljYWxcIiB0aGVuIEBoZWlnaHRcbiAgICAgIHdoZW4gXCJob3Jpem9udGFsXCIgdGhlbiBAd2lkdGhcbiAgXG4gIGdldEF2YWlsYWJsZVNpemU6IChvcmllbnRhdGlvbikgLT5cbiAgICBzd2l0Y2ggb3JpZW50YXRpb25cbiAgICAgIHdoZW4gXCJ2ZXJ0aWNhbFwiIHRoZW4gQGhlaWdodCAtIEB0b3AgLSBAYm90dG9tXG4gICAgICB3aGVuIFwiaG9yaXpvbnRhbFwiIHRoZW4gQHdpZHRoIC0gQHJpZ2h0IC0gQGxlZnRcbiAgXG4gIFxuXG5tb2R1bGUuZGlyZWN0aXZlIFwicGFuZVwiLCBbIC0+XG4gIHJlc3RyaWN0OiBcIkVcIlxuICByZXBsYWNlOiB0cnVlXG4gIHJlcXVpcmU6IFtcInBhbmVcIiwgXCJeYm9yZGVyTGF5b3V0XCJdXG4gIHRyYW5zY2x1ZGU6IHRydWVcbiAgc2NvcGU6IHRydWVcbiAgdGVtcGxhdGU6IFwiXCJcIlxuICAgIDxkaXYgY2xhc3M9XCJib3JkZXItbGF5b3V0LXBhbmVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJib3JkZXItbGF5b3V0LXBhbmUtb3ZlcmxheVwiIG5nLXN0eWxlPVwic3R5bGVDb250ZW50XCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiYm9yZGVyLWxheW91dC1wYW5lLWhhbmRsZVwiIGxheW91dC1oYW5kbGUgbmctc3R5bGU9XCJzdHlsZUhhbmRsZVwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImJvcmRlci1sYXlvdXQtcGFuZS1zY3JvbGxlclwiIG5nLXN0eWxlPVwic3R5bGVDb250ZW50XCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgXCJcIlwiXG4gIGNvbnRyb2xsZXI6IFtcIiRzY29wZVwiLCBcIiRlbGVtZW50XCIsIFwiJGF0dHJzXCIsICgkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMpIC0+XG4gICAgcGFuZSA9IEBcbiAgICBcbiAgICBbJG92ZXJsYXksICRoYW5kbGUsICRzY3JvbGxlcl0gPSAkZWxlbWVudC5jaGlsZHJlbigpXG4gICAgXG4gICAgJGF0dHJzLiRvYnNlcnZlIFwiYW5jaG9yXCIsIChhbmNob3IpIC0+XG4gICAgICBwcmV2ID0gcGFuZS5hbmNob3JcbiAgICAgIFxuICAgICAgcGFuZS5hbmNob3IgPSBhbmNob3JcbiAgICAgIHBhbmUub3JpZW50YXRpb24gPSBwYW5lLmdldE9yaWVudGF0aW9uKGFuY2hvcilcbiAgICAgIFxuICAgICAgaWYgcHJldlxuICAgICAgICBwYW5lLmxheW91dC5yZWZsb3coKVxuICAgICAgXG4gICAgJGF0dHJzLiRvYnNlcnZlIFwic2l6ZVwiLCAoc2l6ZSwgcHJldikgLT5cbiAgICAgIHBhbmUudGFyZ2V0ID0gc2l6ZVxuICAgICAgXG4gICAgICBwYW5lLmxheW91dC5yZWZsb3coKVxuICAgICAgXG4gICAgJGF0dHJzLiRvYnNlcnZlIFwib3BlblwiLCAob3BlbiA9IHRydWUsIHdhc09wZW4pIC0+XG4gICAgICBvcGVuID0gZmFsc2UgaWYgb3BlbiA9PSBcImZhbHNlXCJcbiAgICAgIGlmIG9wZW4gdGhlbiAkZWxlbWVudC5yZW1vdmVDbGFzcyhcImNsb3NlZFwiKVxuICAgICAgZWxzZSAkZWxlbWVudC5hZGRDbGFzcyhcImNsb3NlZFwiKVxuICAgICAgXG4gICAgICBwYW5lLnRvZ2dsZShvcGVuKVxuICAgIFxuICAgICRhdHRycy4kb2JzZXJ2ZSBcIm9yZGVyXCIsIChvcmRlciA9IDAsIHByZXYpIC0+XG4gICAgICBwYW5lLm9yZGVyID0gcGFyc2VJbnQob3JkZXIgb3IgMCwgMTApXG4gICAgICBcbiAgICAgIHBhbmUubGF5b3V0LnJlZmxvdygpXG4gICAgXG4gICAgQGNoaWxkcmVuID0gW11cbiAgICBAb3BlblNpemUgPSAwXG4gICAgXG4gICAgQGF0dGFjaENoaWxkID0gKGNoaWxkKSAtPiBAY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgICBcbiAgICBAZ2V0T3JpZW50YXRpb24gPSAoYW5jaG9yID0gJGF0dHJzLmFuY2hvcikgLT5cbiAgICAgIHN3aXRjaCBhbmNob3JcbiAgICAgICAgd2hlbiBcIm5vcnRoXCIsIFwic291dGhcIiB0aGVuIFwidmVydGljYWxcIlxuICAgICAgICB3aGVuIFwiZWFzdFwiLCBcIndlc3RcIiB0aGVuIFwiaG9yaXpvbnRhbFwiXG4gICAgXG4gICAgQGdldENvbnRlbnRTdHlsZSA9IChhbmNob3IsIGhhbmRsZVNpemUpIC0+XG4gICAgICBzdHlsZSA9XG4gICAgICAgIHRvcDogMFxuICAgICAgICByaWdodDogMFxuICAgICAgICBib3R0b206IDBcbiAgICAgICAgbGVmdDogMFxuICAgICAgICBcbiAgICAgIHN3aXRjaCBhbmNob3JcbiAgICAgICAgd2hlbiBcIm5vcnRoXCIgdGhlbiBzdHlsZS5ib3R0b20gPSBcIiN7aGFuZGxlU2l6ZX1weFwiXG4gICAgICAgIHdoZW4gXCJlYXN0XCIgdGhlbiBzdHlsZS5sZWZ0ID0gXCIje2hhbmRsZVNpemV9cHhcIlxuICAgICAgICB3aGVuIFwic291dGhcIiB0aGVuIHN0eWxlLnRvcCA9IFwiI3toYW5kbGVTaXplfXB4XCJcbiAgICAgICAgd2hlbiBcIndlc3RcIiB0aGVuIHN0eWxlLnJpZ2h0ID0gXCIje2hhbmRsZVNpemV9cHhcIlxuICAgICAgXG4gICAgICBzdHlsZVxuICAgICAgICBcbiAgICBAZ2V0SGFuZGxlU3R5bGUgPSAoYW5jaG9yLCByZWdpb24sIGhhbmRsZVNpemUpIC0+XG4gICAgICBcbiAgICAgIHN3aXRjaCBhbmNob3JcbiAgICAgICAgd2hlbiBcIm5vcnRoXCJcbiAgICAgICAgICBoZWlnaHQ6IFwiI3tyZWdpb24uY2FsY3VsYXRlU2l6ZSgndmVydGljYWwnLCBoYW5kbGVTaXplKX1weFwiXG4gICAgICAgICAgcmlnaHQ6IDBcbiAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIHdoZW4gXCJzb3V0aFwiIFxuICAgICAgICAgIGhlaWdodDogXCIje3JlZ2lvbi5jYWxjdWxhdGVTaXplKCd2ZXJ0aWNhbCcsIGhhbmRsZVNpemUpfXB4XCJcbiAgICAgICAgICByaWdodDogMFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICB0b3A6IDBcbiAgICAgICAgd2hlbiBcImVhc3RcIlxuICAgICAgICAgIHdpZHRoOiBcIiN7cmVnaW9uLmNhbGN1bGF0ZVNpemUoJ2hvcml6b250YWwnLCBoYW5kbGVTaXplKX1weFwiXG4gICAgICAgICAgdG9wOiAwXG4gICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB3aGVuIFwid2VzdFwiIFxuICAgICAgICAgIHdpZHRoOiBcIiN7cmVnaW9uLmNhbGN1bGF0ZVNpemUoJ2hvcml6b250YWwnLCBoYW5kbGVTaXplKX1weFwiXG4gICAgICAgICAgdG9wOiAwXG4gICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgICAgcmlnaHQ6IDBcbiAgICBcbiAgICBAb25IYW5kbGVEb3duID0gLT5cbiAgICAgICRlbGVtZW50LmFkZENsYXNzKFwiYWN0aXZlXCIpXG4gICAgICBAbGF5b3V0Lm9uSGFuZGxlRG93bigpXG4gICAgQG9uSGFuZGxlVXAgPSAtPlxuICAgICAgJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIilcbiAgICAgIEBsYXlvdXQub25IYW5kbGVVcCgpXG4gICAgXG4gICAgQHRvZ2dsZSA9IChvcGVuID0gIXBhbmUub3BlbikgLT5cbiAgICAgIHBhbmUub3BlbiA9IG9wZW5cbiAgICAgIFxuICAgICAgaWYgIW9wZW4gdGhlbiBAb3BlblNpemUgPSBAc2l6ZVxuICAgICAgZWxzZSBAc2l6ZSA9IEBvcGVuU2l6ZVxuICAgICAgXG4gICAgICBpZiBvcGVuIHRoZW4gJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJjbG9zZWRcIilcbiAgICAgIGVsc2UgJGVsZW1lbnQuYWRkQ2xhc3MoXCJjbG9zZWRcIilcbiAgICAgIFxuICAgICAgQGxheW91dC5yZWZsb3coKVxuICAgIFxuICAgIEByZWZsb3cgPSAocmVnaW9uLCB0YXJnZXQgPSBwYW5lLnRhcmdldCkgLT5cbiAgICAgIGFuY2hvciA9IHBhbmUuYW5jaG9yXG4gICAgICBcbiAgICAgIGlmIGFuY2hvciBpcyBcImNlbnRlclwiXG4gICAgICAgICRlbGVtZW50LmNzc1xuICAgICAgICAgIHRvcDogXCIje3JlZ2lvbi50b3B9cHhcIlxuICAgICAgICAgIHJpZ2h0OiBcIiN7cmVnaW9uLnJpZ2h0fXB4XCJcbiAgICAgICAgICBib3R0b206IFwiI3tyZWdpb24uYm90dG9tfXB4XCJcbiAgICAgICAgICBsZWZ0OiBcIiN7cmVnaW9uLmxlZnR9cHhcIlxuICAgICAgZWxzZSBpZiBhbmNob3IgaW4gW1wibm9ydGhcIiwgXCJlYXN0XCIsIFwic291dGhcIiwgXCJ3ZXN0XCJdXG4gICAgICAgIG9yaWVudGF0aW9uID0gQGdldE9yaWVudGF0aW9uKGFuY2hvcilcbiAgICAgICAgaGFuZGxlU2l6ZSA9IHJlZ2lvbi5jYWxjdWxhdGVTaXplKG9yaWVudGF0aW9uLCAkYXR0cnMuaGFuZGxlIHx8IDApXG5cbiAgICAgICAgaWYgIXBhbmUub3BlblxuICAgICAgICAgIHNpemUgPSBoYW5kbGVTaXplXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzaXplID0gcmVnaW9uLmNhbGN1bGF0ZVNpemUob3JpZW50YXRpb24sIHRhcmdldClcbiAgICAgICAgICBtYXggPSAkYXR0cnMubWF4IHx8IE51bWJlci5NQVhfVkFMVUVcbiAgICAgICAgICBtaW4gPSAkYXR0cnMubWluIHx8IDBcbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgICBzaXplID0gTWF0aC5taW4oc2l6ZSwgcmVnaW9uLmNhbGN1bGF0ZVNpemUob3JpZW50YXRpb24sIG1heCkpXG4gICAgICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIHJlZ2lvbi5jYWxjdWxhdGVTaXplKG9yaWVudGF0aW9uLCBtaW4pKVxuICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCByZWdpb24uZ2V0QXZhaWxhYmxlU2l6ZShvcmllbnRhdGlvbikpXG4gICAgICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIGhhbmRsZVNpemUgKyAyKSAjIFdoeSBkb2VzIDEuNSB3b3JrIT9cbiAgICAgICAgXG4gICAgICAgIEBzaXplID0gc2l6ZVxuICAgICAgICBcbiAgICAgICAgc3R5bGVDb250YWluZXIgPSByZWdpb24uY29uc3VtZShhbmNob3IsIHNpemUpXG4gICAgICAgIHN0eWxlQ29udGVudCA9IEBnZXRDb250ZW50U3R5bGUoYW5jaG9yLCBoYW5kbGVTaXplKVxuICAgICAgICBzdHlsZUhhbmRsZSA9IEBnZXRIYW5kbGVTdHlsZShhbmNob3IsIHJlZ2lvbiwgaGFuZGxlU2l6ZSlcbiAgICAgICAgXG4gICAgICAgICRlbGVtZW50LmF0dHIoXCJzdHlsZVwiLCBcIlwiKS5jc3Moc3R5bGVDb250YWluZXIpXG4gICAgICAgIFxuICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJG92ZXJsYXkpLmF0dHIoXCJzdHlsZVwiLCBcIlwiKS5jc3Moc3R5bGVDb250ZW50KVxuICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJHNjcm9sbGVyKS5hdHRyKFwic3R5bGVcIiwgXCJcIikuY3NzKHN0eWxlQ29udGVudClcbiAgICAgICAgYW5ndWxhci5lbGVtZW50KCRoYW5kbGUpLmF0dHIoXCJzdHlsZVwiLCBcIlwiKS5jc3Moc3R5bGVIYW5kbGUpXG4gICAgICAgIFxuICAgICAgaWYgQGNoaWxkcmVuLmxlbmd0aFxuICAgICAgICBpbm5lciA9IHJlZ2lvbi5nZXRJbm5lclJlZ2lvbigpXG4gICAgICAgIGlubmVyID0gY2hpbGQucmVmbG93KGlubmVyKSBmb3IgY2hpbGQgaW4gQGNoaWxkcmVuXG4gICAgICBcbiAgICAgIHJldHVybiByZWdpb25cbiAgICBcbiAgICBAcmVzaXplID0gKHRhcmdldCkgLT5cbiAgICAgICRhdHRycy4kc2V0IFwic2l6ZVwiLCB0YXJnZXQgfHwgMFxuICAgICAgXG4gICAgICBAbGF5b3V0LnJlZmxvdygpXG4gICAgICBcbiAgXVxuICBsaW5rOiAoJHNjb3BlLCAkZWwsICRhdHRycywgW3BhbmUsIHBhcmVudF0pIC0+XG4gICAgcGFuZS5sYXlvdXQgPSBwYXJlbnRcbiAgICBwYXJlbnQuYXR0YWNoQ2hpbGQocGFuZSlcbiAgICBcbiAgICAkc2NvcGUuJCRuZXh0U2libGluZy5wYW5lID0gcGFuZVxuICAgIFxuICAgICRzY29wZS4kd2F0Y2ggXCJjb25zdHJhaW5lZFwiLCAoY29uc3RyYWluZWQpIC0+XG4gICAgICBpZiBjb25zdHJhaW5lZCB0aGVuICRlbC5hZGRDbGFzcyhcImJvcmRlci1sYXlvdXQtY29uc3RyYWluZWRcIilcbiAgICAgIGVsc2UgJGVsLnJlbW92ZUNsYXNzKFwiYm9yZGVyLWxheW91dC1jb25zdHJhaW5lZFwiKVxuXVxuXG5tb2R1bGUuZGlyZWN0aXZlIFwibGF5b3V0SGFuZGxlXCIsIFsgXCIkd2luZG93XCIsICgkd2luZG93KSAtPlxuICByZXN0cmljdDogXCJBXCJcbiAgcmVxdWlyZTogW1wiP15wYW5lXCIsIFwiXj9ib3JkZXJMYXlvdXRcIl1cbiAgbGluazogKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgW3BhbmUsIGxheW91dF0pIC0+XG4gICAgcmV0dXJuIHVubGVzcyBwYW5lXG4gICAgXG4gICAgZWwgPSAkZWxlbWVudFswXVxuICAgIFxuICAgIGNsaWNrUmFkaXVzID0gNVxuICAgIGNsaWNrVGltZSA9IDMwMFxuICAgIFxuICAgICRzY29wZS4kd2F0Y2ggKCAtPiBwYW5lLmdldE9yaWVudGF0aW9uKCkgKSwgKG9yaWVudGF0aW9uKSAtPlxuICAgICAgJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJ2ZXJ0aWNhbFwiKVxuICAgICAgJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJob3Jpem9udGFsXCIpXG4gICAgICBzd2l0Y2ggb3JpZW50YXRpb25cbiAgICAgICAgd2hlbiBcInZlcnRpY2FsXCIgdGhlbiAkZWxlbWVudC5hZGRDbGFzcyhcInZlcnRpY2FsXCIpXG4gICAgICAgIHdoZW4gXCJob3Jpem9udGFsXCIgdGhlbiAkZWxlbWVudC5hZGRDbGFzcyhcImhvcml6b250YWxcIilcbiAgICBcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyIFwibW91c2Vkb3duXCIsIChlKSAtPlxuICAgICAgcmV0dXJuIHVubGVzcyBlLmJ1dHRvbiBpcyAwXG4gICAgICBcbiAgICAgIGFuY2hvciA9IHBhbmUuYW5jaG9yXG4gICAgICBcbiAgICAgIGlmIGFuY2hvciBpbiBbXCJub3J0aFwiLCBcInNvdXRoXCJdIHRoZW4gY29vcmQgPSBcInNjcmVlbllcIlxuICAgICAgZWxzZSBpZiBhbmNob3IgaW4gW1wid2VzdFwiLCBcImVhc3RcIl0gdGhlbiBjb29yZCA9IFwic2NyZWVuWFwiXG5cbiAgICAgIGlmIGFuY2hvciBpbiBbXCJub3J0aFwiLCBcIndlc3RcIl0gdGhlbiBzY2FsZSA9IDFcbiAgICAgIGVsc2UgaWYgYW5jaG9yIGluIFtcInNvdXRoXCIsIFwiZWFzdFwiXSB0aGVuIHNjYWxlID0gLTFcbiAgICBcbiAgICAgIHN0YXJ0UG9zID0ge3g6IGUuc2NyZWVuWCwgeTogZS5zY3JlZW5ZfVxuICAgICAgc3RhcnRDb29yZCA9IGVbY29vcmRdXG4gICAgICBzdGFydFNpemUgPSBwYW5lLnNpemVcbiAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICAgIFxuICAgICAgcGFuZS5vbkhhbmRsZURvd24oKVxuICAgICAgXG4gICAgICAjIE5vdCBzdXJlIGlmIHRoaXMgcmVhbGx5IGFkZHMgdmFsdWUsIGJ1dCBhZGRlZCBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgZWwudW5zZWxlY3RhYmxlID0gXCJvblwiXG4gICAgICBlbC5vbnNlbGVjdHN0YXJ0ID0gLT4gZmFsc2VcbiAgICAgIGVsLnN0eWxlLnVzZXJTZWxlY3QgPSBlbC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCJcbiAgICAgIFxuICAgICAgIyBOdWxsIG91dCB0aGUgZXZlbnQgdG8gcmUtdXNlIGUgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAjZS5zZXRDYXB0dXJlKClcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZVxuICAgICAgZSA9IG51bGxcbiAgICAgIFxuICAgICAgaGFuZGxlQ2xpY2sgPSAoZSkgLT5cbiAgICAgICAgJHNjb3BlLiRhcHBseSAtPiBwYW5lLnRvZ2dsZSgpXG4gICAgICAgICAgXG4gICAgICBoYW5kbGVNb3VzZU1vdmUgPSAoZSkgLT5cbiAgICAgICAgJGVsZW1lbnQuYWRkQ2xhc3MoXCJib3JkZXItbGF5b3V0LXBhbmUtbW92aW5nXCIpXG4gICAgICBcbiAgICAgICAgIyBJbnNpZGUgQW5ndWxhcidzIGRpZ2VzdCwgZGV0ZXJtaW5lIHRoZSBpZGVhbCBzaXplIG9mIHRoZSBlbGVtZW50XG4gICAgICAgICMgYWNjb3JkaW5nIHRvIG1vdmVtZW50cyB0aGVuIGRldGVybWluZSBpZiB0aG9zZSBtb3ZlbWVudHMgaGF2ZSBiZWVuXG4gICAgICAgICMgY29uc3RyYWluZWQgYnkgYm91bmRhcmllcywgb3RoZXIgcGFuZXMgb3IgbWluL21heCBjbGF1c2VzXG4gICAgICAgICRzY29wZS4kYXBwbHkgLT4gcGFuZS5yZXNpemUgdGFyZ2V0U2l6ZSA9IHN0YXJ0U2l6ZSArIHNjYWxlICogKGVbY29vcmRdIC0gc3RhcnRDb29yZClcblxuICAgICAgICAjIE51bGwgb3V0IHRoZSBldmVudCBpbiBjYXNlIG9mIG1lbW9yeSBsZWFrc1xuICAgICAgICAjZS5zZXRDYXB0dXJlKClcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGUuZGVmYXVsdFByZXZlbnRlZCA9IHRydWVcbiAgICAgICAgZSA9IG51bGxcbiAgICAgICAgXG4gICAgICBoYW5kbGVNb3VzZVVwID0gKGUpIC0+XG4gICAgICAgIGRpc3BsYWNlbWVudFNxID0gTWF0aC5wb3coZS5zY3JlZW5YIC0gc3RhcnRQb3MueCwgMikgKyBNYXRoLnBvdyhlLnNjcmVlblkgLSBzdGFydFBvcy55LCAyKVxuICAgICAgICB0aW1lRWxhcHNlZCA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcblxuICAgICAgICAkd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlVGhyb3R0bGVkLCB0cnVlXG4gICAgICAgICR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciBcIm1vdXNldXBcIiwgaGFuZGxlTW91c2VVcCwgdHJ1ZVxuICAgICAgICBcbiAgICAgICAgY2xlYW51cCA9IC0+XG4gICAgICAgICAgIyBOdWxsIG91dCB0aGUgZXZlbnQgaW4gY2FzZSBvZiBtZW1vcnkgbGVha3NcbiAgICAgICAgICAjZS5yZWxlYXNlQ2FwdHVyZSgpXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgZS5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZVxuICAgICAgICAgIGUgPSBudWxsXG5cbiAgICAgICAgICBwYW5lLm9uSGFuZGxlVXAoKVxuICAgICAgICBcbiBcbiAgICAgICAgaWYgZGlzcGxhY2VtZW50U3EgPD0gTWF0aC5wb3coY2xpY2tSYWRpdXMsIDIpIGFuZCB0aW1lRWxhcHNlZCA8PSBjbGlja1RpbWVcbiAgICAgICAgICBoYW5kbGVDbGljayhlKVxuICAgICAgICAgIGNsZWFudXAoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICAgIFxuICAgICAgICAjIEluIGNhc2UgdGhlIG1vdXNlIGlzIHJlbGVhc2VkIGF0IHRoZSBlbmQgb2YgYSB0aHJvdHRsZSBwZXJpb2RcbiAgICAgICAgaGFuZGxlTW91c2VNb3ZlKGUpXG4gICAgICAgIFxuICAgICAgICBjbGVhbnVwKClcblxuICAgICAgXG4gICAgICAjIFByZXZlbnQgdGhlIHJlZmxvdyBsb2dpYyBmcm9tIGhhcHBlbmluZyB0b28gb2Z0ZW5cbiAgICAgIGhhbmRsZU1vdXNlTW92ZVRocm90dGxlZCA9IHRocm90dGxlKDEwLCBoYW5kbGVNb3VzZU1vdmUpXG4gICAgXG4gICAgICAkd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlVGhyb3R0bGVkLCB0cnVlXG4gICAgICAkd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgXCJtb3VzZXVwXCIsIGhhbmRsZU1vdXNlVXAsIHRydWVcblxuXVxuXG5cbm1vZHVsZS5kaXJlY3RpdmUgXCJib3JkZXJMYXlvdXRcIiwgWyBcIiR3aW5kb3dcIiwgXCIkdGltZW91dFwiLCAoJHdpbmRvdywgJHRpbWVvdXQpLT5cbiAgcmVzdHJpY3Q6IFwiRVwiXG4gIHJlcGxhY2U6IHRydWVcbiAgcmVxdWlyZTogW1wiYm9yZGVyTGF5b3V0XCIsIFwiXj9wYW5lXCJdXG4gIHRyYW5zY2x1ZGU6IHRydWVcbiAgdGVtcGxhdGU6IFwiXCJcIlxuICAgIDxkaXYgY2xhc3M9XCJib3JkZXItbGF5b3V0XCIgbmctdHJhbnNjbHVkZT5cbiAgICA8L2Rpdj5cbiAgXCJcIlwiXG4gIGNvbnRyb2xsZXI6IFtcIiRzY29wZVwiLCBcIiRlbGVtZW50XCIsIFwiJGF0dHJzXCIsICgkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMpIC0+XG4gICAgbGF5b3V0ID0gQFxuICAgIFxuICAgIEBjaGlsZHJlbiA9IFtdXG4gICAgXG4gICAgQGF0dGFjaENoaWxkID0gKGNoaWxkKSAtPlxuICAgICAgQGNoaWxkcmVuLnB1c2goY2hpbGQpXG4gICAgXG4gICAgQG9uSGFuZGxlRG93biA9IC0+ICRlbGVtZW50LmFkZENsYXNzKFwiYWN0aXZlXCIpXG4gICAgQG9uSGFuZGxlVXAgPSAtPlxuICAgICAgJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIilcbiAgICAgICRzY29wZS4kYnJvYWRjYXN0IFwiYm9yZGVyLWxheW91dC1yZWZsb3dcIlxuICAgIFxuICAgIEByZWZsb3cgPSAocmVnaW9uKSAtPlxuICAgICAgd2lkdGggPSAkZWxlbWVudFswXS5vZmZzZXRXaWR0aFxuICAgICAgaGVpZ2h0ID0gJGVsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0XG4gICAgICBcbiAgICAgIHJlZ2lvbiB8fD0gbmV3IFJlZ2lvbih3aWR0aCwgaGVpZ2h0KVxuICAgICAgXG4gICAgICBAY2hpbGRyZW4uc29ydCAoYSwgYikgLT4gYi5vcmRlciAtIGEub3JkZXJcbiAgICAgIFxuICAgICAgcmVnaW9uID0gY2hpbGQucmVmbG93KHJlZ2lvbikgZm9yIGNoaWxkIGluIEBjaGlsZHJlblxuICAgICAgICBcbiAgXVxuICBsaW5rOiAoJHNjb3BlLCAkZWwsICRhdHRycywgW2xheW91dCwgcGFyZW50XSkgLT5cbiAgICBwYXJlbnQuYXR0YWNoQ2hpbGQobGF5b3V0KSBpZiBwYXJlbnRcbiAgICBcbiAgICAkc2NvcGUuJG9uIFwicmVmbG93XCIsIC0+XG4gICAgICBsYXlvdXQucmVmbG93KCkgdW5sZXNzIHBhcmVudFxuICAgIFxuICAgICR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciBcInJlc2l6ZVwiLCAoZSkgLT5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICRzY29wZS4kYXBwbHkgLT4gJHNjb3BlLiRicm9hZGNhc3QgXCJib3JkZXItbGF5b3V0LXJlZmxvd1wiXG4gICAgXG4gICAgJHRpbWVvdXQgLT4gbGF5b3V0LnJlZmxvdygpIHVubGVzcyBwYXJlbnRcbl0iLCJyZXF1aXJlIFwiLi4vc2VydmljZXMvc2Vzc2lvbi5jb2ZmZWVcIlxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL3R5cGVzLmNvZmZlZVwiXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvc2V0dGluZ3MuY29mZmVlXCJcbnJlcXVpcmUgXCIuLi9zZXJ2aWNlcy9hbm5vdGF0aW9ucy5jb2ZmZWVcIlxuXG5tb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuZGlyZWN0aXZlLmNvZGVFZGl0b3JcIiwgW1xuICBcInBsdW5rZXIuc2VydmljZS5zZXNzaW9uXCJcbiAgXCJwbHVua2VyLnNlcnZpY2UudHlwZXNcIlxuICBcInBsdW5rZXIuc2VydmljZS5zZXR0aW5nc1wiXG4gIFwicGx1bmtlci5zZXJ2aWNlLmFubm90YXRpb25zXCJcbl1cblxubW9kdWxlLmRpcmVjdGl2ZSBcImNvZGVFZGl0b3JcIiwgWyBcIiRyb290U2NvcGVcIiwgXCIkdGltZW91dFwiLCBcInNlc3Npb25cIiwgXCJ0eXBlc1wiLCBcInNldHRpbmdzXCIsIFwiYW5ub3RhdGlvbnNcIiwgKCRyb290U2NvcGUsICR0aW1lb3V0LCBzZXNzaW9uLCB0eXBlcywgc2V0dGluZ3MsIGFubm90YXRpb25zKSAtPlxuICBBY2VFZGl0b3IgPSBhY2UucmVxdWlyZShcImFjZS9lZGl0b3JcIikuRWRpdG9yXG4gIFJlbmRlcmVyID0gYWNlLnJlcXVpcmUoXCJhY2UvdmlydHVhbF9yZW5kZXJlclwiKS5WaXJ0dWFsUmVuZGVyZXJcbiAgRWRpdFNlc3Npb24gPSBhY2UucmVxdWlyZShcImFjZS9lZGl0X3Nlc3Npb25cIikuRWRpdFNlc3Npb25cbiAgVW5kb01hbmFnZXIgPSBhY2UucmVxdWlyZShcImFjZS91bmRvbWFuYWdlclwiKS5VbmRvTWFuYWdlclxuICBSYW5nZSA9IGFjZS5yZXF1aXJlKFwiYWNlL3JhbmdlXCIpLlJhbmdlXG4gIFxuICBjb25maWcgPSBhY2UucmVxdWlyZShcImFjZS9jb25maWdcIilcbiAgXG4gIHJlc3RyaWN0OiBcIkVcIlxuICByZXBsYWNlOiB0cnVlXG4gIHNjb3BlOlxuICAgIGFjdGl2ZTogXCI9XCJcbiAgdGVtcGxhdGU6IFwiXCJcIlxuICAgIDxkaXYgY2xhc3M9XCJjb2RlLWVkaXRvclwiPlxuICAgIDwvZGl2PlxuICBcIlwiXCJcbiAgbGluazogKCRzY29wZSwgJGVsLCBhdHRycykgLT5cbiAgICBlZGl0b3IgPSBuZXcgQWNlRWRpdG9yKG5ldyBSZW5kZXJlcigkZWxbMF0sIFwiYWNlL3RoZW1lLyN7c2V0dGluZ3MuZWRpdG9yLnRoZW1lfVwiKSlcbiAgICBjbGllbnQgPSBzZXNzaW9uLmNyZWF0ZUNsaWVudChcImNvZGUtZWRpdG9yXCIpXG4gICAgc25pcHBldE1hbmFnZXIgPSBudWxsXG4gICAgYnVmZmVycyA9IFtdXG4gICAgXG4gICAgYWNlLmNvbmZpZy5sb2FkTW9kdWxlIFwiYWNlL2V4dC9sYW5ndWFnZV90b29sc1wiLCAtPlxuICAgICAgZWRpdG9yLnNldE9wdGlvbnNcbiAgICAgICAgZW5hYmxlQmFzaWNBdXRvY29tcGxldGlvbjogdHJ1ZVxuICAgICAgICBlbmFibGVTbmlwcGV0czogdHJ1ZVxuICBcbiAgICAgIHNuaXBwZXRNYW5hZ2VyID0gYWNlLnJlcXVpcmUoXCJhY2Uvc25pcHBldHNcIikuc25pcHBldE1hbmFnZXJcbiAgICAgIFxuICAgICRzY29wZS4kd2F0Y2ggKCAtPiBzZXR0aW5ncy5lZGl0b3IudGhlbWUgKSwgKHRoZW1lKSAtPlxuICAgICAgZWRpdG9yLnNldFRoZW1lKFwiYWNlL3RoZW1lLyN7dGhlbWV9XCIpIGlmIHRoZW1lXG4gICAgXG5cbiAgICBndWVzc01vZGUgPSAoZmlsZW5hbWUpIC0+IFwiYWNlL21vZGUvXCIgKyB0eXBlcy5nZXRCeUZpbGVuYW1lKGZpbGVuYW1lKS5uYW1lXG4gICAgXG4gICAgYWN0aXZhdGVCdWZmZXIgPSAoaW5kZXgpIC0+XG4gICAgICBlZGl0b3Iuc2V0U2Vzc2lvbihidWZmZXJzW2luZGV4XSlcbiAgICAgIGVkaXRvci5mb2N1cygpXG4gICAgXG4gICAgbW92ZUN1cnNvciA9IChvZmZzZXQpIC0+XG4gICAgICBkb2MgPSBlZGl0b3Iuc2Vzc2lvbi5kb2NcbiAgICAgIGVkaXRvci5tb3ZlQ3Vyc29yVG9Qb3NpdGlvbihkb2MuaW5kZXhUb1Bvc2l0aW9uKG9mZnNldCkpXG4gICAgXG4gICAgYWRkQWNlU2Vzc2lvbiA9IChpbmRleCwgZmlsZSkgLT5cbiAgICAgIGFjZVNlc3Npb24gPSBuZXcgRWRpdFNlc3Npb24oZmlsZS5jb250ZW50IG9yIFwiXCIpXG4gICAgICBhY2VTZXNzaW9uLnNldFVuZG9NYW5hZ2VyKG5ldyBVbmRvTWFuYWdlcigpKVxuICAgICAgYWNlU2Vzc2lvbi5zZXRVc2VXb3JrZXIodHJ1ZSlcbiAgICAgIGFjZVNlc3Npb24uc2V0VGFiU2l6ZShzZXR0aW5ncy5lZGl0b3IudGFiX3NpemUpXG4gICAgICBhY2VTZXNzaW9uLnNldFVzZVdyYXBNb2RlKCEhc2V0dGluZ3MuZWRpdG9yLndyYXAuZW5hYmxlZClcbiAgICAgIGFjZVNlc3Npb24uc2V0V3JhcExpbWl0UmFuZ2Uoc2V0dGluZ3MuZWRpdG9yLndyYXAucmFuZ2UubWluLCBzZXR0aW5ncy5lZGl0b3Iud3JhcC5yYW5nZS5tYXgpXG4gICAgICBhY2VTZXNzaW9uLnNldE1vZGUoZ3Vlc3NNb2RlKGZpbGUuZmlsZW5hbWUpKVxuXG4gICAgICBcbiAgICAgIGRvYyA9IGFjZVNlc3Npb24uZ2V0RG9jdW1lbnQoKVxuICAgICAgICAgIFxuICAgICAgaGFuZGxlQ2hhbmdlRXZlbnQgPSAoZSkgLT5cbiAgICAgICAgdW5sZXNzICRyb290U2NvcGUuJCRwaGFzZSB0aGVuICRzY29wZS4kYXBwbHkgLT5cbiAgICAgICAgICBubCA9IGRvYy5nZXROZXdMaW5lQ2hhcmFjdGVyKClcbiAgICAgICAgICBcbiAgICAgICAgICBzd2l0Y2ggZS5kYXRhLmFjdGlvblxuICAgICAgICAgICAgd2hlbiBcImluc2VydFRleHRcIiB0aGVuIGNsaWVudC50ZXh0SW5zZXJ0IGZpbGUuZmlsZW5hbWUsIGRvYy5wb3NpdGlvblRvSW5kZXgoZS5kYXRhLnJhbmdlLnN0YXJ0KSwgZS5kYXRhLnRleHRcbiAgICAgICAgICAgIHdoZW4gXCJpbnNlcnRMaW5lc1wiIHRoZW4gY2xpZW50LnRleHRJbnNlcnQgZmlsZS5maWxlbmFtZSwgZG9jLnBvc2l0aW9uVG9JbmRleChlLmRhdGEucmFuZ2Uuc3RhcnQpLCBlLmRhdGEubGluZXMuam9pbihubCkgKyBubFxuICAgICAgICAgICAgd2hlbiBcInJlbW92ZVRleHRcIiB0aGVuIGNsaWVudC50ZXh0UmVtb3ZlIGZpbGUuZmlsZW5hbWUsIGRvYy5wb3NpdGlvblRvSW5kZXgoZS5kYXRhLnJhbmdlLnN0YXJ0KSwgZS5kYXRhLnRleHRcbiAgICAgICAgICAgIHdoZW4gXCJyZW1vdmVMaW5lc1wiIHRoZW4gY2xpZW50LnRleHRSZW1vdmUgZmlsZS5maWxlbmFtZSwgZG9jLnBvc2l0aW9uVG9JbmRleChlLmRhdGEucmFuZ2Uuc3RhcnQpLCBlLmRhdGEubGluZXMuam9pbihubCkgKyBubFxuICAgICAgXG4gICAgICBoYW5kbGVDaGFuZ2VBbm5vdGF0aW9uRXZlbnQgPSAoZSkgLT5cbiAgICAgICAgdW5sZXNzICRyb290U2NvcGUuJCRwaGFzZSB0aGVuICRzY29wZS4kYXBwbHkgLT5cbiAgICAgICAgICBpZiAoaWR4ID0gY2xpZW50LmdldEZpbGVJbmRleChmaWxlLmZpbGVuYW1lKSkgPCAwXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXJzIGFuZCBzZXNzaW9uIGFyZSBvdXQgb2Ygc3luYyBmb3I6ICN7ZmlsZS5maWxlbmFtZX1cIilcbiAgICAgICAgICBcbiAgICAgICAgICBhbm5vdGF0aW9ucy51cGRhdGUoZmlsZS5maWxlbmFtZSwgYWNlU2Vzc2lvbi5nZXRBbm5vdGF0aW9ucygpKVxuICAgICAgICAgIFxuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCBcInVwZGF0ZUFubm90YXRpbm9zXCIsIGZpbGUsIGFjZVNlc3Npb24uZ2V0QW5ub3RhdGlvbnMoKVxuXG4gICAgICBidWZmZXJzW2luZGV4XSA9IGFjZVNlc3Npb25cbiAgICAgIFxuICAgICAgYW5ub3RhdGlvbnMudXBkYXRlIGZpbGUuZmlsZW5hbWUsIGFjZVNlc3Npb24uZ2V0QW5ub3RhdGlvbnMoKVxuXG4gICAgICBhY2VTZXNzaW9uLm9uIFwiY2hhbmdlXCIsIGhhbmRsZUNoYW5nZUV2ZW50XG4gICAgICBhY2VTZXNzaW9uLm9uIFwiY2hhbmdlQW5ub3RhdGlvblwiLCBoYW5kbGVDaGFuZ2VBbm5vdGF0aW9uRXZlbnRcblxuICAgICAgYWNlU2Vzc2lvbi5kZXN0cm95ID0gLT5cbiAgICAgICAgYWNlU2Vzc2lvbi5vZmYgXCJjaGFuZ2VcIiwgaGFuZGxlQ2hhbmdlRXZlbnRcbiAgICAgICAgYWNlU2Vzc2lvbi5vZmYgXCJjaGFuZ2VBbm5vdGF0aW9uXCIsIGhhbmRsZUNoYW5nZUFubm90YXRpb25FdmVudFxuXG4gICAgcmVtb3ZlQWNlU2Vzc2lvbiA9IChpbmRleCkgLT5cbiAgICAgIHVubGVzcyBidWZmZXJzW2luZGV4XSB0aGVuIGRlYnVnZ2VyXG4gICAgICBidWZmZXJzW2luZGV4XS5kZXN0cm95KClcbiAgICAgIGJ1ZmZlcnMuc3BsaWNlIGluZGV4LCAxXG4gICAgICBcbiAgICAgIGlmIGZpbGUgPSBjbGllbnQuZ2V0RmlsZUJ5SW5kZXgoaW5kZXgpXG4gICAgICAgIGFubm90YXRpb25zLnJlbW92ZShmaWxlLmZpbGVuYW1lKVxuICAgICAgXG4gICAgcmVzZXQgPSAoc25hcHNob3QpIC0+XG4gICAgICByZW1vdmVBY2VTZXNzaW9uKGlkeCkgZm9yIGlkeCBpbiBbYnVmZmVycy5sZW5ndGggLSAxLi4wXSBieSAtMVxuICAgICAgYWRkQWNlU2Vzc2lvbihpZHgsIGZpbGUpIGZvciBmaWxlLCBpZHggaW4gc25hcHNob3QuZmlsZXNcbiAgICBcbiAgICBjaGFuZ2VTZXNzaW9uTW9kZSA9IChpbmRleCwgZmlsZW5hbWUpIC0+XG4gICAgICBidWZmZXIuc2V0TW9kZShndWVzc01vZGUoZmlsZW5hbWUpKSBpZiBidWZmZXIgPSBidWZmZXJzW2luZGV4XVxuICAgICAgICBcbiAgICBjbGllbnQub24gXCJyZXNldFwiLCAoZSwgc25hcHNob3QpIC0+IHJlc2V0KGUuc25hcHNob3QpXG4gICAgXG4gICAgY2xpZW50Lm9uIFwiY3Vyc29yU2V0RmlsZVwiLCAoZSwgc25hcHNob3QpIC0+XG4gICAgICBhY3RpdmF0ZUJ1ZmZlcihlLmluZGV4KVxuICAgIFxuICAgIGNsaWVudC5vbiBcImN1cnNvclNldE9mZnNldFwiLCAoZSwgc25hcHNob3QpIC0+XG4gICAgICBtb3ZlQ3Vyc29yKGUub2Zmc2V0KVxuICAgICAgXG4gICAgY2xpZW50Lm9uIFwiZmlsZUNyZWF0ZVwiLCAoZSwgc25hcHNob3QpIC0+XG4gICAgICBhZGRBY2VTZXNzaW9uKGUuaW5kZXgsIHNuYXBzaG90LmZpbGVzW2UuaW5kZXhdKVxuICAgIFxuICAgIGNsaWVudC5vbiBcImZpbGVSZW1vdmVcIiwgKGUsIHNuYXBzaG90KSAtPlxuICAgICAgcmVtb3ZlQWNlU2Vzc2lvbihlLmluZGV4KVxuICAgICAgYW5ub3RhdGlvbnMucmVtb3ZlKGUuZmlsZW5hbWUpXG4gICAgXG4gICAgY2xpZW50Lm9uIFwiZmlsZVJlbmFtZVwiLCAoZSwgc25hcHNob3QpIC0+XG4gICAgICBjaGFuZ2VTZXNzaW9uTW9kZShlLmluZGV4LCBlLmZpbGVuYW1lKVxuICAgICAgYW5ub3RhdGlvbnMucmVuYW1lKGUuZmlsZW5hbWUsIGUub2xkX2ZpbGVuYW1lKVxuICAgIFxuICAgIGNsaWVudC5vbiBcInRleHRJbnNlcnRcIiwgKGUsIHNuYXBzaG90KSAtPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjZWl2ZWQgdGV4dEluc2VydCBldmVudCBmb3IgYSBmaWxlIG5vdCBiZWluZyB0cmFja2VkXCIpIHVubGVzcyBhY2VTZXNzaW9uID0gYnVmZmVyc1tlLmluZGV4XVxuICAgICAgYWNlU2Vzc2lvbi5kb2MuaW5zZXJ0IGFjZVNlc3Npb24uZG9jLmluZGV4VG9Qb3NpdGlvbihlLm9mZnNldCksIHRleHRcbiAgICAgIFxuICAgIGNsaWVudC5vbiBcInRleHRSZW1vdmVcIiwgKGUsIHNuYXBzaG90KSAtPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjZWl2ZWQgdGV4dEluc2VydCBldmVudCBmb3IgYSBmaWxlIG5vdCBiZWluZyB0cmFja2VkXCIpIHVubGVzcyBhY2VTZXNzaW9uID0gYnVmZmVyc1tlLmluZGV4XVxuICAgICAgYWNlU2Vzc2lvbi5kb2MucmVtb3ZlIFJhbmdlLmZyb21Qb2ludHMoYWNlU2Vzc2lvbi5kb2MuaW5kZXhUb1Bvc2l0aW9uKGUub2Zmc2V0KSwgYWNlU2Vzc2lvbi5kb2MuaW5kZXhUb1Bvc2l0aW9uKGUub2Zmc2V0ICsgZS50ZXh0Lmxlbmd0aCkpXG4gICAgXG4gICAgcmVzZXQoY2xpZW50LmdldFNuYXBzaG90KCkpXG4gICAgYWN0aXZhdGVCdWZmZXIoY2xpZW50LmdldEN1cnNvckZpbGVJbmRleCgpKVxuICAgIG1vdmVDdXJzb3IoY2xpZW50LmdldEN1cnNvclRleHRPZmZzZXQoKSlcbiAgICBcbiAgICAjIFJlc2l6ZSB0aGUgYWNlIGNvbXBvbmVudCB3aGVuZXZlciB3ZSBnZXQgYSByZWZsb3cgZXZlbnQgZnJvbSBib3JkZXItbGF5b3V0XG4gICAgJHNjb3BlLiRvbiBcImJvcmRlci1sYXlvdXQtcmVmbG93XCIsIC0+IGVkaXRvci5yZXNpemUoKVxuXG4gICAgJHRpbWVvdXQgLT5cbiAgICAgIGVkaXRvci5yZXNpemUoKVxuICAgICwgMTAwXG5cbl0iLCJnZW5pZCA9IHJlcXVpcmUoXCJnZW5pZFwiKVxuZGVib3VuY2UgPSByZXF1aXJlKFwibG9kYXNoLmRlYm91bmNlXCIpXG5cbnJlcXVpcmUgXCIuLi8uLi92ZW5kb3Ivb3BlcmF0aXZlLmpzXCJcblxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL3Nlc3Npb24uY29mZmVlXCJcbnJlcXVpcmUgXCIuLi9zZXJ2aWNlcy90eXBlcy5jb2ZmZWVcIlxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL3VybC5jb2ZmZWVcIlxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL3NldHRpbmdzLmNvZmZlZVwiXG5yZXF1aXJlIFwiLi4vc2VydmljZXMvYW5ub3RhdGlvbnMuY29mZmVlXCJcblxubW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJwbHVua2VyLmRpcmVjdGl2ZS5wcmV2aWV3ZXJcIiwgW1xuICBcInBsdW5rZXIuc2VydmljZS5zZXNzaW9uXCJcbiAgXCJwbHVua2VyLnNlcnZpY2UudXJsXCJcbiAgXCJwbHVua2VyLnNlcnZpY2Uuc2V0dGluZ3NcIlxuICBcInBsdW5rZXIuc2VydmljZS5hbm5vdGF0aW9uc1wiXG5dXG5cbm1vZHVsZS5kaXJlY3RpdmUgXCJwcmV2aWV3ZXJcIiwgWyBcIiR0aW1lb3V0XCIsIFwic2Vzc2lvblwiLCBcInVybFwiLCBcInNldHRpbmdzXCIsIFwiYW5ub3RhdGlvbnNcIiwgKCR0aW1lb3V0LCBzZXNzaW9uLCB1cmwsIHNldHRpbmdzLCBhbm5vdGF0aW9ucykgLT5cbiAgcmVzdHJpY3Q6IFwiRVwiXG4gIHJlcGxhY2U6IHRydWVcbiAgc2NvcGU6XG4gICAgc2Vzc2lvbjogXCI9XCJcbiAgdGVtcGxhdGU6IFwiXCJcIlxuICAgIDxkaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwicGx1bmtlci1wcmV2aWV3LWNvbnRhaW5lclwiIG5nLWNsYXNzPVwie21lc3NhZ2U6IG1lc3NhZ2V9XCI+XG4gICAgICAgIDxpZnJhbWUgbmFtZT1cInBsdW5rZXJQcmV2aWV3VGFyZ2V0XCIgc3JjPVwiYWJvdXQ6YmxhbmtcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgZnJhbWVib3JkZXI9XCIwXCI+PC9pZnJhbWU+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJwbHVua2VyLXByZXZpZXctbWVzc2FnZSBhbGVydCBhbGVydC1kYW5nZXJcIiBuZy1zaG93PVwibWVzc2FnZVwiPlxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCIgbmctY2xpY2s9XCJtZXNzYWdlPScnXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvYnV0dG9uPlxuICAgICAgICA8c3BhbiBuZy1iaW5kPVwibWVzc2FnZVwiPjwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBcIlwiXCJcbiAgbGluazogKCRzY29wZSwgJGVsLCBhdHRycykgLT5cbiAgICAkc2NvcGUucHJldmlld1VybCB8fD0gXCIje3VybC5ydW59LyN7Z2VuaWQoKX0vXCJcbiAgICBcbiAgICBjbGllbnQgPSBzZXNzaW9uLmNyZWF0ZUNsaWVudChcInByZXZpZXdlclwiKVxuICAgIFxuICAgIHJlZnJlc2ggPSAoc25hcHNob3QpIC0+ICRzY29wZS4kYXBwbHkgLT5cbiAgICAgIHJldHVybiBpZiAkc2NvcGUubW9kZSBpcyBcImRpc2FibGVkXCJcbiAgICAgIFxuICAgICAgaWYgZmlsZW5hbWUgPSBhbm5vdGF0aW9ucy5oYXNFcnJvcigpXG4gICAgICAgICRzY29wZS5tZXNzYWdlID0gXCJQcmV2aWV3IGhhcyBub3QgYmVlbiB1cGRhdGVkIGR1ZSB0byBzeW50YXggZXJyb3JzIGluICN7ZmlsZW5hbWV9XCJcbiAgICAgICAgcmV0dXJuXG4gICAgICBlbHNlXG4gICAgICAgICRzY29wZS5tZXNzYWdlID0gXCJcIlxuICAgICAgXG4gICAgICBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIilcbiAgICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG4gICAgICBmb3JtLnNldEF0dHJpYnV0ZSBcIm1ldGhvZFwiLCBcInBvc3RcIlxuICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUgXCJhY3Rpb25cIiwgJHNjb3BlLnByZXZpZXdVcmxcbiAgICAgIGZvcm0uc2V0QXR0cmlidXRlIFwidGFyZ2V0XCIsIFwicGx1bmtlclByZXZpZXdUYXJnZXRcIlxuICAgICAgXG4gICAgICBmb3IgZmlsZSBpbiBzbmFwc2hvdC5maWxlc1xuICAgICAgICBmaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKVxuICAgICAgICBmaWVsZC5zZXRBdHRyaWJ1dGUgXCJ0eXBlXCIsIFwiaGlkZGVuXCJcbiAgICAgICAgZmllbGQuc2V0QXR0cmlidXRlIFwibmFtZVwiLCBcImZpbGVzWyN7ZmlsZS5maWxlbmFtZX1dW2NvbnRlbnRdXCJcbiAgICAgICAgZmllbGQuc2V0QXR0cmlidXRlIFwidmFsdWVcIiwgZmlsZS5jb250ZW50XG4gICAgICAgIFxuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGZpZWxkKVxuICAgICAgXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pXG4gICAgICBcbiAgICAgIGZvcm0uc3VibWl0KClcbiAgICAgIFxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChmb3JtKVxuICAgIFxuICAgIFxuICAgIFxuICAgICRzY29wZS4kd2F0Y2ggKCAtPiBzZXR0aW5ncy5wcmV2aWV3ZXIuZGVsYXkpLCAoZGVsYXkpIC0+XG4gICAgICByZWZyZXNoID0gZGVib3VuY2UgcmVmcmVzaCwgZGVsYXlcbiAgICAgIFxuICAgIGNsaWVudC5vbiBcInJlc2V0XCIsIChlLCBzbmFwc2hvdCkgLT4gcmVmcmVzaChzbmFwc2hvdClcblxuICAgIGNsaWVudC5vbiBcImZpbGVDcmVhdGVcIiwgKGUsIHNuYXBzaG90KSAtPiByZWZyZXNoKHNuYXBzaG90KVxuICAgIGNsaWVudC5vbiBcImZpbGVSZW5hbWVcIiwgKGUsIHNuYXBzaG90KSAtPiByZWZyZXNoKHNuYXBzaG90KVxuICAgIGNsaWVudC5vbiBcImZpbGVSZW1vdmVcIiwgKGUsIHNuYXBzaG90KSAtPiByZWZyZXNoKHNuYXBzaG90KVxuXG4gICAgY2xpZW50Lm9uIFwidGV4dEluc2VydFwiLCAoZSwgc25hcHNob3QpIC0+IHJlZnJlc2goc25hcHNob3QpXG4gICAgY2xpZW50Lm9uIFwidGV4dFJlbW92ZVwiLCAoZSwgc25hcHNob3QpIC0+IHJlZnJlc2goc25hcHNob3QpXG4gICAgXG4gICAgJHRpbWVvdXQgLT4gcmVmcmVzaChjbGllbnQuZ2V0U25hcHNob3QoKSlcbl0iLCJyZXF1aXJlIFwiLi4vLi4vdmVuZG9yL2FuZ3VsYXItdWkvdWktYm9vdHN0cmFwXCJcblxucmVxdWlyZSBcIi4uL3NlcnZpY2VzL25vdGlmaWVyLmNvZmZlZVwiXG5cbm1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlIFwicGx1bmtlci5kaXJlY3RpdmUudG9vbGJhclwiLCBbXG4gIFwidWkuYm9vdHN0cmFwXCJcbiAgXG4gIFwicGx1bmtlci5zZXJ2aWNlLm5vdGlmaWVyXCJcbl1cblxubW9kdWxlLmRpcmVjdGl2ZSBcInBsdW5rZXJUb29sYmFyXCIsIFsgXCIkc3RhdGVcIiwgXCJzZXNzaW9uXCIsIFwibm90aWZpZXJcIiwgKCRzdGF0ZSwgc2Vzc2lvbiwgbm90aWZpZXIpIC0+XG4gIHJlc3RyaWN0OiBcIkVcIlxuICByZXBsYWNlOiB0cnVlXG4gIHNjb3BlOiB0cnVlXG4gIHRlbXBsYXRlOiBcIlwiXCJcbiAgICA8ZGl2IGNsYXNzPVwicGx1bmtlci1lZGl0b3ItdG9vbGJhclwiPlxuICAgICAgPGRpdiBjbGFzcz1cInB1bGwtbGVmdFwiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tcHJpbWFyeVwiIG5nLWNsaWNrPVwic2F2ZSgpXCI+XG4gICAgICAgICAgU2F2ZVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1zdWNjZXNzXCIgdWktc3JlZj1cImVkaXRvclwiPlxuICAgICAgICAgIE5ld1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1pbmZvXCIgbmctY2xhc3M9XCJ7YWN0aXZlOiBzaG93UHJldmlld1BhbmV9XCIgbmctY2xpY2s9XCJ0b2dnbGVQcmV2aWV3UGFuZSgpXCI+XG4gICAgICAgICAgUHJldmlld1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInB1bGwtcmlnaHRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBidG4tc21cIiBuZy1jb250cm9sbGVyPVwiTGF5b3V0Q29udHJvbGxlclwiPlxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1kZWZhdWx0XCIgbmctY2xpY2s9XCJsYXlvdXQuc2V0TGF5b3V0KCRpbmRleClcIiBuZy1yZXBlYXQ9XCJwcmVzZXQgaW4gbGF5b3V0LnByZXNldHNcIiBuZy1iaW5kPVwiJGluZGV4XCIgdG9vbHRpcD1cInt7cHJlc2V0Lm5hbWV9fVwiIHRvb2x0aXAtYXBwZW5kLXRvLWJvZHk9XCJ0cnVlXCIgdG9vbHRpcC1wbGFjZW1lbnQ9XCJib3R0b21cIj48L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgXCJcIlwiXG4gIFxuICBsaW5rOiAoJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzKSAtPlxuICAgIGNsaWVudCA9IHNlc3Npb24uY3JlYXRlQ2xpZW50KFwiZGlyZWN0aXZlLnRvb2xiYXJcIilcbiAgICBcbiAgICAkc2NvcGUuc2F2ZSA9IC0+XG4gICAgICBub3RpZmllci53YXJuIFwiU2F2ZSBub3QgaW1wbGVtZW50ZWQuLi4geWV0XCJcbl0iLCJtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuc2VydmljZS5hbm5vdGF0aW9uc1wiLCBbXVxuXG5tb2R1bGUuZmFjdG9yeSBcImFubm90YXRpb25zXCIsIC0+XG4gIGFubm90YXRpb25zOiB7fVxuICBcbiAgdXBkYXRlOiAoZmlsZW5hbWUsIGFubm90YXRpb25zID0gW10pIC0+XG4gICAgYW5ndWxhci5jb3B5IGFubm90YXRpb25zLCAoQGFubm90YXRpb25zW2ZpbGVuYW1lXSB8fD0gW10pXG4gIFxuICByZW5hbWU6IChvbGRfZmlsZW5hbWUsIG5ld19maWxlbmFtZSkgLT5cbiAgICBAYW5ub3RhdGlvbnNbbmV3X2ZpbGVuYW1lXSA9IEBhbm5vdGF0aW9uc1tvbGRfZmlsZW5hbWVdIG9yIFtdXG4gICAgZGVsZXRlIEBhbm5vdGF0aW9uc1tvbGRfZmlsZW5hbWVdXG4gIFxuICByZW1vdmU6IChmaWxlbmFtZSkgLT5cbiAgICBkZWxldGUgQGFubm90YXRpb25zW2ZpbGVuYW1lXVxuICAgIFxuICBoYXNFcnJvcjogLT5cbiAgICBmb3IgZmlsZW5hbWUsIGFubm90YXRpb25zIG9mIEBhbm5vdGF0aW9uc1xuICAgICAgXG4gICAgICByZXR1cm4gZmlsZW5hbWUgZm9yIGFubm90YXRpb24gaW4gYW5ub3RhdGlvbnMgd2hlbiBhbm5vdGF0aW9uLnR5cGUgaXMgXCJlcnJvclwiXG4gICAgXG4gICAgcmV0dXJuIGZhbHNlIiwibW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJwbHVua2VyLnNlcnZpY2UuYmFzZVBsdW5rXCIsIFtdXG5cbm1vZHVsZS52YWx1ZSBcImJhc2VQbHVua1wiLFxuICBmaWxlczogW1xuICAgIGZpbGVuYW1lOiBcImluZGV4Lmh0bWxcIlxuICAgIGNvbnRlbnQ6IFwiXCJcIlxuICAgICAgPCFkb2N0eXBlIGh0bWw+XG4gICAgICA8aHRtbCBuZy1hcHA9XCJwbHVua2VyXCIgPlxuICAgICAgPGhlYWQ+XG4gICAgICAgIDxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiPlxuICAgICAgICA8dGl0bGU+QW5ndWxhckpTIFBsdW5rZXI8L3RpdGxlPlxuICAgICAgICA8c2NyaXB0PmRvY3VtZW50LndyaXRlKCc8YmFzZSBocmVmPVwiJyArIGRvY3VtZW50LmxvY2F0aW9uICsgJ1wiIC8+Jyk7PC9zY3JpcHQ+XG4gICAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwic3R5bGUuY3NzXCI+XG4gICAgICAgIDxzY3JpcHQgZGF0YS1yZXF1aXJlPVwiYW5ndWxhci5qc0AxLjEueFwiIHNyYz1cImh0dHA6Ly9jb2RlLmFuZ3VsYXJqcy5vcmcvMS4xLjQvYW5ndWxhci5qc1wiPjwvc2NyaXB0PlxuICAgICAgICA8c2NyaXB0IHNyYz1cImFwcC5qc1wiPjwvc2NyaXB0PlxuICAgICAgPC9oZWFkPlxuICAgICAgPGJvZHkgbmctY29udHJvbGxlcj1cIk1haW5DdHJsXCI+XG4gICAgICAgIDxwPkhlbGxvIHt7bmFtZX19ITwvcD5cbiAgICAgIDwvYm9keT5cbiAgICAgIDwvaHRtbD4gXG4gICAgXCJcIlwiXG4gICxcbiAgICBmaWxlbmFtZTogXCJhcHAuanNcIlxuICAgIGNvbnRlbnQ6IFwiXCJcIlxuICAgICAgdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdwbHVua2VyJywgW10pO1xuICAgICAgIFxuICAgICAgYXBwLmNvbnRyb2xsZXIoJ01haW5DdHJsJywgZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICAgICRzY29wZS5uYW1lID0gJ1dvcmxkJztcbiAgICAgIH0pO1xuICAgIFwiXCJcIlxuICAsXG4gICAgZmlsZW5hbWU6IFwic3R5bGUuY3NzXCJcbiAgICBjb250ZW50OiBcIlwiXCJcbiAgICAgIHAge1xuICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgfVxuICAgIFwiXCJcIlxuICBdIiwibW9kdWxlID0gYW5ndWxhci5tb2R1bGUgXCJwbHVua2VyLnNlcnZpY2UuZGlzYWJsZXJcIiwgW11cblxubW9kdWxlLmRpcmVjdGl2ZSBcInBsdW5rZXJEaXNhYmxlclwiLCBbXCJkaXNhYmxlclwiLCAoZGlzYWJsZXIpIC0+XG4gIGxpbms6ICgkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMpIC0+XG4gICAgbWFzayA9IGFuZ3VsYXIuZWxlbWVudCBcIlwiXCJcbiAgICAgIDxkaXYgY2xhc3M9XCJwbHVua2VyLWRpc2FibGVyXCI+PC9kaXY+XG4gICAgXCJcIlwiXG5cbiAgICAkc2NvcGUuJHdhdGNoICggLT4gZGlzYWJsZXIuc3RhdGVbJGF0dHJzLnBsdW5rZXJEaXNhYmxlcl0pLCAoc3RhdGUsIHByZXYpIC0+XG4gICAgICBpZiBzdGF0ZSB0aGVuICRlbGVtZW50LmFwcGVuZChtYXNrKVxuICAgICAgZWxzZSBtYXNrLnJlbW92ZSgpXG5dXG5cbm1vZHVsZS5zZXJ2aWNlIFwiZGlzYWJsZXJcIiwgWyBcIiRxXCIsICgkcSkgLT5cbiAgcXVldWVzID0ge31cbiAgXG4gIEBzdGF0ZSA9IHt9XG4gIEBlbnF1ZXVlID0gKG5hbWUsIHZhbHVlT3JQcm9taXNlKSAtPlxuICAgIGRpc2FibGVyID0gQFxuICAgIFxuICAgIGRpc2FibGVyLnN0YXRlW25hbWVdID0gdHJ1ZVxuICAgICRxLndoZW4odmFsdWVPclByb21pc2UpLmZpbmFsbHkgLT5cbiAgICAgIGRpc2FibGVyLnN0YXRlW25hbWVdID0gZmFsc2Vcbl0iLCJtb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuc2VydmljZS5sYXlvdXRcIiwgW1xuXVxuXG5tb2R1bGUuZmFjdG9yeSBcImxheW91dFwiLCBbXCIkcm9vdFNjb3BlXCIsICgkcm9vdFNjb3BlKSAtPlxuICBwcmVzZXRzID0gW1xuICAgIG5hbWU6IFwiUHJldmlldyBvbiB0aGUgcmlnaHRcIlxuICAgIGxheW91dDpcbiAgICAgIHByZXZpZXc6XG4gICAgICAgIGFuY2hvcjogXCJlYXN0XCJcbiAgICAgICAgb3JkZXI6IDBcbiAgICAgICAgc2l6ZTogXCI1MCYgLSA0cHhcIlxuICAgICAgICBvcGVuOiB0cnVlXG4gICAgICB0ZW1wbGF0ZXM6XG4gICAgICAgIGFuY2hvcjogXCJ3ZXN0XCJcbiAgICAgICAgb3JkZXI6IDJcbiAgICAgICAgc2l6ZTogXCIzMDBweFwiXG4gICxcbiAgICBuYW1lOiBcIlByZXZpZXcgYXQgdGhlIGJvdHRvbVwiXG4gICAgbGF5b3V0OlxuICAgICAgcHJldmlldzpcbiAgICAgICAgYW5jaG9yOiBcInNvdXRoXCJcbiAgICAgICAgb3JkZXI6IDJcbiAgICAgICAgc2l6ZTogXCI0MCUgLSA0cHhcIlxuICAgICAgICBvcGVuOiB0cnVlXG4gICAgICB0ZW1wbGF0ZXM6XG4gICAgICAgIGFuY2hvcjogXCJ3ZXN0XCJcbiAgICAgICAgb3JkZXI6IDJcbiAgICAgICAgc2l6ZTogXCIzMDBweFwiXG4gIF1cbiAgXG4gIHNlcnZpY2UgPVxuICAgIGN1cnJlbnQ6IG51bGxcbiAgICBwcmVzZXRzOiBwcmVzZXRzXG4gICAgaXNPcGVuOiAocGFuZUlkKSAtPiBAY3VycmVudD8ubGF5b3V0P1twYW5lSWRdLm9wZW5cbiAgICB0b2dnbGU6IChwYW5lSWQpIC0+IEBjdXJyZW50Py5sYXlvdXQ/W3BhbmVJZF0ub3BlbiA9ICFAY3VycmVudC5sYXlvdXRbcGFuZUlkXS5vcGVuXG4gICAgICBcbiAgICBzZXRMYXlvdXQ6IChpZHgpIC0+XG4gICAgICBAY3VycmVudCA9IGFuZ3VsYXIuY29weShwcmVzZXRzW2lkeF0ubGF5b3V0KSBpZiBwcmVzZXRzW2lkeF1cbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCBcInJlZmxvd1wiXG4gICAgICBAY3VycmVudFxuICBcbiAgc2VydmljZS5zZXRMYXlvdXQoMCkgIyBEZWZhdWx0XG5cbiAgc2VydmljZVxuXSIsInJlcXVpcmUgXCIuLi8uLi92ZW5kb3IvYW5ndWxhci1ncm93bC9hbmd1bGFyLWdyb3dsXCJcblxuXG5tb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSBcInBsdW5rZXIuc2VydmljZS5ub3RpZmllclwiLCBbXG4gIFwiYW5ndWxhci1ncm93bFwiXG5dXG5cbm1vZHVsZS5jb25maWcgW1wiZ3Jvd2xQcm92aWRlclwiLCAoZ3Jvd2xQcm92aWRlcikgLT5cbiAgICBncm93bFByb3ZpZGVyLmdsb2JhbFRpbWVUb0xpdmUoMzAwMClcbl1cblxubW9kdWxlLmZhY3RvcnkgXCJub3RpZmllclwiLCBbXCJncm93bFwiLCAoZ3Jvd2wpIC0+XG4gIGVycm9yOiAobWVzc2FnZSkgLT5cbiAgICBjb25zb2xlLmxvZyBcIltFUlJdXCIsIGFyZ3VtZW50cy4uLlxuICAgIGdyb3dsLmFkZEVycm9yTWVzc2FnZSBtZXNzYWdlXG4gIHdhcm46IChtZXNzYWdlKSAtPlxuICAgIGNvbnNvbGUubG9nIFwiW1dBUk5dXCIsIGFyZ3VtZW50cy4uLlxuICAgIGdyb3dsLmFkZFdhcm5NZXNzYWdlIG1lc3NhZ2VcbiAgc3VjY2VzczogKG1lc3NhZ2UpIC0+XG4gICAgY29uc29sZS5sb2cgXCJbT0tdXCIsIGFyZ3VtZW50cy4uLlxuICAgIGdyb3dsLmFkZFN1Y2Nlc3NNZXNzYWdlIG1lc3NhZ2Vcbl0iLCJyZXF1aXJlIFwiLi4vLi4vdmVuZG9yL290dHlwZXMvd2ViY2xpZW50L2pzb24wLnVuY29tcHJlc3NlZC5qc1wiXG5cbm1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlIFwicGx1bmtlci5zZXJ2aWNlLnNlc3Npb25cIiwgW1xuXVxuXG5tb2R1bGUuc2VydmljZSBcInNlc3Npb25cIiwgY2xhc3MgU2Vzc2lvblxuICAjIFNlc3Npb25DbGllbnQgaXMgdGhlIGludGVyZmFjZSB0aHJvdWdoLXdoaWNoIHN1YnNjcmliZXJzIGNhbiBpc3N1ZSBvcGVyYXRpb25zIG9uIHRoZSBzZXNzaW9uXG4gIGNsYXNzIFNlc3Npb25DbGllbnRcbiAgICBjb25zdHJ1Y3RvcjogKEBuYW1lLCBAc2Vzc2lvbikgLT5cbiAgICAgIEBsaXN0ZW5lcnMgPSB7fVxuICAgICAgXG4gICAgb246IChldmVudE5hbWUsIGxpc3RlbmVyKSAtPiAoQGxpc3RlbmVyc1tldmVudE5hbWVdIHx8PSBbXSkucHVzaChsaXN0ZW5lcilcbiAgICBvZmY6IChldmVudE5hbWUsIGxpc3RlbmVyKSAtPiBAbGlzdGVuZXJzLnNwbGljZShpZHgsIDEpIHVubGVzcyAwID4gKGlkeCA9IEBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcikpXG4gICAgXG4gICAgX2FwcGx5T3A6IChvcCkgLT4gQF9hcHBseU9wcyBbb3BdXG4gICAgX2FwcGx5T3BzOiAob3BzKSAtPiBAc2Vzc2lvbi5hcHBseU9wcyBAbmFtZSwgb3BzXG4gICAgXG4gICAgX2hhbmRsZU9wOiAoc291cmNlQ2xpZW50TmFtZSwgb3AsIHNuYXBzaG90KSAtPlxuICAgICAgaWYgb3AucC5sZW5ndGggaXMgMFxuICAgICAgICBAX2VtaXQgXCJyZXNldFwiLFxuICAgICAgICAgIHNuYXBzaG90OiBvcC5vaVxuICAgICAgICAgIG9sZF9zbmFwc2hvdDogb3Aub2RcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoIG9wLnBbMF1cbiAgICAgICAgICB3aGVuIFwiY3Vyc29yXCJcbiAgICAgICAgICAgIGlmIG9wLnBbMV0gaXMgXCJmaWxlSW5kZXhcIiB0aGVuIEBfZW1pdCBcImN1cnNvclNldEZpbGVcIixcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IHNuYXBzaG90LmZpbGVzW29wLm9pXS5maWxlbmFtZVxuICAgICAgICAgICAgICBwcmV2X2ZpbGVuYW1lOiBzbmFwc2hvdC5maWxlc1tvcC5vZF0uZmlsZW5hbWVcbiAgICAgICAgICAgICAgaW5kZXg6IG9wLm9pXG4gICAgICAgICAgICAgIHByZXZfaW5kZXg6IG9wLm9kXG4gICAgICAgICAgICBlbHNlIGlmIG9wLnBbMV0gaXMgXCJ0ZXh0T2Zmc2V0XCIgdGhlbiBAX2VtaXQgXCJjdXJzb3JTZXRPZmZzZXRcIixcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvcC5vaVxuICAgICAgICAgICAgICBwcmV2X29mZnNldDogb3Aub2RcbiAgICAgICAgICB3aGVuIFwiZGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgIyBBc3N1bWUgc2kvc2Qgb3BzIGF0IG9mZnNldCA9IDBcbiAgICAgICAgICAgIHJldHVybiB1bmxlc3Mgb3AucFsxXSBpcyAwXG4gICAgICAgICAgICByZXR1cm4gdW5sZXNzIG9wLnNpIGFuZCBvcC5zZFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBAX2VtaXQgXCJzZXREZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogb3Auc2lcbiAgICAgICAgICAgICAgb2xkX2Rlc2NyaXB0aW9uOiBvcC5zZFxuICAgICAgICAgIHdoZW4gXCJ0YWdzXCJcbiAgICAgICAgICAgIHJldHVybiB1bmxlc3Mgb3AubGkgb3Igb3AubGRcbiAgICAgICAgICAgIHJldHVybiBpZiBvcC5wLmxlbmd0aCAhPSAyXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIG9wLmxpIHRoZW4gQF9lbWl0IFwidGFnQWRkXCIsXG4gICAgICAgICAgICAgIHRhZ05hbWU6IG9wLmxpXG4gICAgICAgICAgICAgIGluZGV4OiBvcC5wWzFdXG4gICAgICAgICAgICBlbHNlIGlmIG9wLmxkIHRoZW4gQF9lbWl0IFwidGFnUmVtb3ZlXCIsXG4gICAgICAgICAgICAgIHRhZ05hbWU6IG9wLmxkXG4gICAgICAgICAgICAgIGluZGV4OiBvcC5wWzJdXG4gICAgICAgICAgd2hlbiBcImZpbGVzXCJcbiAgICAgICAgICAgICMgVGhpcyBpcyBhIGZpbGUgY3JlYXRpb24vcmVtb3ZhbFxuICAgICAgICAgICAgaWYgb3AucC5sZW5ndGggaXMgMlxuICAgICAgICAgICAgICBpZiBvcC5saSB0aGVuIEBfZW1pdCBcImZpbGVDcmVhdGVcIixcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogb3AubGkuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICBpbmRleDogb3AucFsxXVxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9wLmxpLmNvbnRlbnRcbiAgICAgICAgICAgICAgZWxzZSBpZiBvcC5sZCB0aGVuIEBfZW1pdCBcImZpbGVSZW1vdmVcIixcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogb3AubGQuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICBpbmRleDogb3AucFsxXVxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9wLmxkLmNvbnRlbnRcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZWxzZSBpZiBvcC5wWzJdIGlzIFwiZmlsZW5hbWVcIlxuICAgICAgICAgICAgICBAX2VtaXQgXCJmaWxlUmVuYW1lXCIsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IG9wLm9pXG4gICAgICAgICAgICAgICAgaW5kZXg6IG9wLnBbMV1cbiAgICAgICAgICAgICAgICBvbGRfZmlsZW5hbWU6IG9wLm9kXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBlbHNlIGlmIG9wLnBbMl0gaXMgXCJjb250ZW50XCJcbiAgICAgICAgICAgICAgZmlsZW5hbWUgPSBzbmFwc2hvdC5maWxlc1tvcC5wWzFdXS5maWxlbmFtZVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgb3Auc2kgdGhlbiBAX2VtaXQgXCJ0ZXh0SW5zZXJ0XCIsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lXG4gICAgICAgICAgICAgICAgaW5kZXg6IG9wLnBbMV1cbiAgICAgICAgICAgICAgICB0ZXh0OiBvcC5zaVxuICAgICAgICAgICAgICAgIG9mZnNldDogb3AucFszXVxuICAgICAgICAgICAgICBpZiBvcC5zZCB0aGVuIEBfZW1pdCBcInRleHRSZW1vdmVcIixcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWVcbiAgICAgICAgICAgICAgICBpbmRleDogb3AucFsxXVxuICAgICAgICAgICAgICAgIHRleHQ6IG9wLnNkXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvcC5wWzNdXG4gICAgICAgICAgICAgICAgXG4gICAgX2VtaXQ6IChldmVudE5hbWUsIGUpIC0+XG4gICAgICBzbmFwc2hvdCA9IEBnZXRTbmFwc2hvdCgpXG4gICAgICBlLmV2ZW50TmFtZSA9IGV2ZW50TmFtZVxuICAgICAgXG4gICAgICBsaXN0ZW5lcihlLCBzbmFwc2hvdCkgZm9yIGxpc3RlbmVyIGluIEBsaXN0ZW5lcnNbZXZlbnROYW1lXSBpZiBAbGlzdGVuZXJzW2V2ZW50TmFtZV1cbiAgICBcbiAgICBnZXRDdXJzb3JGaWxlSW5kZXg6IC0+IEBzZXNzaW9uLnNuYXBzaG90LmN1cnNvci5maWxlSW5kZXhcbiAgICBcbiAgICBnZXRDdXJzb3JUZXh0T2Zmc2V0OiAtPiBAc2Vzc2lvbi5zbmFwc2hvdC5jdXJzb3IudGV4dE9mZnNldFxuICAgIFxuICAgIGdldERlc2NyaXB0aW9uOiAtPiBAc2Vzc2lvbi5zbmFwc2hvdC5kZXNjcmlwdGlvblxuICAgIFxuICAgICMgUmV0dXJuIHZhbHVlIGlzIGp1c3QgbGlrZSBpbmRleE9mICg+PSAwIG1lYW5zIGZvdW5kLCAtMSBtZWFucyBub3QgZm91bmQpXG4gICAgZ2V0RmlsZUluZGV4OiAoZmlsZW5hbWUpIC0+XG4gICAgICByZXR1cm4gaWR4IGZvciBmaWxlLCBpZHggaW4gQHNlc3Npb24uc25hcHNob3QuZmlsZXMgd2hlbiBmaWxlLmZpbGVuYW1lIGlzIGZpbGVuYW1lXG4gICAgICByZXR1cm4gLTFcbiAgICBcbiAgICBnZXRGaWxlQnlJbmRleDogKGlkeCkgLT5cbiAgICAgIGlmIGFuZ3VsYXIuaXNTdHJpbmcoaWR4KSB0aGVuIGlkeCA9IEBnZXRGaWxlSW5kZXgoaWR4KVxuICAgICAgXG4gICAgICBAc2Vzc2lvbi5zbmFwc2hvdC5maWxlc1tpZHhdXG4gICAgXG4gICAgZ2V0RmlsZTogKGZpbGVuYW1lKSAtPlxuICAgICAgcmV0dXJuIGZpbGUgZm9yIGZpbGUgaW4gQHNlc3Npb24uc25hcHNob3QuZmlsZXMgd2hlbiBmaWxlLmZpbGVuYW1lIGlzIGZpbGVuYW1lXG4gICAgXG4gICAgZ2V0TnVtRmlsZXM6IC0+IHJldHVybiBAc2Vzc2lvbi5zbmFwc2hvdC5maWxlcz8ubGVuZ3RoIG9yIDBcbiAgICBcbiAgICBnZXROdW1UYWdzOiAtPiByZXR1cm4gQHNlc3Npb24uc25hcHNob3QudGFncz8ubGVuZ3RoIG9yIDBcbiAgICBcbiAgICBnZXRTbmFwc2hvdDogLT4gcmV0dXJuIEBzZXNzaW9uLnNuYXBzaG90XG4gICAgXG4gICAgIyBSZXR1cm4gdmFsdWUgaXMganVzdCBsaWtlIGluZGV4T2YgKD49IDAgbWVhbnMgZm91bmQsIC0xIG1lYW5zIG5vdCBmb3VuZClcbiAgICBnZXRUYWdJbmRleDogKHRhZ05hbWUpIC0+XG4gICAgICByZXR1cm4gaWR4IGZvciB0YWcsIGlkeCBpbiBAc2Vzc2lvbi5zbmFwc2hvdC50YWdzIHdoZW4gdGFnIGlzIHRhZ05hbWVcbiAgICAgIHJldHVybiAtMVxuICAgIFxuICAgIGhhc0ZpbGU6IChmaWxlbmFtZSkgLT4gcmV0dXJuIEBnZXRGaWxlSW5kZXgoZmlsZW5hbWUpID49IDBcblxuICAgIGhhc0ZpbGVJbmRleDogKGlkeCkgLT4gcmV0dXJuIEBnZXRGaWxlQnlJbmRleChpZHgpP1xuICAgIFxuICAgIGhhc1RhZzogKHRhZ05hbWUpIC0+IHJldHVybiBAZ2V0VGFnSW5kZXgodGFnTmFtZSkgPj0gMFxuICAgIFxuICAgIGlzVmFsaWRUYWc6ICh0YWdOYW1lKSAtPiByZXR1cm4gL15bLV9hLXowLTlcXC5cXFtcXF1dKyQvaS50ZXN0KHRhZ05hbWUpXG4gICAgXG4gICAgaXNWYWxpZEZpbGU6IChmaWxlKSAtPiByZXR1cm4gQGlzVmFsaWRGaWxlbmFtZShmaWxlLmZpbGVuYW1lKSAmJiBhbmd1bGFyLmlzU3RyaW5nKGZpbGUuY29udGVudClcbiAgICBcbiAgICBpc1ZhbGlkRmlsZW5hbWU6IChmaWxlbmFtZSkgLT4gcmV0dXJuIC9eWy1fYS16MC05XFwuXFxbXFxdXSskL2kudGVzdChmaWxlbmFtZSlcbiAgICBcbiAgICBcbiAgICBcbiAgICByZXNldDogKGpzb24gPSB7fSkgLT5cbiAgICAgIGpzb24uZGVzY3JpcHRpb24gfHw9IFwiXCJcbiAgICAgIGpzb24udGFncyB8fD0gW11cbiAgICAgIGpzb24uY3Vyc29yIHx8PSB7IGZpbGVJbmRleDogMCwgdGV4dE9mZnNldDogMCB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc2V0IGZhaWxlZC4gRGVzY3JpcHRpb24gbXVzdCBiZSBhIHN0cmluZy5cIikgdW5sZXNzIGFuZ3VsYXIuaXNTdHJpbmcoanNvbi5kZXNjcmlwdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc2V0IGZhaWxlZC4gVGFncyBtdXN0IGJlIGFuIGFycmF5LlwiKSB1bmxlc3MgYW5ndWxhci5pc0FycmF5KGpzb24udGFncylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc2V0IGZhaWxlZC4gSW52YWxpZCB0YWc6ICN7dGFnTmFtZX0uXCIpIGZvciB0YWdOYW1lIGluIGpzb24udGFncyB3aGVuICFAaXNWYWxpZFRhZyh0YWdOYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzZXQgZmFpbGVkLiBGaWxlcyBtdXN0IGJlIGFuIGFycmF5LlwiKSB1bmxlc3MgYW5ndWxhci5pc0FycmF5KGpzb24uZmlsZXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNldCBmYWlsZWQuIEludmFsaWQgZmlsZTogI3tKU09OLnN0cmluZ2lmeShmaWxlKX0uXCIpIGZvciBmaWxlIGluIGpzb24uZmlsZXMgd2hlbiAhQGlzVmFsaWRGaWxlKGZpbGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNldCBmYWlsZWQuIFRoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIGZpbGUuXCIpIHVubGVzcyBqc29uLmZpbGVzLmxlbmd0aFxuICAgIFxuICAgICAgQF9hcHBseU9wXG4gICAgICAgIHA6IFtdXG4gICAgICAgIG9kOiBhbmd1bGFyLmNvcHkoQGdldFNuYXBzaG90KCkpXG4gICAgICAgIG9pOiBqc29uXG4gICAgXG4gICAgY3Vyc29yU2V0RmlsZTogKGZpbGVuYW1lKSAtPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHNldCB0aGUgYWN0aXZlIGZpbGUuIEZpbGUgZG9lcyBub3QgZXhpc3Q6ICN7ZmlsZW5hbWV9XCIpIHVubGVzcyBAaGFzRmlsZShmaWxlbmFtZSlcbiAgICAgIFxuICAgICAgaWR4ID0gQGdldEZpbGVJbmRleChmaWxlbmFtZSlcbiAgICAgIFxuICAgICAgQF9hcHBseU9wXG4gICAgICAgIHA6IFtcImN1cnNvclwiLCBcImZpbGVJbmRleFwiXVxuICAgICAgICBvZDogQGdldEN1cnNvckZpbGVJbmRleCgpXG4gICAgICAgIG9pOiBpZHhcbiAgICBcbiAgICBjdXJzb3JTZXRJbmRleDogKGlkeCkgLT5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSBzZXQgdGhlIGFjdGl2ZSBmaWxlLiBGaWxlIGRvZXMgbm90IGV4aXN0OiAje2lkeH1cIikgdW5sZXNzIEBoYXNGaWxlSW5kZXgoaWR4KVxuICAgICAgXG4gICAgICBAX2FwcGx5T3BcbiAgICAgICAgcDogW1wiY3Vyc29yXCIsIFwiZmlsZUluZGV4XCJdXG4gICAgICAgIG9kOiBAZ2V0Q3Vyc29yRmlsZUluZGV4KClcbiAgICAgICAgb2k6IGlkeFxuICAgIFxuICAgIGN1cnNvclNldE9mZnNldDogKG9mZnNldCkgLT5cbiAgICAgIEBfYXBwbHlPcFxuICAgICAgICBwOiBbXCJjdXJzb3JcIiwgXCJ0ZXh0T2Zmc2V0XCJdXG4gICAgICAgIG9kOiBAZ2V0Q3Vyc29yVGV4dE9mZnNldCgpXG4gICAgICAgIG9pOiBvZmZzZXRcbiAgICBcbiAgICBzZXREZXNjcmlwdGlvbjogKGRlc2NyaXB0aW9uID0gXCJcIikgLT5cbiAgICAgIEBfYXBwbHlPcFxuICAgICAgICBwOiBbXCJkZXNjcmlwdGlvblwiLCAwXVxuICAgICAgICBzZDogQGdldERlc2NyaXB0aW9uKClcbiAgICAgICAgc2k6IGRlc2NyaXB0aW9uXG4gICAgXG4gICAgXG4gICAgXG4gICAgZmlsZUNyZWF0ZTogKGZpbGVuYW1lLCBjb250ZW50ID0gXCJcIikgLT5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjcmVhdGUgZmlsZS4gSW52YWxpZCBmaWxlbmFtZTogI3tmaWxlbmFtZX1cIikgdW5sZXNzIEBpc1ZhbGlkRmlsZW5hbWUoZmlsZW5hbWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIGZpbGUuIEZpbGUgYWxyZWFkeSBleGlzdHM6ICN7ZmlsZW5hbWV9XCIpIGlmIEBoYXNGaWxlKGZpbGVuYW1lKVxuICAgICAgXG4gICAgICBpZHggPSBAZ2V0TnVtRmlsZXMoKVxuICAgICAgXG4gICAgICBAX2FwcGx5T3BcbiAgICAgICAgcDogW1wiZmlsZXNcIiwgaWR4XVxuICAgICAgICBsaToge2ZpbGVuYW1lLCBjb250ZW50fVxuICAgIFxuICAgIGZpbGVSZW5hbWU6IChmaWxlbmFtZSwgbmV3X2ZpbGVuYW1lKSAtPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSBmaWxlLiBJbnZhbGlkIGZpbGVuYW1lOiAje25ld19maWxlbmFtZX1cIikgdW5sZXNzIEBpc1ZhbGlkRmlsZW5hbWUobmV3X2ZpbGVuYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlbmFtZSBmaWxlLiBGaWxlIGRvZXMgbm90IGV4aXN0OiAje2ZpbGVuYW1lfVwiKSB1bmxlc3MgQGhhc0ZpbGUoZmlsZW5hbWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVuYW1lIGZpbGUuIEEgZmlsZSBhbHJlYWR5IGV4aXN0cyBuYW1lZDogI3tuZXdfZmlsZW5hbWV9XCIpIGlmIEBoYXNGaWxlKG5ld19maWxlbmFtZSlcblxuICAgICAgaWR4ID0gQGdldEZpbGVJbmRleChmaWxlbmFtZSlcbiAgICAgIFxuICAgICAgQF9hcHBseU9wXG4gICAgICAgIHA6IFtcImZpbGVzXCIsIGlkeCwgXCJmaWxlbmFtZVwiXVxuICAgICAgICBvZDogZmlsZW5hbWVcbiAgICAgICAgb2k6IG5ld19maWxlbmFtZVxuXG4gICAgZmlsZVJlbW92ZTogKGZpbGVuYW1lKSAtPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlbW92ZSBmaWxlLiBGaWxlIGRvZXMgbm90IGV4aXN0OiAje2ZpbGVuYW1lfVwiKSB1bmxlc3MgQGhhc0ZpbGUoZmlsZW5hbWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVtb3ZlIGZpbGUuIFlvdSBjYW4gbm90IHJlbW92ZSBhbGwgZmlsZXMuXCIpIGlmIEBnZXROdW1GaWxlcygpIDw9IDFcblxuICAgICAgaWR4ID0gQGdldEZpbGVJbmRleChmaWxlbmFtZSlcbiAgICAgIFxuICAgICAgQGN1cnNvclNldEluZGV4KDApXG4gICAgXG4gICAgICBAX2FwcGx5T3BcbiAgICAgICAgcDogW1wiZmlsZXNcIiwgaWR4XVxuICAgICAgICBsZDogQGdldEZpbGUoZmlsZW5hbWUpXG4gICAgICAgIFxuICAgIFxuICAgIFxuICAgIHRleHRJbnNlcnQ6IChmaWxlbmFtZSwgb2Zmc2V0LCB0ZXh0KSAtPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGluc2VydCB0ZXh0LiBGaWxlIGRvZXMgbm90IGV4aXN0OiAje2ZpbGVuYW1lfVwiKSB1bmxlc3MgQGhhc0ZpbGUoZmlsZW5hbWUpXG4gICAgICBcbiAgICAgIGlkeCA9IEBnZXRGaWxlSW5kZXgoZmlsZW5hbWUpXG5cbiAgICAgIEBfYXBwbHlPcFxuICAgICAgICBwOiBbXCJmaWxlc1wiLCBpZHgsIFwiY29udGVudFwiLCBvZmZzZXRdXG4gICAgICAgIHNpOiB0ZXh0XG5cbiAgICB0ZXh0UmVtb3ZlOiAoZmlsZW5hbWUsIG9mZnNldCwgdGV4dCkgLT5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZW1vdmUgdGV4dC4gRmlsZSBkb2VzIG5vdCBleGlzdDogI3tmaWxlbmFtZX1cIikgdW5sZXNzIEBoYXNGaWxlKGZpbGVuYW1lKVxuICAgICAgXG4gICAgICBpZHggPSBAZ2V0RmlsZUluZGV4KGZpbGVuYW1lKVxuXG4gICAgICBAX2FwcGx5T3BcbiAgICAgICAgcDogW1wiZmlsZXNcIiwgaWR4LCBcImNvbnRlbnRcIiwgb2Zmc2V0XVxuICAgICAgICBzZDogdGV4dFxuICAgIFxuICAgIFxuICAgIFxuICAgIHRhZ0FkZDogKHRhZ05hbWUpIC0+XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYWRkIHRhZy4gSW52YWxpZCB0YWc6ICN7dGFnTmFtZX1cIikgdW5sZXNzIEBpc1ZhbGlkVGFnKHRhZ05hbWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYWRkIHRhZy4gVGFnIGFscmVhZHkgZXhpc3RzOiAje3RhZ05hbWV9XCIpIGlmIEBoYXNUYWcodGFnTmFtZSlcbiAgICAgIFxuICAgICAgaWR4ID0gQGdldE51bVRhZ3MoKVxuICAgICAgXG4gICAgICBAX2FwcGx5T3BcbiAgICAgICAgcDogW1widGFnc1wiLCBpZHhdXG4gICAgICAgIGxpOiB0YWdOYW1lXG5cbiAgICB0YWdSZW1vdmU6ICh0YWdOYW1lKSAtPlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlbW92ZSB0YWcuIFRhZyBub3QgZm91bmQ6ICN7dGFnTmFtZX1cIikgdW5sZXNzIEBoYXNUYWcodGFnTmFtZSlcbiAgICAgIFxuICAgICAgaWR4ID0gQGdldFRhZ0luZGV4KHRhZ05hbWUpXG4gICAgICBcbiAgICAgIEBfYXBwbHlPcFxuICAgICAgICBwOiBbXCJ0YWdzXCIsIGlkeF1cbiAgICAgICAgbGQ6IHRhZ05hbWVcbiAgXG4gIFxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBAJGNsaWVudHMgPSB7fVxuICAgIFxuICAgIEBzbmFwc2hvdCA9IHt9XG4gICAgQGlmYWNlID0gQGNyZWF0ZUNsaWVudChcInNlc3Npb25cIilcbiAgICBcbiAgICBAaWZhY2UucmVzZXRcbiAgICAgIGZpbGVzOiBbXG4gICAgICAgIGZpbGVuYW1lOiBcImluZGV4Lmh0bWxcIlxuICAgICAgICBjb250ZW50OiBcIlwiXG4gICAgICBdXG4gIFxuICBjcmVhdGVDbGllbnQ6IChjbGllbnROYW1lKSAtPlxuICAgICN0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIGNsaWVudC4gQ2xpZW50IGFscmVhZHkgY3JlYXRlZDogI3tjbGllbnROYW1lfS5cIikgaWYgQCRjbGllbnRzW2NsaWVudE5hbWVdXG4gICAgXG4gICAgc2Vzc2lvbiA9IEBcbiAgICBcbiAgICBAJGNsaWVudHNbY2xpZW50TmFtZV0gfHw9IG5ldyBTZXNzaW9uQ2xpZW50KGNsaWVudE5hbWUsIHNlc3Npb24pXG4gIFxuICBhcHBseU9wczogKHNvdXJjZUNsaWVudE5hbWUsIG9wcykgLT5cbiAgICBwb3N0U25hcHNob3QgPSBvdHR5cGVzLmpzb24wLmFwcGx5IEBzbmFwc2hvdCwgb3BzXG4gICAgXG4gICAgY29uc29sZS5sb2cgXCJbT1RdIG9wXCIsIG9wIGZvciBvcCBpbiBvcHNcbiAgICBjb25zb2xlLmxvZyBcIltPVF0gc25hcHNob3RcIiwgYW5ndWxhci5jb3B5KEBzbmFwc2hvdClcbiAgICBcbiAgICBhbmd1bGFyLmNvcHkgcG9zdFNuYXBzaG90LCBAc25hcHNob3QgdW5sZXNzIEBzbmFwc2hvdCA9PSBwb3N0U25hcHNob3RcbiAgICBcbiAgICBmb3IgY2xpZW50TmFtZSwgY2xpZW50IG9mIEAkY2xpZW50cyB3aGVuIGNsaWVudE5hbWUgIT0gc291cmNlQ2xpZW50TmFtZVxuICAgICAgY2xpZW50Ll9oYW5kbGVPcChzb3VyY2VDbGllbnROYW1lLCBvcCwgQHNuYXBzaG90KSBmb3Igb3AgaW4gb3BzXG4gICAgICBcbiIsIm1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlIFwicGx1bmtlci5zZXJ2aWNlLnNldHRpbmdzXCIsIFtdXHJcblxyXG5tb2R1bGUuc2VydmljZSBcInNldHRpbmdzXCIsIFsgKCkgLT5cclxuICBcclxuICBzZXR0aW5ncyA9XHJcbiAgICBwcmV2aWV3ZXI6XHJcbiAgICAgIGRlbGF5OiAxMDAwXHJcbiAgICAgIGF1dG9fcmVmcmVzaDogdHJ1ZVxyXG4gICAgZWRpdG9yOlxyXG4gICAgICB0YWJfc2l6ZTogMlxyXG4gICAgICBzb2Z0X3RhYnM6IHRydWVcclxuICAgICAgdGhlbWU6IFwidGV4dG1hdGVcIlxyXG4gICAgICB3cmFwOlxyXG4gICAgICAgIHJhbmdlOlxyXG4gICAgICAgICAgbWluOiAwXHJcbiAgICAgICAgICBtYXg6IDgwXHJcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcclxuICAgICAgICBcclxuICBcclxuICBcclxuICBpZiBsb2NhbFN0b3JhZ2U/XHJcbiAgICBpZiBzYXZlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwicGxua3Jfc2V0dGluZ3NcIilcclxuICAgICAgdHJ5XHJcbiAgICAgICAgc2F2ZWQgPSBKU09OLnBhcnNlKHNhdmVkKVxyXG4gICAgICBjYXRjaCBlXHJcbiAgICAgICAgc2F2ZWQgPSB7fVxyXG4gICAgICBcclxuICAgIHNldEludGVydmFsIC0+XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtIFwicGxua3Jfc2V0dGluZ3NcIiwgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpXHJcbiAgICAsIDIwMDBcclxuICBcclxuICBhbmd1bGFyLmV4dGVuZCBzZXR0aW5ncywgc2F2ZWRcclxuICBcclxuXSIsIm1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlIFwicGx1bmtlci5zZXJ2aWNlLnR5cGVzXCIsIFtcbl1cblxuXG5tb2R1bGUuZmFjdG9yeSBcInR5cGVzXCIsIC0+XG4gIHR5cGVzID1cbiAgICBodG1sOlxuICAgICAgcmVnZXg6IC9cXC5odG1sJC9pXG4gICAgICBtaW1lOiBcInRleHQvaHRtbFwiXG4gICAgamF2YXNjcmlwdDpcbiAgICAgIHJlZ2V4OiAvXFwuanMkL2lcbiAgICAgIG1pbWU6IFwidGV4dC9qYXZhc2NyaXB0XCJcbiAgICBjb2ZmZWU6XG4gICAgICByZWdleDogL1xcLmNvZmZlZSQvaVxuICAgICAgbWltZTogXCJ0ZXh0L2NvZmZlZVwiXG4gICAgY3NzOlxuICAgICAgcmVnZXg6IC9cXC5jc3MkL2lcbiAgICAgIG1pbWU6IFwidGV4dC9jc3NcIlxuICAgIHRleHQ6XG4gICAgICByZWdleDogL1xcLnR4dCQvXG4gICAgICBtaW1lOiBcInRleHQvcGxhaW5cIlxuICBcbiAgZm9yIG5hbWUsIHR5cGUgb2YgdHlwZXNcbiAgICB0eXBlLm5hbWUgPSBuYW1lXG4gIFxuICB0eXBlczogdHlwZXNcbiAgZ2V0QnlGaWxlbmFtZTogKGZpbGVuYW1lKSAtPlxuICAgIGZvciBuYW1lLCBtb2RlIG9mIHR5cGVzXG4gICAgICBpZiBtb2RlLnJlZ2V4LnRlc3QoZmlsZW5hbWUpIHRoZW4gcmV0dXJuIG1vZGVcbiAgICBcbiAgICByZXR1cm4gdHlwZXMudGV4dFxuXG5cbiIsIm1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlIFwicGx1bmtlci5zZXJ2aWNlLnVybFwiLCBbXVxuXG5tb2R1bGUuY29uc3RhbnQgXCJ1cmxcIiwgX3BsdW5rZXIudXJsIiwiLyoqXHJcbiAqIGFuZ3VsYXItZ3Jvd2wgLSB2MC4zLjAgLSAyMDEzLTA5LTI2XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjb3JpbmNrL2FuZ3VsYXItZ3Jvd2xcclxuICogQ29weXJpZ2h0IChjKSAyMDEzIE1hcmNvIFJpbmNrOyBMaWNlbnNlZCBNSVRcclxuICovXHJcbmFuZ3VsYXIubW9kdWxlKCdhbmd1bGFyLWdyb3dsJywgW10pO1xyXG5hbmd1bGFyLm1vZHVsZSgnYW5ndWxhci1ncm93bCcpLmRpcmVjdGl2ZSgnZ3Jvd2wnLCBbXHJcbiAgJyRyb290U2NvcGUnLFxyXG4gIGZ1bmN0aW9uICgkcm9vdFNjb3BlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJncm93bFwiPicgKyAnXFx0PGRpdiBjbGFzcz1cImdyb3dsLWl0ZW0gYWxlcnRcIiBuZy1yZXBlYXQ9XCJtZXNzYWdlIGluIG1lc3NhZ2VzXCIgbmctY2xhc3M9XCJjb21wdXRlQ2xhc3NlcyhtZXNzYWdlKVwiPicgKyAnXFx0XFx0PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIG5nLWNsaWNrPVwiZGVsZXRlTWVzc2FnZShtZXNzYWdlKVwiPiZ0aW1lczs8L2J1dHRvbj4nICsgJyAgICAgICAgICAgIHt7IG1lc3NhZ2UudGV4dH19JyArICdcXHQ8L2Rpdj4nICsgJzwvZGl2PicsXHJcbiAgICAgIHJlcGxhY2U6IGZhbHNlLFxyXG4gICAgICBzY29wZTogdHJ1ZSxcclxuICAgICAgY29udHJvbGxlcjogW1xyXG4gICAgICAgICckc2NvcGUnLFxyXG4gICAgICAgICckdGltZW91dCcsXHJcbiAgICAgICAgZnVuY3Rpb24gKCRzY29wZSwgJHRpbWVvdXQpIHtcclxuICAgICAgICAgICRzY29wZS5tZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgICAgJHJvb3RTY29wZS4kb24oJ2dyb3dsTWVzc2FnZScsIGZ1bmN0aW9uIChldmVudCwgbWVzc2FnZSkge1xyXG4gICAgICAgICAgICAkc2NvcGUubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHRsICYmIG1lc3NhZ2UudHRsICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICRzY29wZS5kZWxldGVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgIH0sIG1lc3NhZ2UudHRsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAkc2NvcGUuZGVsZXRlTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9ICRzY29wZS5tZXNzYWdlcy5pbmRleE9mKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICRzY29wZS5tZXNzYWdlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgJHNjb3BlLmNvbXB1dGVDbGFzc2VzID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAnYWxlcnQtc3VjY2Vzcyc6IG1lc3NhZ2UuaXNTdWNjZXNzLFxyXG4gICAgICAgICAgICAgICdhbGVydC1kYW5nZXInOiBtZXNzYWdlLmlzRXJyb3IsXHJcbiAgICAgICAgICAgICAgJ2FsZXJ0LXdhcm5pbmcnOiBtZXNzYWdlLmlzV2FybixcclxuICAgICAgICAgICAgICAnYWxlcnQtaW5mbyc6IG1lc3NhZ2UuaXNJbmZvXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbl0pO1xyXG5hbmd1bGFyLm1vZHVsZSgnYW5ndWxhci1ncm93bCcpLnByb3ZpZGVyKCdncm93bCcsIGZ1bmN0aW9uICgpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgdmFyIF90dGwgPSBudWxsLCBfbWVzc2FnZXNLZXkgPSAnbWVzc2FnZXMnLCBfbWVzc2FnZVRleHRLZXkgPSAndGV4dCcsIF9tZXNzYWdlU2V2ZXJpdHlLZXkgPSAnc2V2ZXJpdHknO1xyXG4gIHRoaXMuZ2xvYmFsVGltZVRvTGl2ZSA9IGZ1bmN0aW9uICh0dGwpIHtcclxuICAgIF90dGwgPSB0dGw7XHJcbiAgfTtcclxuICB0aGlzLm1lc3NhZ2VzS2V5ID0gZnVuY3Rpb24gKG1lc3NhZ2VzS2V5KSB7XHJcbiAgICBfbWVzc2FnZXNLZXkgPSBtZXNzYWdlc0tleTtcclxuICB9O1xyXG4gIHRoaXMubWVzc2FnZVRleHRLZXkgPSBmdW5jdGlvbiAobWVzc2FnZVRleHRLZXkpIHtcclxuICAgIF9tZXNzYWdlVGV4dEtleSA9IG1lc3NhZ2VUZXh0S2V5O1xyXG4gIH07XHJcbiAgdGhpcy5tZXNzYWdlU2V2ZXJpdHlLZXkgPSBmdW5jdGlvbiAobWVzc2FnZVNldmVyaXR5S2V5KSB7XHJcbiAgICBfbWVzc2FnZVNldmVyaXR5S2V5ID0gbWVzc2FnZVNldmVyaXR5S2V5O1xyXG4gIH07XHJcbiAgdGhpcy5zZXJ2ZXJNZXNzYWdlc0ludGVyY2VwdG9yID0gW1xyXG4gICAgJyRxJyxcclxuICAgICdncm93bCcsXHJcbiAgICBmdW5jdGlvbiAoJHEsIGdyb3dsKSB7XHJcbiAgICAgIGZ1bmN0aW9uIGNoZWNrUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuICAgICAgICBpZiAocmVzcG9uc2UuZGF0YVtfbWVzc2FnZXNLZXldICYmIHJlc3BvbnNlLmRhdGFbX21lc3NhZ2VzS2V5XS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBncm93bC5hZGRTZXJ2ZXJNZXNzYWdlcyhyZXNwb25zZS5kYXRhW19tZXNzYWdlc0tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBzdWNjZXNzKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgY2hlY2tSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIGVycm9yKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgY2hlY2tSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICAgICAgcmV0dXJuICRxLnJlamVjdChyZXNwb25zZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9taXNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgXTtcclxuICB0aGlzLiRnZXQgPSBbXHJcbiAgICAnJHJvb3RTY29wZScsXHJcbiAgICAnJGZpbHRlcicsXHJcbiAgICBmdW5jdGlvbiAoJHJvb3RTY29wZSwgJGZpbHRlcikge1xyXG4gICAgICB2YXIgdHJhbnNsYXRlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRyYW5zbGF0ZSA9ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gYnJvYWRjYXN0TWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zbGF0ZSkge1xyXG4gICAgICAgICAgbWVzc2FnZSA9IHRyYW5zbGF0ZShtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdncm93bE1lc3NhZ2UnLCBtZXNzYWdlKTtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBzZW5kTWVzc2FnZSh0ZXh0LCBjb25maWcsIHNldmVyaXR5KSB7XHJcbiAgICAgICAgdmFyIF9jb25maWcgPSBjb25maWcgfHwge30sIG1lc3NhZ2U7XHJcbiAgICAgICAgbWVzc2FnZSA9IHtcclxuICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICBpc1dhcm46IHNldmVyaXR5LmlzV2FybixcclxuICAgICAgICAgIGlzRXJyb3I6IHNldmVyaXR5LmlzRXJyb3IsXHJcbiAgICAgICAgICBpc0luZm86IHNldmVyaXR5LmlzSW5mbyxcclxuICAgICAgICAgIGlzU3VjY2Vzczogc2V2ZXJpdHkuaXNTdWNjZXNzLFxyXG4gICAgICAgICAgdHRsOiBfY29uZmlnLnR0bCB8fCBfdHRsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBicm9hZGNhc3RNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIGFkZFdhcm5NZXNzYWdlKHRleHQsIGNvbmZpZykge1xyXG4gICAgICAgIHNlbmRNZXNzYWdlKHRleHQsIGNvbmZpZywgeyBpc1dhcm46IHRydWUgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gYWRkRXJyb3JNZXNzYWdlKHRleHQsIGNvbmZpZykge1xyXG4gICAgICAgIHNlbmRNZXNzYWdlKHRleHQsIGNvbmZpZywgeyBpc0Vycm9yOiB0cnVlIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGZ1bmN0aW9uIGFkZEluZm9NZXNzYWdlKHRleHQsIGNvbmZpZykge1xyXG4gICAgICAgIHNlbmRNZXNzYWdlKHRleHQsIGNvbmZpZywgeyBpc0luZm86IHRydWUgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZnVuY3Rpb24gYWRkU3VjY2Vzc01lc3NhZ2UodGV4dCwgY29uZmlnKSB7XHJcbiAgICAgICAgc2VuZE1lc3NhZ2UodGV4dCwgY29uZmlnLCB7IGlzU3VjY2VzczogdHJ1ZSB9KTtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBhZGRTZXJ2ZXJNZXNzYWdlcyhtZXNzYWdlcykge1xyXG4gICAgICAgIHZhciBpLCBtZXNzYWdlLCBzZXZlcml0eSwgbGVuZ3RoO1xyXG4gICAgICAgIGxlbmd0aCA9IG1lc3NhZ2VzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc1tpXTtcclxuICAgICAgICAgIGlmIChtZXNzYWdlW19tZXNzYWdlVGV4dEtleV0gJiYgbWVzc2FnZVtfbWVzc2FnZVNldmVyaXR5S2V5XSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2VbX21lc3NhZ2VTZXZlcml0eUtleV0pIHtcclxuICAgICAgICAgICAgY2FzZSAnd2Fybic6XHJcbiAgICAgICAgICAgICAgc2V2ZXJpdHkgPSB7IGlzV2FybjogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdzdWNjZXNzJzpcclxuICAgICAgICAgICAgICBzZXZlcml0eSA9IHsgaXNTdWNjZXNzOiB0cnVlIH07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2luZm8nOlxyXG4gICAgICAgICAgICAgIHNldmVyaXR5ID0geyBpc0luZm86IHRydWUgfTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxyXG4gICAgICAgICAgICAgIHNldmVyaXR5ID0geyBpc0Vycm9yOiB0cnVlIH07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VuZE1lc3NhZ2UobWVzc2FnZVtfbWVzc2FnZVRleHRLZXldLCB1bmRlZmluZWQsIHNldmVyaXR5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBhZGRXYXJuTWVzc2FnZTogYWRkV2Fybk1lc3NhZ2UsXHJcbiAgICAgICAgYWRkRXJyb3JNZXNzYWdlOiBhZGRFcnJvck1lc3NhZ2UsXHJcbiAgICAgICAgYWRkSW5mb01lc3NhZ2U6IGFkZEluZm9NZXNzYWdlLFxyXG4gICAgICAgIGFkZFN1Y2Nlc3NNZXNzYWdlOiBhZGRTdWNjZXNzTWVzc2FnZSxcclxuICAgICAgICBhZGRTZXJ2ZXJNZXNzYWdlczogYWRkU2VydmVyTWVzc2FnZXNcclxuICAgICAgfTtcclxuICAgIH1cclxuICBdO1xyXG59KTsiLCJhbmd1bGFyLm1vZHVsZShcInVpLmJvb3RzdHJhcFwiLCBbXCJ1aS5ib290c3RyYXAudHBsc1wiLCBcInVpLmJvb3RzdHJhcC50cmFuc2l0aW9uXCIsXCJ1aS5ib290c3RyYXAuY29sbGFwc2VcIixcInVpLmJvb3RzdHJhcC5hY2NvcmRpb25cIixcInVpLmJvb3RzdHJhcC5hbGVydFwiLFwidWkuYm9vdHN0cmFwLmJpbmRIdG1sXCIsXCJ1aS5ib290c3RyYXAuYnV0dG9uc1wiLFwidWkuYm9vdHN0cmFwLmNhcm91c2VsXCIsXCJ1aS5ib290c3RyYXAucG9zaXRpb25cIixcInVpLmJvb3RzdHJhcC5kYXRlcGlja2VyXCIsXCJ1aS5ib290c3RyYXAuZHJvcGRvd25Ub2dnbGVcIixcInVpLmJvb3RzdHJhcC5tb2RhbFwiLFwidWkuYm9vdHN0cmFwLnBhZ2luYXRpb25cIixcInVpLmJvb3RzdHJhcC50b29sdGlwXCIsXCJ1aS5ib290c3RyYXAucG9wb3ZlclwiLFwidWkuYm9vdHN0cmFwLnByb2dyZXNzYmFyXCIsXCJ1aS5ib290c3RyYXAucmF0aW5nXCIsXCJ1aS5ib290c3RyYXAudGFic1wiLFwidWkuYm9vdHN0cmFwLnRpbWVwaWNrZXJcIixcInVpLmJvb3RzdHJhcC50eXBlYWhlYWRcIl0pO1xyXG5hbmd1bGFyLm1vZHVsZShcInVpLmJvb3RzdHJhcC50cGxzXCIsIFtcInRlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsXCJ0ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXCIsXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLFwidGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXCIsXCJ0ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sXCIsXCJ0ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sXCIsXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtdW5zYWZlLXBvcHVwLmh0bWxcIixcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXCIsXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbFwiLFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWxcIixcInRlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWxcIixcInRlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLFwidGVtcGxhdGUvdGFicy90YWIuaHRtbFwiLFwidGVtcGxhdGUvdGFicy90YWJzZXQtdGl0bGVzLmh0bWxcIixcInRlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcIixcInRlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sXCIsXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcIixcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiXSk7XHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudHJhbnNpdGlvbicsIFtdKVxyXG5cclxuLyoqXHJcbiAqICR0cmFuc2l0aW9uIHNlcnZpY2UgcHJvdmlkZXMgYSBjb25zaXN0ZW50IGludGVyZmFjZSB0byB0cmlnZ2VyIENTUyAzIHRyYW5zaXRpb25zIGFuZCB0byBiZSBpbmZvcm1lZCB3aGVuIHRoZXkgY29tcGxldGUuXHJcbiAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGVsZW1lbnQgIFRoZSBET01FbGVtZW50IHRoYXQgd2lsbCBiZSBhbmltYXRlZC5cclxuICogQHBhcmFtICB7c3RyaW5nfG9iamVjdHxmdW5jdGlvbn0gdHJpZ2dlciAgVGhlIHRoaW5nIHRoYXQgd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBzdGFydDpcclxuICogICAtIEFzIGEgc3RyaW5nLCBpdCByZXByZXNlbnRzIHRoZSBjc3MgY2xhc3MgdG8gYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQuXHJcbiAqICAgLSBBcyBhbiBvYmplY3QsIGl0IHJlcHJlc2VudHMgYSBoYXNoIG9mIHN0eWxlIGF0dHJpYnV0ZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudC5cclxuICogICAtIEFzIGEgZnVuY3Rpb24sIGl0IHJlcHJlc2VudHMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdGhhdCB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIG9jY3VyLlxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAgQSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlcy5cclxuICovXHJcbi5mYWN0b3J5KCckdHJhbnNpdGlvbicsIFsnJHEnLCAnJHRpbWVvdXQnLCAnJHJvb3RTY29wZScsIGZ1bmN0aW9uKCRxLCAkdGltZW91dCwgJHJvb3RTY29wZSkge1xyXG5cclxuICB2YXIgJHRyYW5zaXRpb24gPSBmdW5jdGlvbihlbGVtZW50LCB0cmlnZ2VyLCBvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XHJcbiAgICB2YXIgZW5kRXZlbnROYW1lID0gJHRyYW5zaXRpb25bb3B0aW9ucy5hbmltYXRpb24gPyBcImFuaW1hdGlvbkVuZEV2ZW50TmFtZVwiIDogXCJ0cmFuc2l0aW9uRW5kRXZlbnROYW1lXCJdO1xyXG5cclxuICAgIHZhciB0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICRyb290U2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGVsZW1lbnQudW5iaW5kKGVuZEV2ZW50TmFtZSwgdHJhbnNpdGlvbkVuZEhhbmRsZXIpO1xyXG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoZWxlbWVudCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoZW5kRXZlbnROYW1lKSB7XHJcbiAgICAgIGVsZW1lbnQuYmluZChlbmRFdmVudE5hbWUsIHRyYW5zaXRpb25FbmRIYW5kbGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXcmFwIGluIGEgdGltZW91dCB0byBhbGxvdyB0aGUgYnJvd3NlciB0aW1lIHRvIHVwZGF0ZSB0aGUgRE9NIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBpcyB0byBvY2N1clxyXG4gICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICggYW5ndWxhci5pc1N0cmluZyh0cmlnZ2VyKSApIHtcclxuICAgICAgICBlbGVtZW50LmFkZENsYXNzKHRyaWdnZXIpO1xyXG4gICAgICB9IGVsc2UgaWYgKCBhbmd1bGFyLmlzRnVuY3Rpb24odHJpZ2dlcikgKSB7XHJcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50KTtcclxuICAgICAgfSBlbHNlIGlmICggYW5ndWxhci5pc09iamVjdCh0cmlnZ2VyKSApIHtcclxuICAgICAgICBlbGVtZW50LmNzcyh0cmlnZ2VyKTtcclxuICAgICAgfVxyXG4gICAgICAvL0lmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0cmFuc2l0aW9ucywgaW5zdGFudGx5IHJlc29sdmVcclxuICAgICAgaWYgKCAhZW5kRXZlbnROYW1lICkge1xyXG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCBvdXIgY3VzdG9tIGNhbmNlbCBmdW5jdGlvbiB0byB0aGUgcHJvbWlzZSB0aGF0IGlzIHJldHVybmVkXHJcbiAgICAvLyBXZSBjYW4gY2FsbCB0aGlzIGlmIHdlIGFyZSBhYm91dCB0byBydW4gYSBuZXcgdHJhbnNpdGlvbiwgd2hpY2ggd2Uga25vdyB3aWxsIHByZXZlbnQgdGhpcyB0cmFuc2l0aW9uIGZyb20gZW5kaW5nLFxyXG4gICAgLy8gaS5lLiBpdCB3aWxsIHRoZXJlZm9yZSBuZXZlciByYWlzZSBhIHRyYW5zaXRpb25FbmQgZXZlbnQgZm9yIHRoYXQgdHJhbnNpdGlvblxyXG4gICAgZGVmZXJyZWQucHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCBlbmRFdmVudE5hbWUgKSB7XHJcbiAgICAgICAgZWxlbWVudC51bmJpbmQoZW5kRXZlbnROYW1lLCB0cmFuc2l0aW9uRW5kSGFuZGxlcik7XHJcbiAgICAgIH1cclxuICAgICAgZGVmZXJyZWQucmVqZWN0KCdUcmFuc2l0aW9uIGNhbmNlbGxlZCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICB9O1xyXG5cclxuICAvLyBXb3JrIG91dCB0aGUgbmFtZSBvZiB0aGUgdHJhbnNpdGlvbkVuZCBldmVudFxyXG4gIHZhciB0cmFuc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFucycpO1xyXG4gIHZhciB0cmFuc2l0aW9uRW5kRXZlbnROYW1lcyA9IHtcclxuICAgICdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxyXG4gICAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXHJcbiAgICAnT1RyYW5zaXRpb24nOiAnb1RyYW5zaXRpb25FbmQnLFxyXG4gICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCdcclxuICB9O1xyXG4gIHZhciBhbmltYXRpb25FbmRFdmVudE5hbWVzID0ge1xyXG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcclxuICAgICdNb3pUcmFuc2l0aW9uJzogJ2FuaW1hdGlvbmVuZCcsXHJcbiAgICAnT1RyYW5zaXRpb24nOiAnb0FuaW1hdGlvbkVuZCcsXHJcbiAgICAndHJhbnNpdGlvbic6ICdhbmltYXRpb25lbmQnXHJcbiAgfTtcclxuICBmdW5jdGlvbiBmaW5kRW5kRXZlbnROYW1lKGVuZEV2ZW50TmFtZXMpIHtcclxuICAgIGZvciAodmFyIG5hbWUgaW4gZW5kRXZlbnROYW1lcyl7XHJcbiAgICAgIGlmICh0cmFuc0VsZW1lbnQuc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBlbmRFdmVudE5hbWVzW25hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gICR0cmFuc2l0aW9uLnRyYW5zaXRpb25FbmRFdmVudE5hbWUgPSBmaW5kRW5kRXZlbnROYW1lKHRyYW5zaXRpb25FbmRFdmVudE5hbWVzKTtcclxuICAkdHJhbnNpdGlvbi5hbmltYXRpb25FbmRFdmVudE5hbWUgPSBmaW5kRW5kRXZlbnROYW1lKGFuaW1hdGlvbkVuZEV2ZW50TmFtZXMpO1xyXG4gIHJldHVybiAkdHJhbnNpdGlvbjtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5jb2xsYXBzZScsWyd1aS5ib290c3RyYXAudHJhbnNpdGlvbiddKVxyXG5cclxuLy8gVGhlIGNvbGxhcHNpYmxlIGRpcmVjdGl2ZSBpbmRpY2F0ZXMgYSBibG9jayBvZiBodG1sIHRoYXQgd2lsbCBleHBhbmQgYW5kIGNvbGxhcHNlXHJcbi5kaXJlY3RpdmUoJ2NvbGxhcHNlJywgWyckdHJhbnNpdGlvbicsIGZ1bmN0aW9uKCR0cmFuc2l0aW9uKSB7XHJcbiAgLy8gQ1NTIHRyYW5zaXRpb25zIGRvbid0IHdvcmsgd2l0aCBoZWlnaHQ6IGF1dG8sIHNvIHdlIGhhdmUgdG8gbWFudWFsbHkgY2hhbmdlIHRoZSBoZWlnaHQgdG8gYVxyXG4gIC8vIHNwZWNpZmljIHZhbHVlIGFuZCB0aGVuIG9uY2UgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXMsIHdlIGNhbiByZXNldCB0aGUgaGVpZ2h0IHRvIGF1dG8uXHJcbiAgLy8gVW5mb3J0dW5hdGVseSBpZiB5b3UgZG8gdGhpcyB3aGlsZSB0aGUgQ1NTIHRyYW5zaXRpb25zIGFyZSBzcGVjaWZpZWQgKGkuZS4gaW4gdGhlIENTUyBjbGFzc1xyXG4gIC8vIFwiY29sbGFwc2VcIikgdGhlbiB5b3UgdHJpZ2dlciBhIGNoYW5nZSB0byBoZWlnaHQgMCBpbiBiZXR3ZWVuLlxyXG4gIC8vIFRoZSBmaXggaXMgdG8gcmVtb3ZlIHRoZSBcImNvbGxhcHNlXCIgQ1NTIGNsYXNzIHdoaWxlIGNoYW5naW5nIHRoZSBoZWlnaHQgYmFjayB0byBhdXRvIC0gcGhldyFcclxuICB2YXIgZml4VXBIZWlnaHQgPSBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgaGVpZ2h0KSB7XHJcbiAgICAvLyBXZSByZW1vdmUgdGhlIGNvbGxhcHNlIENTUyBjbGFzcyB0byBwcmV2ZW50IGEgdHJhbnNpdGlvbiB3aGVuIHdlIGNoYW5nZSB0byBoZWlnaHQ6IGF1dG9cclxuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlJyk7XHJcbiAgICBlbGVtZW50LmNzcyh7IGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgLy8gSXQgYXBwZWFycyB0aGF0ICByZWFkaW5nIG9mZnNldFdpZHRoIG1ha2VzIHRoZSBicm93c2VyIHJlYWxpc2UgdGhhdCB3ZSBoYXZlIGNoYW5nZWQgdGhlXHJcbiAgICAvLyBoZWlnaHQgYWxyZWFkeSA6LS9cclxuICAgIHZhciB4ID0gZWxlbWVudFswXS5vZmZzZXRXaWR0aDtcclxuICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2NvbGxhcHNlJyk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG5cclxuICAgICAgdmFyIGlzQ29sbGFwc2VkO1xyXG4gICAgICB2YXIgaW5pdGlhbEFuaW1Ta2lwID0gdHJ1ZTtcclxuICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpeyByZXR1cm4gZWxlbWVudFswXS5zY3JvbGxIZWlnaHQ7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIC8vVGhlIGxpc3RlbmVyIGlzIGNhbGxlZCB3aGVuIHNjb2xsSGVpZ2h0IGNoYW5nZXNcclxuICAgICAgICAvL0l0IGFjdHVhbGx5IGRvZXMgb24gMiBzY2VuYXJpb3M6IFxyXG4gICAgICAgIC8vIDEuIFBhcmVudCBpcyBzZXQgdG8gZGlzcGxheSBub25lXHJcbiAgICAgICAgLy8gMi4gYW5ndWxhciBiaW5kaW5ncyBpbnNpZGUgYXJlIHJlc29sdmVkXHJcbiAgICAgICAgLy9XaGVuIHdlIGhhdmUgYSBjaGFuZ2Ugb2Ygc2Nyb2xsSGVpZ2h0IHdlIGFyZSBzZXR0aW5nIGFnYWluIHRoZSBjb3JyZWN0IGhlaWdodCBpZiB0aGUgZ3JvdXAgaXMgb3BlbmVkXHJcbiAgICAgICAgaWYgKGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ICE9PSAwKSB7XHJcbiAgICAgICAgICBpZiAoIWlzQ29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgIGlmIChpbml0aWFsQW5pbVNraXApIHtcclxuICAgICAgICAgICAgICBmaXhVcEhlaWdodChzY29wZSwgZWxlbWVudCwgZWxlbWVudFswXS5zY3JvbGxIZWlnaHQgKyAncHgnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBmaXhVcEhlaWdodChzY29wZSwgZWxlbWVudCwgJ2F1dG8nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBzY29wZS4kd2F0Y2goYXR0cnMuY29sbGFwc2UsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICBjb2xsYXBzZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBleHBhbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuXHJcbiAgICAgIHZhciBjdXJyZW50VHJhbnNpdGlvbjtcclxuICAgICAgdmFyIGRvVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGNoYW5nZSkge1xyXG4gICAgICAgIGlmICggY3VycmVudFRyYW5zaXRpb24gKSB7XHJcbiAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5jYW5jZWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24gPSAkdHJhbnNpdGlvbihlbGVtZW50LGNoYW5nZSk7XHJcbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24udGhlbihcclxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyBjdXJyZW50VHJhbnNpdGlvbiA9IHVuZGVmaW5lZDsgfSxcclxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyBjdXJyZW50VHJhbnNpdGlvbiA9IHVuZGVmaW5lZDsgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUcmFuc2l0aW9uO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGV4cGFuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChpbml0aWFsQW5pbVNraXApIHtcclxuICAgICAgICAgIGluaXRpYWxBbmltU2tpcCA9IGZhbHNlO1xyXG4gICAgICAgICAgaWYgKCAhaXNDb2xsYXBzZWQgKSB7XHJcbiAgICAgICAgICAgIGZpeFVwSGVpZ2h0KHNjb3BlLCBlbGVtZW50LCAnYXV0bycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkb1RyYW5zaXRpb24oeyBoZWlnaHQgOiBlbGVtZW50WzBdLnNjcm9sbEhlaWdodCArICdweCcgfSlcclxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGNoZWNrIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHkgdXBkYXRlIHRoZSBoZWlnaHQgaWYgdGhlIHVzZXIgaGFzIGNsb3NlZFxyXG4gICAgICAgICAgICAvLyB0aGUgZ3JvdXAgd2hpbGUgdGhlIGFuaW1hdGlvbiB3YXMgc3RpbGwgcnVubmluZ1xyXG4gICAgICAgICAgICBpZiAoICFpc0NvbGxhcHNlZCApIHtcclxuICAgICAgICAgICAgICBmaXhVcEhlaWdodChzY29wZSwgZWxlbWVudCwgJ2F1dG8nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlzQ29sbGFwc2VkID0gZmFsc2U7XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICB2YXIgY29sbGFwc2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGluaXRpYWxBbmltU2tpcCkge1xyXG4gICAgICAgICAgaW5pdGlhbEFuaW1Ta2lwID0gZmFsc2U7XHJcbiAgICAgICAgICBmaXhVcEhlaWdodChzY29wZSwgZWxlbWVudCwgMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZpeFVwSGVpZ2h0KHNjb3BlLCBlbGVtZW50LCBlbGVtZW50WzBdLnNjcm9sbEhlaWdodCArICdweCcpO1xyXG4gICAgICAgICAgZG9UcmFuc2l0aW9uKHsnaGVpZ2h0JzonMCd9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5hY2NvcmRpb24nLCBbJ3VpLmJvb3RzdHJhcC5jb2xsYXBzZSddKVxyXG5cclxuLmNvbnN0YW50KCdhY2NvcmRpb25Db25maWcnLCB7XHJcbiAgY2xvc2VPdGhlcnM6IHRydWVcclxufSlcclxuXHJcbi5jb250cm9sbGVyKCdBY2NvcmRpb25Db250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJ2FjY29yZGlvbkNvbmZpZycsIGZ1bmN0aW9uICgkc2NvcGUsICRhdHRycywgYWNjb3JkaW9uQ29uZmlnKSB7XHJcbiAgXHJcbiAgLy8gVGhpcyBhcnJheSBrZWVwcyB0cmFjayBvZiB0aGUgYWNjb3JkaW9uIGdyb3Vwc1xyXG4gIHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG4gIC8vIEVuc3VyZSB0aGF0IGFsbCB0aGUgZ3JvdXBzIGluIHRoaXMgYWNjb3JkaW9uIGFyZSBjbG9zZWQsIHVubGVzcyBjbG9zZS1vdGhlcnMgZXhwbGljaXRseSBzYXlzIG5vdCB0b1xyXG4gIHRoaXMuY2xvc2VPdGhlcnMgPSBmdW5jdGlvbihvcGVuR3JvdXApIHtcclxuICAgIHZhciBjbG9zZU90aGVycyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5jbG9zZU90aGVycykgPyAkc2NvcGUuJGV2YWwoJGF0dHJzLmNsb3NlT3RoZXJzKSA6IGFjY29yZGlvbkNvbmZpZy5jbG9zZU90aGVycztcclxuICAgIGlmICggY2xvc2VPdGhlcnMgKSB7XHJcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaCh0aGlzLmdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgaWYgKCBncm91cCAhPT0gb3Blbkdyb3VwICkge1xyXG4gICAgICAgICAgZ3JvdXAuaXNPcGVuID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG4gIFxyXG4gIC8vIFRoaXMgaXMgY2FsbGVkIGZyb20gdGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgdG8gYWRkIGl0c2VsZiB0byB0aGUgYWNjb3JkaW9uXHJcbiAgdGhpcy5hZGRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwU2NvcGUpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoaXMuZ3JvdXBzLnB1c2goZ3JvdXBTY29wZSk7XHJcblxyXG4gICAgZ3JvdXBTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgIHRoYXQucmVtb3ZlR3JvdXAoZ3JvdXBTY29wZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyBUaGlzIGlzIGNhbGxlZCBmcm9tIHRoZSBhY2NvcmRpb24tZ3JvdXAgZGlyZWN0aXZlIHdoZW4gdG8gcmVtb3ZlIGl0c2VsZlxyXG4gIHRoaXMucmVtb3ZlR3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5ncm91cHMuaW5kZXhPZihncm91cCk7XHJcbiAgICBpZiAoIGluZGV4ICE9PSAtMSApIHtcclxuICAgICAgdGhpcy5ncm91cHMuc3BsaWNlKHRoaXMuZ3JvdXBzLmluZGV4T2YoZ3JvdXApLCAxKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxufV0pXHJcblxyXG4vLyBUaGUgYWNjb3JkaW9uIGRpcmVjdGl2ZSBzaW1wbHkgc2V0cyB1cCB0aGUgZGlyZWN0aXZlIGNvbnRyb2xsZXJcclxuLy8gYW5kIGFkZHMgYW4gYWNjb3JkaW9uIENTUyBjbGFzcyB0byBpdHNlbGYgZWxlbWVudC5cclxuLmRpcmVjdGl2ZSgnYWNjb3JkaW9uJywgZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDonRUEnLFxyXG4gICAgY29udHJvbGxlcjonQWNjb3JkaW9uQ29udHJvbGxlcicsXHJcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgcmVwbGFjZTogZmFsc2UsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24uaHRtbCdcclxuICB9O1xyXG59KVxyXG5cclxuLy8gVGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgaW5kaWNhdGVzIGEgYmxvY2sgb2YgaHRtbCB0aGF0IHdpbGwgZXhwYW5kIGFuZCBjb2xsYXBzZSBpbiBhbiBhY2NvcmRpb25cclxuLmRpcmVjdGl2ZSgnYWNjb3JkaW9uR3JvdXAnLCBbJyRwYXJzZScsICckdHJhbnNpdGlvbicsICckdGltZW91dCcsIGZ1bmN0aW9uKCRwYXJzZSwgJHRyYW5zaXRpb24sICR0aW1lb3V0KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlcXVpcmU6J15hY2NvcmRpb24nLCAgICAgICAgIC8vIFdlIG5lZWQgdGhpcyBkaXJlY3RpdmUgdG8gYmUgaW5zaWRlIGFuIGFjY29yZGlvblxyXG4gICAgcmVzdHJpY3Q6J0VBJyxcclxuICAgIHRyYW5zY2x1ZGU6dHJ1ZSwgICAgICAgICAgICAgIC8vIEl0IHRyYW5zY2x1ZGVzIHRoZSBjb250ZW50cyBvZiB0aGUgZGlyZWN0aXZlIGludG8gdGhlIHRlbXBsYXRlXHJcbiAgICByZXBsYWNlOiB0cnVlLCAgICAgICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBkaXJlY3RpdmUgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSB0ZW1wbGF0ZVxyXG4gICAgdGVtcGxhdGVVcmw6J3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbCcsXHJcbiAgICBzY29wZTp7IGhlYWRpbmc6J0AnIH0sICAgICAgICAvLyBDcmVhdGUgYW4gaXNvbGF0ZWQgc2NvcGUgYW5kIGludGVycG9sYXRlIHRoZSBoZWFkaW5nIGF0dHJpYnV0ZSBvbnRvIHRoaXMgc2NvcGVcclxuICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24oJHNjb3BlKSB7XHJcbiAgICAgIHRoaXMuc2V0SGVhZGluZyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmhlYWRpbmcgPSBlbGVtZW50O1xyXG4gICAgICB9O1xyXG4gICAgfV0sXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGFjY29yZGlvbkN0cmwpIHtcclxuICAgICAgdmFyIGdldElzT3Blbiwgc2V0SXNPcGVuO1xyXG5cclxuICAgICAgYWNjb3JkaW9uQ3RybC5hZGRHcm91cChzY29wZSk7XHJcblxyXG4gICAgICBzY29wZS5pc09wZW4gPSBmYWxzZTtcclxuICAgICAgXHJcbiAgICAgIGlmICggYXR0cnMuaXNPcGVuICkge1xyXG4gICAgICAgIGdldElzT3BlbiA9ICRwYXJzZShhdHRycy5pc09wZW4pO1xyXG4gICAgICAgIHNldElzT3BlbiA9IGdldElzT3Blbi5hc3NpZ247XHJcblxyXG4gICAgICAgIHNjb3BlLiR3YXRjaChcclxuICAgICAgICAgIGZ1bmN0aW9uIHdhdGNoSXNPcGVuKCkgeyByZXR1cm4gZ2V0SXNPcGVuKHNjb3BlLiRwYXJlbnQpOyB9LFxyXG4gICAgICAgICAgZnVuY3Rpb24gdXBkYXRlT3Blbih2YWx1ZSkgeyBzY29wZS5pc09wZW4gPSB2YWx1ZTsgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2NvcGUuaXNPcGVuID0gZ2V0SXNPcGVuID8gZ2V0SXNPcGVuKHNjb3BlLiRwYXJlbnQpIDogZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNjb3BlLiR3YXRjaCgnaXNPcGVuJywgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAoIHZhbHVlICkge1xyXG4gICAgICAgICAgYWNjb3JkaW9uQ3RybC5jbG9zZU90aGVycyhzY29wZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICggc2V0SXNPcGVuICkge1xyXG4gICAgICAgICAgc2V0SXNPcGVuKHNjb3BlLiRwYXJlbnQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuLy8gVXNlIGFjY29yZGlvbi1oZWFkaW5nIGJlbG93IGFuIGFjY29yZGlvbi1ncm91cCB0byBwcm92aWRlIGEgaGVhZGluZyBjb250YWluaW5nIEhUTUxcclxuLy8gPGFjY29yZGlvbi1ncm91cD5cclxuLy8gICA8YWNjb3JkaW9uLWhlYWRpbmc+SGVhZGluZyBjb250YWluaW5nIEhUTUwgLSA8aW1nIHNyYz1cIi4uLlwiPjwvYWNjb3JkaW9uLWhlYWRpbmc+XHJcbi8vIDwvYWNjb3JkaW9uLWdyb3VwPlxyXG4uZGlyZWN0aXZlKCdhY2NvcmRpb25IZWFkaW5nJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSwgICAvLyBHcmFiIHRoZSBjb250ZW50cyB0byBiZSB1c2VkIGFzIHRoZSBoZWFkaW5nXHJcbiAgICB0ZW1wbGF0ZTogJycsICAgICAgIC8vIEluIGVmZmVjdCByZW1vdmUgdGhpcyBlbGVtZW50IVxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHJlcXVpcmU6ICdeYWNjb3JkaW9uR3JvdXAnLFxyXG4gICAgY29tcGlsZTogZnVuY3Rpb24oZWxlbWVudCwgYXR0ciwgdHJhbnNjbHVkZSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gbGluayhzY29wZSwgZWxlbWVudCwgYXR0ciwgYWNjb3JkaW9uR3JvdXBDdHJsKSB7XHJcbiAgICAgICAgLy8gUGFzcyB0aGUgaGVhZGluZyB0byB0aGUgYWNjb3JkaW9uLWdyb3VwIGNvbnRyb2xsZXJcclxuICAgICAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSB0cmFuc2NsdWRlZCBpbnRvIHRoZSByaWdodCBwbGFjZSBpbiB0aGUgdGVtcGxhdGVcclxuICAgICAgICAvLyBbVGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gdHJhbnNjbHVkZSBjYXVzZXMgdGhlIGVsZW1lbnRzIHRvIGJlIGNsb25lZCBzbyB0aGF0IHRoZXkgd29yayBpbiBuZy1yZXBlYXRdXHJcbiAgICAgICAgYWNjb3JkaW9uR3JvdXBDdHJsLnNldEhlYWRpbmcodHJhbnNjbHVkZShzY29wZSwgZnVuY3Rpb24oKSB7fSkpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn0pXHJcblxyXG4vLyBVc2UgaW4gdGhlIGFjY29yZGlvbi1ncm91cCB0ZW1wbGF0ZSB0byBpbmRpY2F0ZSB3aGVyZSB5b3Ugd2FudCB0aGUgaGVhZGluZyB0byBiZSB0cmFuc2NsdWRlZFxyXG4vLyBZb3UgbXVzdCBwcm92aWRlIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYWNjb3JkaW9uLWdyb3VwIGNvbnRyb2xsZXIgdGhhdCB3aWxsIGhvbGQgdGhlIHRyYW5zY2x1ZGVkIGVsZW1lbnRcclxuLy8gPGRpdiBjbGFzcz1cImFjY29yZGlvbi1ncm91cFwiPlxyXG4vLyAgIDxkaXYgY2xhc3M9XCJhY2NvcmRpb24taGVhZGluZ1wiID48YSAuLi4gYWNjb3JkaW9uLXRyYW5zY2x1ZGU9XCJoZWFkaW5nXCI+Li4uPC9hPjwvZGl2PlxyXG4vLyAgIC4uLlxyXG4vLyA8L2Rpdj5cclxuLmRpcmVjdGl2ZSgnYWNjb3JkaW9uVHJhbnNjbHVkZScsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXF1aXJlOiAnXmFjY29yZGlvbkdyb3VwJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjb250cm9sbGVyKSB7XHJcbiAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbigpIHsgcmV0dXJuIGNvbnRyb2xsZXJbYXR0ci5hY2NvcmRpb25UcmFuc2NsdWRlXTsgfSwgZnVuY3Rpb24oaGVhZGluZykge1xyXG4gICAgICAgIGlmICggaGVhZGluZyApIHtcclxuICAgICAgICAgIGVsZW1lbnQuaHRtbCgnJyk7XHJcbiAgICAgICAgICBlbGVtZW50LmFwcGVuZChoZWFkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ1aS5ib290c3RyYXAuYWxlcnRcIiwgW10pLmRpcmVjdGl2ZSgnYWxlcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OidFQScsXHJcbiAgICB0ZW1wbGF0ZVVybDondGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbCcsXHJcbiAgICB0cmFuc2NsdWRlOnRydWUsXHJcbiAgICByZXBsYWNlOnRydWUsXHJcbiAgICBzY29wZToge1xyXG4gICAgICB0eXBlOiAnPScsXHJcbiAgICAgIGNsb3NlOiAnJidcclxuICAgIH0sXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgaUVsZW1lbnQsIGlBdHRycywgY29udHJvbGxlcikge1xyXG4gICAgICBzY29wZS5jbG9zZWFibGUgPSBcImNsb3NlXCIgaW4gaUF0dHJzO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5iaW5kSHRtbCcsIFtdKVxyXG5cclxuICAuZGlyZWN0aXZlKCdiaW5kSHRtbFVuc2FmZScsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICAgICAgZWxlbWVudC5hZGRDbGFzcygnbmctYmluZGluZycpLmRhdGEoJyRiaW5kaW5nJywgYXR0ci5iaW5kSHRtbFVuc2FmZSk7XHJcbiAgICAgIHNjb3BlLiR3YXRjaChhdHRyLmJpbmRIdG1sVW5zYWZlLCBmdW5jdGlvbiBiaW5kSHRtbFVuc2FmZVdhdGNoQWN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgZWxlbWVudC5odG1sKHZhbHVlIHx8ICcnKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmJ1dHRvbnMnLCBbXSlcclxuXHJcbiAgLmNvbnN0YW50KCdidXR0b25Db25maWcnLCB7XHJcbiAgICBhY3RpdmVDbGFzczonYWN0aXZlJyxcclxuICAgIHRvZ2dsZUV2ZW50OidjbGljaydcclxuICB9KVxyXG5cclxuICAuZGlyZWN0aXZlKCdidG5SYWRpbycsIFsnYnV0dG9uQ29uZmlnJywgZnVuY3Rpb24gKGJ1dHRvbkNvbmZpZykge1xyXG4gIHZhciBhY3RpdmVDbGFzcyA9IGJ1dHRvbkNvbmZpZy5hY3RpdmVDbGFzcyB8fCAnYWN0aXZlJztcclxuICB2YXIgdG9nZ2xlRXZlbnQgPSBidXR0b25Db25maWcudG9nZ2xlRXZlbnQgfHwgJ2NsaWNrJztcclxuXHJcbiAgcmV0dXJuIHtcclxuXHJcbiAgICByZXF1aXJlOiduZ01vZGVsJyxcclxuICAgIGxpbms6ZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbEN0cmwpIHtcclxuXHJcbiAgICAgIC8vbW9kZWwgLT4gVUlcclxuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBlbGVtZW50LnRvZ2dsZUNsYXNzKGFjdGl2ZUNsYXNzLCBhbmd1bGFyLmVxdWFscyhuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSwgc2NvcGUuJGV2YWwoYXR0cnMuYnRuUmFkaW8pKSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvL3VpLT5tb2RlbFxyXG4gICAgICBlbGVtZW50LmJpbmQodG9nZ2xlRXZlbnQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQ2xhc3MoYWN0aXZlQ2xhc3MpKSB7XHJcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKHNjb3BlLiRldmFsKGF0dHJzLmJ0blJhZGlvKSk7XHJcbiAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufV0pXHJcblxyXG4gIC5kaXJlY3RpdmUoJ2J0bkNoZWNrYm94JywgWydidXR0b25Db25maWcnLCBmdW5jdGlvbiAoYnV0dG9uQ29uZmlnKSB7XHJcblxyXG4gIHZhciBhY3RpdmVDbGFzcyA9IGJ1dHRvbkNvbmZpZy5hY3RpdmVDbGFzcyB8fCAnYWN0aXZlJztcclxuICB2YXIgdG9nZ2xlRXZlbnQgPSBidXR0b25Db25maWcudG9nZ2xlRXZlbnQgfHwgJ2NsaWNrJztcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHJlcXVpcmU6J25nTW9kZWwnLFxyXG4gICAgbGluazpmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsQ3RybCkge1xyXG5cclxuICAgICAgZnVuY3Rpb24gZ2V0VHJ1ZVZhbHVlKCkge1xyXG4gICAgICAgIHZhciB0cnVlVmFsdWUgPSBzY29wZS4kZXZhbChhdHRycy5idG5DaGVja2JveFRydWUpO1xyXG4gICAgICAgIHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZCh0cnVlVmFsdWUpID8gdHJ1ZVZhbHVlIDogdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZ2V0RmFsc2VWYWx1ZSgpIHtcclxuICAgICAgICB2YXIgZmFsc2VWYWx1ZSA9IHNjb3BlLiRldmFsKGF0dHJzLmJ0bkNoZWNrYm94RmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZChmYWxzZVZhbHVlKSA/IGZhbHNlVmFsdWUgOiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy9tb2RlbCAtPiBVSVxyXG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBnZXRUcnVlVmFsdWUoKSkpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy91aS0+bW9kZWxcclxuICAgICAgZWxlbWVudC5iaW5kKHRvZ2dsZUV2ZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoZWxlbWVudC5oYXNDbGFzcyhhY3RpdmVDbGFzcykgPyBnZXRGYWxzZVZhbHVlKCkgOiBnZXRUcnVlVmFsdWUoKSk7XHJcbiAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKTtcclxuLyoqXHJcbiogQG5nZG9jIG92ZXJ2aWV3XHJcbiogQG5hbWUgdWkuYm9vdHN0cmFwLmNhcm91c2VsXHJcbipcclxuKiBAZGVzY3JpcHRpb25cclxuKiBBbmd1bGFySlMgdmVyc2lvbiBvZiBhbiBpbWFnZSBjYXJvdXNlbC5cclxuKlxyXG4qL1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmNhcm91c2VsJywgWyd1aS5ib290c3RyYXAudHJhbnNpdGlvbiddKVxyXG4uY29udHJvbGxlcignQ2Fyb3VzZWxDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJHRpbWVvdXQnLCAnJHRyYW5zaXRpb24nLCAnJHEnLCBmdW5jdGlvbiAoJHNjb3BlLCAkdGltZW91dCwgJHRyYW5zaXRpb24sICRxKSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgc2xpZGVzID0gc2VsZi5zbGlkZXMgPSBbXSxcclxuICAgIGN1cnJlbnRJbmRleCA9IC0xLFxyXG4gICAgY3VycmVudFRpbWVvdXQsIGlzUGxheWluZztcclxuICBzZWxmLmN1cnJlbnRTbGlkZSA9IG51bGw7XHJcblxyXG4gIC8qIGRpcmVjdGlvbjogXCJwcmV2XCIgb3IgXCJuZXh0XCIgKi9cclxuICBzZWxmLnNlbGVjdCA9IGZ1bmN0aW9uKG5leHRTbGlkZSwgZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgbmV4dEluZGV4ID0gc2xpZGVzLmluZGV4T2YobmV4dFNsaWRlKTtcclxuICAgIC8vRGVjaWRlIGRpcmVjdGlvbiBpZiBpdCdzIG5vdCBnaXZlblxyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGRpcmVjdGlvbiA9IG5leHRJbmRleCA+IGN1cnJlbnRJbmRleCA/IFwibmV4dFwiIDogXCJwcmV2XCI7XHJcbiAgICB9XHJcbiAgICBpZiAobmV4dFNsaWRlICYmIG5leHRTbGlkZSAhPT0gc2VsZi5jdXJyZW50U2xpZGUpIHtcclxuICAgICAgaWYgKCRzY29wZS4kY3VycmVudFRyYW5zaXRpb24pIHtcclxuICAgICAgICAkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uLmNhbmNlbCgpO1xyXG4gICAgICAgIC8vVGltZW91dCBzbyBuZy1jbGFzcyBpbiB0ZW1wbGF0ZSBoYXMgdGltZSB0byBmaXggY2xhc3NlcyBmb3IgZmluaXNoZWQgc2xpZGVcclxuICAgICAgICAkdGltZW91dChnb05leHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdvTmV4dCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnb05leHQoKSB7XHJcbiAgICAgIC8vSWYgd2UgaGF2ZSBhIHNsaWRlIHRvIHRyYW5zaXRpb24gZnJvbSBhbmQgd2UgaGF2ZSBhIHRyYW5zaXRpb24gdHlwZSBhbmQgd2UncmUgYWxsb3dlZCwgZ29cclxuICAgICAgaWYgKHNlbGYuY3VycmVudFNsaWRlICYmIGFuZ3VsYXIuaXNTdHJpbmcoZGlyZWN0aW9uKSAmJiAhJHNjb3BlLm5vVHJhbnNpdGlvbiAmJiBuZXh0U2xpZGUuJGVsZW1lbnQpIHtcclxuICAgICAgICAvL1dlIHNob3VsZG4ndCBkbyBjbGFzcyBtYW5pcCBpbiBoZXJlLCBidXQgaXQncyB0aGUgc2FtZSB3ZWlyZCB0aGluZyBib290c3RyYXAgZG9lcy4gbmVlZCB0byBmaXggc29tZXRpbWVcclxuICAgICAgICBuZXh0U2xpZGUuJGVsZW1lbnQuYWRkQ2xhc3MoZGlyZWN0aW9uKTtcclxuICAgICAgICB2YXIgcmVmbG93ID0gbmV4dFNsaWRlLiRlbGVtZW50WzBdLm9mZnNldFdpZHRoOyAvL2ZvcmNlIHJlZmxvd1xyXG5cclxuICAgICAgICAvL1NldCBhbGwgb3RoZXIgc2xpZGVzIHRvIHN0b3AgZG9pbmcgdGhlaXIgc3R1ZmYgZm9yIHRoZSBuZXcgdHJhbnNpdGlvblxyXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChzbGlkZXMsIGZ1bmN0aW9uKHNsaWRlKSB7XHJcbiAgICAgICAgICBhbmd1bGFyLmV4dGVuZChzbGlkZSwge2RpcmVjdGlvbjogJycsIGVudGVyaW5nOiBmYWxzZSwgbGVhdmluZzogZmFsc2UsIGFjdGl2ZTogZmFsc2V9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhbmd1bGFyLmV4dGVuZChuZXh0U2xpZGUsIHtkaXJlY3Rpb246IGRpcmVjdGlvbiwgYWN0aXZlOiB0cnVlLCBlbnRlcmluZzogdHJ1ZX0pO1xyXG4gICAgICAgIGFuZ3VsYXIuZXh0ZW5kKHNlbGYuY3VycmVudFNsaWRlfHx7fSwge2RpcmVjdGlvbjogZGlyZWN0aW9uLCBsZWF2aW5nOiB0cnVlfSk7XHJcblxyXG4gICAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gPSAkdHJhbnNpdGlvbihuZXh0U2xpZGUuJGVsZW1lbnQsIHt9KTtcclxuICAgICAgICAvL1dlIGhhdmUgdG8gY3JlYXRlIG5ldyBwb2ludGVycyBpbnNpZGUgYSBjbG9zdXJlIHNpbmNlIG5leHQgJiBjdXJyZW50IHdpbGwgY2hhbmdlXHJcbiAgICAgICAgKGZ1bmN0aW9uKG5leHQsY3VycmVudCkge1xyXG4gICAgICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbi50aGVuKFxyXG4gICAgICAgICAgICBmdW5jdGlvbigpeyB0cmFuc2l0aW9uRG9uZShuZXh0LCBjdXJyZW50KTsgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24oKXsgdHJhbnNpdGlvbkRvbmUobmV4dCwgY3VycmVudCk7IH1cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfShuZXh0U2xpZGUsIHNlbGYuY3VycmVudFNsaWRlKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbkRvbmUobmV4dFNsaWRlLCBzZWxmLmN1cnJlbnRTbGlkZSk7XHJcbiAgICAgIH1cclxuICAgICAgc2VsZi5jdXJyZW50U2xpZGUgPSBuZXh0U2xpZGU7XHJcbiAgICAgIGN1cnJlbnRJbmRleCA9IG5leHRJbmRleDtcclxuICAgICAgLy9ldmVyeSB0aW1lIHlvdSBjaGFuZ2Ugc2xpZGVzLCByZXNldCB0aGUgdGltZXJcclxuICAgICAgcmVzdGFydFRpbWVyKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uRG9uZShuZXh0LCBjdXJyZW50KSB7XHJcbiAgICAgIGFuZ3VsYXIuZXh0ZW5kKG5leHQsIHtkaXJlY3Rpb246ICcnLCBhY3RpdmU6IHRydWUsIGxlYXZpbmc6IGZhbHNlLCBlbnRlcmluZzogZmFsc2V9KTtcclxuICAgICAgYW5ndWxhci5leHRlbmQoY3VycmVudHx8e30sIHtkaXJlY3Rpb246ICcnLCBhY3RpdmU6IGZhbHNlLCBsZWF2aW5nOiBmYWxzZSwgZW50ZXJpbmc6IGZhbHNlfSk7XHJcbiAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qIEFsbG93IG91dHNpZGUgcGVvcGxlIHRvIGNhbGwgaW5kZXhPZiBvbiBzbGlkZXMgYXJyYXkgKi9cclxuICBzZWxmLmluZGV4T2ZTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlKSB7XHJcbiAgICByZXR1cm4gc2xpZGVzLmluZGV4T2Yoc2xpZGUpO1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5uZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbmV3SW5kZXggPSAoY3VycmVudEluZGV4ICsgMSkgJSBzbGlkZXMubGVuZ3RoO1xyXG5cclxuICAgIC8vUHJldmVudCB0aGlzIHVzZXItdHJpZ2dlcmVkIHRyYW5zaXRpb24gZnJvbSBvY2N1cnJpbmcgaWYgdGhlcmUgaXMgYWxyZWFkeSBvbmUgaW4gcHJvZ3Jlc3NcclxuICAgIGlmICghJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbikge1xyXG4gICAgICByZXR1cm4gc2VsZi5zZWxlY3Qoc2xpZGVzW25ld0luZGV4XSwgJ25leHQnKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAkc2NvcGUucHJldiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG5ld0luZGV4ID0gY3VycmVudEluZGV4IC0gMSA8IDAgPyBzbGlkZXMubGVuZ3RoIC0gMSA6IGN1cnJlbnRJbmRleCAtIDE7XHJcblxyXG4gICAgLy9QcmV2ZW50IHRoaXMgdXNlci10cmlnZ2VyZWQgdHJhbnNpdGlvbiBmcm9tIG9jY3VycmluZyBpZiB0aGVyZSBpcyBhbHJlYWR5IG9uZSBpbiBwcm9ncmVzc1xyXG4gICAgaWYgKCEkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uKSB7XHJcbiAgICAgIHJldHVybiBzZWxmLnNlbGVjdChzbGlkZXNbbmV3SW5kZXhdLCAncHJldicpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gICRzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihzbGlkZSkge1xyXG4gICAgc2VsZi5zZWxlY3Qoc2xpZGUpO1xyXG4gIH07XHJcblxyXG4gICRzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKHNsaWRlKSB7XHJcbiAgICAgcmV0dXJuIHNlbGYuY3VycmVudFNsaWRlID09PSBzbGlkZTtcclxuICB9O1xyXG5cclxuICAkc2NvcGUuc2xpZGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gc2xpZGVzO1xyXG4gIH07XHJcblxyXG4gICRzY29wZS4kd2F0Y2goJ2ludGVydmFsJywgcmVzdGFydFRpbWVyKTtcclxuICBmdW5jdGlvbiByZXN0YXJ0VGltZXIoKSB7XHJcbiAgICBpZiAoY3VycmVudFRpbWVvdXQpIHtcclxuICAgICAgJHRpbWVvdXQuY2FuY2VsKGN1cnJlbnRUaW1lb3V0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdvKCkge1xyXG4gICAgICBpZiAoaXNQbGF5aW5nKSB7XHJcbiAgICAgICAgJHNjb3BlLm5leHQoKTtcclxuICAgICAgICByZXN0YXJ0VGltZXIoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAkc2NvcGUucGF1c2UoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGludGVydmFsID0gKyRzY29wZS5pbnRlcnZhbDtcclxuICAgIGlmICghaXNOYU4oaW50ZXJ2YWwpICYmIGludGVydmFsPj0wKSB7XHJcbiAgICAgIGN1cnJlbnRUaW1lb3V0ID0gJHRpbWVvdXQoZ28sIGludGVydmFsKTtcclxuICAgIH1cclxuICB9XHJcbiAgJHNjb3BlLnBsYXkgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICghaXNQbGF5aW5nKSB7XHJcbiAgICAgIGlzUGxheWluZyA9IHRydWU7XHJcbiAgICAgIHJlc3RhcnRUaW1lcigpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgJHNjb3BlLnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoISRzY29wZS5ub1BhdXNlKSB7XHJcbiAgICAgIGlzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICBpZiAoY3VycmVudFRpbWVvdXQpIHtcclxuICAgICAgICAkdGltZW91dC5jYW5jZWwoY3VycmVudFRpbWVvdXQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgc2VsZi5hZGRTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlLCBlbGVtZW50KSB7XHJcbiAgICBzbGlkZS4kZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICBzbGlkZXMucHVzaChzbGlkZSk7XHJcbiAgICAvL2lmIHRoaXMgaXMgdGhlIGZpcnN0IHNsaWRlIG9yIHRoZSBzbGlkZSBpcyBzZXQgdG8gYWN0aXZlLCBzZWxlY3QgaXRcclxuICAgIGlmKHNsaWRlcy5sZW5ndGggPT09IDEgfHwgc2xpZGUuYWN0aXZlKSB7XHJcbiAgICAgIHNlbGYuc2VsZWN0KHNsaWRlc1tzbGlkZXMubGVuZ3RoLTFdKTtcclxuICAgICAgaWYgKHNsaWRlcy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgICRzY29wZS5wbGF5KCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNsaWRlLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHNlbGYucmVtb3ZlU2xpZGUgPSBmdW5jdGlvbihzbGlkZSkge1xyXG4gICAgLy9nZXQgdGhlIGluZGV4IG9mIHRoZSBzbGlkZSBpbnNpZGUgdGhlIGNhcm91c2VsXHJcbiAgICB2YXIgaW5kZXggPSBzbGlkZXMuaW5kZXhPZihzbGlkZSk7XHJcbiAgICBzbGlkZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIGlmIChzbGlkZXMubGVuZ3RoID4gMCAmJiBzbGlkZS5hY3RpdmUpIHtcclxuICAgICAgaWYgKGluZGV4ID49IHNsaWRlcy5sZW5ndGgpIHtcclxuICAgICAgICBzZWxmLnNlbGVjdChzbGlkZXNbaW5kZXgtMV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGYuc2VsZWN0KHNsaWRlc1tpbmRleF0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRJbmRleCA+IGluZGV4KSB7XHJcbiAgICAgIGN1cnJlbnRJbmRleC0tO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgdWkuYm9vdHN0cmFwLmNhcm91c2VsLmRpcmVjdGl2ZTpjYXJvdXNlbFxyXG4gKiBAcmVzdHJpY3QgRUFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENhcm91c2VsIGlzIHRoZSBvdXRlciBjb250YWluZXIgZm9yIGEgc2V0IG9mIGltYWdlICdzbGlkZXMnIHRvIHNob3djYXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcj19IGludGVydmFsIFRoZSB0aW1lLCBpbiBtaWxsaXNlY29uZHMsIHRoYXQgaXQgd2lsbCB0YWtlIHRoZSBjYXJvdXNlbCB0byBnbyB0byB0aGUgbmV4dCBzbGlkZS5cclxuICogQHBhcmFtIHtib29sZWFuPX0gbm9UcmFuc2l0aW9uIFdoZXRoZXIgdG8gZGlzYWJsZSB0cmFuc2l0aW9ucyBvbiB0aGUgY2Fyb3VzZWwuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vUGF1c2UgV2hldGhlciB0byBkaXNhYmxlIHBhdXNpbmcgb24gdGhlIGNhcm91c2VsIChieSBkZWZhdWx0LCB0aGUgY2Fyb3VzZWwgaW50ZXJ2YWwgcGF1c2VzIG9uIGhvdmVyKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuPGV4YW1wbGUgbW9kdWxlPVwidWkuYm9vdHN0cmFwXCI+XHJcbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgIDxjYXJvdXNlbD5cclxuICAgICAgPHNsaWRlPlxyXG4gICAgICAgIDxpbWcgc3JjPVwiaHR0cDovL3BsYWNla2l0dGVuLmNvbS8xNTAvMTUwXCIgc3R5bGU9XCJtYXJnaW46YXV0bztcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWwtY2FwdGlvblwiPlxyXG4gICAgICAgICAgPHA+QmVhdXRpZnVsITwvcD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9zbGlkZT5cclxuICAgICAgPHNsaWRlPlxyXG4gICAgICAgIDxpbWcgc3JjPVwiaHR0cDovL3BsYWNla2l0dGVuLmNvbS8xMDAvMTUwXCIgc3R5bGU9XCJtYXJnaW46YXV0bztcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWwtY2FwdGlvblwiPlxyXG4gICAgICAgICAgPHA+RCdhd3chPC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L3NsaWRlPlxyXG4gICAgPC9jYXJvdXNlbD5cclxuICA8L2ZpbGU+XHJcbiAgPGZpbGUgbmFtZT1cImRlbW8uY3NzXCI+XHJcbiAgICAuY2Fyb3VzZWwtaW5kaWNhdG9ycyB7XHJcbiAgICAgIHRvcDogYXV0bztcclxuICAgICAgYm90dG9tOiAxNXB4O1xyXG4gICAgfVxyXG4gIDwvZmlsZT5cclxuPC9leGFtcGxlPlxyXG4gKi9cclxuLmRpcmVjdGl2ZSgnY2Fyb3VzZWwnLCBbZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICBjb250cm9sbGVyOiAnQ2Fyb3VzZWxDb250cm9sbGVyJyxcclxuICAgIHJlcXVpcmU6ICdjYXJvdXNlbCcsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWwnLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgaW50ZXJ2YWw6ICc9JyxcclxuICAgICAgbm9UcmFuc2l0aW9uOiAnPScsXHJcbiAgICAgIG5vUGF1c2U6ICc9J1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgdWkuYm9vdHN0cmFwLmNhcm91c2VsLmRpcmVjdGl2ZTpzbGlkZVxyXG4gKiBAcmVzdHJpY3QgRUFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENyZWF0ZXMgYSBzbGlkZSBpbnNpZGUgYSB7QGxpbmsgdWkuYm9vdHN0cmFwLmNhcm91c2VsLmRpcmVjdGl2ZTpjYXJvdXNlbCBjYXJvdXNlbH0uICBNdXN0IGJlIHBsYWNlZCBhcyBhIGNoaWxkIG9mIGEgY2Fyb3VzZWwgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtib29sZWFuPX0gYWN0aXZlIE1vZGVsIGJpbmRpbmcsIHdoZXRoZXIgb3Igbm90IHRoaXMgc2xpZGUgaXMgY3VycmVudGx5IGFjdGl2ZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuPGV4YW1wbGUgbW9kdWxlPVwidWkuYm9vdHN0cmFwXCI+XHJcbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuPGRpdiBuZy1jb250cm9sbGVyPVwiQ2Fyb3VzZWxEZW1vQ3RybFwiPlxyXG4gIDxjYXJvdXNlbD5cclxuICAgIDxzbGlkZSBuZy1yZXBlYXQ9XCJzbGlkZSBpbiBzbGlkZXNcIiBhY3RpdmU9XCJzbGlkZS5hY3RpdmVcIj5cclxuICAgICAgPGltZyBuZy1zcmM9XCJ7e3NsaWRlLmltYWdlfX1cIiBzdHlsZT1cIm1hcmdpbjphdXRvO1wiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWwtY2FwdGlvblwiPlxyXG4gICAgICAgIDxoND5TbGlkZSB7eyRpbmRleH19PC9oND5cclxuICAgICAgICA8cD57e3NsaWRlLnRleHR9fTwvcD5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L3NsaWRlPlxyXG4gIDwvY2Fyb3VzZWw+XHJcbiAgPGRpdiBjbGFzcz1cInJvdy1mbHVpZFwiPlxyXG4gICAgPGRpdiBjbGFzcz1cInNwYW42XCI+XHJcbiAgICAgIDx1bD5cclxuICAgICAgICA8bGkgbmctcmVwZWF0PVwic2xpZGUgaW4gc2xpZGVzXCI+XHJcbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1taW5pXCIgbmctY2xhc3M9XCJ7J2J0bi1pbmZvJzogIXNsaWRlLmFjdGl2ZSwgJ2J0bi1zdWNjZXNzJzogc2xpZGUuYWN0aXZlfVwiIG5nLWRpc2FibGVkPVwic2xpZGUuYWN0aXZlXCIgbmctY2xpY2s9XCJzbGlkZS5hY3RpdmUgPSB0cnVlXCI+c2VsZWN0PC9idXR0b24+XHJcbiAgICAgICAgICB7eyRpbmRleH19OiB7e3NsaWRlLnRleHR9fVxyXG4gICAgICAgIDwvbGk+XHJcbiAgICAgIDwvdWw+XHJcbiAgICAgIDxhIGNsYXNzPVwiYnRuXCIgbmctY2xpY2s9XCJhZGRTbGlkZSgpXCI+QWRkIFNsaWRlPC9hPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwic3BhbjZcIj5cclxuICAgICAgSW50ZXJ2YWwsIGluIG1pbGxpc2Vjb25kczogPGlucHV0IHR5cGU9XCJudW1iZXJcIiBuZy1tb2RlbD1cIm15SW50ZXJ2YWxcIj5cclxuICAgICAgPGJyIC8+RW50ZXIgYSBuZWdhdGl2ZSBudW1iZXIgdG8gc3RvcCB0aGUgaW50ZXJ2YWwuXHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcbiAgPC9maWxlPlxyXG4gIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cclxuZnVuY3Rpb24gQ2Fyb3VzZWxEZW1vQ3RybCgkc2NvcGUpIHtcclxuICAkc2NvcGUubXlJbnRlcnZhbCA9IDUwMDA7XHJcbiAgdmFyIHNsaWRlcyA9ICRzY29wZS5zbGlkZXMgPSBbXTtcclxuICAkc2NvcGUuYWRkU2xpZGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBuZXdXaWR0aCA9IDIwMCArICgoc2xpZGVzLmxlbmd0aCArICgyNSAqIHNsaWRlcy5sZW5ndGgpKSAlIDE1MCk7XHJcbiAgICBzbGlkZXMucHVzaCh7XHJcbiAgICAgIGltYWdlOiAnaHR0cDovL3BsYWNla2l0dGVuLmNvbS8nICsgbmV3V2lkdGggKyAnLzIwMCcsXHJcbiAgICAgIHRleHQ6IFsnTW9yZScsJ0V4dHJhJywnTG90cyBvZicsJ1N1cnBsdXMnXVtzbGlkZXMubGVuZ3RoICUgNF0gKyAnICdcclxuICAgICAgICBbJ0NhdHMnLCAnS2l0dHlzJywgJ0ZlbGluZXMnLCAnQ3V0ZXMnXVtzbGlkZXMubGVuZ3RoICUgNF1cclxuICAgIH0pO1xyXG4gIH07XHJcbiAgZm9yICh2YXIgaT0wOyBpPDQ7IGkrKykgJHNjb3BlLmFkZFNsaWRlKCk7XHJcbn1cclxuICA8L2ZpbGU+XHJcbiAgPGZpbGUgbmFtZT1cImRlbW8uY3NzXCI+XHJcbiAgICAuY2Fyb3VzZWwtaW5kaWNhdG9ycyB7XHJcbiAgICAgIHRvcDogYXV0bztcclxuICAgICAgYm90dG9tOiAxNXB4O1xyXG4gICAgfVxyXG4gIDwvZmlsZT5cclxuPC9leGFtcGxlPlxyXG4qL1xyXG5cclxuLmRpcmVjdGl2ZSgnc2xpZGUnLCBbJyRwYXJzZScsIGZ1bmN0aW9uKCRwYXJzZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXF1aXJlOiAnXmNhcm91c2VsJyxcclxuICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2Nhcm91c2VsL3NsaWRlLmh0bWwnLFxyXG4gICAgc2NvcGU6IHtcclxuICAgIH0sXHJcbiAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjYXJvdXNlbEN0cmwpIHtcclxuICAgICAgLy9TZXQgdXAgb3B0aW9uYWwgJ2FjdGl2ZScgPSBiaW5kaW5nXHJcbiAgICAgIGlmIChhdHRycy5hY3RpdmUpIHtcclxuICAgICAgICB2YXIgZ2V0QWN0aXZlID0gJHBhcnNlKGF0dHJzLmFjdGl2ZSk7XHJcbiAgICAgICAgdmFyIHNldEFjdGl2ZSA9IGdldEFjdGl2ZS5hc3NpZ247XHJcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHNjb3BlLmFjdGl2ZSA9IGdldEFjdGl2ZShzY29wZS4kcGFyZW50KTtcclxuICAgICAgICBzY29wZS4kd2F0Y2goZnVuY3Rpb24gcGFyZW50QWN0aXZlV2F0Y2goKSB7XHJcbiAgICAgICAgICB2YXIgcGFyZW50QWN0aXZlID0gZ2V0QWN0aXZlKHNjb3BlLiRwYXJlbnQpO1xyXG5cclxuICAgICAgICAgIGlmIChwYXJlbnRBY3RpdmUgIT09IHNjb3BlLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAvLyB3ZSBhcmUgb3V0IG9mIHN5bmMgYW5kIG5lZWQgdG8gY29weVxyXG4gICAgICAgICAgICBpZiAocGFyZW50QWN0aXZlICE9PSBsYXN0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAvLyBwYXJlbnQgY2hhbmdlZCBhbmQgaXQgaGFzIHByZWNlZGVuY2VcclxuICAgICAgICAgICAgICBsYXN0VmFsdWUgPSBzY29wZS5hY3RpdmUgPSBwYXJlbnRBY3RpdmU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gaWYgdGhlIHBhcmVudCBjYW4gYmUgYXNzaWduZWQgdGhlbiBkbyBzb1xyXG4gICAgICAgICAgICAgIHNldEFjdGl2ZShzY29wZS4kcGFyZW50LCBwYXJlbnRBY3RpdmUgPSBsYXN0VmFsdWUgPSBzY29wZS5hY3RpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcGFyZW50QWN0aXZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjYXJvdXNlbEN0cmwuYWRkU2xpZGUoc2NvcGUsIGVsZW1lbnQpO1xyXG4gICAgICAvL3doZW4gdGhlIHNjb3BlIGlzIGRlc3Ryb3llZCB0aGVuIHJlbW92ZSB0aGUgc2xpZGUgZnJvbSB0aGUgY3VycmVudCBzbGlkZXMgYXJyYXlcclxuICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNhcm91c2VsQ3RybC5yZW1vdmVTbGlkZShzY29wZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc2NvcGUuJHdhdGNoKCdhY3RpdmUnLCBmdW5jdGlvbihhY3RpdmUpIHtcclxuICAgICAgICBpZiAoYWN0aXZlKSB7XHJcbiAgICAgICAgICBjYXJvdXNlbEN0cmwuc2VsZWN0KHNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucG9zaXRpb24nLCBbXSlcclxuXHJcbi8qKlxyXG4gKiBBIHNldCBvZiB1dGlsaXR5IG1ldGhvZHMgdGhhdCBjYW4gYmUgdXNlIHRvIHJldHJpZXZlIHBvc2l0aW9uIG9mIERPTSBlbGVtZW50cy5cclxuICogSXQgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aGVyZSB3ZSBuZWVkIHRvIGFic29sdXRlLXBvc2l0aW9uIERPTSBlbGVtZW50cyBpblxyXG4gKiByZWxhdGlvbiB0byBvdGhlciwgZXhpc3RpbmcgZWxlbWVudHMgKHRoaXMgaXMgdGhlIGNhc2UgZm9yIHRvb2x0aXBzLCBwb3BvdmVycyxcclxuICogdHlwZWFoZWFkIHN1Z2dlc3Rpb25zIGV0Yy4pLlxyXG4gKi9cclxuICAuZmFjdG9yeSgnJHBvc2l0aW9uJywgWyckZG9jdW1lbnQnLCAnJHdpbmRvdycsIGZ1bmN0aW9uICgkZG9jdW1lbnQsICR3aW5kb3cpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTdHlsZShlbCwgY3NzcHJvcCkge1xyXG4gICAgICBpZiAoZWwuY3VycmVudFN0eWxlKSB7IC8vSUVcclxuICAgICAgICByZXR1cm4gZWwuY3VycmVudFN0eWxlW2Nzc3Byb3BdO1xyXG4gICAgICB9IGVsc2UgaWYgKCR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xyXG4gICAgICAgIHJldHVybiAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpW2Nzc3Byb3BdO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIGZpbmFsbHkgdHJ5IGFuZCBnZXQgaW5saW5lIHN0eWxlXHJcbiAgICAgIHJldHVybiBlbC5zdHlsZVtjc3Nwcm9wXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgc3RhdGljYWxseSBwb3NpdGlvbmVkXHJcbiAgICAgKiBAcGFyYW0gZWxlbWVudCAtIHJhdyBET00gZWxlbWVudFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1N0YXRpY1Bvc2l0aW9uZWQoZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gKGdldFN0eWxlKGVsZW1lbnQsIFwicG9zaXRpb25cIikgfHwgJ3N0YXRpYycgKSA9PT0gJ3N0YXRpYyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSBjbG9zZXN0LCBub24tc3RhdGljYWxseSBwb3NpdGlvbmVkIHBhcmVudE9mZnNldCBvZiBhIGdpdmVuIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIHZhciBwYXJlbnRPZmZzZXRFbCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgIHZhciBkb2NEb21FbCA9ICRkb2N1bWVudFswXTtcclxuICAgICAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IGRvY0RvbUVsO1xyXG4gICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZG9jRG9tRWwgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkgKSB7XHJcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY0RvbUVsO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvKipcclxuICAgICAgICogUHJvdmlkZXMgcmVhZC1vbmx5IGVxdWl2YWxlbnQgb2YgalF1ZXJ5J3MgcG9zaXRpb24gZnVuY3Rpb246XHJcbiAgICAgICAqIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9wb3NpdGlvbi9cclxuICAgICAgICovXHJcbiAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBlbEJDUiA9IHRoaXMub2Zmc2V0KGVsZW1lbnQpO1xyXG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnRCQ1IgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xyXG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnRFbCA9IHBhcmVudE9mZnNldEVsKGVsZW1lbnRbMF0pO1xyXG4gICAgICAgIGlmIChvZmZzZXRQYXJlbnRFbCAhPSAkZG9jdW1lbnRbMF0pIHtcclxuICAgICAgICAgIG9mZnNldFBhcmVudEJDUiA9IHRoaXMub2Zmc2V0KGFuZ3VsYXIuZWxlbWVudChvZmZzZXRQYXJlbnRFbCkpO1xyXG4gICAgICAgICAgb2Zmc2V0UGFyZW50QkNSLnRvcCArPSBvZmZzZXRQYXJlbnRFbC5jbGllbnRUb3AgLSBvZmZzZXRQYXJlbnRFbC5zY3JvbGxUb3A7XHJcbiAgICAgICAgICBvZmZzZXRQYXJlbnRCQ1IubGVmdCArPSBvZmZzZXRQYXJlbnRFbC5jbGllbnRMZWZ0IC0gb2Zmc2V0UGFyZW50RWwuc2Nyb2xsTGVmdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB3aWR0aDogZWxlbWVudC5wcm9wKCdvZmZzZXRXaWR0aCcpLFxyXG4gICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LnByb3AoJ29mZnNldEhlaWdodCcpLFxyXG4gICAgICAgICAgdG9wOiBlbEJDUi50b3AgLSBvZmZzZXRQYXJlbnRCQ1IudG9wLFxyXG4gICAgICAgICAgbGVmdDogZWxCQ1IubGVmdCAtIG9mZnNldFBhcmVudEJDUi5sZWZ0XHJcbiAgICAgICAgfTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgZXF1aXZhbGVudCBvZiBqUXVlcnkncyBvZmZzZXQgZnVuY3Rpb246XHJcbiAgICAgICAqIGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9vZmZzZXQvXHJcbiAgICAgICAqL1xyXG4gICAgICBvZmZzZXQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nQ2xpZW50UmVjdCA9IGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHdpZHRoOiBlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJyksXHJcbiAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0JyksXHJcbiAgICAgICAgICB0b3A6IGJvdW5kaW5nQ2xpZW50UmVjdC50b3AgKyAoJHdpbmRvdy5wYWdlWU9mZnNldCB8fCAkZG9jdW1lbnRbMF0uYm9keS5zY3JvbGxUb3AgfHwgJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApLFxyXG4gICAgICAgICAgbGVmdDogYm91bmRpbmdDbGllbnRSZWN0LmxlZnQgKyAoJHdpbmRvdy5wYWdlWE9mZnNldCB8fCAkZG9jdW1lbnRbMF0uYm9keS5zY3JvbGxMZWZ0ICB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRhdGVwaWNrZXInLCBbJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxyXG5cclxuLmNvbnN0YW50KCdkYXRlcGlja2VyQ29uZmlnJywge1xyXG4gIGRheUZvcm1hdDogJ2RkJyxcclxuICBtb250aEZvcm1hdDogJ01NTU0nLFxyXG4gIHllYXJGb3JtYXQ6ICd5eXl5JyxcclxuICBkYXlIZWFkZXJGb3JtYXQ6ICdFRUUnLFxyXG4gIGRheVRpdGxlRm9ybWF0OiAnTU1NTSB5eXl5JyxcclxuICBtb250aFRpdGxlRm9ybWF0OiAneXl5eScsXHJcbiAgc2hvd1dlZWtzOiB0cnVlLFxyXG4gIHN0YXJ0aW5nRGF5OiAwLFxyXG4gIHllYXJSYW5nZTogMjAsXHJcbiAgbWluRGF0ZTogbnVsbCxcclxuICBtYXhEYXRlOiBudWxsXHJcbn0pXHJcblxyXG4uY29udHJvbGxlcignRGF0ZXBpY2tlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnZGF0ZUZpbHRlcicsICdkYXRlcGlja2VyQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsIGRhdGVGaWx0ZXIsIGR0Q29uZmlnKSB7XHJcbiAgdmFyIGZvcm1hdCA9IHtcclxuICAgIGRheTogICAgICAgIGdldFZhbHVlKCRhdHRycy5kYXlGb3JtYXQsICAgICAgICBkdENvbmZpZy5kYXlGb3JtYXQpLFxyXG4gICAgbW9udGg6ICAgICAgZ2V0VmFsdWUoJGF0dHJzLm1vbnRoRm9ybWF0LCAgICAgIGR0Q29uZmlnLm1vbnRoRm9ybWF0KSxcclxuICAgIHllYXI6ICAgICAgIGdldFZhbHVlKCRhdHRycy55ZWFyRm9ybWF0LCAgICAgICBkdENvbmZpZy55ZWFyRm9ybWF0KSxcclxuICAgIGRheUhlYWRlcjogIGdldFZhbHVlKCRhdHRycy5kYXlIZWFkZXJGb3JtYXQsICBkdENvbmZpZy5kYXlIZWFkZXJGb3JtYXQpLFxyXG4gICAgZGF5VGl0bGU6ICAgZ2V0VmFsdWUoJGF0dHJzLmRheVRpdGxlRm9ybWF0LCAgIGR0Q29uZmlnLmRheVRpdGxlRm9ybWF0KSxcclxuICAgIG1vbnRoVGl0bGU6IGdldFZhbHVlKCRhdHRycy5tb250aFRpdGxlRm9ybWF0LCBkdENvbmZpZy5tb250aFRpdGxlRm9ybWF0KVxyXG4gIH0sXHJcbiAgc3RhcnRpbmdEYXkgPSBnZXRWYWx1ZSgkYXR0cnMuc3RhcnRpbmdEYXksICAgICAgZHRDb25maWcuc3RhcnRpbmdEYXkpLFxyXG4gIHllYXJSYW5nZSA9ICAgZ2V0VmFsdWUoJGF0dHJzLnllYXJSYW5nZSwgICAgICAgIGR0Q29uZmlnLnllYXJSYW5nZSk7XHJcblxyXG4gIHRoaXMubWluRGF0ZSA9IGR0Q29uZmlnLm1pbkRhdGUgPyBuZXcgRGF0ZShkdENvbmZpZy5taW5EYXRlKSA6IG51bGw7XHJcbiAgdGhpcy5tYXhEYXRlID0gZHRDb25maWcubWF4RGF0ZSA/IG5ldyBEYXRlKGR0Q29uZmlnLm1heERhdGUpIDogbnVsbDtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKHZhbHVlKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKHZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoKCB5ZWFyLCBtb250aCApIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMCkuZ2V0RGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0RGF0ZXMoc3RhcnREYXRlLCBuKSB7XHJcbiAgICB2YXIgZGF0ZXMgPSBuZXcgQXJyYXkobik7XHJcbiAgICB2YXIgY3VycmVudCA9IHN0YXJ0RGF0ZSwgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IG4pIHtcclxuICAgICAgZGF0ZXNbaSsrXSA9IG5ldyBEYXRlKGN1cnJlbnQpO1xyXG4gICAgICBjdXJyZW50LnNldERhdGUoIGN1cnJlbnQuZ2V0RGF0ZSgpICsgMSApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGVzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWFrZURhdGUoZGF0ZSwgZm9ybWF0LCBpc1NlbGVjdGVkLCBpc1NlY29uZGFyeSkge1xyXG4gICAgcmV0dXJuIHsgZGF0ZTogZGF0ZSwgbGFiZWw6IGRhdGVGaWx0ZXIoZGF0ZSwgZm9ybWF0KSwgc2VsZWN0ZWQ6ICEhaXNTZWxlY3RlZCwgc2Vjb25kYXJ5OiAhIWlzU2Vjb25kYXJ5IH07XHJcbiAgfVxyXG5cclxuICB0aGlzLm1vZGVzID0gW1xyXG4gICAge1xyXG4gICAgICBuYW1lOiAnZGF5JyxcclxuICAgICAgZ2V0VmlzaWJsZURhdGVzOiBmdW5jdGlvbihkYXRlLCBzZWxlY3RlZCkge1xyXG4gICAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKSwgZmlyc3REYXlPZk1vbnRoID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpO1xyXG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gc3RhcnRpbmdEYXkgLSBmaXJzdERheU9mTW9udGguZ2V0RGF5KCksXHJcbiAgICAgICAgbnVtRGlzcGxheWVkRnJvbVByZXZpb3VzTW9udGggPSAoZGlmZmVyZW5jZSA+IDApID8gNyAtIGRpZmZlcmVuY2UgOiAtIGRpZmZlcmVuY2UsXHJcbiAgICAgICAgZmlyc3REYXRlID0gbmV3IERhdGUoZmlyc3REYXlPZk1vbnRoKSwgbnVtRGF0ZXMgPSAwO1xyXG5cclxuICAgICAgICBpZiAoIG51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoID4gMCApIHtcclxuICAgICAgICAgIGZpcnN0RGF0ZS5zZXREYXRlKCAtIG51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoICsgMSApO1xyXG4gICAgICAgICAgbnVtRGF0ZXMgKz0gbnVtRGlzcGxheWVkRnJvbVByZXZpb3VzTW9udGg7IC8vIFByZXZpb3VzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG51bURhdGVzICs9IGdldERheXNJbk1vbnRoKHllYXIsIG1vbnRoICsgMSk7IC8vIEN1cnJlbnRcclxuICAgICAgICBudW1EYXRlcyArPSAoNyAtIG51bURhdGVzICUgNykgJSA3OyAvLyBOZXh0XHJcblxyXG4gICAgICAgIHZhciBkYXlzID0gZ2V0RGF0ZXMoZmlyc3REYXRlLCBudW1EYXRlcyksIGxhYmVscyA9IG5ldyBBcnJheSg3KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGVzOyBpICsrKSB7XHJcbiAgICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZShkYXlzW2ldKTtcclxuICAgICAgICAgIGRheXNbaV0gPSBtYWtlRGF0ZShkdCwgZm9ybWF0LmRheSwgKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldERhdGUoKSA9PT0gZHQuZ2V0RGF0ZSgpICYmIHNlbGVjdGVkLmdldE1vbnRoKCkgPT09IGR0LmdldE1vbnRoKCkgJiYgc2VsZWN0ZWQuZ2V0RnVsbFllYXIoKSA9PT0gZHQuZ2V0RnVsbFllYXIoKSksIGR0LmdldE1vbnRoKCkgIT09IG1vbnRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA3OyBqKyspIHtcclxuICAgICAgICAgIGxhYmVsc1tqXSA9IGRhdGVGaWx0ZXIoZGF5c1tqXS5kYXRlLCBmb3JtYXQuZGF5SGVhZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgb2JqZWN0czogZGF5cywgdGl0bGU6IGRhdGVGaWx0ZXIoZGF0ZSwgZm9ybWF0LmRheVRpdGxlKSwgbGFiZWxzOiBsYWJlbHMgfTtcclxuICAgICAgfSxcclxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XHJcbiAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSggZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSwgZGF0ZTEuZ2V0RGF0ZSgpICkgLSBuZXcgRGF0ZSggZGF0ZTIuZ2V0RnVsbFllYXIoKSwgZGF0ZTIuZ2V0TW9udGgoKSwgZGF0ZTIuZ2V0RGF0ZSgpICkgKTtcclxuICAgICAgfSxcclxuICAgICAgc3BsaXQ6IDcsXHJcbiAgICAgIHN0ZXA6IHsgbW9udGhzOiAxIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6ICdtb250aCcsXHJcbiAgICAgIGdldFZpc2libGVEYXRlczogZnVuY3Rpb24oZGF0ZSwgc2VsZWN0ZWQpIHtcclxuICAgICAgICB2YXIgbW9udGhzID0gbmV3IEFycmF5KDEyKSwgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCAxMjsgaSsrICkge1xyXG4gICAgICAgICAgdmFyIGR0ID0gbmV3IERhdGUoeWVhciwgaSwgMSk7XHJcbiAgICAgICAgICBtb250aHNbaV0gPSBtYWtlRGF0ZShkdCwgZm9ybWF0Lm1vbnRoLCAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQuZ2V0TW9udGgoKSA9PT0gaSAmJiBzZWxlY3RlZC5nZXRGdWxsWWVhcigpID09PSB5ZWFyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IG9iamVjdHM6IG1vbnRocywgdGl0bGU6IGRhdGVGaWx0ZXIoZGF0ZSwgZm9ybWF0Lm1vbnRoVGl0bGUpIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSggZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSApIC0gbmV3IERhdGUoIGRhdGUyLmdldEZ1bGxZZWFyKCksIGRhdGUyLmdldE1vbnRoKCkgKTtcclxuICAgICAgfSxcclxuICAgICAgc3BsaXQ6IDMsXHJcbiAgICAgIHN0ZXA6IHsgeWVhcnM6IDEgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogJ3llYXInLFxyXG4gICAgICBnZXRWaXNpYmxlRGF0ZXM6IGZ1bmN0aW9uKGRhdGUsIHNlbGVjdGVkKSB7XHJcbiAgICAgICAgdmFyIHllYXJzID0gbmV3IEFycmF5KHllYXJSYW5nZSksIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCksIHN0YXJ0WWVhciA9IHBhcnNlSW50KCh5ZWFyIC0gMSkgLyB5ZWFyUmFuZ2UsIDEwKSAqIHllYXJSYW5nZSArIDE7XHJcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgeWVhclJhbmdlOyBpKysgKSB7XHJcbiAgICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZShzdGFydFllYXIgKyBpLCAwLCAxKTtcclxuICAgICAgICAgIHllYXJzW2ldID0gbWFrZURhdGUoZHQsIGZvcm1hdC55ZWFyLCAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQuZ2V0RnVsbFllYXIoKSA9PT0gZHQuZ2V0RnVsbFllYXIoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBvYmplY3RzOiB5ZWFycywgdGl0bGU6IFt5ZWFyc1swXS5sYWJlbCwgeWVhcnNbeWVhclJhbmdlIC0gMV0ubGFiZWxdLmpvaW4oJyAtICcpIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xyXG4gICAgICAgIHJldHVybiBkYXRlMS5nZXRGdWxsWWVhcigpIC0gZGF0ZTIuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgfSxcclxuICAgICAgc3BsaXQ6IDUsXHJcbiAgICAgIHN0ZXA6IHsgeWVhcnM6IHllYXJSYW5nZSB9XHJcbiAgICB9XHJcbiAgXTtcclxuXHJcbiAgdGhpcy5pc0Rpc2FibGVkID0gZnVuY3Rpb24oZGF0ZSwgbW9kZSkge1xyXG4gICAgdmFyIGN1cnJlbnRNb2RlID0gdGhpcy5tb2Rlc1ttb2RlIHx8IDBdO1xyXG4gICAgcmV0dXJuICgodGhpcy5taW5EYXRlICYmIGN1cnJlbnRNb2RlLmNvbXBhcmUoZGF0ZSwgdGhpcy5taW5EYXRlKSA8IDApIHx8ICh0aGlzLm1heERhdGUgJiYgY3VycmVudE1vZGUuY29tcGFyZShkYXRlLCB0aGlzLm1heERhdGUpID4gMCkgfHwgKCRzY29wZS5kYXRlRGlzYWJsZWQgJiYgJHNjb3BlLmRhdGVEaXNhYmxlZCh7ZGF0ZTogZGF0ZSwgbW9kZTogY3VycmVudE1vZGUubmFtZX0pKSk7XHJcbiAgfTtcclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCAnZGF0ZXBpY2tlcicsIFsnZGF0ZUZpbHRlcicsICckcGFyc2UnLCAnZGF0ZXBpY2tlckNvbmZpZycsICckbG9nJywgZnVuY3Rpb24gKGRhdGVGaWx0ZXIsICRwYXJzZSwgZGF0ZXBpY2tlckNvbmZpZywgJGxvZykge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0VBJyxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sJyxcclxuICAgIHNjb3BlOiB7XHJcbiAgICAgIGRhdGVEaXNhYmxlZDogJyYnXHJcbiAgICB9LFxyXG4gICAgcmVxdWlyZTogWydkYXRlcGlja2VyJywgJz9ebmdNb2RlbCddLFxyXG4gICAgY29udHJvbGxlcjogJ0RhdGVwaWNrZXJDb250cm9sbGVyJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcclxuICAgICAgdmFyIGRhdGVwaWNrZXJDdHJsID0gY3RybHNbMF0sIG5nTW9kZWwgPSBjdHJsc1sxXTtcclxuXHJcbiAgICAgIGlmICghbmdNb2RlbCkge1xyXG4gICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZyBpZiBubyBuZy1tb2RlbFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcclxuICAgICAgdmFyIG1vZGUgPSAwLCBzZWxlY3RlZCA9IG5ldyBEYXRlKCksIHNob3dXZWVrcyA9IGRhdGVwaWNrZXJDb25maWcuc2hvd1dlZWtzO1xyXG5cclxuICAgICAgaWYgKGF0dHJzLnNob3dXZWVrcykge1xyXG4gICAgICAgIHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZShhdHRycy5zaG93V2Vla3MpLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgc2hvd1dlZWtzID0gISEgdmFsdWU7XHJcbiAgICAgICAgICB1cGRhdGVTaG93V2Vla051bWJlcnMoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB1cGRhdGVTaG93V2Vla051bWJlcnMoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGF0dHJzLm1pbikge1xyXG4gICAgICAgIHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZShhdHRycy5taW4pLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgZGF0ZXBpY2tlckN0cmwubWluRGF0ZSA9IHZhbHVlID8gbmV3IERhdGUodmFsdWUpIDogbnVsbDtcclxuICAgICAgICAgIHJlZmlsbCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhdHRycy5tYXgpIHtcclxuICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMubWF4KSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIGRhdGVwaWNrZXJDdHJsLm1heERhdGUgPSB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlKSA6IG51bGw7XHJcbiAgICAgICAgICByZWZpbGwoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gdXBkYXRlU2hvd1dlZWtOdW1iZXJzKCkge1xyXG4gICAgICAgIHNjb3BlLnNob3dXZWVrTnVtYmVycyA9IG1vZGUgPT09IDAgJiYgc2hvd1dlZWtzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTcGxpdCBhcnJheSBpbnRvIHNtYWxsZXIgYXJyYXlzXHJcbiAgICAgIGZ1bmN0aW9uIHNwbGl0KGFyciwgc2l6ZSkge1xyXG4gICAgICAgIHZhciBhcnJheXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoYXJyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGFycmF5cy5wdXNoKGFyci5zcGxpY2UoMCwgc2l6ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXlzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiByZWZpbGwoIHVwZGF0ZVNlbGVjdGVkICkge1xyXG4gICAgICAgIHZhciBkYXRlID0gbnVsbCwgdmFsaWQgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoIG5nTW9kZWwuJG1vZGVsVmFsdWUgKSB7XHJcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUoIG5nTW9kZWwuJG1vZGVsVmFsdWUgKTtcclxuXHJcbiAgICAgICAgICBpZiAoIGlzTmFOKGRhdGUpICkge1xyXG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAkbG9nLmVycm9yKCdEYXRlcGlja2VyIGRpcmVjdGl2ZTogXCJuZy1tb2RlbFwiIHZhbHVlIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDAxLjAxLjE5NzAgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIFJGQzI4MjIgb3IgSVNPIDg2MDEgZGF0ZS4nKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoIHVwZGF0ZVNlbGVjdGVkICkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGRhdGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCdkYXRlJywgdmFsaWQpO1xyXG5cclxuICAgICAgICB2YXIgY3VycmVudE1vZGUgPSBkYXRlcGlja2VyQ3RybC5tb2Rlc1ttb2RlXSwgZGF0YSA9IGN1cnJlbnRNb2RlLmdldFZpc2libGVEYXRlcyhzZWxlY3RlZCwgZGF0ZSk7XHJcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGRhdGEub2JqZWN0cywgZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICBvYmouZGlzYWJsZWQgPSBkYXRlcGlja2VyQ3RybC5pc0Rpc2FibGVkKG9iai5kYXRlLCBtb2RlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ2RhdGUtZGlzYWJsZWQnLCAoIWRhdGUgfHwgIWRhdGVwaWNrZXJDdHJsLmlzRGlzYWJsZWQoZGF0ZSkpKTtcclxuXHJcbiAgICAgICAgc2NvcGUucm93cyA9IHNwbGl0KGRhdGEub2JqZWN0cywgY3VycmVudE1vZGUuc3BsaXQpO1xyXG4gICAgICAgIHNjb3BlLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xyXG4gICAgICAgIHNjb3BlLnRpdGxlID0gZGF0YS50aXRsZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc2V0TW9kZSh2YWx1ZSkge1xyXG4gICAgICAgIG1vZGUgPSB2YWx1ZTtcclxuICAgICAgICB1cGRhdGVTaG93V2Vla051bWJlcnMoKTtcclxuICAgICAgICByZWZpbGwoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbmdNb2RlbC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmVmaWxsKCB0cnVlICk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzY29wZS5zZWxlY3QgPSBmdW5jdGlvbiggZGF0ZSApIHtcclxuICAgICAgICBpZiAoIG1vZGUgPT09IDAgKSB7XHJcbiAgICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZSggbmdNb2RlbC4kbW9kZWxWYWx1ZSApO1xyXG4gICAgICAgICAgZHQuc2V0RnVsbFllYXIoIGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSApO1xyXG4gICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKCBkdCApO1xyXG4gICAgICAgICAgcmVmaWxsKCB0cnVlICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNlbGVjdGVkID0gZGF0ZTtcclxuICAgICAgICAgIHNldE1vZGUoIG1vZGUgLSAxICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBzY29wZS5tb3ZlID0gZnVuY3Rpb24oZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIHN0ZXAgPSBkYXRlcGlja2VyQ3RybC5tb2Rlc1ttb2RlXS5zdGVwO1xyXG4gICAgICAgIHNlbGVjdGVkLnNldE1vbnRoKCBzZWxlY3RlZC5nZXRNb250aCgpICsgZGlyZWN0aW9uICogKHN0ZXAubW9udGhzIHx8IDApICk7XHJcbiAgICAgICAgc2VsZWN0ZWQuc2V0RnVsbFllYXIoIHNlbGVjdGVkLmdldEZ1bGxZZWFyKCkgKyBkaXJlY3Rpb24gKiAoc3RlcC55ZWFycyB8fCAwKSApO1xyXG4gICAgICAgIHJlZmlsbCgpO1xyXG4gICAgICB9O1xyXG4gICAgICBzY29wZS50b2dnbGVNb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2V0TW9kZSggKG1vZGUgKyAxKSAlIGRhdGVwaWNrZXJDdHJsLm1vZGVzLmxlbmd0aCApO1xyXG4gICAgICB9O1xyXG4gICAgICBzY29wZS5nZXRXZWVrTnVtYmVyID0gZnVuY3Rpb24ocm93KSB7XHJcbiAgICAgICAgcmV0dXJuICggbW9kZSA9PT0gMCAmJiBzY29wZS5zaG93V2Vla051bWJlcnMgJiYgcm93Lmxlbmd0aCA9PT0gNyApID8gZ2V0SVNPODYwMVdlZWtOdW1iZXIocm93WzBdLmRhdGUpIDogbnVsbDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdldElTTzg2MDFXZWVrTnVtYmVyKGRhdGUpIHtcclxuICAgICAgICB2YXIgY2hlY2tEYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgICAgICAgY2hlY2tEYXRlLnNldERhdGUoY2hlY2tEYXRlLmdldERhdGUoKSArIDQgLSAoY2hlY2tEYXRlLmdldERheSgpIHx8IDcpKTsgLy8gVGh1cnNkYXlcclxuICAgICAgICB2YXIgdGltZSA9IGNoZWNrRGF0ZS5nZXRUaW1lKCk7XHJcbiAgICAgICAgY2hlY2tEYXRlLnNldE1vbnRoKDApOyAvLyBDb21wYXJlIHdpdGggSmFuIDFcclxuICAgICAgICBjaGVja0RhdGUuc2V0RGF0ZSgxKTtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJvdW5kKCh0aW1lIC0gY2hlY2tEYXRlKSAvIDg2NDAwMDAwKSAvIDcpICsgMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuLmNvbnN0YW50KCdkYXRlcGlja2VyUG9wdXBDb25maWcnLCB7XHJcbiAgZGF0ZUZvcm1hdDogJ3l5eXktTU0tZGQnLFxyXG4gIGNsb3NlT25EYXRlU2VsZWN0aW9uOiB0cnVlXHJcbn0pXHJcblxyXG4uZGlyZWN0aXZlKCdkYXRlcGlja2VyUG9wdXAnLCBbJyRjb21waWxlJywgJyRwYXJzZScsICckZG9jdW1lbnQnLCAnJHBvc2l0aW9uJywgJ2RhdGVGaWx0ZXInLCAnZGF0ZXBpY2tlclBvcHVwQ29uZmlnJyxcclxuZnVuY3Rpb24gKCRjb21waWxlLCAkcGFyc2UsICRkb2N1bWVudCwgJHBvc2l0aW9uLCBkYXRlRmlsdGVyLCBkYXRlcGlja2VyUG9wdXBDb25maWcpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICByZXF1aXJlOiAnbmdNb2RlbCcsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihvcmlnaW5hbFNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbCkge1xyXG5cclxuICAgICAgdmFyIGNsb3NlT25EYXRlU2VsZWN0aW9uID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuY2xvc2VPbkRhdGVTZWxlY3Rpb24pID8gc2NvcGUuJGV2YWwoYXR0cnMuY2xvc2VPbkRhdGVTZWxlY3Rpb24pIDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmNsb3NlT25EYXRlU2VsZWN0aW9uO1xyXG4gICAgICB2YXIgZGF0ZUZvcm1hdCA9IGF0dHJzLmRhdGVwaWNrZXJQb3B1cCB8fCBkYXRlcGlja2VyUG9wdXBDb25maWcuZGF0ZUZvcm1hdDtcclxuXHJcbiAgICAgLy8gY3JlYXRlIGEgY2hpbGQgc2NvcGUgZm9yIHRoZSBkYXRlcGlja2VyIGRpcmVjdGl2ZSBzbyB3ZSBhcmUgbm90IHBvbGx1dGluZyBvcmlnaW5hbCBzY29wZVxyXG4gICAgICB2YXIgc2NvcGUgPSBvcmlnaW5hbFNjb3BlLiRuZXcoKTtcclxuICAgICAgb3JpZ2luYWxTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2NvcGUuJGRlc3Ryb3koKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB2YXIgZ2V0SXNPcGVuLCBzZXRJc09wZW47XHJcbiAgICAgIGlmICggYXR0cnMuaXNPcGVuICkge1xyXG4gICAgICAgIGdldElzT3BlbiA9ICRwYXJzZShhdHRycy5pc09wZW4pO1xyXG4gICAgICAgIHNldElzT3BlbiA9IGdldElzT3Blbi5hc3NpZ247XHJcblxyXG4gICAgICAgIG9yaWdpbmFsU2NvcGUuJHdhdGNoKGdldElzT3BlbiwgZnVuY3Rpb24gdXBkYXRlT3Blbih2YWx1ZSkge1xyXG4gICAgICAgICAgc2NvcGUuaXNPcGVuID0gISEgdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgc2NvcGUuaXNPcGVuID0gZ2V0SXNPcGVuID8gZ2V0SXNPcGVuKG9yaWdpbmFsU2NvcGUpIDogZmFsc2U7IC8vIEluaXRpYWwgc3RhdGVcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHNldE9wZW4oIHZhbHVlICkge1xyXG4gICAgICAgIGlmIChzZXRJc09wZW4pIHtcclxuICAgICAgICAgIHNldElzT3BlbihvcmlnaW5hbFNjb3BlLCAhIXZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2NvcGUuaXNPcGVuID0gISF2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBkb2N1bWVudENsaWNrQmluZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHNjb3BlLmlzT3BlbiAmJiBldmVudC50YXJnZXQgIT09IGVsZW1lbnRbMF0pIHtcclxuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgc2V0T3BlbihmYWxzZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgZWxlbWVudEZvY3VzQmluZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNldE9wZW4oIHRydWUgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIHBvcHVwIGVsZW1lbnQgdXNlZCB0byBkaXNwbGF5IGNhbGVuZGFyXHJcbiAgICAgIHZhciBwb3B1cEVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGF0ZXBpY2tlci1wb3B1cC13cmFwPjxkYXRlcGlja2VyPjwvZGF0ZXBpY2tlcj48L2RhdGVwaWNrZXItcG9wdXAtd3JhcD4nKTtcclxuICAgICAgcG9wdXBFbC5hdHRyKHtcclxuICAgICAgICAnbmctbW9kZWwnOiAnZGF0ZScsXHJcbiAgICAgICAgJ25nLWNoYW5nZSc6ICdkYXRlU2VsZWN0aW9uKCknXHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXIgZGF0ZXBpY2tlckVsID0gcG9wdXBFbC5maW5kKCdkYXRlcGlja2VyJyk7XHJcbiAgICAgIGlmIChhdHRycy5kYXRlcGlja2VyT3B0aW9ucykge1xyXG4gICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKGFuZ3VsYXIuZXh0ZW5kKHt9LCBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLmRhdGVwaWNrZXJPcHRpb25zKSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUT0RPOiByZXZlcnNlIGZyb20gZGF0ZUZpbHRlciBzdHJpbmcgdG8gRGF0ZSBvYmplY3RcclxuICAgICAgZnVuY3Rpb24gcGFyc2VEYXRlKHZpZXdWYWx1ZSkge1xyXG4gICAgICAgIGlmICghdmlld1ZhbHVlKSB7XHJcbiAgICAgICAgICBuZ01vZGVsLiRzZXRWYWxpZGl0eSgnZGF0ZScsIHRydWUpO1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzRGF0ZSh2aWV3VmFsdWUpKSB7XHJcbiAgICAgICAgICBuZ01vZGVsLiRzZXRWYWxpZGl0eSgnZGF0ZScsIHRydWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHZpZXdWYWx1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFuZ3VsYXIuaXNTdHJpbmcodmlld1ZhbHVlKSkge1xyXG4gICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh2aWV3VmFsdWUpO1xyXG4gICAgICAgICAgaWYgKGlzTmFOKGRhdGUpKSB7XHJcbiAgICAgICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCdkYXRlJywgZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ2RhdGUnLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCdkYXRlJywgZmFsc2UpO1xyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgbmdNb2RlbC4kcGFyc2Vycy51bnNoaWZ0KHBhcnNlRGF0ZSk7XHJcblxyXG4gICAgICAvLyBJbm5lciBjaGFuZ2VcclxuICAgICAgc2NvcGUuZGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZShzY29wZS5kYXRlKTtcclxuICAgICAgICBuZ01vZGVsLiRyZW5kZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGNsb3NlT25EYXRlU2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICBzZXRPcGVuKCBmYWxzZSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGVsZW1lbnQuYmluZCgnaW5wdXQgY2hhbmdlIGtleXVwJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdXBkYXRlQ2FsZW5kYXIoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBPdXR0ZXIgY2hhbmdlXHJcbiAgICAgIG5nTW9kZWwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBkYXRlID0gbmdNb2RlbC4kdmlld1ZhbHVlID8gZGF0ZUZpbHRlcihuZ01vZGVsLiR2aWV3VmFsdWUsIGRhdGVGb3JtYXQpIDogJyc7XHJcbiAgICAgICAgZWxlbWVudC52YWwoZGF0ZSk7XHJcblxyXG4gICAgICAgIHVwZGF0ZUNhbGVuZGFyKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmdW5jdGlvbiB1cGRhdGVDYWxlbmRhcigpIHtcclxuICAgICAgICBzY29wZS5kYXRlID0gbmdNb2RlbC4kbW9kZWxWYWx1ZTtcclxuICAgICAgICB1cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBhZGRXYXRjaGFibGVBdHRyaWJ1dGUoYXR0cmlidXRlLCBzY29wZVByb3BlcnR5LCBkYXRlcGlja2VyQXR0cmlidXRlKSB7XHJcbiAgICAgICAgaWYgKGF0dHJpYnV0ZSkge1xyXG4gICAgICAgICAgb3JpZ2luYWxTY29wZS4kd2F0Y2goJHBhcnNlKGF0dHJpYnV0ZSksIGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgICAgc2NvcGVbc2NvcGVQcm9wZXJ0eV0gPSB2YWx1ZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoZGF0ZXBpY2tlckF0dHJpYnV0ZSB8fCBzY29wZVByb3BlcnR5LCBzY29wZVByb3BlcnR5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYWRkV2F0Y2hhYmxlQXR0cmlidXRlKGF0dHJzLm1pbiwgJ21pbicpO1xyXG4gICAgICBhZGRXYXRjaGFibGVBdHRyaWJ1dGUoYXR0cnMubWF4LCAnbWF4Jyk7XHJcbiAgICAgIGlmIChhdHRycy5zaG93V2Vla3MpIHtcclxuICAgICAgICBhZGRXYXRjaGFibGVBdHRyaWJ1dGUoYXR0cnMuc2hvd1dlZWtzLCAnc2hvd1dlZWtzJywgJ3Nob3ctd2Vla3MnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzY29wZS5zaG93V2Vla3MgPSB0cnVlO1xyXG4gICAgICAgIGRhdGVwaWNrZXJFbC5hdHRyKCdzaG93LXdlZWtzJywgJ3Nob3dXZWVrcycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhdHRycy5kYXRlRGlzYWJsZWQpIHtcclxuICAgICAgICBkYXRlcGlja2VyRWwuYXR0cignZGF0ZS1kaXNhYmxlZCcsIGF0dHJzLmRhdGVEaXNhYmxlZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCkge1xyXG4gICAgICAgIHNjb3BlLnBvc2l0aW9uID0gJHBvc2l0aW9uLnBvc2l0aW9uKGVsZW1lbnQpO1xyXG4gICAgICAgIHNjb3BlLnBvc2l0aW9uLnRvcCA9IHNjb3BlLnBvc2l0aW9uLnRvcCArIGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBkb2N1bWVudEJpbmRpbmdJbml0aWFsaXplZCA9IGZhbHNlLCBlbGVtZW50Rm9jdXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICBzY29wZS4kd2F0Y2goJ2lzT3BlbicsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICB1cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgJGRvY3VtZW50LmJpbmQoJ2NsaWNrJywgZG9jdW1lbnRDbGlja0JpbmQpO1xyXG4gICAgICAgICAgaWYoZWxlbWVudEZvY3VzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC51bmJpbmQoJ2ZvY3VzJywgZWxlbWVudEZvY3VzQmluZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbGVtZW50WzBdLmZvY3VzKCk7XHJcbiAgICAgICAgICBkb2N1bWVudEJpbmRpbmdJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmKGRvY3VtZW50QmluZGluZ0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICRkb2N1bWVudC51bmJpbmQoJ2NsaWNrJywgZG9jdW1lbnRDbGlja0JpbmQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxlbWVudC5iaW5kKCdmb2N1cycsIGVsZW1lbnRGb2N1c0JpbmQpO1xyXG4gICAgICAgICAgZWxlbWVudEZvY3VzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBzZXRJc09wZW4gKSB7XHJcbiAgICAgICAgICBzZXRJc09wZW4ob3JpZ2luYWxTY29wZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB2YXIgJHNldE1vZGVsVmFsdWUgPSAkcGFyc2UoYXR0cnMubmdNb2RlbCkuYXNzaWduO1xyXG5cclxuICAgICAgc2NvcGUudG9kYXkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAkc2V0TW9kZWxWYWx1ZShvcmlnaW5hbFNjb3BlLCBuZXcgRGF0ZSgpKTtcclxuICAgICAgfTtcclxuICAgICAgc2NvcGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAkc2V0TW9kZWxWYWx1ZShvcmlnaW5hbFNjb3BlLCBudWxsKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGVsZW1lbnQuYWZ0ZXIoJGNvbXBpbGUocG9wdXBFbCkoc2NvcGUpKTtcclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ2RhdGVwaWNrZXJQb3B1cFdyYXAnLCBbZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OidFJyxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWwnLFxyXG4gICAgbGluazpmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgIGVsZW1lbnQuYmluZCgnY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKTtcclxuXHJcbi8qXHJcbiAqIGRyb3Bkb3duVG9nZ2xlIC0gUHJvdmlkZXMgZHJvcGRvd24gbWVudSBmdW5jdGlvbmFsaXR5IGluIHBsYWNlIG9mIGJvb3RzdHJhcCBqc1xyXG4gKiBAcmVzdHJpY3QgY2xhc3Mgb3IgYXR0cmlidXRlXHJcbiAqIEBleGFtcGxlOlxyXG4gICA8bGkgY2xhc3M9XCJkcm9wZG93blwiPlxyXG4gICAgIDxhIGNsYXNzPVwiZHJvcGRvd24tdG9nZ2xlXCI+TXkgRHJvcGRvd24gTWVudTwvYT5cclxuICAgICA8dWwgY2xhc3M9XCJkcm9wZG93bi1tZW51XCI+XHJcbiAgICAgICA8bGkgbmctcmVwZWF0PVwiY2hvaWNlIGluIGRyb3BDaG9pY2VzXCI+XHJcbiAgICAgICAgIDxhIG5nLWhyZWY9XCJ7e2Nob2ljZS5ocmVmfX1cIj57e2Nob2ljZS50ZXh0fX08L2E+XHJcbiAgICAgICA8L2xpPlxyXG4gICAgIDwvdWw+XHJcbiAgIDwvbGk+XHJcbiAqL1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5kcm9wZG93blRvZ2dsZScsIFtdKS5kaXJlY3RpdmUoJ2Ryb3Bkb3duVG9nZ2xlJywgWyckZG9jdW1lbnQnLCAnJGxvY2F0aW9uJywgZnVuY3Rpb24gKCRkb2N1bWVudCwgJGxvY2F0aW9uKSB7XHJcbiAgdmFyIG9wZW5FbGVtZW50ID0gbnVsbCxcclxuICAgICAgY2xvc2VNZW51ICAgPSBhbmd1bGFyLm5vb3A7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnQ0EnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgIHNjb3BlLiR3YXRjaCgnJGxvY2F0aW9uLnBhdGgnLCBmdW5jdGlvbigpIHsgY2xvc2VNZW51KCk7IH0pO1xyXG4gICAgICBlbGVtZW50LnBhcmVudCgpLmJpbmQoJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGNsb3NlTWVudSgpOyB9KTtcclxuICAgICAgZWxlbWVudC5iaW5kKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xyXG5cclxuICAgICAgICB2YXIgZWxlbWVudFdhc09wZW4gPSAoZWxlbWVudCA9PT0gb3BlbkVsZW1lbnQpO1xyXG5cclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICBpZiAoISFvcGVuRWxlbWVudCkge1xyXG4gICAgICAgICAgY2xvc2VNZW51KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWVsZW1lbnRXYXNPcGVuKSB7XHJcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCgpLmFkZENsYXNzKCdvcGVuJyk7XHJcbiAgICAgICAgICBvcGVuRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICBjbG9zZU1lbnUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAkZG9jdW1lbnQudW5iaW5kKCdjbGljaycsIGNsb3NlTWVudSk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICAgICAgY2xvc2VNZW51ID0gYW5ndWxhci5ub29wO1xyXG4gICAgICAgICAgICBvcGVuRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgJGRvY3VtZW50LmJpbmQoJ2NsaWNrJywgY2xvc2VNZW51KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKTtcclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5tb2RhbCcsIFtdKVxyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyLCBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSB0aGF0IGFjdHMgYXMgYSBtYXAgYnV0IGFsc28gYWxsb3dzIGdldHRpbmcgLyByZW1vdmluZ1xyXG4gKiBlbGVtZW50cyBpbiB0aGUgTElGTyBvcmRlclxyXG4gKi9cclxuICAuZmFjdG9yeSgnJCRzdGFja2VkTWFwJywgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY3JlYXRlTmV3OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0YWNrID0gW107XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbaV07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBrZXlzLnB1c2goc3RhY2tbaV0ua2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB0b3A6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBpZiAoa2V5ID09IHN0YWNrW2ldLmtleSkge1xyXG4gICAgICAgICAgICAgICAgaWR4ID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suc3BsaWNlKGlkeCwgMSlbMF07XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcmVtb3ZlVG9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gMSwgMSlbMF07XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KVxyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyIGRpcmVjdGl2ZSBmb3IgdGhlICRtb2RhbCBzZXJ2aWNlLiBJdCBjcmVhdGVzIGEgYmFja2Ryb3AgZWxlbWVudC5cclxuICovXHJcbiAgLmRpcmVjdGl2ZSgnbW9kYWxCYWNrZHJvcCcsIFsnJG1vZGFsU3RhY2snLCAnJHRpbWVvdXQnLCBmdW5jdGlvbiAoJG1vZGFsU3RhY2ssICR0aW1lb3V0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXN0cmljdDogJ0VBJyxcclxuICAgICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sJyxcclxuICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG5cclxuICAgICAgICAvL3RyaWdnZXIgQ1NTIHRyYW5zaXRpb25zXHJcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgc2NvcGUuYW5pbWF0ZSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNjb3BlLmNsb3NlID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgdmFyIG1vZGFsID0gJG1vZGFsU3RhY2suZ2V0VG9wKCk7XHJcbiAgICAgICAgICBpZiAobW9kYWwgJiYgbW9kYWwudmFsdWUuYmFja2Ryb3AgJiYgbW9kYWwudmFsdWUuYmFja2Ryb3AgIT0gJ3N0YXRpYycpIHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgJG1vZGFsU3RhY2suZGlzbWlzcyhtb2RhbC5rZXksICdiYWNrZHJvcCBjbGljaycpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfV0pXHJcblxyXG4gIC5kaXJlY3RpdmUoJ21vZGFsV2luZG93JywgWyckdGltZW91dCcsIGZ1bmN0aW9uICgkdGltZW91dCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgaW5kZXg6ICdAJ1xyXG4gICAgICB9LFxyXG4gICAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sJyxcclxuICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG4gICAgICAgIHNjb3BlLndpbmRvd0NsYXNzID0gYXR0cnMud2luZG93Q2xhc3MgfHwgJyc7XHJcblxyXG4gICAgICAgIC8vdHJpZ2dlciBDU1MgdHJhbnNpdGlvbnNcclxuICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBzY29wZS5hbmltYXRlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XSlcclxuXHJcbiAgLmZhY3RvcnkoJyRtb2RhbFN0YWNrJywgWyckZG9jdW1lbnQnLCAnJGNvbXBpbGUnLCAnJHJvb3RTY29wZScsICckJHN0YWNrZWRNYXAnLFxyXG4gICAgZnVuY3Rpb24gKCRkb2N1bWVudCwgJGNvbXBpbGUsICRyb290U2NvcGUsICQkc3RhY2tlZE1hcCkge1xyXG5cclxuICAgICAgdmFyIGJhY2tkcm9wanFMaXRlRWwsIGJhY2tkcm9wRG9tRWw7XHJcbiAgICAgIHZhciBiYWNrZHJvcFNjb3BlID0gJHJvb3RTY29wZS4kbmV3KHRydWUpO1xyXG4gICAgICB2YXIgYm9keSA9ICRkb2N1bWVudC5maW5kKCdib2R5JykuZXEoMCk7XHJcbiAgICAgIHZhciBvcGVuZWRXaW5kb3dzID0gJCRzdGFja2VkTWFwLmNyZWF0ZU5ldygpO1xyXG4gICAgICB2YXIgJG1vZGFsU3RhY2sgPSB7fTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGJhY2tkcm9wSW5kZXgoKSB7XHJcbiAgICAgICAgdmFyIHRvcEJhY2tkcm9wSW5kZXggPSAtMTtcclxuICAgICAgICB2YXIgb3BlbmVkID0gb3BlbmVkV2luZG93cy5rZXlzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcGVuZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChvcGVuZWRXaW5kb3dzLmdldChvcGVuZWRbaV0pLnZhbHVlLmJhY2tkcm9wKSB7XHJcbiAgICAgICAgICAgIHRvcEJhY2tkcm9wSW5kZXggPSBpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9wQmFja2Ryb3BJbmRleDtcclxuICAgICAgfVxyXG5cclxuICAgICAgJHJvb3RTY29wZS4kd2F0Y2goYmFja2Ryb3BJbmRleCwgZnVuY3Rpb24obmV3QmFja2Ryb3BJbmRleCl7XHJcbiAgICAgICAgYmFja2Ryb3BTY29wZS5pbmRleCA9IG5ld0JhY2tkcm9wSW5kZXg7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gcmVtb3ZlTW9kYWxXaW5kb3cobW9kYWxJbnN0YW5jZSkge1xyXG5cclxuICAgICAgICB2YXIgbW9kYWxXaW5kb3cgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKS52YWx1ZTtcclxuXHJcbiAgICAgICAgLy9jbGVhbiB1cCB0aGUgc3RhY2tcclxuICAgICAgICBvcGVuZWRXaW5kb3dzLnJlbW92ZShtb2RhbEluc3RhbmNlKTtcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgd2luZG93IERPTSBlbGVtZW50XHJcbiAgICAgICAgbW9kYWxXaW5kb3cubW9kYWxEb21FbC5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgYmFja2Ryb3AgaWYgbm8gbG9uZ2VyIG5lZWRlZFxyXG4gICAgICAgIGlmIChiYWNrZHJvcEluZGV4KCkgPT0gLTEpIHtcclxuICAgICAgICAgIGJhY2tkcm9wRG9tRWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICBiYWNrZHJvcERvbUVsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9kZXN0cm95IHNjb3BlXHJcbiAgICAgICAgbW9kYWxXaW5kb3cubW9kYWxTY29wZS4kZGVzdHJveSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAkZG9jdW1lbnQuYmluZCgna2V5ZG93bicsIGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICB2YXIgbW9kYWw7XHJcblxyXG4gICAgICAgIGlmIChldnQud2hpY2ggPT09IDI3KSB7XHJcbiAgICAgICAgICBtb2RhbCA9IG9wZW5lZFdpbmRvd3MudG9wKCk7XHJcbiAgICAgICAgICBpZiAobW9kYWwgJiYgbW9kYWwudmFsdWUua2V5Ym9hcmQpIHtcclxuICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MobW9kYWwua2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICRtb2RhbFN0YWNrLm9wZW4gPSBmdW5jdGlvbiAobW9kYWxJbnN0YW5jZSwgbW9kYWwpIHtcclxuXHJcbiAgICAgICAgb3BlbmVkV2luZG93cy5hZGQobW9kYWxJbnN0YW5jZSwge1xyXG4gICAgICAgICAgZGVmZXJyZWQ6IG1vZGFsLmRlZmVycmVkLFxyXG4gICAgICAgICAgbW9kYWxTY29wZTogbW9kYWwuc2NvcGUsXHJcbiAgICAgICAgICBiYWNrZHJvcDogbW9kYWwuYmFja2Ryb3AsXHJcbiAgICAgICAgICBrZXlib2FyZDogbW9kYWwua2V5Ym9hcmRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIGFuZ3VsYXJEb21FbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiBtb2RhbC13aW5kb3c+PC9kaXY+Jyk7XHJcbiAgICAgICAgYW5ndWxhckRvbUVsLmF0dHIoJ3dpbmRvdy1jbGFzcycsIG1vZGFsLndpbmRvd0NsYXNzKTtcclxuICAgICAgICBhbmd1bGFyRG9tRWwuYXR0cignaW5kZXgnLCBvcGVuZWRXaW5kb3dzLmxlbmd0aCgpIC0gMSk7XHJcbiAgICAgICAgYW5ndWxhckRvbUVsLmh0bWwobW9kYWwuY29udGVudCk7XHJcblxyXG4gICAgICAgIHZhciBtb2RhbERvbUVsID0gJGNvbXBpbGUoYW5ndWxhckRvbUVsKShtb2RhbC5zY29wZSk7XHJcbiAgICAgICAgb3BlbmVkV2luZG93cy50b3AoKS52YWx1ZS5tb2RhbERvbUVsID0gbW9kYWxEb21FbDtcclxuICAgICAgICBib2R5LmFwcGVuZChtb2RhbERvbUVsKTtcclxuXHJcbiAgICAgICAgaWYgKGJhY2tkcm9wSW5kZXgoKSA+PSAwICYmICFiYWNrZHJvcERvbUVsKSB7XHJcbiAgICAgICAgICAgIGJhY2tkcm9wanFMaXRlRWwgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXYgbW9kYWwtYmFja2Ryb3A+PC9kaXY+Jyk7XHJcbiAgICAgICAgICAgIGJhY2tkcm9wRG9tRWwgPSAkY29tcGlsZShiYWNrZHJvcGpxTGl0ZUVsKShiYWNrZHJvcFNjb3BlKTtcclxuICAgICAgICAgICAgYm9keS5hcHBlbmQoYmFja2Ryb3BEb21FbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgJG1vZGFsU3RhY2suY2xvc2UgPSBmdW5jdGlvbiAobW9kYWxJbnN0YW5jZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIG1vZGFsID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSk7XHJcbiAgICAgICAgaWYgKG1vZGFsKSB7XHJcbiAgICAgICAgICBtb2RhbC52YWx1ZS5kZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICByZW1vdmVNb2RhbFdpbmRvdyhtb2RhbEluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkbW9kYWxTdGFjay5kaXNtaXNzID0gZnVuY3Rpb24gKG1vZGFsSW5zdGFuY2UsIHJlYXNvbikge1xyXG4gICAgICAgIHZhciBtb2RhbFdpbmRvdyA9IG9wZW5lZFdpbmRvd3MuZ2V0KG1vZGFsSW5zdGFuY2UpLnZhbHVlO1xyXG4gICAgICAgIGlmIChtb2RhbFdpbmRvdykge1xyXG4gICAgICAgICAgbW9kYWxXaW5kb3cuZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XHJcbiAgICAgICAgICByZW1vdmVNb2RhbFdpbmRvdyhtb2RhbEluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAkbW9kYWxTdGFjay5nZXRUb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wZW5lZFdpbmRvd3MudG9wKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gJG1vZGFsU3RhY2s7XHJcbiAgICB9XSlcclxuXHJcbiAgLnByb3ZpZGVyKCckbW9kYWwnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyICRtb2RhbFByb3ZpZGVyID0ge1xyXG4gICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgYmFja2Ryb3A6IHRydWUsIC8vY2FuIGJlIGFsc28gZmFsc2Ugb3IgJ3N0YXRpYydcclxuICAgICAgICBrZXlib2FyZDogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICAkZ2V0OiBbJyRpbmplY3RvcicsICckcm9vdFNjb3BlJywgJyRxJywgJyRodHRwJywgJyR0ZW1wbGF0ZUNhY2hlJywgJyRjb250cm9sbGVyJywgJyRtb2RhbFN0YWNrJyxcclxuICAgICAgICBmdW5jdGlvbiAoJGluamVjdG9yLCAkcm9vdFNjb3BlLCAkcSwgJGh0dHAsICR0ZW1wbGF0ZUNhY2hlLCAkY29udHJvbGxlciwgJG1vZGFsU3RhY2spIHtcclxuXHJcbiAgICAgICAgICB2YXIgJG1vZGFsID0ge307XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VGVtcGxhdGVQcm9taXNlKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMudGVtcGxhdGUgPyAkcS53aGVuKG9wdGlvbnMudGVtcGxhdGUpIDpcclxuICAgICAgICAgICAgICAkaHR0cC5nZXQob3B0aW9ucy50ZW1wbGF0ZVVybCwge2NhY2hlOiAkdGVtcGxhdGVDYWNoZX0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIGdldFJlc29sdmVQcm9taXNlcyhyZXNvbHZlcykge1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXNBcnIgPSBbXTtcclxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc29sdmVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24odmFsdWUpIHx8IGFuZ3VsYXIuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzQXJyLnB1c2goJHEud2hlbigkaW5qZWN0b3IuaW52b2tlKHZhbHVlKSkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlc0FycjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAkbW9kYWwub3BlbiA9IGZ1bmN0aW9uIChtb2RhbE9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBtb2RhbFJlc3VsdERlZmVycmVkID0gJHEuZGVmZXIoKTtcclxuICAgICAgICAgICAgdmFyIG1vZGFsT3BlbmVkRGVmZXJyZWQgPSAkcS5kZWZlcigpO1xyXG5cclxuICAgICAgICAgICAgLy9wcmVwYXJlIGFuIGluc3RhbmNlIG9mIGEgbW9kYWwgdG8gYmUgaW5qZWN0ZWQgaW50byBjb250cm9sbGVycyBhbmQgcmV0dXJuZWQgdG8gYSBjYWxsZXJcclxuICAgICAgICAgICAgdmFyIG1vZGFsSW5zdGFuY2UgPSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0OiBtb2RhbFJlc3VsdERlZmVycmVkLnByb21pc2UsXHJcbiAgICAgICAgICAgICAgb3BlbmVkOiBtb2RhbE9wZW5lZERlZmVycmVkLnByb21pc2UsXHJcbiAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICRtb2RhbFN0YWNrLmNsb3NlKG1vZGFsSW5zdGFuY2UsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBkaXNtaXNzOiBmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsSW5zdGFuY2UsIHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy9tZXJnZSBhbmQgY2xlYW4gdXAgb3B0aW9uc1xyXG4gICAgICAgICAgICBtb2RhbE9wdGlvbnMgPSBhbmd1bGFyLmV4dGVuZCh7fSwgJG1vZGFsUHJvdmlkZXIub3B0aW9ucywgbW9kYWxPcHRpb25zKTtcclxuICAgICAgICAgICAgbW9kYWxPcHRpb25zLnJlc29sdmUgPSBtb2RhbE9wdGlvbnMucmVzb2x2ZSB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vdmVyaWZ5IG9wdGlvbnNcclxuICAgICAgICAgICAgaWYgKCFtb2RhbE9wdGlvbnMudGVtcGxhdGUgJiYgIW1vZGFsT3B0aW9ucy50ZW1wbGF0ZVVybCkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIG9mIHRlbXBsYXRlIG9yIHRlbXBsYXRlVXJsIG9wdGlvbnMgaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUFuZFJlc29sdmVQcm9taXNlID1cclxuICAgICAgICAgICAgICAkcS5hbGwoW2dldFRlbXBsYXRlUHJvbWlzZShtb2RhbE9wdGlvbnMpXS5jb25jYXQoZ2V0UmVzb2x2ZVByb21pc2VzKG1vZGFsT3B0aW9ucy5yZXNvbHZlKSkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHRlbXBsYXRlQW5kUmVzb2x2ZVByb21pc2UudGhlbihmdW5jdGlvbiByZXNvbHZlU3VjY2Vzcyh0cGxBbmRWYXJzKSB7XHJcblxyXG4gICAgICAgICAgICAgIHZhciBtb2RhbFNjb3BlID0gKG1vZGFsT3B0aW9ucy5zY29wZSB8fCAkcm9vdFNjb3BlKS4kbmV3KCk7XHJcbiAgICAgICAgICAgICAgbW9kYWxTY29wZS4kY2xvc2UgPSBtb2RhbEluc3RhbmNlLmNsb3NlO1xyXG4gICAgICAgICAgICAgIG1vZGFsU2NvcGUuJGRpc21pc3MgPSBtb2RhbEluc3RhbmNlLmRpc21pc3M7XHJcblxyXG4gICAgICAgICAgICAgIHZhciBjdHJsSW5zdGFuY2UsIGN0cmxMb2NhbHMgPSB7fTtcclxuICAgICAgICAgICAgICB2YXIgcmVzb2x2ZUl0ZXIgPSAxO1xyXG5cclxuICAgICAgICAgICAgICAvL2NvbnRyb2xsZXJzXHJcbiAgICAgICAgICAgICAgaWYgKG1vZGFsT3B0aW9ucy5jb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjdHJsTG9jYWxzLiRzY29wZSA9IG1vZGFsU2NvcGU7XHJcbiAgICAgICAgICAgICAgICBjdHJsTG9jYWxzLiRtb2RhbEluc3RhbmNlID0gbW9kYWxJbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2RhbE9wdGlvbnMucmVzb2x2ZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgY3RybExvY2Fsc1trZXldID0gdHBsQW5kVmFyc1tyZXNvbHZlSXRlcisrXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGN0cmxJbnN0YW5jZSA9ICRjb250cm9sbGVyKG1vZGFsT3B0aW9ucy5jb250cm9sbGVyLCBjdHJsTG9jYWxzKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICRtb2RhbFN0YWNrLm9wZW4obW9kYWxJbnN0YW5jZSwge1xyXG4gICAgICAgICAgICAgICAgc2NvcGU6IG1vZGFsU2NvcGUsXHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZDogbW9kYWxSZXN1bHREZWZlcnJlZCxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRwbEFuZFZhcnNbMF0sXHJcbiAgICAgICAgICAgICAgICBiYWNrZHJvcDogbW9kYWxPcHRpb25zLmJhY2tkcm9wLFxyXG4gICAgICAgICAgICAgICAga2V5Ym9hcmQ6IG1vZGFsT3B0aW9ucy5rZXlib2FyZCxcclxuICAgICAgICAgICAgICAgIHdpbmRvd0NsYXNzOiBtb2RhbE9wdGlvbnMud2luZG93Q2xhc3NcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIHJlc29sdmVFcnJvcihyZWFzb24pIHtcclxuICAgICAgICAgICAgICBtb2RhbFJlc3VsdERlZmVycmVkLnJlamVjdChyZWFzb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRlbXBsYXRlQW5kUmVzb2x2ZVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgbW9kYWxPcGVuZWREZWZlcnJlZC5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgbW9kYWxPcGVuZWREZWZlcnJlZC5yZWplY3QoZmFsc2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtb2RhbEluc3RhbmNlO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gJG1vZGFsO1xyXG4gICAgICAgIH1dXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAkbW9kYWxQcm92aWRlcjtcclxuICB9KTtcclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wYWdpbmF0aW9uJywgW10pXHJcblxyXG4uY29udHJvbGxlcignUGFnaW5hdGlvbkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnJHBhcnNlJywgJyRpbnRlcnBvbGF0ZScsIGZ1bmN0aW9uICgkc2NvcGUsICRhdHRycywgJHBhcnNlLCAkaW50ZXJwb2xhdGUpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGRlZmF1bHRJdGVtc1BlclBhZ2UpIHtcclxuICAgIGlmICgkYXR0cnMuaXRlbXNQZXJQYWdlKSB7XHJcbiAgICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLml0ZW1zUGVyUGFnZSksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgc2VsZi5pdGVtc1BlclBhZ2UgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xyXG4gICAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gc2VsZi5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5pdGVtc1BlclBhZ2UgPSBkZWZhdWx0SXRlbXNQZXJQYWdlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoaXMubm9QcmV2aW91cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGFnZSA9PT0gMTtcclxuICB9O1xyXG4gIHRoaXMubm9OZXh0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYWdlID09PSAkc2NvcGUudG90YWxQYWdlcztcclxuICB9O1xyXG5cclxuICB0aGlzLmlzQWN0aXZlID0gZnVuY3Rpb24ocGFnZSkge1xyXG4gICAgcmV0dXJuIHRoaXMucGFnZSA9PT0gcGFnZTtcclxuICB9O1xyXG5cclxuICB0aGlzLmNhbGN1bGF0ZVRvdGFsUGFnZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLml0ZW1zUGVyUGFnZSA8IDEgPyAxIDogTWF0aC5jZWlsKCRzY29wZS50b3RhbEl0ZW1zIC8gdGhpcy5pdGVtc1BlclBhZ2UpO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuZ2V0QXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbihhdHRyaWJ1dGUsIGRlZmF1bHRWYWx1ZSwgaW50ZXJwb2xhdGUpIHtcclxuICAgIHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZChhdHRyaWJ1dGUpID8gKGludGVycG9sYXRlID8gJGludGVycG9sYXRlKGF0dHJpYnV0ZSkoJHNjb3BlLiRwYXJlbnQpIDogJHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cmlidXRlKSkgOiBkZWZhdWx0VmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucGFnZSA9IHBhcnNlSW50KCRzY29wZS5wYWdlLCAxMCkgfHwgMTtcclxuICAgICRzY29wZS5wYWdlcyA9IHRoaXMuZ2V0UGFnZXModGhpcy5wYWdlLCAkc2NvcGUudG90YWxQYWdlcyk7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLnNlbGVjdFBhZ2UgPSBmdW5jdGlvbihwYWdlKSB7XHJcbiAgICBpZiAoICEgc2VsZi5pc0FjdGl2ZShwYWdlKSAmJiBwYWdlID4gMCAmJiBwYWdlIDw9ICRzY29wZS50b3RhbFBhZ2VzKSB7XHJcbiAgICAgICRzY29wZS5wYWdlID0gcGFnZTtcclxuICAgICAgJHNjb3BlLm9uU2VsZWN0UGFnZSh7IHBhZ2U6IHBhZ2UgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLiR3YXRjaCgndG90YWxJdGVtcycsIGZ1bmN0aW9uKCkge1xyXG4gICAgJHNjb3BlLnRvdGFsUGFnZXMgPSBzZWxmLmNhbGN1bGF0ZVRvdGFsUGFnZXMoKTtcclxuICB9KTtcclxuXHJcbiAgJHNjb3BlLiR3YXRjaCgndG90YWxQYWdlcycsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZiAoICRhdHRycy5udW1QYWdlcyApIHtcclxuICAgICAgJHNjb3BlLm51bVBhZ2VzID0gdmFsdWU7IC8vIFJlYWRvbmx5IHZhcmlhYmxlXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCBzZWxmLnBhZ2UgPiB2YWx1ZSApIHtcclxuICAgICAgJHNjb3BlLnNlbGVjdFBhZ2UodmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VsZi5yZW5kZXIoKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgJHNjb3BlLiR3YXRjaCgncGFnZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgc2VsZi5yZW5kZXIoKTtcclxuICB9KTtcclxufV0pXHJcblxyXG4uY29uc3RhbnQoJ3BhZ2luYXRpb25Db25maWcnLCB7XHJcbiAgaXRlbXNQZXJQYWdlOiAxMCxcclxuICBib3VuZGFyeUxpbmtzOiBmYWxzZSxcclxuICBkaXJlY3Rpb25MaW5rczogdHJ1ZSxcclxuICBmaXJzdFRleHQ6ICdGaXJzdCcsXHJcbiAgcHJldmlvdXNUZXh0OiAnUHJldmlvdXMnLFxyXG4gIG5leHRUZXh0OiAnTmV4dCcsXHJcbiAgbGFzdFRleHQ6ICdMYXN0JyxcclxuICByb3RhdGU6IHRydWVcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3BhZ2luYXRpb24nLCBbJyRwYXJzZScsICdwYWdpbmF0aW9uQ29uZmlnJywgZnVuY3Rpb24oJHBhcnNlLCBjb25maWcpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICBzY29wZToge1xyXG4gICAgICBwYWdlOiAnPScsXHJcbiAgICAgIHRvdGFsSXRlbXM6ICc9JyxcclxuICAgICAgb25TZWxlY3RQYWdlOicgJicsXHJcbiAgICAgIG51bVBhZ2VzOiAnPSdcclxuICAgIH0sXHJcbiAgICBjb250cm9sbGVyOiAnUGFnaW5hdGlvbkNvbnRyb2xsZXInLFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbCcsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwYWdpbmF0aW9uQ3RybCkge1xyXG5cclxuICAgICAgLy8gU2V0dXAgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXHJcbiAgICAgIHZhciBtYXhTaXplLFxyXG4gICAgICBib3VuZGFyeUxpbmtzICA9IHBhZ2luYXRpb25DdHJsLmdldEF0dHJpYnV0ZVZhbHVlKGF0dHJzLmJvdW5kYXJ5TGlua3MsICBjb25maWcuYm91bmRhcnlMaW5rcyAgICAgICksXHJcbiAgICAgIGRpcmVjdGlvbkxpbmtzID0gcGFnaW5hdGlvbkN0cmwuZ2V0QXR0cmlidXRlVmFsdWUoYXR0cnMuZGlyZWN0aW9uTGlua3MsIGNvbmZpZy5kaXJlY3Rpb25MaW5rcyAgICAgKSxcclxuICAgICAgZmlyc3RUZXh0ICAgICAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5maXJzdFRleHQsICAgICAgY29uZmlnLmZpcnN0VGV4dCwgICAgIHRydWUpLFxyXG4gICAgICBwcmV2aW91c1RleHQgICA9IHBhZ2luYXRpb25DdHJsLmdldEF0dHJpYnV0ZVZhbHVlKGF0dHJzLnByZXZpb3VzVGV4dCwgICBjb25maWcucHJldmlvdXNUZXh0LCAgdHJ1ZSksXHJcbiAgICAgIG5leHRUZXh0ICAgICAgID0gcGFnaW5hdGlvbkN0cmwuZ2V0QXR0cmlidXRlVmFsdWUoYXR0cnMubmV4dFRleHQsICAgICAgIGNvbmZpZy5uZXh0VGV4dCwgICAgICB0cnVlKSxcclxuICAgICAgbGFzdFRleHQgICAgICAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5sYXN0VGV4dCwgICAgICAgY29uZmlnLmxhc3RUZXh0LCAgICAgIHRydWUpLFxyXG4gICAgICByb3RhdGUgICAgICAgICA9IHBhZ2luYXRpb25DdHJsLmdldEF0dHJpYnV0ZVZhbHVlKGF0dHJzLnJvdGF0ZSwgICAgICAgICBjb25maWcucm90YXRlKTtcclxuXHJcbiAgICAgIHBhZ2luYXRpb25DdHJsLmluaXQoY29uZmlnLml0ZW1zUGVyUGFnZSk7XHJcblxyXG4gICAgICBpZiAoYXR0cnMubWF4U2l6ZSkge1xyXG4gICAgICAgIHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZShhdHRycy5tYXhTaXplKSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIG1heFNpemUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xyXG4gICAgICAgICAgcGFnaW5hdGlvbkN0cmwucmVuZGVyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENyZWF0ZSBwYWdlIG9iamVjdCB1c2VkIGluIHRlbXBsYXRlXHJcbiAgICAgIGZ1bmN0aW9uIG1ha2VQYWdlKG51bWJlciwgdGV4dCwgaXNBY3RpdmUsIGlzRGlzYWJsZWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgbnVtYmVyOiBudW1iZXIsXHJcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgYWN0aXZlOiBpc0FjdGl2ZSxcclxuICAgICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcGFnaW5hdGlvbkN0cmwuZ2V0UGFnZXMgPSBmdW5jdGlvbihjdXJyZW50UGFnZSwgdG90YWxQYWdlcykge1xyXG4gICAgICAgIHZhciBwYWdlcyA9IFtdO1xyXG5cclxuICAgICAgICAvLyBEZWZhdWx0IHBhZ2UgbGltaXRzXHJcbiAgICAgICAgdmFyIHN0YXJ0UGFnZSA9IDEsIGVuZFBhZ2UgPSB0b3RhbFBhZ2VzO1xyXG4gICAgICAgIHZhciBpc01heFNpemVkID0gKCBhbmd1bGFyLmlzRGVmaW5lZChtYXhTaXplKSAmJiBtYXhTaXplIDwgdG90YWxQYWdlcyApO1xyXG5cclxuICAgICAgICAvLyByZWNvbXB1dGUgaWYgbWF4U2l6ZVxyXG4gICAgICAgIGlmICggaXNNYXhTaXplZCApIHtcclxuICAgICAgICAgIGlmICggcm90YXRlICkge1xyXG4gICAgICAgICAgICAvLyBDdXJyZW50IHBhZ2UgaXMgZGlzcGxheWVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIHZpc2libGUgb25lc1xyXG4gICAgICAgICAgICBzdGFydFBhZ2UgPSBNYXRoLm1heChjdXJyZW50UGFnZSAtIE1hdGguZmxvb3IobWF4U2l6ZS8yKSwgMSk7XHJcbiAgICAgICAgICAgIGVuZFBhZ2UgICA9IHN0YXJ0UGFnZSArIG1heFNpemUgLSAxO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRqdXN0IGlmIGxpbWl0IGlzIGV4Y2VlZGVkXHJcbiAgICAgICAgICAgIGlmIChlbmRQYWdlID4gdG90YWxQYWdlcykge1xyXG4gICAgICAgICAgICAgIGVuZFBhZ2UgICA9IHRvdGFsUGFnZXM7XHJcbiAgICAgICAgICAgICAgc3RhcnRQYWdlID0gZW5kUGFnZSAtIG1heFNpemUgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBWaXNpYmxlIHBhZ2VzIGFyZSBwYWdpbmF0ZWQgd2l0aCBtYXhTaXplXHJcbiAgICAgICAgICAgIHN0YXJ0UGFnZSA9ICgoTWF0aC5jZWlsKGN1cnJlbnRQYWdlIC8gbWF4U2l6ZSkgLSAxKSAqIG1heFNpemUpICsgMTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkanVzdCBsYXN0IHBhZ2UgaWYgbGltaXQgaXMgZXhjZWVkZWRcclxuICAgICAgICAgICAgZW5kUGFnZSA9IE1hdGgubWluKHN0YXJ0UGFnZSArIG1heFNpemUgLSAxLCB0b3RhbFBhZ2VzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBwYWdlIG51bWJlciBsaW5rc1xyXG4gICAgICAgIGZvciAodmFyIG51bWJlciA9IHN0YXJ0UGFnZTsgbnVtYmVyIDw9IGVuZFBhZ2U7IG51bWJlcisrKSB7XHJcbiAgICAgICAgICB2YXIgcGFnZSA9IG1ha2VQYWdlKG51bWJlciwgbnVtYmVyLCBwYWdpbmF0aW9uQ3RybC5pc0FjdGl2ZShudW1iZXIpLCBmYWxzZSk7XHJcbiAgICAgICAgICBwYWdlcy5wdXNoKHBhZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGxpbmtzIHRvIG1vdmUgYmV0d2VlbiBwYWdlIHNldHNcclxuICAgICAgICBpZiAoIGlzTWF4U2l6ZWQgJiYgISByb3RhdGUgKSB7XHJcbiAgICAgICAgICBpZiAoIHN0YXJ0UGFnZSA+IDEgKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1BhZ2VTZXQgPSBtYWtlUGFnZShzdGFydFBhZ2UgLSAxLCAnLi4uJywgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgcGFnZXMudW5zaGlmdChwcmV2aW91c1BhZ2VTZXQpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICggZW5kUGFnZSA8IHRvdGFsUGFnZXMgKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXh0UGFnZVNldCA9IG1ha2VQYWdlKGVuZFBhZ2UgKyAxLCAnLi4uJywgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgcGFnZXMucHVzaChuZXh0UGFnZVNldCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgcHJldmlvdXMgJiBuZXh0IGxpbmtzXHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbkxpbmtzKSB7XHJcbiAgICAgICAgICB2YXIgcHJldmlvdXNQYWdlID0gbWFrZVBhZ2UoY3VycmVudFBhZ2UgLSAxLCBwcmV2aW91c1RleHQsIGZhbHNlLCBwYWdpbmF0aW9uQ3RybC5ub1ByZXZpb3VzKCkpO1xyXG4gICAgICAgICAgcGFnZXMudW5zaGlmdChwcmV2aW91c1BhZ2UpO1xyXG5cclxuICAgICAgICAgIHZhciBuZXh0UGFnZSA9IG1ha2VQYWdlKGN1cnJlbnRQYWdlICsgMSwgbmV4dFRleHQsIGZhbHNlLCBwYWdpbmF0aW9uQ3RybC5ub05leHQoKSk7XHJcbiAgICAgICAgICBwYWdlcy5wdXNoKG5leHRQYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBmaXJzdCAmIGxhc3QgbGlua3NcclxuICAgICAgICBpZiAoYm91bmRhcnlMaW5rcykge1xyXG4gICAgICAgICAgdmFyIGZpcnN0UGFnZSA9IG1ha2VQYWdlKDEsIGZpcnN0VGV4dCwgZmFsc2UsIHBhZ2luYXRpb25DdHJsLm5vUHJldmlvdXMoKSk7XHJcbiAgICAgICAgICBwYWdlcy51bnNoaWZ0KGZpcnN0UGFnZSk7XHJcblxyXG4gICAgICAgICAgdmFyIGxhc3RQYWdlID0gbWFrZVBhZ2UodG90YWxQYWdlcywgbGFzdFRleHQsIGZhbHNlLCBwYWdpbmF0aW9uQ3RybC5ub05leHQoKSk7XHJcbiAgICAgICAgICBwYWdlcy5wdXNoKGxhc3RQYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYWdlcztcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbi5jb25zdGFudCgncGFnZXJDb25maWcnLCB7XHJcbiAgaXRlbXNQZXJQYWdlOiAxMCxcclxuICBwcmV2aW91c1RleHQ6ICfDgsKrIFByZXZpb3VzJyxcclxuICBuZXh0VGV4dDogJ05leHQgw4LCuycsXHJcbiAgYWxpZ246IHRydWVcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3BhZ2VyJywgWydwYWdlckNvbmZpZycsIGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0VBJyxcclxuICAgIHNjb3BlOiB7XHJcbiAgICAgIHBhZ2U6ICc9JyxcclxuICAgICAgdG90YWxJdGVtczogJz0nLFxyXG4gICAgICBvblNlbGVjdFBhZ2U6JyAmJyxcclxuICAgICAgbnVtUGFnZXM6ICc9J1xyXG4gICAgfSxcclxuICAgIGNvbnRyb2xsZXI6ICdQYWdpbmF0aW9uQ29udHJvbGxlcicsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnZXIuaHRtbCcsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwYWdpbmF0aW9uQ3RybCkge1xyXG5cclxuICAgICAgLy8gU2V0dXAgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXHJcbiAgICAgIHZhciBwcmV2aW91c1RleHQgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5wcmV2aW91c1RleHQsIGNvbmZpZy5wcmV2aW91c1RleHQsIHRydWUpLFxyXG4gICAgICBuZXh0VGV4dCAgICAgICAgID0gcGFnaW5hdGlvbkN0cmwuZ2V0QXR0cmlidXRlVmFsdWUoYXR0cnMubmV4dFRleHQsICAgICBjb25maWcubmV4dFRleHQsICAgICB0cnVlKSxcclxuICAgICAgYWxpZ24gICAgICAgICAgICA9IHBhZ2luYXRpb25DdHJsLmdldEF0dHJpYnV0ZVZhbHVlKGF0dHJzLmFsaWduLCAgICAgICAgY29uZmlnLmFsaWduKTtcclxuXHJcbiAgICAgIHBhZ2luYXRpb25DdHJsLmluaXQoY29uZmlnLml0ZW1zUGVyUGFnZSk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgcGFnZSBvYmplY3QgdXNlZCBpbiB0ZW1wbGF0ZVxyXG4gICAgICBmdW5jdGlvbiBtYWtlUGFnZShudW1iZXIsIHRleHQsIGlzRGlzYWJsZWQsIGlzUHJldmlvdXMsIGlzTmV4dCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBudW1iZXI6IG51bWJlcixcclxuICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICBkaXNhYmxlZDogaXNEaXNhYmxlZCxcclxuICAgICAgICAgIHByZXZpb3VzOiAoIGFsaWduICYmIGlzUHJldmlvdXMgKSxcclxuICAgICAgICAgIG5leHQ6ICggYWxpZ24gJiYgaXNOZXh0IClcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwYWdpbmF0aW9uQ3RybC5nZXRQYWdlcyA9IGZ1bmN0aW9uKGN1cnJlbnRQYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgIG1ha2VQYWdlKGN1cnJlbnRQYWdlIC0gMSwgcHJldmlvdXNUZXh0LCBwYWdpbmF0aW9uQ3RybC5ub1ByZXZpb3VzKCksIHRydWUsIGZhbHNlKSxcclxuICAgICAgICAgIG1ha2VQYWdlKGN1cnJlbnRQYWdlICsgMSwgbmV4dFRleHQsIHBhZ2luYXRpb25DdHJsLm5vTmV4dCgpLCBmYWxzZSwgdHJ1ZSlcclxuICAgICAgICBdO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZm9sbG93aW5nIGZlYXR1cmVzIGFyZSBzdGlsbCBvdXRzdGFuZGluZzogYW5pbWF0aW9uIGFzIGFcclxuICogZnVuY3Rpb24sIHBsYWNlbWVudCBhcyBhIGZ1bmN0aW9uLCBpbnNpZGUsIHN1cHBvcnQgZm9yIG1vcmUgdHJpZ2dlcnMgdGhhblxyXG4gKiBqdXN0IG1vdXNlIGVudGVyL2xlYXZlLCBodG1sIHRvb2x0aXBzLCBhbmQgc2VsZWN0b3IgZGVsZWdhdGlvbi5cclxuICovXHJcbmFuZ3VsYXIubW9kdWxlKCAndWkuYm9vdHN0cmFwLnRvb2x0aXAnLCBbICd1aS5ib290c3RyYXAucG9zaXRpb24nLCAndWkuYm9vdHN0cmFwLmJpbmRIdG1sJyBdIClcclxuXHJcbi8qKlxyXG4gKiBUaGUgJHRvb2x0aXAgc2VydmljZSBjcmVhdGVzIHRvb2x0aXAtIGFuZCBwb3BvdmVyLWxpa2UgZGlyZWN0aXZlcyBhcyB3ZWxsIGFzXHJcbiAqIGhvdXNlcyBnbG9iYWwgb3B0aW9ucyBmb3IgdGhlbS5cclxuICovXHJcbi5wcm92aWRlciggJyR0b29sdGlwJywgZnVuY3Rpb24gKCkge1xyXG4gIC8vIFRoZSBkZWZhdWx0IG9wdGlvbnMgdG9vbHRpcCBhbmQgcG9wb3Zlci5cclxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxyXG4gICAgYW5pbWF0aW9uOiB0cnVlLFxyXG4gICAgcG9wdXBEZWxheTogMFxyXG4gIH07XHJcblxyXG4gIC8vIERlZmF1bHQgaGlkZSB0cmlnZ2VycyBmb3IgZWFjaCBzaG93IHRyaWdnZXJcclxuICB2YXIgdHJpZ2dlck1hcCA9IHtcclxuICAgICdtb3VzZWVudGVyJzogJ21vdXNlbGVhdmUnLFxyXG4gICAgJ2NsaWNrJzogJ2NsaWNrJyxcclxuICAgICdmb2N1cyc6ICdibHVyJ1xyXG4gIH07XHJcblxyXG4gIC8vIFRoZSBvcHRpb25zIHNwZWNpZmllZCB0byB0aGUgcHJvdmlkZXIgZ2xvYmFsbHkuXHJcbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSB7fTtcclxuICBcclxuICAvKipcclxuICAgKiBgb3B0aW9ucyh7fSlgIGFsbG93cyBnbG9iYWwgY29uZmlndXJhdGlvbiBvZiBhbGwgdG9vbHRpcHMgaW4gdGhlXHJcbiAgICogYXBwbGljYXRpb24uXHJcbiAgICpcclxuICAgKiAgIHZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSggJ0FwcCcsIFsndWkuYm9vdHN0cmFwLnRvb2x0aXAnXSwgZnVuY3Rpb24oICR0b29sdGlwUHJvdmlkZXIgKSB7XHJcbiAgICogICAgIC8vIHBsYWNlIHRvb2x0aXBzIGxlZnQgaW5zdGVhZCBvZiB0b3AgYnkgZGVmYXVsdFxyXG4gICAqICAgICAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnMoIHsgcGxhY2VtZW50OiAnbGVmdCcgfSApO1xyXG4gICAqICAgfSk7XHJcbiAgICovXHJcblx0dGhpcy5vcHRpb25zID0gZnVuY3Rpb24oIHZhbHVlICkge1xyXG5cdFx0YW5ndWxhci5leHRlbmQoIGdsb2JhbE9wdGlvbnMsIHZhbHVlICk7XHJcblx0fTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIGV4dGVuZCB0aGUgc2V0IG9mIHRyaWdnZXIgbWFwcGluZ3MgYXZhaWxhYmxlLiBFLmcuOlxyXG4gICAqXHJcbiAgICogICAkdG9vbHRpcFByb3ZpZGVyLnNldFRyaWdnZXJzKCAnb3BlblRyaWdnZXInOiAnY2xvc2VUcmlnZ2VyJyApO1xyXG4gICAqL1xyXG4gIHRoaXMuc2V0VHJpZ2dlcnMgPSBmdW5jdGlvbiBzZXRUcmlnZ2VycyAoIHRyaWdnZXJzICkge1xyXG4gICAgYW5ndWxhci5leHRlbmQoIHRyaWdnZXJNYXAsIHRyaWdnZXJzICk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgdHJhbnNsYXRpbmcgY2FtZWwtY2FzZSB0byBzbmFrZS1jYXNlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNuYWtlX2Nhc2UobmFtZSl7XHJcbiAgICB2YXIgcmVnZXhwID0gL1tBLVpdL2c7XHJcbiAgICB2YXIgc2VwYXJhdG9yID0gJy0nO1xyXG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZShyZWdleHAsIGZ1bmN0aW9uKGxldHRlciwgcG9zKSB7XHJcbiAgICAgIHJldHVybiAocG9zID8gc2VwYXJhdG9yIDogJycpICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGFjdHVhbCBpbnN0YW5jZSBvZiB0aGUgJHRvb2x0aXAgc2VydmljZS5cclxuICAgKiBUT0RPIHN1cHBvcnQgbXVsdGlwbGUgdHJpZ2dlcnNcclxuICAgKi9cclxuICB0aGlzLiRnZXQgPSBbICckd2luZG93JywgJyRjb21waWxlJywgJyR0aW1lb3V0JywgJyRwYXJzZScsICckZG9jdW1lbnQnLCAnJHBvc2l0aW9uJywgJyRpbnRlcnBvbGF0ZScsIGZ1bmN0aW9uICggJHdpbmRvdywgJGNvbXBpbGUsICR0aW1lb3V0LCAkcGFyc2UsICRkb2N1bWVudCwgJHBvc2l0aW9uLCAkaW50ZXJwb2xhdGUgKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gJHRvb2x0aXAgKCB0eXBlLCBwcmVmaXgsIGRlZmF1bHRUcmlnZ2VyU2hvdyApIHtcclxuICAgICAgdmFyIG9wdGlvbnMgPSBhbmd1bGFyLmV4dGVuZCgge30sIGRlZmF1bHRPcHRpb25zLCBnbG9iYWxPcHRpb25zICk7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJucyBhbiBvYmplY3Qgb2Ygc2hvdyBhbmQgaGlkZSB0cmlnZ2Vycy5cclxuICAgICAgICpcclxuICAgICAgICogSWYgYSB0cmlnZ2VyIGlzIHN1cHBsaWVkLFxyXG4gICAgICAgKiBpdCBpcyB1c2VkIHRvIHNob3cgdGhlIHRvb2x0aXA7IG90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0cmlnZ2VyYFxyXG4gICAgICAgKiBvcHRpb24gcGFzc2VkIHRvIHRoZSBgJHRvb2x0aXBQcm92aWRlci5vcHRpb25zYCBtZXRob2Q7IGVsc2UgaXQgd2lsbFxyXG4gICAgICAgKiBkZWZhdWx0IHRvIHRoZSB0cmlnZ2VyIHN1cHBsaWVkIHRvIHRoaXMgZGlyZWN0aXZlIGZhY3RvcnkuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFRoZSBoaWRlIHRyaWdnZXIgaXMgYmFzZWQgb24gdGhlIHNob3cgdHJpZ2dlci4gSWYgdGhlIGB0cmlnZ2VyYCBvcHRpb25cclxuICAgICAgICogd2FzIHBhc3NlZCB0byB0aGUgYCR0b29sdGlwUHJvdmlkZXIub3B0aW9uc2AgbWV0aG9kLCBpdCB3aWxsIHVzZSB0aGVcclxuICAgICAgICogbWFwcGVkIHRyaWdnZXIgZnJvbSBgdHJpZ2dlck1hcGAgb3IgdGhlIHBhc3NlZCB0cmlnZ2VyIGlmIHRoZSBtYXAgaXNcclxuICAgICAgICogdW5kZWZpbmVkOyBvdGhlcndpc2UsIGl0IHVzZXMgdGhlIGB0cmlnZ2VyTWFwYCB2YWx1ZSBvZiB0aGUgc2hvd1xyXG4gICAgICAgKiB0cmlnZ2VyOyBlbHNlIGl0IHdpbGwganVzdCB1c2UgdGhlIHNob3cgdHJpZ2dlci5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGdldFRyaWdnZXJzICggdHJpZ2dlciApIHtcclxuICAgICAgICB2YXIgc2hvdyA9IHRyaWdnZXIgfHwgb3B0aW9ucy50cmlnZ2VyIHx8IGRlZmF1bHRUcmlnZ2VyU2hvdztcclxuICAgICAgICB2YXIgaGlkZSA9IHRyaWdnZXJNYXBbc2hvd10gfHwgc2hvdztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgc2hvdzogc2hvdyxcclxuICAgICAgICAgIGhpZGU6IGhpZGVcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZGlyZWN0aXZlTmFtZSA9IHNuYWtlX2Nhc2UoIHR5cGUgKTtcclxuXHJcbiAgICAgIHZhciBzdGFydFN5bSA9ICRpbnRlcnBvbGF0ZS5zdGFydFN5bWJvbCgpO1xyXG4gICAgICB2YXIgZW5kU3ltID0gJGludGVycG9sYXRlLmVuZFN5bWJvbCgpO1xyXG4gICAgICB2YXIgdGVtcGxhdGUgPSBcclxuICAgICAgICAnPCcrIGRpcmVjdGl2ZU5hbWUgKyctcG9wdXAgJytcclxuICAgICAgICAgICd0aXRsZT1cIicrc3RhcnRTeW0rJ3R0X3RpdGxlJytlbmRTeW0rJ1wiICcrXHJcbiAgICAgICAgICAnY29udGVudD1cIicrc3RhcnRTeW0rJ3R0X2NvbnRlbnQnK2VuZFN5bSsnXCIgJytcclxuICAgICAgICAgICdwbGFjZW1lbnQ9XCInK3N0YXJ0U3ltKyd0dF9wbGFjZW1lbnQnK2VuZFN5bSsnXCIgJytcclxuICAgICAgICAgICdhbmltYXRpb249XCJ0dF9hbmltYXRpb24oKVwiICcrXHJcbiAgICAgICAgICAnaXMtb3Blbj1cInR0X2lzT3BlblwiJytcclxuICAgICAgICAgICc+JytcclxuICAgICAgICAnPC8nKyBkaXJlY3RpdmVOYW1lICsnLXBvcHVwPic7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgICAgIHNjb3BlOiB0cnVlLFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIGxpbmsgKCBzY29wZSwgZWxlbWVudCwgYXR0cnMgKSB7XHJcbiAgICAgICAgICB2YXIgdG9vbHRpcCA9ICRjb21waWxlKCB0ZW1wbGF0ZSApKCBzY29wZSApO1xyXG4gICAgICAgICAgdmFyIHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgdmFyIHBvcHVwVGltZW91dDtcclxuICAgICAgICAgIHZhciAkYm9keTtcclxuICAgICAgICAgIHZhciBhcHBlbmRUb0JvZHkgPSBhbmd1bGFyLmlzRGVmaW5lZCggb3B0aW9ucy5hcHBlbmRUb0JvZHkgKSA/IG9wdGlvbnMuYXBwZW5kVG9Cb2R5IDogZmFsc2U7XHJcbiAgICAgICAgICB2YXIgdHJpZ2dlcnMgPSBnZXRUcmlnZ2VycyggdW5kZWZpbmVkICk7XHJcbiAgICAgICAgICB2YXIgaGFzUmVnaXN0ZXJlZFRyaWdnZXJzID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIHRvb2x0aXAgaXMgbm90IG9wZW4uXHJcbiAgICAgICAgICAvLyBUT0RPIGFkZCBhYmlsaXR5IHRvIHN0YXJ0IHRvb2x0aXAgb3BlbmVkXHJcbiAgICAgICAgICBzY29wZS50dF9pc09wZW4gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiB0b2dnbGVUb29sdGlwQmluZCAoKSB7XHJcbiAgICAgICAgICAgIGlmICggISBzY29wZS50dF9pc09wZW4gKSB7XHJcbiAgICAgICAgICAgICAgc2hvd1Rvb2x0aXBCaW5kKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaGlkZVRvb2x0aXBCaW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcCB3aXRoIGRlbGF5IGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNob3cgaXQgaW1tZWRpYXRlbHlcclxuICAgICAgICAgIGZ1bmN0aW9uIHNob3dUb29sdGlwQmluZCgpIHtcclxuICAgICAgICAgICAgaWYgKCBzY29wZS50dF9wb3B1cERlbGF5ICkge1xyXG4gICAgICAgICAgICAgIHBvcHVwVGltZW91dCA9ICR0aW1lb3V0KCBzaG93LCBzY29wZS50dF9wb3B1cERlbGF5ICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KCBzaG93ICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmdW5jdGlvbiBoaWRlVG9vbHRpcEJpbmQgKCkge1xyXG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIGhpZGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXAgcG9wdXAgZWxlbWVudC5cclxuICAgICAgICAgIGZ1bmN0aW9uIHNob3coKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIHR0V2lkdGgsXHJcbiAgICAgICAgICAgICAgICB0dEhlaWdodCxcclxuICAgICAgICAgICAgICAgIHR0UG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAvLyBEb24ndCBzaG93IGVtcHR5IHRvb2x0aXBzLlxyXG4gICAgICAgICAgICBpZiAoICEgc2NvcGUudHRfY29udGVudCApIHtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcGVuZGluZyByZW1vdmUgdHJhbnNpdGlvbiwgd2UgbXVzdCBjYW5jZWwgaXQsIGxlc3QgdGhlXHJcbiAgICAgICAgICAgIC8vIHRvb2x0aXAgYmUgbXlzdGVyaW91c2x5IHJlbW92ZWQuXHJcbiAgICAgICAgICAgIGlmICggdHJhbnNpdGlvblRpbWVvdXQgKSB7XHJcbiAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKCB0cmFuc2l0aW9uVGltZW91dCApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGluaXRpYWwgcG9zaXRpb25pbmcuXHJcbiAgICAgICAgICAgIHRvb2x0aXAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCBkaXNwbGF5OiAnYmxvY2snIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gTm93IHdlIGFkZCBpdCB0byB0aGUgRE9NIGJlY2F1c2UgbmVlZCBzb21lIGluZm8gYWJvdXQgaXQuIEJ1dCBpdCdzIG5vdCBcclxuICAgICAgICAgICAgLy8gdmlzaWJsZSB5ZXQgYW55d2F5LlxyXG4gICAgICAgICAgICBpZiAoIGFwcGVuZFRvQm9keSApIHtcclxuICAgICAgICAgICAgICAgICRib2R5ID0gJGJvZHkgfHwgJGRvY3VtZW50LmZpbmQoICdib2R5JyApO1xyXG4gICAgICAgICAgICAgICAgJGJvZHkuYXBwZW5kKCB0b29sdGlwICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZWxlbWVudC5hZnRlciggdG9vbHRpcCApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBkaXJlY3RpdmUgZWxlbWVudC5cclxuICAgICAgICAgICAgcG9zaXRpb24gPSBhcHBlbmRUb0JvZHkgPyAkcG9zaXRpb24ub2Zmc2V0KCBlbGVtZW50ICkgOiAkcG9zaXRpb24ucG9zaXRpb24oIGVsZW1lbnQgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgdG9vbHRpcCBzbyB3ZSBjYW4gY2VudGVyIGl0LlxyXG4gICAgICAgICAgICB0dFdpZHRoID0gdG9vbHRpcC5wcm9wKCAnb2Zmc2V0V2lkdGgnICk7XHJcbiAgICAgICAgICAgIHR0SGVpZ2h0ID0gdG9vbHRpcC5wcm9wKCAnb2Zmc2V0SGVpZ2h0JyApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0b29sdGlwJ3MgdG9wIGFuZCBsZWZ0IGNvb3JkaW5hdGVzIHRvIGNlbnRlciBpdCB3aXRoXHJcbiAgICAgICAgICAgIC8vIHRoaXMgZGlyZWN0aXZlLlxyXG4gICAgICAgICAgICBzd2l0Y2ggKCBzY29wZS50dF9wbGFjZW1lbnQgKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgdHRQb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgKyBwb3NpdGlvbi5oZWlnaHQgLyAyIC0gdHRIZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0ICsgcG9zaXRpb24ud2lkdGhcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgdHRQb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgKyBwb3NpdGlvbi5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgKyBwb3NpdGlvbi53aWR0aCAvIDIgLSB0dFdpZHRoIC8gMlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgdHRQb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgKyBwb3NpdGlvbi5oZWlnaHQgLyAyIC0gdHRIZWlnaHQgLyAyLFxyXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0IC0gdHRXaWR0aFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0dFBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCAtIHR0SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0ICsgcG9zaXRpb24ud2lkdGggLyAyIC0gdHRXaWR0aCAvIDJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdHRQb3NpdGlvbi50b3AgKz0gJ3B4JztcclxuICAgICAgICAgICAgdHRQb3NpdGlvbi5sZWZ0ICs9ICdweCc7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3cgc2V0IHRoZSBjYWxjdWxhdGVkIHBvc2l0aW9uaW5nLlxyXG4gICAgICAgICAgICB0b29sdGlwLmNzcyggdHRQb3NpdGlvbiApO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBbmQgc2hvdyB0aGUgdG9vbHRpcC5cclxuICAgICAgICAgICAgc2NvcGUudHRfaXNPcGVuID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gSGlkZSB0aGUgdG9vbHRpcCBwb3B1cCBlbGVtZW50LlxyXG4gICAgICAgICAgZnVuY3Rpb24gaGlkZSgpIHtcclxuICAgICAgICAgICAgLy8gRmlyc3QgdGhpbmdzIGZpcnN0OiB3ZSBkb24ndCBzaG93IGl0IGFueW1vcmUuXHJcbiAgICAgICAgICAgIHNjb3BlLnR0X2lzT3BlbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy9pZiB0b29sdGlwIGlzIGdvaW5nIHRvIGJlIHNob3duIGFmdGVyIGRlbGF5LCB3ZSBtdXN0IGNhbmNlbCB0aGlzXHJcbiAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCggcG9wdXBUaW1lb3V0ICk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBbmQgbm93IHdlIHJlbW92ZSBpdCBmcm9tIHRoZSBET00uIEhvd2V2ZXIsIGlmIHdlIGhhdmUgYW5pbWF0aW9uLCB3ZSBcclxuICAgICAgICAgICAgLy8gbmVlZCB0byB3YWl0IGZvciBpdCB0byBleHBpcmUgYmVmb3JlaGFuZC5cclxuICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBwb3J0IG9mIHRoZSB0cmFuc2l0aW9ucyBsaWJyYXJ5LlxyXG4gICAgICAgICAgICBpZiAoIGFuZ3VsYXIuaXNEZWZpbmVkKCBzY29wZS50dF9hbmltYXRpb24gKSAmJiBzY29wZS50dF9hbmltYXRpb24oKSApIHtcclxuICAgICAgICAgICAgICB0cmFuc2l0aW9uVGltZW91dCA9ICR0aW1lb3V0KCBmdW5jdGlvbiAoKSB7IHRvb2x0aXAucmVtb3ZlKCk7IH0sIDUwMCApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIE9ic2VydmUgdGhlIHJlbGV2YW50IGF0dHJpYnV0ZXMuXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCB0eXBlLCBmdW5jdGlvbiAoIHZhbCApIHtcclxuICAgICAgICAgICAgc2NvcGUudHRfY29udGVudCA9IHZhbDtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCBwcmVmaXgrJ1RpdGxlJywgZnVuY3Rpb24gKCB2YWwgKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLnR0X3RpdGxlID0gdmFsO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoIHByZWZpeCsnUGxhY2VtZW50JywgZnVuY3Rpb24gKCB2YWwgKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLnR0X3BsYWNlbWVudCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCB2YWwgKSA/IHZhbCA6IG9wdGlvbnMucGxhY2VtZW50O1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoIHByZWZpeCsnQW5pbWF0aW9uJywgZnVuY3Rpb24gKCB2YWwgKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLnR0X2FuaW1hdGlvbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCB2YWwgKSA/ICRwYXJzZSggdmFsICkgOiBmdW5jdGlvbigpeyByZXR1cm4gb3B0aW9ucy5hbmltYXRpb247IH07XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSggcHJlZml4KydQb3B1cERlbGF5JywgZnVuY3Rpb24gKCB2YWwgKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWxheSA9IHBhcnNlSW50KCB2YWwsIDEwICk7XHJcbiAgICAgICAgICAgIHNjb3BlLnR0X3BvcHVwRGVsYXkgPSAhIGlzTmFOKGRlbGF5KSA/IGRlbGF5IDogb3B0aW9ucy5wb3B1cERlbGF5O1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoIHByZWZpeCsnVHJpZ2dlcicsIGZ1bmN0aW9uICggdmFsICkge1xyXG5cclxuICAgICAgICAgICAgaWYgKGhhc1JlZ2lzdGVyZWRUcmlnZ2Vycykge1xyXG4gICAgICAgICAgICAgIGVsZW1lbnQudW5iaW5kKCB0cmlnZ2Vycy5zaG93LCBzaG93VG9vbHRpcEJpbmQgKTtcclxuICAgICAgICAgICAgICBlbGVtZW50LnVuYmluZCggdHJpZ2dlcnMuaGlkZSwgaGlkZVRvb2x0aXBCaW5kICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRyaWdnZXJzID0gZ2V0VHJpZ2dlcnMoIHZhbCApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0cmlnZ2Vycy5zaG93ID09PSB0cmlnZ2Vycy5oaWRlICkge1xyXG4gICAgICAgICAgICAgIGVsZW1lbnQuYmluZCggdHJpZ2dlcnMuc2hvdywgdG9nZ2xlVG9vbHRpcEJpbmQgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBlbGVtZW50LmJpbmQoIHRyaWdnZXJzLnNob3csIHNob3dUb29sdGlwQmluZCApO1xyXG4gICAgICAgICAgICAgIGVsZW1lbnQuYmluZCggdHJpZ2dlcnMuaGlkZSwgaGlkZVRvb2x0aXBCaW5kICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGhhc1JlZ2lzdGVyZWRUcmlnZ2VycyA9IHRydWU7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBhdHRycy4kb2JzZXJ2ZSggcHJlZml4KydBcHBlbmRUb0JvZHknLCBmdW5jdGlvbiAoIHZhbCApIHtcclxuICAgICAgICAgICAgYXBwZW5kVG9Cb2R5ID0gYW5ndWxhci5pc0RlZmluZWQoIHZhbCApID8gJHBhcnNlKCB2YWwgKSggc2NvcGUgKSA6IGFwcGVuZFRvQm9keTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIC8vIGlmIGEgdG9vbHRpcCBpcyBhdHRhY2hlZCB0byA8Ym9keT4gd2UgbmVlZCB0byByZW1vdmUgaXQgb25cclxuICAgICAgICAgIC8vIGxvY2F0aW9uIGNoYW5nZSBhcyBpdHMgcGFyZW50IHNjb3BlIHdpbGwgcHJvYmFibHkgbm90IGJlIGRlc3Ryb3llZFxyXG4gICAgICAgICAgLy8gYnkgdGhlIGNoYW5nZS5cclxuICAgICAgICAgIGlmICggYXBwZW5kVG9Cb2R5ICkge1xyXG4gICAgICAgICAgICBzY29wZS4kb24oJyRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MnLCBmdW5jdGlvbiBjbG9zZVRvb2x0aXBPbkxvY2F0aW9uQ2hhbmdlU3VjY2VzcyAoKSB7XHJcbiAgICAgICAgICAgIGlmICggc2NvcGUudHRfaXNPcGVuICkge1xyXG4gICAgICAgICAgICAgIGhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRvb2x0aXAgaXMgZGVzdHJveWVkIGFuZCByZW1vdmVkLlxyXG4gICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uIG9uRGVzdHJveVRvb2x0aXAoKSB7XHJcbiAgICAgICAgICAgIGlmICggc2NvcGUudHRfaXNPcGVuICkge1xyXG4gICAgICAgICAgICAgIGhpZGUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0b29sdGlwLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIH1dO1xyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSggJ3Rvb2x0aXBQb3B1cCcsIGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICBzY29wZTogeyBjb250ZW50OiAnQCcsIHBsYWNlbWVudDogJ0AnLCBhbmltYXRpb246ICcmJywgaXNPcGVuOiAnJicgfSxcclxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWwnXHJcbiAgfTtcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoICd0b29sdGlwJywgWyAnJHRvb2x0aXAnLCBmdW5jdGlvbiAoICR0b29sdGlwICkge1xyXG4gIHJldHVybiAkdG9vbHRpcCggJ3Rvb2x0aXAnLCAndG9vbHRpcCcsICdtb3VzZWVudGVyJyApO1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoICd0b29sdGlwSHRtbFVuc2FmZVBvcHVwJywgZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHNjb3BlOiB7IGNvbnRlbnQ6ICdAJywgcGxhY2VtZW50OiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyB9LFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC11bnNhZmUtcG9wdXAuaHRtbCdcclxuICB9O1xyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSggJ3Rvb2x0aXBIdG1sVW5zYWZlJywgWyAnJHRvb2x0aXAnLCBmdW5jdGlvbiAoICR0b29sdGlwICkge1xyXG4gIHJldHVybiAkdG9vbHRpcCggJ3Rvb2x0aXBIdG1sVW5zYWZlJywgJ3Rvb2x0aXAnLCAnbW91c2VlbnRlcicgKTtcclxufV0pO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgYXJlIHN0aWxsIG91dHN0YW5kaW5nOiBwb3B1cCBkZWxheSwgYW5pbWF0aW9uIGFzIGFcclxuICogZnVuY3Rpb24sIHBsYWNlbWVudCBhcyBhIGZ1bmN0aW9uLCBpbnNpZGUsIHN1cHBvcnQgZm9yIG1vcmUgdHJpZ2dlcnMgdGhhblxyXG4gKiBqdXN0IG1vdXNlIGVudGVyL2xlYXZlLCBodG1sIHBvcG92ZXJzLCBhbmQgc2VsZWN0b3IgZGVsZWdhdGF0aW9uLlxyXG4gKi9cclxuYW5ndWxhci5tb2R1bGUoICd1aS5ib290c3RyYXAucG9wb3ZlcicsIFsgJ3VpLmJvb3RzdHJhcC50b29sdGlwJyBdIClcclxuLmRpcmVjdGl2ZSggJ3BvcG92ZXJQb3B1cCcsIGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgc2NvcGU6IHsgdGl0bGU6ICdAJywgY29udGVudDogJ0AnLCBwbGFjZW1lbnQ6ICdAJywgYW5pbWF0aW9uOiAnJicsIGlzT3BlbjogJyYnIH0sXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sJ1xyXG4gIH07XHJcbn0pXHJcbi5kaXJlY3RpdmUoICdwb3BvdmVyJywgWyAnJGNvbXBpbGUnLCAnJHRpbWVvdXQnLCAnJHBhcnNlJywgJyR3aW5kb3cnLCAnJHRvb2x0aXAnLCBmdW5jdGlvbiAoICRjb21waWxlLCAkdGltZW91dCwgJHBhcnNlLCAkd2luZG93LCAkdG9vbHRpcCApIHtcclxuICByZXR1cm4gJHRvb2x0aXAoICdwb3BvdmVyJywgJ3BvcG92ZXInLCAnY2xpY2snICk7XHJcbn1dKTtcclxuXHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnByb2dyZXNzYmFyJywgWyd1aS5ib290c3RyYXAudHJhbnNpdGlvbiddKVxyXG5cclxuLmNvbnN0YW50KCdwcm9ncmVzc0NvbmZpZycsIHtcclxuICBhbmltYXRlOiB0cnVlLFxyXG4gIGF1dG9UeXBlOiBmYWxzZSxcclxuICBzdGFja2VkVHlwZXM6IFsnc3VjY2VzcycsICdpbmZvJywgJ3dhcm5pbmcnLCAnZGFuZ2VyJ11cclxufSlcclxuXHJcbi5jb250cm9sbGVyKCdQcm9ncmVzc0JhckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAncHJvZ3Jlc3NDb25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgcHJvZ3Jlc3NDb25maWcpIHtcclxuXHJcbiAgICAvLyBXaGV0aGVyIGJhciB0cmFuc2l0aW9ucyBzaG91bGQgYmUgYW5pbWF0ZWRcclxuICAgIHZhciBhbmltYXRlID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmFuaW1hdGUpID8gJHNjb3BlLiRldmFsKCRhdHRycy5hbmltYXRlKSA6IHByb2dyZXNzQ29uZmlnLmFuaW1hdGU7XHJcbiAgICB2YXIgYXV0b1R5cGUgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYXV0b1R5cGUpID8gJHNjb3BlLiRldmFsKCRhdHRycy5hdXRvVHlwZSkgOiBwcm9ncmVzc0NvbmZpZy5hdXRvVHlwZTtcclxuICAgIHZhciBzdGFja2VkVHlwZXMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuc3RhY2tlZFR5cGVzKSA/ICRzY29wZS4kZXZhbCgnWycgKyAkYXR0cnMuc3RhY2tlZFR5cGVzICsgJ10nKSA6IHByb2dyZXNzQ29uZmlnLnN0YWNrZWRUeXBlcztcclxuXHJcbiAgICAvLyBDcmVhdGUgYmFyIG9iamVjdFxyXG4gICAgdGhpcy5tYWtlQmFyID0gZnVuY3Rpb24obmV3QmFyLCBvbGRCYXIsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gKGFuZ3VsYXIuaXNPYmplY3QobmV3QmFyKSkgPyBuZXdCYXIudmFsdWUgOiAobmV3QmFyIHx8IDApO1xyXG4gICAgICAgIHZhciBvbGRWYWx1ZSA9ICAoYW5ndWxhci5pc09iamVjdChvbGRCYXIpKSA/IG9sZEJhci52YWx1ZSA6IChvbGRCYXIgfHwgMCk7XHJcbiAgICAgICAgdmFyIHR5cGUgPSAoYW5ndWxhci5pc09iamVjdChuZXdCYXIpICYmIGFuZ3VsYXIuaXNEZWZpbmVkKG5ld0Jhci50eXBlKSkgPyBuZXdCYXIudHlwZSA6IChhdXRvVHlwZSkgPyBnZXRTdGFja2VkVHlwZShpbmRleCB8fCAwKSA6IG51bGw7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZyb206IG9sZFZhbHVlLFxyXG4gICAgICAgICAgICB0bzogbmV3VmFsdWUsXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIGFuaW1hdGU6IGFuaW1hdGVcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTdGFja2VkVHlwZShpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBzdGFja2VkVHlwZXNbaW5kZXhdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYWRkQmFyID0gZnVuY3Rpb24oYmFyKSB7XHJcbiAgICAgICAgJHNjb3BlLmJhcnMucHVzaChiYXIpO1xyXG4gICAgICAgICRzY29wZS50b3RhbFBlcmNlbnQgKz0gYmFyLnRvO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNsZWFyQmFycyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICRzY29wZS5iYXJzID0gW107XHJcbiAgICAgICAgJHNjb3BlLnRvdGFsUGVyY2VudCA9IDA7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5jbGVhckJhcnMoKTtcclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCdwcm9ncmVzcycsIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0VBJyxcclxuICAgICAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6ICdQcm9ncmVzc0JhckNvbnRyb2xsZXInLFxyXG4gICAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiAnPXBlcmNlbnQnLFxyXG4gICAgICAgICAgICBvbkZ1bGw6ICcmJyxcclxuICAgICAgICAgICAgb25FbXB0eTogJyYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3Byb2dyZXNzYmFyL3Byb2dyZXNzLmh0bWwnLFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlcikge1xyXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goJ3ZhbHVlJywgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsZWFyQmFycygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhY2tlZCBwcm9ncmVzcyBiYXJcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIG49bmV3VmFsdWUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWRkQmFyKGNvbnRyb2xsZXIubWFrZUJhcihuZXdWYWx1ZVtpXSwgb2xkVmFsdWVbaV0sIGkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBiYXJcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFkZEJhcihjb250cm9sbGVyLm1ha2VCYXIobmV3VmFsdWUsIG9sZFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gVG90YWwgcGVyY2VudCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCd0b3RhbFBlcmNlbnQnLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAxMDApIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlLm9uRnVsbCgpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcGUub25FbXB0eSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSlcclxuXHJcbi5kaXJlY3RpdmUoJ3Byb2dyZXNzYmFyJywgWyckdHJhbnNpdGlvbicsIGZ1bmN0aW9uKCR0cmFuc2l0aW9uKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgd2lkdGg6ICc9JyxcclxuICAgICAgICAgICAgb2xkOiAnPScsXHJcbiAgICAgICAgICAgIHR5cGU6ICc9JyxcclxuICAgICAgICAgICAgYW5pbWF0ZTogJz0nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sJyxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goJ3dpZHRoJywgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5hbmltYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jc3MoJ3dpZHRoJywgc2NvcGUub2xkICsgJyUnKTtcclxuICAgICAgICAgICAgICAgICAgICAkdHJhbnNpdGlvbihlbGVtZW50LCB7d2lkdGg6IHZhbHVlICsgJyUnfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY3NzKCd3aWR0aCcsIHZhbHVlICsgJyUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufV0pO1xyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnJhdGluZycsIFtdKVxyXG5cclxuLmNvbnN0YW50KCdyYXRpbmdDb25maWcnLCB7XHJcbiAgbWF4OiA1LFxyXG4gIHN0YXRlT246IG51bGwsXHJcbiAgc3RhdGVPZmY6IG51bGxcclxufSlcclxuXHJcbi5jb250cm9sbGVyKCdSYXRpbmdDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJyRwYXJzZScsICdyYXRpbmdDb25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgJHBhcnNlLCByYXRpbmdDb25maWcpIHtcclxuXHJcbiAgdGhpcy5tYXhSYW5nZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5tYXgpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLm1heCkgOiByYXRpbmdDb25maWcubWF4O1xyXG4gIHRoaXMuc3RhdGVPbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zdGF0ZU9uKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5zdGF0ZU9uKSA6IHJhdGluZ0NvbmZpZy5zdGF0ZU9uO1xyXG4gIHRoaXMuc3RhdGVPZmYgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuc3RhdGVPZmYpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnN0YXRlT2ZmKSA6IHJhdGluZ0NvbmZpZy5zdGF0ZU9mZjtcclxuXHJcbiAgdGhpcy5jcmVhdGVEZWZhdWx0UmFuZ2UgPSBmdW5jdGlvbihsZW4pIHtcclxuICAgIHZhciBkZWZhdWx0U3RhdGVPYmplY3QgPSB7XHJcbiAgICAgIHN0YXRlT246IHRoaXMuc3RhdGVPbixcclxuICAgICAgc3RhdGVPZmY6IHRoaXMuc3RhdGVPZmZcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHN0YXRlcyA9IG5ldyBBcnJheShsZW4pO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICBzdGF0ZXNbaV0gPSBkZWZhdWx0U3RhdGVPYmplY3Q7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhdGVzO1xyXG4gIH07XHJcblxyXG4gIHRoaXMubm9ybWFsaXplUmFuZ2UgPSBmdW5jdGlvbihzdGF0ZXMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gc3RhdGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICBzdGF0ZXNbaV0uc3RhdGVPbiA9IHN0YXRlc1tpXS5zdGF0ZU9uIHx8IHRoaXMuc3RhdGVPbjtcclxuICAgICAgc3RhdGVzW2ldLnN0YXRlT2ZmID0gc3RhdGVzW2ldLnN0YXRlT2ZmIHx8IHRoaXMuc3RhdGVPZmY7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhdGVzO1xyXG4gIH07XHJcblxyXG4gIC8vIEdldCBvYmplY3RzIHVzZWQgaW4gdGVtcGxhdGVcclxuICAkc2NvcGUucmFuZ2UgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMucmF0aW5nU3RhdGVzKSA/ICB0aGlzLm5vcm1hbGl6ZVJhbmdlKGFuZ3VsYXIuY29weSgkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMucmF0aW5nU3RhdGVzKSkpOiB0aGlzLmNyZWF0ZURlZmF1bHRSYW5nZSh0aGlzLm1heFJhbmdlKTtcclxuXHJcbiAgJHNjb3BlLnJhdGUgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYgKCAkc2NvcGUucmVhZG9ubHkgfHwgJHNjb3BlLnZhbHVlID09PSB2YWx1ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgJHNjb3BlLnZhbHVlID0gdmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLmVudGVyID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIGlmICggISAkc2NvcGUucmVhZG9ubHkgKSB7XHJcbiAgICAgICRzY29wZS52YWwgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgICRzY29wZS5vbkhvdmVyKHt2YWx1ZTogdmFsdWV9KTtcclxuICB9O1xyXG5cclxuICAkc2NvcGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICRzY29wZS52YWwgPSBhbmd1bGFyLmNvcHkoJHNjb3BlLnZhbHVlKTtcclxuICAgICRzY29wZS5vbkxlYXZlKCk7XHJcbiAgfTtcclxuXHJcbiAgJHNjb3BlLiR3YXRjaCgndmFsdWUnLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgJHNjb3BlLnZhbCA9IHZhbHVlO1xyXG4gIH0pO1xyXG5cclxuICAkc2NvcGUucmVhZG9ubHkgPSBmYWxzZTtcclxuICBpZiAoJGF0dHJzLnJlYWRvbmx5KSB7XHJcbiAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5yZWFkb25seSksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICRzY29wZS5yZWFkb25seSA9ICEhdmFsdWU7XHJcbiAgICB9KTtcclxuICB9XHJcbn1dKVxyXG5cclxuLmRpcmVjdGl2ZSgncmF0aW5nJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgc2NvcGU6IHtcclxuICAgICAgdmFsdWU6ICc9JyxcclxuICAgICAgb25Ib3ZlcjogJyYnLFxyXG4gICAgICBvbkxlYXZlOiAnJidcclxuICAgIH0sXHJcbiAgICBjb250cm9sbGVyOiAnUmF0aW5nQ29udHJvbGxlcicsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbCcsXHJcbiAgICByZXBsYWNlOiB0cnVlXHJcbiAgfTtcclxufSk7XHJcblxyXG4vKipcclxuICogQG5nZG9jIG92ZXJ2aWV3XHJcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC50YWJzXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBbmd1bGFySlMgdmVyc2lvbiBvZiB0aGUgdGFicyBkaXJlY3RpdmUuXHJcbiAqL1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50YWJzJywgW10pXHJcblxyXG4uZGlyZWN0aXZlKCd0YWJzJywgZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB0YWJzYCBkaXJlY3RpdmUgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIG1pZ3JhdGUgdG8gYHRhYnNldGAuIEluc3RydWN0aW9ucyBjYW4gYmUgZm91bmQgYXQgaHR0cDovL2dpdGh1Yi5jb20vYW5ndWxhci11aS9ib290c3RyYXAvdHJlZS9tYXN0ZXIvQ0hBTkdFTE9HLm1kXCIpO1xyXG4gIH07XHJcbn0pXHJcblxyXG4uY29udHJvbGxlcignVGFic2V0Q29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JyxcclxuZnVuY3Rpb24gVGFic2V0Q3RybCgkc2NvcGUsICRlbGVtZW50KSB7XHJcblxyXG4gIHZhciBjdHJsID0gdGhpcyxcclxuICAgIHRhYnMgPSBjdHJsLnRhYnMgPSAkc2NvcGUudGFicyA9IFtdO1xyXG5cclxuICBjdHJsLnNlbGVjdCA9IGZ1bmN0aW9uKHRhYikge1xyXG4gICAgYW5ndWxhci5mb3JFYWNoKHRhYnMsIGZ1bmN0aW9uKHRhYikge1xyXG4gICAgICB0YWIuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9KTtcclxuICAgIHRhYi5hY3RpdmUgPSB0cnVlO1xyXG4gIH07XHJcblxyXG4gIGN0cmwuYWRkVGFiID0gZnVuY3Rpb24gYWRkVGFiKHRhYikge1xyXG4gICAgdGFicy5wdXNoKHRhYik7XHJcbiAgICBpZiAodGFicy5sZW5ndGggPT09IDEgfHwgdGFiLmFjdGl2ZSkge1xyXG4gICAgICBjdHJsLnNlbGVjdCh0YWIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGN0cmwucmVtb3ZlVGFiID0gZnVuY3Rpb24gcmVtb3ZlVGFiKHRhYikge1xyXG4gICAgdmFyIGluZGV4ID0gdGFicy5pbmRleE9mKHRhYik7XHJcbiAgICAvL1NlbGVjdCBhIG5ldyB0YWIgaWYgdGhlIHRhYiB0byBiZSByZW1vdmVkIGlzIHNlbGVjdGVkXHJcbiAgICBpZiAodGFiLmFjdGl2ZSAmJiB0YWJzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgLy9JZiB0aGlzIGlzIHRoZSBsYXN0IHRhYiwgc2VsZWN0IHRoZSBwcmV2aW91cyB0YWIuIGVsc2UsIHRoZSBuZXh0IHRhYi5cclxuICAgICAgdmFyIG5ld0FjdGl2ZUluZGV4ID0gaW5kZXggPT0gdGFicy5sZW5ndGggLSAxID8gaW5kZXggLSAxIDogaW5kZXggKyAxO1xyXG4gICAgICBjdHJsLnNlbGVjdCh0YWJzW25ld0FjdGl2ZUluZGV4XSk7XHJcbiAgICB9XHJcbiAgICB0YWJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgfTtcclxufV0pXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFic2V0XHJcbiAqIEByZXN0cmljdCBFQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGFic2V0IGlzIHRoZSBvdXRlciBjb250YWluZXIgZm9yIHRoZSB0YWJzIGRpcmVjdGl2ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB2ZXJ0aWNhbCBXaGV0aGVyIG9yIG5vdCB0byB1c2UgdmVydGljYWwgc3R5bGluZyBmb3IgdGhlIHRhYnMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gZGlyZWN0aW9uICBXaGF0IGRpcmVjdGlvbiB0aGUgdGFicyBzaG91bGQgYmUgcmVuZGVyZWQuIEF2YWlsYWJsZTpcclxuICogJ3JpZ2h0JywgJ2xlZnQnLCAnYmVsb3cnLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cclxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgPHRhYnNldD5cclxuICAgICAgPHRhYiBoZWFkaW5nPVwiVmVydGljYWwgVGFiIDFcIj48Yj5GaXJzdDwvYj4gQ29udGVudCE8L3RhYj5cclxuICAgICAgPHRhYiBoZWFkaW5nPVwiVmVydGljYWwgVGFiIDJcIj48aT5TZWNvbmQ8L2k+IENvbnRlbnQhPC90YWI+XHJcbiAgICA8L3RhYnNldD5cclxuICAgIDxociAvPlxyXG4gICAgPHRhYnNldCB2ZXJ0aWNhbD1cInRydWVcIj5cclxuICAgICAgPHRhYiBoZWFkaW5nPVwiVmVydGljYWwgVGFiIDFcIj48Yj5GaXJzdDwvYj4gVmVydGljYWwgQ29udGVudCE8L3RhYj5cclxuICAgICAgPHRhYiBoZWFkaW5nPVwiVmVydGljYWwgVGFiIDJcIj48aT5TZWNvbmQ8L2k+IFZlcnRpY2FsIENvbnRlbnQhPC90YWI+XHJcbiAgICA8L3RhYnNldD5cclxuICA8L2ZpbGU+XHJcbjwvZXhhbXBsZT5cclxuICovXHJcbi5kaXJlY3RpdmUoJ3RhYnNldCcsIGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0VBJyxcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgcmVxdWlyZTogJ150YWJzZXQnLFxyXG4gICAgc2NvcGU6IHt9LFxyXG4gICAgY29udHJvbGxlcjogJ1RhYnNldENvbnRyb2xsZXInLFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sJyxcclxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGVsbSwgYXR0cnMsIHRyYW5zY2x1ZGUpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdGFic2V0Q3RybCkge1xyXG4gICAgICAgIHNjb3BlLnZlcnRpY2FsID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudmVydGljYWwpID8gc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy52ZXJ0aWNhbCkgOiBmYWxzZTtcclxuICAgICAgICBzY29wZS50eXBlID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudHlwZSkgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLnR5cGUpIDogJ3RhYnMnO1xyXG4gICAgICAgIHNjb3BlLmRpcmVjdGlvbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmRpcmVjdGlvbikgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmRpcmVjdGlvbikgOiAndG9wJztcclxuICAgICAgICBzY29wZS50YWJzQWJvdmUgPSAoc2NvcGUuZGlyZWN0aW9uICE9ICdiZWxvdycpO1xyXG4gICAgICAgIHRhYnNldEN0cmwuJHNjb3BlID0gc2NvcGU7XHJcbiAgICAgICAgdGFic2V0Q3RybC4kdHJhbnNjbHVkZUZuID0gdHJhbnNjbHVkZTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG59KVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYlxyXG4gKiBAcmVzdHJpY3QgRUFcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmc9fSBoZWFkaW5nIFRoZSB2aXNpYmxlIGhlYWRpbmcsIG9yIHRpdGxlLCBvZiB0aGUgdGFiLiBTZXQgSFRNTCBoZWFkaW5ncyB3aXRoIHtAbGluayB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFiSGVhZGluZyB0YWJIZWFkaW5nfS5cclxuICogQHBhcmFtIHtzdHJpbmc9fSBzZWxlY3QgQW4gZXhwcmVzc2lvbiB0byBldmFsdWF0ZSB3aGVuIHRoZSB0YWIgaXMgc2VsZWN0ZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGFjdGl2ZSBBIGJpbmRpbmcsIHRlbGxpbmcgd2hldGhlciBvciBub3QgdGhpcyB0YWIgaXMgc2VsZWN0ZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGRpc2FibGVkIEEgYmluZGluZywgdGVsbGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRhYiBpcyBkaXNhYmxlZC5cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENyZWF0ZXMgYSB0YWIgd2l0aCBhIGhlYWRpbmcgYW5kIGNvbnRlbnQuIE11c3QgYmUgcGxhY2VkIHdpdGhpbiBhIHtAbGluayB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFic2V0IHRhYnNldH0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbjxleGFtcGxlIG1vZHVsZT1cInVpLmJvb3RzdHJhcFwiPlxyXG4gIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJUYWJzRGVtb0N0cmxcIj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc21hbGxcIiBuZy1jbGljaz1cIml0ZW1zWzBdLmFjdGl2ZSA9IHRydWVcIj5cclxuICAgICAgICBTZWxlY3QgaXRlbSAxLCB1c2luZyBhY3RpdmUgYmluZGluZ1xyXG4gICAgICA8L2J1dHRvbj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc21hbGxcIiBuZy1jbGljaz1cIml0ZW1zWzFdLmRpc2FibGVkID0gIWl0ZW1zWzFdLmRpc2FibGVkXCI+XHJcbiAgICAgICAgRW5hYmxlL2Rpc2FibGUgaXRlbSAyLCB1c2luZyBkaXNhYmxlZCBiaW5kaW5nXHJcbiAgICAgIDwvYnV0dG9uPlxyXG4gICAgICA8YnIgLz5cclxuICAgICAgPHRhYnNldD5cclxuICAgICAgICA8dGFiIGhlYWRpbmc9XCJUYWIgMVwiPkZpcnN0IFRhYjwvdGFiPlxyXG4gICAgICAgIDx0YWIgc2VsZWN0PVwiYWxlcnRNZSgpXCI+XHJcbiAgICAgICAgICA8dGFiLWhlYWRpbmc+PGkgY2xhc3M9XCJpY29uLWJlbGxcIj48L2k+IEFsZXJ0IG1lITwvdGFiLWhlYWRpbmc+XHJcbiAgICAgICAgICBTZWNvbmQgVGFiLCB3aXRoIGFsZXJ0IGNhbGxiYWNrIGFuZCBodG1sIGhlYWRpbmchXHJcbiAgICAgICAgPC90YWI+XHJcbiAgICAgICAgPHRhYiBuZy1yZXBlYXQ9XCJpdGVtIGluIGl0ZW1zXCJcclxuICAgICAgICAgIGhlYWRpbmc9XCJ7e2l0ZW0udGl0bGV9fVwiXHJcbiAgICAgICAgICBkaXNhYmxlZD1cIml0ZW0uZGlzYWJsZWRcIlxyXG4gICAgICAgICAgYWN0aXZlPVwiaXRlbS5hY3RpdmVcIj5cclxuICAgICAgICAgIHt7aXRlbS5jb250ZW50fX1cclxuICAgICAgICA8L3RhYj5cclxuICAgICAgPC90YWJzZXQ+XHJcbiAgICA8L2Rpdj5cclxuICA8L2ZpbGU+XHJcbiAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxyXG4gICAgZnVuY3Rpb24gVGFic0RlbW9DdHJsKCRzY29wZSkge1xyXG4gICAgICAkc2NvcGUuaXRlbXMgPSBbXHJcbiAgICAgICAgeyB0aXRsZTpcIkR5bmFtaWMgVGl0bGUgMVwiLCBjb250ZW50OlwiRHluYW1pYyBJdGVtIDBcIiB9LFxyXG4gICAgICAgIHsgdGl0bGU6XCJEeW5hbWljIFRpdGxlIDJcIiwgY29udGVudDpcIkR5bmFtaWMgSXRlbSAxXCIsIGRpc2FibGVkOiB0cnVlIH1cclxuICAgICAgXTtcclxuXHJcbiAgICAgICRzY29wZS5hbGVydE1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGFsZXJ0KFwiWW91J3ZlIHNlbGVjdGVkIHRoZSBhbGVydCB0YWIhXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICA8L2ZpbGU+XHJcbjwvZXhhbXBsZT5cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFiSGVhZGluZ1xyXG4gKiBAcmVzdHJpY3QgRUFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENyZWF0ZXMgYW4gSFRNTCBoZWFkaW5nIGZvciBhIHtAbGluayB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFiIHRhYn0uIE11c3QgYmUgcGxhY2VkIGFzIGEgY2hpbGQgb2YgYSB0YWIgZWxlbWVudC5cclxuICpcclxuICogQGV4YW1wbGVcclxuPGV4YW1wbGUgbW9kdWxlPVwidWkuYm9vdHN0cmFwXCI+XHJcbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgIDx0YWJzZXQ+XHJcbiAgICAgIDx0YWI+XHJcbiAgICAgICAgPHRhYi1oZWFkaW5nPjxiPkhUTUw8L2I+IGluIG15IHRpdGxlcz8hPC90YWItaGVhZGluZz5cclxuICAgICAgICBBbmQgc29tZSBjb250ZW50LCB0b28hXHJcbiAgICAgIDwvdGFiPlxyXG4gICAgICA8dGFiPlxyXG4gICAgICAgIDx0YWItaGVhZGluZz48aSBjbGFzcz1cImljb24taGVhcnRcIj48L2k+IEljb24gaGVhZGluZz8hPzwvdGFiLWhlYWRpbmc+XHJcbiAgICAgICAgVGhhdCdzIHJpZ2h0LlxyXG4gICAgICA8L3RhYj5cclxuICAgIDwvdGFic2V0PlxyXG4gIDwvZmlsZT5cclxuPC9leGFtcGxlPlxyXG4gKi9cclxuLmRpcmVjdGl2ZSgndGFiJywgWyckcGFyc2UnLCAnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnLCAnJGNvbXBpbGUnLFxyXG5mdW5jdGlvbigkcGFyc2UsICRodHRwLCAkdGVtcGxhdGVDYWNoZSwgJGNvbXBpbGUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVxdWlyZTogJ150YWJzZXQnLFxyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICByZXBsYWNlOiB0cnVlLFxyXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS90YWJzL3RhYi5odG1sJyxcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICBzY29wZToge1xyXG4gICAgICBoZWFkaW5nOiAnQCcsXHJcbiAgICAgIG9uU2VsZWN0OiAnJnNlbGVjdCcsIC8vVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgaW4gY29udGVudEhlYWRpbmdUcmFuc2NsdWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vbmNlIGl0IGluc2VydHMgdGhlIHRhYidzIGNvbnRlbnQgaW50byB0aGUgZG9tXHJcbiAgICAgIG9uRGVzZWxlY3Q6ICcmZGVzZWxlY3QnXHJcbiAgICB9LFxyXG4gICAgY29udHJvbGxlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vRW1wdHkgY29udHJvbGxlciBzbyBvdGhlciBkaXJlY3RpdmVzIGNhbiByZXF1aXJlIGJlaW5nICd1bmRlcicgYSB0YWJcclxuICAgIH0sXHJcbiAgICBjb21waWxlOiBmdW5jdGlvbihlbG0sIGF0dHJzLCB0cmFuc2NsdWRlKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwb3N0TGluayhzY29wZSwgZWxtLCBhdHRycywgdGFic2V0Q3RybCkge1xyXG4gICAgICAgIHZhciBnZXRBY3RpdmUsIHNldEFjdGl2ZTtcclxuICAgICAgICBpZiAoYXR0cnMuYWN0aXZlKSB7XHJcbiAgICAgICAgICBnZXRBY3RpdmUgPSAkcGFyc2UoYXR0cnMuYWN0aXZlKTtcclxuICAgICAgICAgIHNldEFjdGl2ZSA9IGdldEFjdGl2ZS5hc3NpZ247XHJcbiAgICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaChnZXRBY3RpdmUsIGZ1bmN0aW9uIHVwZGF0ZUFjdGl2ZSh2YWx1ZSkge1xyXG4gICAgICAgICAgICBzY29wZS5hY3RpdmUgPSAhIXZhbHVlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBzY29wZS5hY3RpdmUgPSBnZXRBY3RpdmUoc2NvcGUuJHBhcmVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNldEFjdGl2ZSA9IGdldEFjdGl2ZSA9IGFuZ3VsYXIubm9vcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnYWN0aXZlJywgZnVuY3Rpb24oYWN0aXZlKSB7XHJcbiAgICAgICAgICBzZXRBY3RpdmUoc2NvcGUuJHBhcmVudCwgYWN0aXZlKTtcclxuICAgICAgICAgIGlmIChhY3RpdmUpIHtcclxuICAgICAgICAgICAgdGFic2V0Q3RybC5zZWxlY3Qoc2NvcGUpO1xyXG4gICAgICAgICAgICBzY29wZS5vblNlbGVjdCgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2NvcGUub25EZXNlbGVjdCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzY29wZS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICggYXR0cnMuZGlzYWJsZWQgKSB7XHJcbiAgICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMuZGlzYWJsZWQpLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBzY29wZS5kaXNhYmxlZCA9ICEhIHZhbHVlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzY29wZS5zZWxlY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmICggISBzY29wZS5kaXNhYmxlZCApIHtcclxuICAgICAgICAgICAgc2NvcGUuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0YWJzZXRDdHJsLmFkZFRhYihzY29wZSk7XHJcbiAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdGFic2V0Q3RybC5yZW1vdmVUYWIoc2NvcGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChzY29wZS5hY3RpdmUpIHtcclxuICAgICAgICAgIHNldEFjdGl2ZShzY29wZS4kcGFyZW50LCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvL1dlIG5lZWQgdG8gdHJhbnNjbHVkZSBsYXRlciwgb25jZSB0aGUgY29udGVudCBjb250YWluZXIgaXMgcmVhZHkuXHJcbiAgICAgICAgLy93aGVuIHRoaXMgbGluayBoYXBwZW5zLCB3ZSdyZSBpbnNpZGUgYSB0YWIgaGVhZGluZy5cclxuICAgICAgICBzY29wZS4kdHJhbnNjbHVkZUZuID0gdHJhbnNjbHVkZTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbi5kaXJlY3RpdmUoJ3RhYkhlYWRpbmdUcmFuc2NsdWRlJywgW2Z1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgcmVxdWlyZTogJ150YWInLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMsIHRhYkN0cmwpIHtcclxuICAgICAgc2NvcGUuJHdhdGNoKCdoZWFkaW5nRWxlbWVudCcsIGZ1bmN0aW9uIHVwZGF0ZUhlYWRpbmdFbGVtZW50KGhlYWRpbmcpIHtcclxuICAgICAgICBpZiAoaGVhZGluZykge1xyXG4gICAgICAgICAgZWxtLmh0bWwoJycpO1xyXG4gICAgICAgICAgZWxtLmFwcGVuZChoZWFkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dKVxyXG5cclxuLmRpcmVjdGl2ZSgndGFiQ29udGVudFRyYW5zY2x1ZGUnLCBbJyRjb21waWxlJywgJyRwYXJzZScsIGZ1bmN0aW9uKCRjb21waWxlLCAkcGFyc2UpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIHJlcXVpcmU6ICdedGFic2V0JyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbG0sIGF0dHJzKSB7XHJcbiAgICAgIHZhciB0YWIgPSBzY29wZS4kZXZhbChhdHRycy50YWJDb250ZW50VHJhbnNjbHVkZSk7XHJcblxyXG4gICAgICAvL05vdyBvdXIgdGFiIGlzIHJlYWR5IHRvIGJlIHRyYW5zY2x1ZGVkOiBib3RoIHRoZSB0YWIgaGVhZGluZyBhcmVhXHJcbiAgICAgIC8vYW5kIHRoZSB0YWIgY29udGVudCBhcmVhIGFyZSBsb2FkZWQuICBUcmFuc2NsdWRlICdlbSBib3RoLlxyXG4gICAgICB0YWIuJHRyYW5zY2x1ZGVGbih0YWIuJHBhcmVudCwgZnVuY3Rpb24oY29udGVudHMpIHtcclxuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGVudHMsIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgIGlmIChpc1RhYkhlYWRpbmcobm9kZSkpIHtcclxuICAgICAgICAgICAgLy9MZXQgdGFiSGVhZGluZ1RyYW5zY2x1ZGUga25vdy5cclxuICAgICAgICAgICAgdGFiLmhlYWRpbmdFbGVtZW50ID0gbm9kZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsbS5hcHBlbmQobm9kZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgZnVuY3Rpb24gaXNUYWJIZWFkaW5nKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnRhZ05hbWUgJiYgIChcclxuICAgICAgbm9kZS5oYXNBdHRyaWJ1dGUoJ3RhYi1oZWFkaW5nJykgfHxcclxuICAgICAgbm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdGFiLWhlYWRpbmcnKSB8fFxyXG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RhYi1oZWFkaW5nJyB8fFxyXG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RhdGEtdGFiLWhlYWRpbmcnXHJcbiAgICApO1xyXG4gIH1cclxufV0pXHJcblxyXG4uZGlyZWN0aXZlKCd0YWJzZXRUaXRsZXMnLCBbJyRodHRwJywgZnVuY3Rpb24oJGh0dHApIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIHJlcXVpcmU6ICdedGFic2V0JyxcclxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdGFicy90YWJzZXQtdGl0bGVzLmh0bWwnLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbG0sIGF0dHJzLCB0YWJzZXRDdHJsKSB7XHJcbiAgICAgIGlmICghc2NvcGUuJGV2YWwoYXR0cnMudGFic2V0VGl0bGVzKSkge1xyXG4gICAgICAgIGVsbS5yZW1vdmUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvL25vdyB0aGF0IHRhYnMgbG9jYXRpb24gaGFzIGJlZW4gZGVjaWRlZCwgdHJhbnNjbHVkZSB0aGUgdGFiIHRpdGxlcyBpblxyXG4gICAgICAgIHRhYnNldEN0cmwuJHRyYW5zY2x1ZGVGbih0YWJzZXRDdHJsLiRzY29wZS4kcGFyZW50LCBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICBlbG0uYXBwZW5kKG5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufV0pXHJcblxyXG47XHJcblxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50aW1lcGlja2VyJywgW10pXHJcblxyXG4uY29uc3RhbnQoJ3RpbWVwaWNrZXJDb25maWcnLCB7XHJcbiAgaG91clN0ZXA6IDEsXHJcbiAgbWludXRlU3RlcDogMSxcclxuICBzaG93TWVyaWRpYW46IHRydWUsXHJcbiAgbWVyaWRpYW5zOiBbJ0FNJywgJ1BNJ10sXHJcbiAgcmVhZG9ubHlJbnB1dDogZmFsc2UsXHJcbiAgbW91c2V3aGVlbDogdHJ1ZVxyXG59KVxyXG5cclxuLmRpcmVjdGl2ZSgndGltZXBpY2tlcicsIFsnJHBhcnNlJywgJyRsb2cnLCAndGltZXBpY2tlckNvbmZpZycsIGZ1bmN0aW9uICgkcGFyc2UsICRsb2csIHRpbWVwaWNrZXJDb25maWcpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICByZXF1aXJlOic/Xm5nTW9kZWwnLFxyXG4gICAgcmVwbGFjZTogdHJ1ZSxcclxuICAgIHNjb3BlOiB7fSxcclxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWwnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XHJcbiAgICAgIGlmICggIW5nTW9kZWwgKSB7XHJcbiAgICAgICAgcmV0dXJuOyAvLyBkbyBub3RoaW5nIGlmIG5vIG5nLW1vZGVsXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzZWxlY3RlZCA9IG5ldyBEYXRlKCksIG1lcmlkaWFucyA9IHRpbWVwaWNrZXJDb25maWcubWVyaWRpYW5zO1xyXG5cclxuICAgICAgdmFyIGhvdXJTdGVwID0gdGltZXBpY2tlckNvbmZpZy5ob3VyU3RlcDtcclxuICAgICAgaWYgKGF0dHJzLmhvdXJTdGVwKSB7XHJcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLmhvdXJTdGVwKSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgIGhvdXJTdGVwID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG1pbnV0ZVN0ZXAgPSB0aW1lcGlja2VyQ29uZmlnLm1pbnV0ZVN0ZXA7XHJcbiAgICAgIGlmIChhdHRycy5taW51dGVTdGVwKSB7XHJcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLm1pbnV0ZVN0ZXApLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgbWludXRlU3RlcCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDEySCAvIDI0SCBtb2RlXHJcbiAgICAgIHNjb3BlLnNob3dNZXJpZGlhbiA9IHRpbWVwaWNrZXJDb25maWcuc2hvd01lcmlkaWFuO1xyXG4gICAgICBpZiAoYXR0cnMuc2hvd01lcmlkaWFuKSB7XHJcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLnNob3dNZXJpZGlhbiksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICBzY29wZS5zaG93TWVyaWRpYW4gPSAhIXZhbHVlO1xyXG5cclxuICAgICAgICAgIGlmICggbmdNb2RlbC4kZXJyb3IudGltZSApIHtcclxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgZnJvbSB0ZW1wbGF0ZVxyXG4gICAgICAgICAgICB2YXIgaG91cnMgPSBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpLCBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoIGhvdXJzICkgJiYgYW5ndWxhci5pc0RlZmluZWQoIG1pbnV0ZXMgKSkge1xyXG4gICAgICAgICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKCBob3VycyApO1xyXG4gICAgICAgICAgICAgIHJlZnJlc2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdXBkYXRlVGVtcGxhdGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2V0IHNjb3BlLmhvdXJzIGluIDI0SCBtb2RlIGlmIHZhbGlkXHJcbiAgICAgIGZ1bmN0aW9uIGdldEhvdXJzRnJvbVRlbXBsYXRlICggKSB7XHJcbiAgICAgICAgdmFyIGhvdXJzID0gcGFyc2VJbnQoIHNjb3BlLmhvdXJzLCAxMCApO1xyXG4gICAgICAgIHZhciB2YWxpZCA9ICggc2NvcGUuc2hvd01lcmlkaWFuICkgPyAoaG91cnMgPiAwICYmIGhvdXJzIDwgMTMpIDogKGhvdXJzID49IDAgJiYgaG91cnMgPCAyNCk7XHJcbiAgICAgICAgaWYgKCAhdmFsaWQgKSB7XHJcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCBzY29wZS5zaG93TWVyaWRpYW4gKSB7XHJcbiAgICAgICAgICBpZiAoIGhvdXJzID09PSAxMiApIHtcclxuICAgICAgICAgICAgaG91cnMgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCBzY29wZS5tZXJpZGlhbiA9PT0gbWVyaWRpYW5zWzFdICkge1xyXG4gICAgICAgICAgICBob3VycyA9IGhvdXJzICsgMTI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3VycztcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpIHtcclxuICAgICAgICB2YXIgbWludXRlcyA9IHBhcnNlSW50KHNjb3BlLm1pbnV0ZXMsIDEwKTtcclxuICAgICAgICByZXR1cm4gKCBtaW51dGVzID49IDAgJiYgbWludXRlcyA8IDYwICkgPyBtaW51dGVzIDogdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBwYWQoIHZhbHVlICkge1xyXG4gICAgICAgIHJldHVybiAoIGFuZ3VsYXIuaXNEZWZpbmVkKHZhbHVlKSAmJiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aCA8IDIgKSA/ICcwJyArIHZhbHVlIDogdmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElucHV0IGVsZW1lbnRzXHJcbiAgICAgIHZhciBpbnB1dHMgPSBlbGVtZW50LmZpbmQoJ2lucHV0JyksIGhvdXJzSW5wdXRFbCA9IGlucHV0cy5lcSgwKSwgbWludXRlc0lucHV0RWwgPSBpbnB1dHMuZXEoMSk7XHJcblxyXG4gICAgICAvLyBSZXNwb25kIG9uIG1vdXNld2hlZWwgc3BpblxyXG4gICAgICB2YXIgbW91c2V3aGVlbCA9IChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5tb3VzZXdoZWVsKSkgPyBzY29wZS4kZXZhbChhdHRycy5tb3VzZXdoZWVsKSA6IHRpbWVwaWNrZXJDb25maWcubW91c2V3aGVlbDtcclxuICAgICAgaWYgKCBtb3VzZXdoZWVsICkge1xyXG5cclxuICAgICAgICB2YXIgaXNTY3JvbGxpbmdVcCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIHtcclxuICAgICAgICAgICAgZSA9IGUub3JpZ2luYWxFdmVudDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vcGljayBjb3JyZWN0IGRlbHRhIHZhcmlhYmxlIGRlcGVuZGluZyBvbiBldmVudFxyXG4gICAgICAgICAgdmFyIGRlbHRhID0gKGUud2hlZWxEZWx0YSkgPyBlLndoZWVsRGVsdGEgOiAtZS5kZWx0YVk7XHJcbiAgICAgICAgICByZXR1cm4gKGUuZGV0YWlsIHx8IGRlbHRhID4gMCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaG91cnNJbnB1dEVsLmJpbmQoJ21vdXNld2hlZWwgd2hlZWwnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICBzY29wZS4kYXBwbHkoIChpc1Njcm9sbGluZ1VwKGUpKSA/IHNjb3BlLmluY3JlbWVudEhvdXJzKCkgOiBzY29wZS5kZWNyZW1lbnRIb3VycygpICk7XHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG1pbnV0ZXNJbnB1dEVsLmJpbmQoJ21vdXNld2hlZWwgd2hlZWwnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICBzY29wZS4kYXBwbHkoIChpc1Njcm9sbGluZ1VwKGUpKSA/IHNjb3BlLmluY3JlbWVudE1pbnV0ZXMoKSA6IHNjb3BlLmRlY3JlbWVudE1pbnV0ZXMoKSApO1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzY29wZS5yZWFkb25seUlucHV0ID0gKGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnJlYWRvbmx5SW5wdXQpKSA/IHNjb3BlLiRldmFsKGF0dHJzLnJlYWRvbmx5SW5wdXQpIDogdGltZXBpY2tlckNvbmZpZy5yZWFkb25seUlucHV0O1xyXG4gICAgICBpZiAoICEgc2NvcGUucmVhZG9ubHlJbnB1dCApIHtcclxuXHJcbiAgICAgICAgdmFyIGludmFsaWRhdGUgPSBmdW5jdGlvbihpbnZhbGlkSG91cnMsIGludmFsaWRNaW51dGVzKSB7XHJcbiAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoIG51bGwgKTtcclxuICAgICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCd0aW1lJywgZmFsc2UpO1xyXG4gICAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGludmFsaWRIb3VycykpIHtcclxuICAgICAgICAgICAgc2NvcGUuaW52YWxpZEhvdXJzID0gaW52YWxpZEhvdXJzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGludmFsaWRNaW51dGVzKSkge1xyXG4gICAgICAgICAgICBzY29wZS5pbnZhbGlkTWludXRlcyA9IGludmFsaWRNaW51dGVzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNjb3BlLnVwZGF0ZUhvdXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgaG91cnMgPSBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpO1xyXG5cclxuICAgICAgICAgIGlmICggYW5ndWxhci5pc0RlZmluZWQoaG91cnMpICkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZC5zZXRIb3VycyggaG91cnMgKTtcclxuICAgICAgICAgICAgcmVmcmVzaCggJ2gnICk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnZhbGlkYXRlKHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGhvdXJzSW5wdXRFbC5iaW5kKCdibHVyJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgaWYgKCAhc2NvcGUudmFsaWRIb3VycyAmJiBzY29wZS5ob3VycyA8IDEwKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLiRhcHBseSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgc2NvcGUuaG91cnMgPSBwYWQoIHNjb3BlLmhvdXJzICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzY29wZS51cGRhdGVNaW51dGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgbWludXRlcyA9IGdldE1pbnV0ZXNGcm9tVGVtcGxhdGUoKTtcclxuXHJcbiAgICAgICAgICBpZiAoIGFuZ3VsYXIuaXNEZWZpbmVkKG1pbnV0ZXMpICkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZC5zZXRNaW51dGVzKCBtaW51dGVzICk7XHJcbiAgICAgICAgICAgIHJlZnJlc2goICdtJyApO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW52YWxpZGF0ZSh1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG1pbnV0ZXNJbnB1dEVsLmJpbmQoJ2JsdXInLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICBpZiAoICFzY29wZS5pbnZhbGlkTWludXRlcyAmJiBzY29wZS5taW51dGVzIDwgMTAgKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLiRhcHBseSggZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgc2NvcGUubWludXRlcyA9IHBhZCggc2NvcGUubWludXRlcyApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzY29wZS51cGRhdGVIb3VycyA9IGFuZ3VsYXIubm9vcDtcclxuICAgICAgICBzY29wZS51cGRhdGVNaW51dGVzID0gYW5ndWxhci5ub29wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuZ01vZGVsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgZGF0ZSA9IG5nTW9kZWwuJG1vZGVsVmFsdWUgPyBuZXcgRGF0ZSggbmdNb2RlbC4kbW9kZWxWYWx1ZSApIDogbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKCBpc05hTihkYXRlKSApIHtcclxuICAgICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCd0aW1lJywgZmFsc2UpO1xyXG4gICAgICAgICAgJGxvZy5lcnJvcignVGltZXBpY2tlciBkaXJlY3RpdmU6IFwibmctbW9kZWxcIiB2YWx1ZSBtdXN0IGJlIGEgRGF0ZSBvYmplY3QsIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAwMS4wMS4xOTcwIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBSRkMyODIyIG9yIElTTyA4NjAxIGRhdGUuJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICggZGF0ZSApIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBkYXRlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbWFrZVZhbGlkKCk7XHJcbiAgICAgICAgICB1cGRhdGVUZW1wbGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIENhbGwgaW50ZXJuYWxseSB3aGVuIHdlIGtub3cgdGhhdCBtb2RlbCBpcyB2YWxpZC5cclxuICAgICAgZnVuY3Rpb24gcmVmcmVzaCgga2V5Ym9hcmRDaGFuZ2UgKSB7XHJcbiAgICAgICAgbWFrZVZhbGlkKCk7XHJcbiAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKCBuZXcgRGF0ZShzZWxlY3RlZCkgKTtcclxuICAgICAgICB1cGRhdGVUZW1wbGF0ZSgga2V5Ym9hcmRDaGFuZ2UgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gbWFrZVZhbGlkKCkge1xyXG4gICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCd0aW1lJywgdHJ1ZSk7XHJcbiAgICAgICAgc2NvcGUuaW52YWxpZEhvdXJzID0gZmFsc2U7XHJcbiAgICAgICAgc2NvcGUuaW52YWxpZE1pbnV0ZXMgPSBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gdXBkYXRlVGVtcGxhdGUoIGtleWJvYXJkQ2hhbmdlICkge1xyXG4gICAgICAgIHZhciBob3VycyA9IHNlbGVjdGVkLmdldEhvdXJzKCksIG1pbnV0ZXMgPSBzZWxlY3RlZC5nZXRNaW51dGVzKCk7XHJcblxyXG4gICAgICAgIGlmICggc2NvcGUuc2hvd01lcmlkaWFuICkge1xyXG4gICAgICAgICAgaG91cnMgPSAoIGhvdXJzID09PSAwIHx8IGhvdXJzID09PSAxMiApID8gMTIgOiBob3VycyAlIDEyOyAvLyBDb252ZXJ0IDI0IHRvIDEyIGhvdXIgc3lzdGVtXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjb3BlLmhvdXJzID0gIGtleWJvYXJkQ2hhbmdlID09PSAnaCcgPyBob3VycyA6IHBhZChob3Vycyk7XHJcbiAgICAgICAgc2NvcGUubWludXRlcyA9IGtleWJvYXJkQ2hhbmdlID09PSAnbScgPyBtaW51dGVzIDogcGFkKG1pbnV0ZXMpO1xyXG4gICAgICAgIHNjb3BlLm1lcmlkaWFuID0gc2VsZWN0ZWQuZ2V0SG91cnMoKSA8IDEyID8gbWVyaWRpYW5zWzBdIDogbWVyaWRpYW5zWzFdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBhZGRNaW51dGVzKCBtaW51dGVzICkge1xyXG4gICAgICAgIHZhciBkdCA9IG5ldyBEYXRlKCBzZWxlY3RlZC5nZXRUaW1lKCkgKyBtaW51dGVzICogNjAwMDAgKTtcclxuICAgICAgICBzZWxlY3RlZC5zZXRIb3VycyggZHQuZ2V0SG91cnMoKSwgZHQuZ2V0TWludXRlcygpICk7XHJcbiAgICAgICAgcmVmcmVzaCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzY29wZS5pbmNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFkZE1pbnV0ZXMoIGhvdXJTdGVwICogNjAgKTtcclxuICAgICAgfTtcclxuICAgICAgc2NvcGUuZGVjcmVtZW50SG91cnMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBhZGRNaW51dGVzKCAtIGhvdXJTdGVwICogNjAgKTtcclxuICAgICAgfTtcclxuICAgICAgc2NvcGUuaW5jcmVtZW50TWludXRlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFkZE1pbnV0ZXMoIG1pbnV0ZVN0ZXAgKTtcclxuICAgICAgfTtcclxuICAgICAgc2NvcGUuZGVjcmVtZW50TWludXRlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFkZE1pbnV0ZXMoIC0gbWludXRlU3RlcCApO1xyXG4gICAgICB9O1xyXG4gICAgICBzY29wZS50b2dnbGVNZXJpZGlhbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFkZE1pbnV0ZXMoIDEyICogNjAgKiAoKCBzZWxlY3RlZC5nZXRIb3VycygpIDwgMTIgKSA/IDEgOiAtMSkgKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnR5cGVhaGVhZCcsIFsndWkuYm9vdHN0cmFwLnBvc2l0aW9uJywgJ3VpLmJvb3RzdHJhcC5iaW5kSHRtbCddKVxyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyIHNlcnZpY2UgdGhhdCBjYW4gcGFyc2UgdHlwZWFoZWFkJ3Mgc3ludGF4IChzdHJpbmcgcHJvdmlkZWQgYnkgdXNlcnMpXHJcbiAqIEV4dHJhY3RlZCB0byBhIHNlcGFyYXRlIHNlcnZpY2UgZm9yIGVhc2Ugb2YgdW5pdCB0ZXN0aW5nXHJcbiAqL1xyXG4gIC5mYWN0b3J5KCd0eXBlYWhlYWRQYXJzZXInLCBbJyRwYXJzZScsIGZ1bmN0aW9uICgkcGFyc2UpIHtcclxuXHJcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgMDAwMDAxMTEwMDAwMDAwMDAwMDAwMjIyMDAwMDAwMDAwMDAwMDAwMDMzMzMzMzMzMzMzMzMzMzAwMDAwMDAwMDAwNDQwMDBcclxuICB2YXIgVFlQRUFIRUFEX1JFR0VYUCA9IC9eXFxzKiguKj8pKD86XFxzK2FzXFxzKyguKj8pKT9cXHMrZm9yXFxzKyg/OihbXFwkXFx3XVtcXCRcXHdcXGRdKikpXFxzK2luXFxzKyguKikkLztcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHBhcnNlOmZ1bmN0aW9uIChpbnB1dCkge1xyXG5cclxuICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2goVFlQRUFIRUFEX1JFR0VYUCksIG1vZGVsTWFwcGVyLCB2aWV3TWFwcGVyLCBzb3VyY2U7XHJcbiAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBcIkV4cGVjdGVkIHR5cGVhaGVhZCBzcGVjaWZpY2F0aW9uIGluIGZvcm0gb2YgJ19tb2RlbFZhbHVlXyAoYXMgX2xhYmVsXyk/IGZvciBfaXRlbV8gaW4gX2NvbGxlY3Rpb25fJ1wiICtcclxuICAgICAgICAgICAgXCIgYnV0IGdvdCAnXCIgKyBpbnB1dCArIFwiJy5cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaXRlbU5hbWU6bWF0Y2hbM10sXHJcbiAgICAgICAgc291cmNlOiRwYXJzZShtYXRjaFs0XSksXHJcbiAgICAgICAgdmlld01hcHBlcjokcGFyc2UobWF0Y2hbMl0gfHwgbWF0Y2hbMV0pLFxyXG4gICAgICAgIG1vZGVsTWFwcGVyOiRwYXJzZShtYXRjaFsxXSlcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9O1xyXG59XSlcclxuXHJcbiAgLmRpcmVjdGl2ZSgndHlwZWFoZWFkJywgWyckY29tcGlsZScsICckcGFyc2UnLCAnJHEnLCAnJHRpbWVvdXQnLCAnJGRvY3VtZW50JywgJyRwb3NpdGlvbicsICd0eXBlYWhlYWRQYXJzZXInLFxyXG4gICAgZnVuY3Rpb24gKCRjb21waWxlLCAkcGFyc2UsICRxLCAkdGltZW91dCwgJGRvY3VtZW50LCAkcG9zaXRpb24sIHR5cGVhaGVhZFBhcnNlcikge1xyXG5cclxuICB2YXIgSE9UX0tFWVMgPSBbOSwgMTMsIDI3LCAzOCwgNDBdO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcmVxdWlyZTonbmdNb2RlbCcsXHJcbiAgICBsaW5rOmZ1bmN0aW9uIChvcmlnaW5hbFNjb3BlLCBlbGVtZW50LCBhdHRycywgbW9kZWxDdHJsKSB7XHJcblxyXG4gICAgICAvL1NVUFBPUlRFRCBBVFRSSUJVVEVTIChPUFRJT05TKVxyXG5cclxuICAgICAgLy9taW5pbWFsIG5vIG9mIGNoYXJhY3RlcnMgdGhhdCBuZWVkcyB0byBiZSBlbnRlcmVkIGJlZm9yZSB0eXBlYWhlYWQga2lja3MtaW5cclxuICAgICAgdmFyIG1pblNlYXJjaCA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkTWluTGVuZ3RoKSB8fCAxO1xyXG5cclxuICAgICAgLy9taW5pbWFsIHdhaXQgdGltZSBhZnRlciBsYXN0IGNoYXJhY3RlciB0eXBlZCBiZWZvcmUgdHlwZWhlYWQga2lja3MtaW5cclxuICAgICAgdmFyIHdhaXRUaW1lID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRXYWl0TXMpIHx8IDA7XHJcblxyXG4gICAgICAvL3Nob3VsZCBpdCByZXN0cmljdCBtb2RlbCB2YWx1ZXMgdG8gdGhlIG9uZXMgc2VsZWN0ZWQgZnJvbSB0aGUgcG9wdXAgb25seT9cclxuICAgICAgdmFyIGlzRWRpdGFibGUgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEVkaXRhYmxlKSAhPT0gZmFsc2U7XHJcblxyXG4gICAgICAvL2JpbmRpbmcgdG8gYSB2YXJpYWJsZSB0aGF0IGluZGljYXRlcyBpZiBtYXRjaGVzIGFyZSBiZWluZyByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHlcclxuICAgICAgdmFyIGlzTG9hZGluZ1NldHRlciA9ICRwYXJzZShhdHRycy50eXBlYWhlYWRMb2FkaW5nKS5hc3NpZ24gfHwgYW5ndWxhci5ub29wO1xyXG5cclxuICAgICAgLy9hIGNhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gYSBtYXRjaCBpcyBzZWxlY3RlZFxyXG4gICAgICB2YXIgb25TZWxlY3RDYWxsYmFjayA9ICRwYXJzZShhdHRycy50eXBlYWhlYWRPblNlbGVjdCk7XHJcblxyXG4gICAgICB2YXIgaW5wdXRGb3JtYXR0ZXIgPSBhdHRycy50eXBlYWhlYWRJbnB1dEZvcm1hdHRlciA/ICRwYXJzZShhdHRycy50eXBlYWhlYWRJbnB1dEZvcm1hdHRlcikgOiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAvL0lOVEVSTkFMIFZBUklBQkxFU1xyXG5cclxuICAgICAgLy9tb2RlbCBzZXR0ZXIgZXhlY3V0ZWQgdXBvbiBtYXRjaCBzZWxlY3Rpb25cclxuICAgICAgdmFyICRzZXRNb2RlbFZhbHVlID0gJHBhcnNlKGF0dHJzLm5nTW9kZWwpLmFzc2lnbjtcclxuXHJcbiAgICAgIC8vZXhwcmVzc2lvbnMgdXNlZCBieSB0eXBlYWhlYWRcclxuICAgICAgdmFyIHBhcnNlclJlc3VsdCA9IHR5cGVhaGVhZFBhcnNlci5wYXJzZShhdHRycy50eXBlYWhlYWQpO1xyXG5cclxuXHJcbiAgICAgIC8vcG9wLXVwIGVsZW1lbnQgdXNlZCB0byBkaXNwbGF5IG1hdGNoZXNcclxuICAgICAgdmFyIHBvcFVwRWwgPSBhbmd1bGFyLmVsZW1lbnQoJzx0eXBlYWhlYWQtcG9wdXA+PC90eXBlYWhlYWQtcG9wdXA+Jyk7XHJcbiAgICAgIHBvcFVwRWwuYXR0cih7XHJcbiAgICAgICAgbWF0Y2hlczogJ21hdGNoZXMnLFxyXG4gICAgICAgIGFjdGl2ZTogJ2FjdGl2ZUlkeCcsXHJcbiAgICAgICAgc2VsZWN0OiAnc2VsZWN0KGFjdGl2ZUlkeCknLFxyXG4gICAgICAgIHF1ZXJ5OiAncXVlcnknLFxyXG4gICAgICAgIHBvc2l0aW9uOiAncG9zaXRpb24nXHJcbiAgICAgIH0pO1xyXG4gICAgICAvL2N1c3RvbSBpdGVtIHRlbXBsYXRlXHJcbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlYWhlYWRUZW1wbGF0ZVVybCkpIHtcclxuICAgICAgICBwb3BVcEVsLmF0dHIoJ3RlbXBsYXRlLXVybCcsIGF0dHJzLnR5cGVhaGVhZFRlbXBsYXRlVXJsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy9jcmVhdGUgYSBjaGlsZCBzY29wZSBmb3IgdGhlIHR5cGVhaGVhZCBkaXJlY3RpdmUgc28gd2UgYXJlIG5vdCBwb2xsdXRpbmcgb3JpZ2luYWwgc2NvcGVcclxuICAgICAgLy93aXRoIHR5cGVhaGVhZC1zcGVjaWZpYyBkYXRhIChtYXRjaGVzLCBxdWVyeSBldGMuKVxyXG4gICAgICB2YXIgc2NvcGUgPSBvcmlnaW5hbFNjb3BlLiRuZXcoKTtcclxuICAgICAgb3JpZ2luYWxTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKXtcclxuICAgICAgICBzY29wZS4kZGVzdHJveSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciByZXNldE1hdGNoZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBzY29wZS5tYXRjaGVzID0gW107XHJcbiAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gLTE7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgZ2V0TWF0Y2hlc0FzeW5jID0gZnVuY3Rpb24oaW5wdXRWYWx1ZSkge1xyXG5cclxuICAgICAgICB2YXIgbG9jYWxzID0geyR2aWV3VmFsdWU6IGlucHV0VmFsdWV9O1xyXG4gICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCB0cnVlKTtcclxuICAgICAgICAkcS53aGVuKHBhcnNlclJlc3VsdC5zb3VyY2Uoc2NvcGUsIGxvY2FscykpLnRoZW4oZnVuY3Rpb24obWF0Y2hlcykge1xyXG5cclxuICAgICAgICAgIC8vaXQgbWlnaHQgaGFwcGVuIHRoYXQgc2V2ZXJhbCBhc3luYyBxdWVyaWVzIHdlcmUgaW4gcHJvZ3Jlc3MgaWYgYSB1c2VyIHdlcmUgdHlwaW5nIGZhc3RcclxuICAgICAgICAgIC8vYnV0IHdlIGFyZSBpbnRlcmVzdGVkIG9ubHkgaW4gcmVzcG9uc2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgY3VycmVudCB2aWV3IHZhbHVlXHJcbiAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSA9PT0gbW9kZWxDdHJsLiR2aWV3VmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICBzY29wZS5hY3RpdmVJZHggPSAwO1xyXG4gICAgICAgICAgICAgIHNjb3BlLm1hdGNoZXMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgLy90cmFuc2Zvcm0gbGFiZWxzXHJcbiAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8bWF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBtYXRjaGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUubWF0Y2hlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgbGFiZWw6IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKHNjb3BlLCBsb2NhbHMpLFxyXG4gICAgICAgICAgICAgICAgICBtb2RlbDogbWF0Y2hlc1tpXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBzY29wZS5xdWVyeSA9IGlucHV0VmFsdWU7XHJcbiAgICAgICAgICAgICAgLy9wb3NpdGlvbiBwb3AtdXAgd2l0aCBtYXRjaGVzIC0gd2UgbmVlZCB0byByZS1jYWxjdWxhdGUgaXRzIHBvc2l0aW9uIGVhY2ggdGltZSB3ZSBhcmUgb3BlbmluZyBhIHdpbmRvd1xyXG4gICAgICAgICAgICAgIC8vd2l0aCBtYXRjaGVzIGFzIGEgcG9wLXVwIG1pZ2h0IGJlIGFic29sdXRlLXBvc2l0aW9uZWQgYW5kIHBvc2l0aW9uIG9mIGFuIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZCBvbiBhIHBhZ2VcclxuICAgICAgICAgICAgICAvL2R1ZSB0byBvdGhlciBlbGVtZW50cyBiZWluZyByZW5kZXJlZFxyXG4gICAgICAgICAgICAgIHNjb3BlLnBvc2l0aW9uID0gJHBvc2l0aW9uLnBvc2l0aW9uKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgIHNjb3BlLnBvc2l0aW9uLnRvcCA9IHNjb3BlLnBvc2l0aW9uLnRvcCArIGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0Jyk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24oKXtcclxuICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xyXG4gICAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJlc2V0TWF0Y2hlcygpO1xyXG5cclxuICAgICAgLy93ZSBuZWVkIHRvIHByb3BhZ2F0ZSB1c2VyJ3MgcXVlcnkgc28gd2UgY2FuIGhpZ2xpZ2h0IG1hdGNoZXNcclxuICAgICAgc2NvcGUucXVlcnkgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAvL0RlY2xhcmUgdGhlIHRpbWVvdXQgcHJvbWlzZSB2YXIgb3V0c2lkZSB0aGUgZnVuY3Rpb24gc2NvcGUgc28gdGhhdCBzdGFja2VkIGNhbGxzIGNhbiBiZSBjYW5jZWxsZWQgbGF0ZXIgXHJcbiAgICAgIHZhciB0aW1lb3V0UHJvbWlzZTtcclxuXHJcbiAgICAgIC8vcGx1ZyBpbnRvICRwYXJzZXJzIHBpcGVsaW5lIHRvIG9wZW4gYSB0eXBlYWhlYWQgb24gdmlldyBjaGFuZ2VzIGluaXRpYXRlZCBmcm9tIERPTVxyXG4gICAgICAvLyRwYXJzZXJzIGtpY2staW4gb24gYWxsIHRoZSBjaGFuZ2VzIGNvbWluZyBmcm9tIHRoZSB2aWV3IGFzIHdlbGwgYXMgbWFudWFsbHkgdHJpZ2dlcmVkIGJ5ICRzZXRWaWV3VmFsdWVcclxuICAgICAgbW9kZWxDdHJsLiRwYXJzZXJzLnVuc2hpZnQoZnVuY3Rpb24gKGlucHV0VmFsdWUpIHtcclxuXHJcbiAgICAgICAgcmVzZXRNYXRjaGVzKCk7XHJcbiAgICAgICAgaWYgKGlucHV0VmFsdWUgJiYgaW5wdXRWYWx1ZS5sZW5ndGggPj0gbWluU2VhcmNoKSB7XHJcbiAgICAgICAgICBpZiAod2FpdFRpbWUgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0UHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0aW1lb3V0UHJvbWlzZSk7Ly9jYW5jZWwgcHJldmlvdXMgdGltZW91dFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpbWVvdXRQcm9taXNlID0gJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIGdldE1hdGNoZXNBc3luYyhpbnB1dFZhbHVlKTtcclxuICAgICAgICAgICAgfSwgd2FpdFRpbWUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2V0TWF0Y2hlc0FzeW5jKGlucHV0VmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzRWRpdGFibGUpIHtcclxuICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIGZhbHNlKTtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIG1vZGVsQ3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uIChtb2RlbFZhbHVlKSB7XHJcblxyXG4gICAgICAgIHZhciBjYW5kaWRhdGVWaWV3VmFsdWUsIGVtcHR5Vmlld1ZhbHVlO1xyXG4gICAgICAgIHZhciBsb2NhbHMgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKGlucHV0Rm9ybWF0dGVyKSB7XHJcblxyXG4gICAgICAgICAgbG9jYWxzWyckbW9kZWwnXSA9IG1vZGVsVmFsdWU7XHJcbiAgICAgICAgICByZXR1cm4gaW5wdXRGb3JtYXR0ZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvL2l0IG1pZ2h0IGhhcHBlbiB0aGF0IHdlIGRvbid0IGhhdmUgZW5vdWdoIGluZm8gdG8gcHJvcGVybHkgcmVuZGVyIGlucHV0IHZhbHVlXHJcbiAgICAgICAgICAvL3dlIG5lZWQgdG8gY2hlY2sgZm9yIHRoaXMgc2l0dWF0aW9uIGFuZCBzaW1wbHkgcmV0dXJuIG1vZGVsIHZhbHVlIGlmIHdlIGNhbid0IGFwcGx5IGN1c3RvbSBmb3JtYXR0aW5nXHJcbiAgICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IG1vZGVsVmFsdWU7XHJcbiAgICAgICAgICBjYW5kaWRhdGVWaWV3VmFsdWUgPSBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xyXG4gICAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBlbXB0eVZpZXdWYWx1ZSA9IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZVZpZXdWYWx1ZSE9PSBlbXB0eVZpZXdWYWx1ZSA/IGNhbmRpZGF0ZVZpZXdWYWx1ZSA6IG1vZGVsVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uIChhY3RpdmVJZHgpIHtcclxuICAgICAgICAvL2NhbGxlZCBmcm9tIHdpdGhpbiB0aGUgJGRpZ2VzdCgpIGN5Y2xlXHJcbiAgICAgICAgdmFyIGxvY2FscyA9IHt9O1xyXG4gICAgICAgIHZhciBtb2RlbCwgaXRlbTtcclxuXHJcbiAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBpdGVtID0gc2NvcGUubWF0Y2hlc1thY3RpdmVJZHhdLm1vZGVsO1xyXG4gICAgICAgIG1vZGVsID0gcGFyc2VyUmVzdWx0Lm1vZGVsTWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XHJcbiAgICAgICAgJHNldE1vZGVsVmFsdWUob3JpZ2luYWxTY29wZSwgbW9kZWwpO1xyXG4gICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgdHJ1ZSk7XHJcblxyXG4gICAgICAgIG9uU2VsZWN0Q2FsbGJhY2sob3JpZ2luYWxTY29wZSwge1xyXG4gICAgICAgICAgJGl0ZW06IGl0ZW0sXHJcbiAgICAgICAgICAkbW9kZWw6IG1vZGVsLFxyXG4gICAgICAgICAgJGxhYmVsOiBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xyXG5cclxuICAgICAgICAvL3JldHVybiBmb2N1cyB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiBhIG1hY2ggd2FzIHNlbGVjdGVkIHZpYSBhIG1vdXNlIGNsaWNrIGV2ZW50XHJcbiAgICAgICAgZWxlbWVudFswXS5mb2N1cygpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy9iaW5kIGtleWJvYXJkIGV2ZW50czogYXJyb3dzIHVwKDM4KSAvIGRvd24oNDApLCBlbnRlcigxMykgYW5kIHRhYig5KSwgZXNjKDI3KVxyXG4gICAgICBlbGVtZW50LmJpbmQoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XHJcblxyXG4gICAgICAgIC8vdHlwZWFoZWFkIGlzIG9wZW4gYW5kIGFuIFwiaW50ZXJlc3RpbmdcIiBrZXkgd2FzIHByZXNzZWRcclxuICAgICAgICBpZiAoc2NvcGUubWF0Y2hlcy5sZW5ndGggPT09IDAgfHwgSE9UX0tFWVMuaW5kZXhPZihldnQud2hpY2gpID09PSAtMSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGlmIChldnQud2hpY2ggPT09IDQwKSB7XHJcbiAgICAgICAgICBzY29wZS5hY3RpdmVJZHggPSAoc2NvcGUuYWN0aXZlSWR4ICsgMSkgJSBzY29wZS5tYXRjaGVzLmxlbmd0aDtcclxuICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChldnQud2hpY2ggPT09IDM4KSB7XHJcbiAgICAgICAgICBzY29wZS5hY3RpdmVJZHggPSAoc2NvcGUuYWN0aXZlSWR4ID8gc2NvcGUuYWN0aXZlSWR4IDogc2NvcGUubWF0Y2hlcy5sZW5ndGgpIC0gMTtcclxuICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChldnQud2hpY2ggPT09IDEzIHx8IGV2dC53aGljaCA9PT0gOSkge1xyXG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc2NvcGUuc2VsZWN0KHNjb3BlLmFjdGl2ZUlkeCk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChldnQud2hpY2ggPT09IDI3KSB7XHJcbiAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XHJcbiAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEtlZXAgcmVmZXJlbmNlIHRvIGNsaWNrIGhhbmRsZXIgdG8gdW5iaW5kIGl0LlxyXG4gICAgICB2YXIgZGlzbWlzc0NsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBpZiAoZWxlbWVudFswXSAhPT0gZXZ0LnRhcmdldCkge1xyXG4gICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XHJcbiAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgJGRvY3VtZW50LmJpbmQoJ2NsaWNrJywgZGlzbWlzc0NsaWNrSGFuZGxlcik7XHJcblxyXG4gICAgICBvcmlnaW5hbFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICRkb2N1bWVudC51bmJpbmQoJ2NsaWNrJywgZGlzbWlzc0NsaWNrSGFuZGxlcik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZWxlbWVudC5hZnRlcigkY29tcGlsZShwb3BVcEVsKShzY29wZSkpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG59XSlcclxuXHJcbiAgLmRpcmVjdGl2ZSgndHlwZWFoZWFkUG9wdXAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXN0cmljdDonRScsXHJcbiAgICAgIHNjb3BlOntcclxuICAgICAgICBtYXRjaGVzOic9JyxcclxuICAgICAgICBxdWVyeTonPScsXHJcbiAgICAgICAgYWN0aXZlOic9JyxcclxuICAgICAgICBwb3NpdGlvbjonPScsXHJcbiAgICAgICAgc2VsZWN0OicmJ1xyXG4gICAgICB9LFxyXG4gICAgICByZXBsYWNlOnRydWUsXHJcbiAgICAgIHRlbXBsYXRlVXJsOid0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWwnLFxyXG4gICAgICBsaW5rOmZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcclxuXHJcbiAgICAgICAgc2NvcGUudGVtcGxhdGVVcmwgPSBhdHRycy50ZW1wbGF0ZVVybDtcclxuXHJcbiAgICAgICAgc2NvcGUuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHNjb3BlLm1hdGNoZXMubGVuZ3RoID4gMDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChtYXRjaElkeCkge1xyXG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmFjdGl2ZSA9PSBtYXRjaElkeDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzY29wZS5zZWxlY3RBY3RpdmUgPSBmdW5jdGlvbiAobWF0Y2hJZHgpIHtcclxuICAgICAgICAgIHNjb3BlLmFjdGl2ZSA9IG1hdGNoSWR4O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNjb3BlLnNlbGVjdE1hdGNoID0gZnVuY3Rpb24gKGFjdGl2ZUlkeCkge1xyXG4gICAgICAgICAgc2NvcGUuc2VsZWN0KHthY3RpdmVJZHg6YWN0aXZlSWR4fSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9KVxyXG5cclxuICAuZGlyZWN0aXZlKCd0eXBlYWhlYWRNYXRjaCcsIFsnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnLCAnJGNvbXBpbGUnLCAnJHBhcnNlJywgZnVuY3Rpb24gKCRodHRwLCAkdGVtcGxhdGVDYWNoZSwgJGNvbXBpbGUsICRwYXJzZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVzdHJpY3Q6J0UnLFxyXG4gICAgICBzY29wZTp7XHJcbiAgICAgICAgaW5kZXg6Jz0nLFxyXG4gICAgICAgIG1hdGNoOic9JyxcclxuICAgICAgICBxdWVyeTonPSdcclxuICAgICAgfSxcclxuICAgICAgbGluazpmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XHJcbiAgICAgICAgdmFyIHRwbFVybCA9ICRwYXJzZShhdHRycy50ZW1wbGF0ZVVybCkoc2NvcGUuJHBhcmVudCkgfHwgJ3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbCc7XHJcbiAgICAgICAgJGh0dHAuZ2V0KHRwbFVybCwge2NhY2hlOiAkdGVtcGxhdGVDYWNoZX0pLnN1Y2Nlc3MoZnVuY3Rpb24odHBsQ29udGVudCl7XHJcbiAgICAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aCgkY29tcGlsZSh0cGxDb250ZW50LnRyaW0oKSkoc2NvcGUpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XSlcclxuXHJcbiAgLmZpbHRlcigndHlwZWFoZWFkSGlnaGxpZ2h0JywgZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnZXhwKHF1ZXJ5VG9Fc2NhcGUpIHtcclxuICAgICAgcmV0dXJuIHF1ZXJ5VG9Fc2NhcGUucmVwbGFjZSgvKFsuPyorXiRbXFxdXFxcXCgpe318LV0pL2csIFwiXFxcXCQxXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihtYXRjaEl0ZW0sIHF1ZXJ5KSB7XHJcbiAgICAgIHJldHVybiBxdWVyeSA/IG1hdGNoSXRlbS5yZXBsYWNlKG5ldyBSZWdFeHAoZXNjYXBlUmVnZXhwKHF1ZXJ5KSwgJ2dpJyksICc8c3Ryb25nPiQmPC9zdHJvbmc+JykgOiBtYXRjaEl0ZW07XHJcbiAgICB9O1xyXG4gIH0pO1xyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi1ncm91cC5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcImFjY29yZGlvbi1ncm91cFxcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcImFjY29yZGlvbi1oZWFkaW5nXFxcIiA+PGEgY2xhc3M9XFxcImFjY29yZGlvbi10b2dnbGVcXFwiIG5nLWNsaWNrPVxcXCJpc09wZW4gPSAhaXNPcGVuXFxcIiBhY2NvcmRpb24tdHJhbnNjbHVkZT1cXFwiaGVhZGluZ1xcXCI+e3toZWFkaW5nfX08L2E+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcImFjY29yZGlvbi1ib2R5XFxcIiBjb2xsYXBzZT1cXFwiIWlzT3BlblxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwiYWNjb3JkaW9uLWlubmVyXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PiAgPC9kaXY+XFxuXCIgK1xyXG4gICAgXCI8L2Rpdj5cIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwiYWNjb3JkaW9uXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9J2FsZXJ0JyBuZy1jbGFzcz0ndHlwZSAmJiBcXFwiYWxlcnQtXFxcIiArIHR5cGUnPlxcblwiICtcclxuICAgIFwiICAgIDxidXR0b24gbmctc2hvdz0nY2xvc2VhYmxlJyB0eXBlPSdidXR0b24nIGNsYXNzPSdjbG9zZScgbmctY2xpY2s9J2Nsb3NlKCknPiZ0aW1lczs8L2J1dHRvbj5cXG5cIiArXHJcbiAgICBcIiAgICA8ZGl2IG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCI8L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsXHJcbiAgICBcIjxkaXYgbmctbW91c2VlbnRlcj1cXFwicGF1c2UoKVxcXCIgbmctbW91c2VsZWF2ZT1cXFwicGxheSgpXFxcIiBjbGFzcz1cXFwiY2Fyb3VzZWxcXFwiPlxcblwiICtcclxuICAgIFwiICAgIDxvbCBjbGFzcz1cXFwiY2Fyb3VzZWwtaW5kaWNhdG9yc1xcXCIgbmctc2hvdz1cXFwic2xpZGVzKCkubGVuZ3RoID4gMVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICAgIDxsaSBuZy1yZXBlYXQ9XFxcInNsaWRlIGluIHNsaWRlcygpXFxcIiBuZy1jbGFzcz1cXFwie2FjdGl2ZTogaXNBY3RpdmUoc2xpZGUpfVxcXCIgbmctY2xpY2s9XFxcInNlbGVjdChzbGlkZSlcXFwiPjwvbGk+XFxuXCIgK1xyXG4gICAgXCIgICAgPC9vbD5cXG5cIiArXHJcbiAgICBcIiAgICA8ZGl2IGNsYXNzPVxcXCJjYXJvdXNlbC1pbm5lclxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXHJcbiAgICBcIiAgICA8YSBuZy1jbGljaz1cXFwicHJldigpXFxcIiBjbGFzcz1cXFwiY2Fyb3VzZWwtY29udHJvbCBsZWZ0XFxcIiBuZy1zaG93PVxcXCJzbGlkZXMoKS5sZW5ndGggPiAxXFxcIj4mbHNhcXVvOzwvYT5cXG5cIiArXHJcbiAgICBcIiAgICA8YSBuZy1jbGljaz1cXFwibmV4dCgpXFxcIiBjbGFzcz1cXFwiY2Fyb3VzZWwtY29udHJvbCByaWdodFxcXCIgbmctc2hvdz1cXFwic2xpZGVzKCkubGVuZ3RoID4gMVxcXCI+JnJzYXF1bzs8L2E+XFxuXCIgK1xyXG4gICAgXCI8L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sXCIsXHJcbiAgICBcIjxkaXYgbmctY2xhc3M9XFxcIntcXG5cIiArXHJcbiAgICBcIiAgICAnYWN0aXZlJzogbGVhdmluZyB8fCAoYWN0aXZlICYmICFlbnRlcmluZyksXFxuXCIgK1xyXG4gICAgXCIgICAgJ3ByZXYnOiAobmV4dCB8fCBhY3RpdmUpICYmIGRpcmVjdGlvbj09J3ByZXYnLFxcblwiICtcclxuICAgIFwiICAgICduZXh0JzogKG5leHQgfHwgYWN0aXZlKSAmJiBkaXJlY3Rpb249PSduZXh0JyxcXG5cIiArXHJcbiAgICBcIiAgICAncmlnaHQnOiBkaXJlY3Rpb249PSdwcmV2JyxcXG5cIiArXHJcbiAgICBcIiAgICAnbGVmdCc6IGRpcmVjdGlvbj09J25leHQnXFxuXCIgK1xyXG4gICAgXCIgIH1cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLFxyXG4gICAgXCI8dGFibGU+XFxuXCIgK1xyXG4gICAgXCIgIDx0aGVhZD5cXG5cIiArXHJcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBwdWxsLWxlZnRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKC0xKVxcXCI+PGkgY2xhc3M9XFxcImljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0aCBjb2xzcGFuPVxcXCJ7e3Jvd3NbMF0ubGVuZ3RoIC0gMiArIHNob3dXZWVrTnVtYmVyc319XFxcIj48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tYmxvY2tcXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVNb2RlKClcXFwiPjxzdHJvbmc+e3t0aXRsZX19PC9zdHJvbmc+PC9idXR0b24+PC90aD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBwdWxsLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgxKVxcXCI+PGkgY2xhc3M9XFxcImljb24tY2hldnJvbi1yaWdodFxcXCI+PC9pPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xyXG4gICAgXCIgICAgPC90cj5cXG5cIiArXHJcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiBuZy1zaG93PVxcXCJsYWJlbHMubGVuZ3RoID4gMFxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8dGggbmctc2hvdz1cXFwic2hvd1dlZWtOdW1iZXJzXFxcIj4jPC90aD5cXG5cIiArXHJcbiAgICBcIiAgICAgIDx0aCBuZy1yZXBlYXQ9XFxcImxhYmVsIGluIGxhYmVsc1xcXCI+e3tsYWJlbH19PC90aD5cXG5cIiArXHJcbiAgICBcIiAgICA8L3RyPlxcblwiICtcclxuICAgIFwiICA8L3RoZWFkPlxcblwiICtcclxuICAgIFwiICA8dGJvZHk+XFxuXCIgK1xyXG4gICAgXCIgICAgPHRyIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3NcXFwiPlxcblwiICtcclxuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dXZWVrTnVtYmVyc1xcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj48ZW0+e3sgZ2V0V2Vla051bWJlcihyb3cpIH19PC9lbT48L3RkPlxcblwiICtcclxuICAgIFwiICAgICAgPHRkIG5nLXJlcGVhdD1cXFwiZHQgaW4gcm93XFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPlxcblwiICtcclxuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgc3R5bGU9XFxcIndpZHRoOjEwMCU7XFxcIiBjbGFzcz1cXFwiYnRuXFxcIiBuZy1jbGFzcz1cXFwieydidG4taW5mbyc6IGR0LnNlbGVjdGVkfVxcXCIgbmctY2xpY2s9XFxcInNlbGVjdChkdC5kYXRlKVxcXCIgbmctZGlzYWJsZWQ9XFxcImR0LmRpc2FibGVkXFxcIj48c3BhbiBuZy1jbGFzcz1cXFwie211dGVkOiBkdC5zZWNvbmRhcnl9XFxcIj57e2R0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcclxuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xyXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xyXG4gICAgXCI8L3RhYmxlPlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sXCIsXHJcbiAgICBcIjx1bCBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCIgbmctc3R5bGU9XFxcIntkaXNwbGF5OiAoaXNPcGVuICYmICdibG9jaycpIHx8ICdub25lJywgdG9wOiBwb3NpdGlvbi50b3ArJ3B4JywgbGVmdDogcG9zaXRpb24ubGVmdCsncHgnfVxcXCIgY2xhc3M9XFxcImRyb3Bkb3duLW1lbnVcXFwiPlxcblwiICtcclxuICAgIFwiXHQ8bGkgbmctdHJhbnNjbHVkZT48L2xpPlxcblwiICtcclxuICAgIFwiXHQ8bGkgY2xhc3M9XFxcImRpdmlkZXJcXFwiPjwvbGk+XFxuXCIgK1xyXG4gICAgXCJcdDxsaSBzdHlsZT1cXFwicGFkZGluZzogOXB4O1xcXCI+XFxuXCIgK1xyXG4gICAgXCJcdFx0PHNwYW4gY2xhc3M9XFxcImJ0bi1ncm91cFxcXCI+XFxuXCIgK1xyXG4gICAgXCJcdFx0XHQ8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXNtYWxsIGJ0bi1pbnZlcnNlXFxcIiBuZy1jbGljaz1cXFwidG9kYXkoKVxcXCI+VG9kYXk8L2J1dHRvbj5cXG5cIiArXHJcbiAgICBcIlx0XHRcdDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tc21hbGwgYnRuLWluZm9cXFwiIG5nLWNsaWNrPVxcXCJzaG93V2Vla3MgPSAhIHNob3dXZWVrc1xcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IHNob3dXZWVrc31cXFwiPldlZWtzPC9idXR0b24+XFxuXCIgK1xyXG4gICAgXCJcdFx0XHQ8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXNtYWxsIGJ0bi1kYW5nZXJcXFwiIG5nLWNsaWNrPVxcXCJjbGVhcigpXFxcIj5DbGVhcjwvYnV0dG9uPlxcblwiICtcclxuICAgIFwiXHRcdDwvc3Bhbj5cXG5cIiArXHJcbiAgICBcIlx0XHQ8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLXNtYWxsIGJ0bi1zdWNjZXNzIHB1bGwtcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJpc09wZW4gPSBmYWxzZVxcXCI+Q2xvc2U8L2J1dHRvbj5cXG5cIiArXHJcbiAgICBcIlx0PC9saT5cXG5cIiArXHJcbiAgICBcIjwvdWw+XCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwibW9kYWwtYmFja2Ryb3AgZmFkZVxcXCIgbmctY2xhc3M9XFxcIntpbjogYW5pbWF0ZX1cXFwiIG5nLXN0eWxlPVxcXCJ7J3otaW5kZXgnOiAxMDQwICsgaW5kZXgqMTB9XFxcIiBuZy1jbGljaz1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+PC9kaXY+XCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJtb2RhbCBmYWRlIHt7IHdpbmRvd0NsYXNzIH19XFxcIiBuZy1jbGFzcz1cXFwie2luOiBhbmltYXRlfVxcXCIgbmctc3R5bGU9XFxcInsnei1pbmRleCc6IDEwNTAgKyBpbmRleCoxMH1cXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3BhZ2luYXRpb24vcGFnZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdlci5odG1sXCIsXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBhZ2VyXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgPHVsPlxcblwiICtcclxuICAgIFwiICAgIDxsaSBuZy1yZXBlYXQ9XFxcInBhZ2UgaW4gcGFnZXNcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IHBhZ2UuZGlzYWJsZWQsIHByZXZpb3VzOiBwYWdlLnByZXZpb3VzLCBuZXh0OiBwYWdlLm5leHR9XFxcIj48YSBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlLm51bWJlcilcXFwiPnt7cGFnZS50ZXh0fX08L2E+PC9saT5cXG5cIiArXHJcbiAgICBcIiAgPC91bD5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwYWdpbmF0aW9uXFxcIj48dWw+XFxuXCIgK1xyXG4gICAgXCIgIDxsaSBuZy1yZXBlYXQ9XFxcInBhZ2UgaW4gcGFnZXNcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBwYWdlLmFjdGl2ZSwgZGlzYWJsZWQ6IHBhZ2UuZGlzYWJsZWR9XFxcIj48YSBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlLm51bWJlcilcXFwiPnt7cGFnZS50ZXh0fX08L2E+PC9saT5cXG5cIiArXHJcbiAgICBcIiAgPC91bD5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXVuc2FmZS1wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC11bnNhZmUtcG9wdXAuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwIHt7cGxhY2VtZW50fX1cXFwiIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSwgZmFkZTogYW5pbWF0aW9uKCkgfVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIiBuZy1iaW5kLWh0bWwtdW5zYWZlPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwIHt7cGxhY2VtZW50fX1cXFwiIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSwgZmFkZTogYW5pbWF0aW9uKCkgfVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcclxuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIiBuZy1iaW5kPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyIHt7cGxhY2VtZW50fX1cXFwiIG5nLWNsYXNzPVxcXCJ7IGluOiBpc09wZW4oKSwgZmFkZTogYW5pbWF0aW9uKCkgfVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcImFycm93XFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIlxcblwiICtcclxuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWlubmVyXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgIDxoMyBjbGFzcz1cXFwicG9wb3Zlci10aXRsZVxcXCIgbmctYmluZD1cXFwidGl0bGVcXFwiIG5nLXNob3c9XFxcInRpdGxlXFxcIj48L2gzPlxcblwiICtcclxuICAgIFwiICAgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1jb250ZW50XFxcIiBuZy1iaW5kPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIiAgPC9kaXY+XFxuXCIgK1xyXG4gICAgXCI8L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwiYmFyXFxcIiBuZy1jbGFzcz0ndHlwZSAmJiBcXFwiYmFyLVxcXCIgKyB0eXBlJz48L2Rpdj5cIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzc1xcXCI+PHByb2dyZXNzYmFyIG5nLXJlcGVhdD1cXFwiYmFyIGluIGJhcnNcXFwiIHdpZHRoPVxcXCJiYXIudG9cXFwiIG9sZD1cXFwiYmFyLmZyb21cXFwiIGFuaW1hdGU9XFxcImJhci5hbmltYXRlXFxcIiB0eXBlPVxcXCJiYXIudHlwZVxcXCI+PC9wcm9ncmVzc2Jhcj48L2Rpdj5cIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9yYXRpbmcvcmF0aW5nLmh0bWxcIixcclxuICAgIFwiPHNwYW4gbmctbW91c2VsZWF2ZT1cXFwicmVzZXQoKVxcXCI+XFxuXCIgK1xyXG4gICAgXCJcdDxpIG5nLXJlcGVhdD1cXFwiciBpbiByYW5nZVxcXCIgbmctbW91c2VlbnRlcj1cXFwiZW50ZXIoJGluZGV4ICsgMSlcXFwiIG5nLWNsaWNrPVxcXCJyYXRlKCRpbmRleCArIDEpXFxcIiBuZy1jbGFzcz1cXFwiJGluZGV4IDwgdmFsICYmIChyLnN0YXRlT24gfHwgJ2ljb24tc3RhcicpIHx8IChyLnN0YXRlT2ZmIHx8ICdpY29uLXN0YXItZW1wdHknKVxcXCI+PC9pPlxcblwiICtcclxuICAgIFwiPC9zcGFuPlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90YWJzL3BhbmUuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdGFicy9wYW5lLmh0bWxcIixcclxuICAgIFwiPGRpdiBjbGFzcz1cXFwidGFiLXBhbmVcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBzZWxlY3RlZH1cXFwiIG5nLXNob3c9XFxcInNlbGVjdGVkXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3RhYnMvdGFiLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3RhYnMvdGFiLmh0bWxcIixcclxuICAgIFwiPGxpIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiBhY3RpdmUsIGRpc2FibGVkOiBkaXNhYmxlZH1cXFwiPlxcblwiICtcclxuICAgIFwiICA8YSBuZy1jbGljaz1cXFwic2VsZWN0KClcXFwiIHRhYi1oZWFkaW5nLXRyYW5zY2x1ZGU+e3toZWFkaW5nfX08L2E+XFxuXCIgK1xyXG4gICAgXCI8L2xpPlxcblwiICtcclxuICAgIFwiXCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3RhYnMvdGFicy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90YWJzL3RhYnMuaHRtbFwiLFxyXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0YWJiYWJsZVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDx1bCBjbGFzcz1cXFwibmF2IG5hdi10YWJzXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICA8bGkgbmctcmVwZWF0PVxcXCJwYW5lIGluIHBhbmVzXFxcIiBuZy1jbGFzcz1cXFwie2FjdGl2ZTpwYW5lLnNlbGVjdGVkfVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICA8YSBuZy1jbGljaz1cXFwic2VsZWN0KHBhbmUpXFxcIj57e3BhbmUuaGVhZGluZ319PC9hPlxcblwiICtcclxuICAgIFwiICAgIDwvbGk+XFxuXCIgK1xyXG4gICAgXCIgIDwvdWw+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcclxuICAgIFwiPC9kaXY+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdGFicy90YWJzZXQtdGl0bGVzLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3RhYnMvdGFic2V0LXRpdGxlcy5odG1sXCIsXHJcbiAgICBcIjx1bCBjbGFzcz1cXFwibmF2IHt7dHlwZSAmJiAnbmF2LScgKyB0eXBlfX1cXFwiIG5nLWNsYXNzPVxcXCJ7J25hdi1zdGFja2VkJzogdmVydGljYWx9XFxcIj5cXG5cIiArXHJcbiAgICBcIjwvdWw+XFxuXCIgK1xyXG4gICAgXCJcIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLFxyXG4gICAgXCJcXG5cIiArXHJcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRhYmJhYmxlXFxcIiBuZy1jbGFzcz1cXFwieyd0YWJzLXJpZ2h0JzogZGlyZWN0aW9uID09ICdyaWdodCcsICd0YWJzLWxlZnQnOiBkaXJlY3Rpb24gPT0gJ2xlZnQnLCAndGFicy1iZWxvdyc6IGRpcmVjdGlvbiA9PSAnYmVsb3cnfVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgdGFic2V0LXRpdGxlcz1cXFwidGFic0Fib3ZlXFxcIj48L2Rpdj5cXG5cIiArXHJcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidGFiLWNvbnRlbnRcXFwiPlxcblwiICtcclxuICAgIFwiICAgIDxkaXYgY2xhc3M9XFxcInRhYi1wYW5lXFxcIiBcXG5cIiArXHJcbiAgICBcIiAgICAgICAgIG5nLXJlcGVhdD1cXFwidGFiIGluIHRhYnNcXFwiIFxcblwiICtcclxuICAgIFwiICAgICAgICAgbmctY2xhc3M9XFxcInthY3RpdmU6IHRhYi5hY3RpdmV9XFxcIlxcblwiICtcclxuICAgIFwiICAgICAgICAgdGFiLWNvbnRlbnQtdHJhbnNjbHVkZT1cXFwidGFiXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICA8L2Rpdj5cXG5cIiArXHJcbiAgICBcIiAgPC9kaXY+XFxuXCIgK1xyXG4gICAgXCIgIDxkaXYgdGFic2V0LXRpdGxlcz1cXFwiIXRhYnNBYm92ZVxcXCI+PC9kaXY+XFxuXCIgK1xyXG4gICAgXCI8L2Rpdj5cXG5cIiArXHJcbiAgICBcIlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcIixcclxuICAgIFwiPHRhYmxlIGNsYXNzPVxcXCJmb3JtLWlubGluZVxcXCI+XFxuXCIgK1xyXG4gICAgXCJcdDx0ciBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPlxcblwiICtcclxuICAgIFwiXHRcdDx0ZD48YSBuZy1jbGljaz1cXFwiaW5jcmVtZW50SG91cnMoKVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCI+PGkgY2xhc3M9XFxcImljb24tY2hldnJvbi11cFxcXCI+PC9pPjwvYT48L3RkPlxcblwiICtcclxuICAgIFwiXHRcdDx0ZD4mbmJzcDs8L3RkPlxcblwiICtcclxuICAgIFwiXHRcdDx0ZD48YSBuZy1jbGljaz1cXFwiaW5jcmVtZW50TWludXRlcygpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIj48aSBjbGFzcz1cXFwiaWNvbi1jaGV2cm9uLXVwXFxcIj48L2k+PC9hPjwvdGQ+XFxuXCIgK1xyXG4gICAgXCJcdFx0PHRkIG5nLXNob3c9XFxcInNob3dNZXJpZGlhblxcXCI+PC90ZD5cXG5cIiArXHJcbiAgICBcIlx0PC90cj5cXG5cIiArXHJcbiAgICBcIlx0PHRyPlxcblwiICtcclxuICAgIFwiXHRcdDx0ZCBjbGFzcz1cXFwiY29udHJvbC1ncm91cFxcXCIgbmctY2xhc3M9XFxcInsnZXJyb3InOiBpbnZhbGlkSG91cnN9XFxcIj48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcImhvdXJzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZUhvdXJzKClcXFwiIGNsYXNzPVxcXCJzcGFuMSB0ZXh0LWNlbnRlclxcXCIgbmctbW91c2V3aGVlbD1cXFwiaW5jcmVtZW50SG91cnMoKVxcXCIgbmctcmVhZG9ubHk9XFxcInJlYWRvbmx5SW5wdXRcXFwiIG1heGxlbmd0aD1cXFwiMlxcXCIgLz48L3RkPlxcblwiICtcclxuICAgIFwiXHRcdDx0ZD46PC90ZD5cXG5cIiArXHJcbiAgICBcIlx0XHQ8dGQgY2xhc3M9XFxcImNvbnRyb2wtZ3JvdXBcXFwiIG5nLWNsYXNzPVxcXCJ7J2Vycm9yJzogaW52YWxpZE1pbnV0ZXN9XFxcIj48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcIm1pbnV0ZXNcXFwiIG5nLWNoYW5nZT1cXFwidXBkYXRlTWludXRlcygpXFxcIiBjbGFzcz1cXFwic3BhbjEgdGV4dC1jZW50ZXJcXFwiIG5nLXJlYWRvbmx5PVxcXCJyZWFkb25seUlucHV0XFxcIiBtYXhsZW5ndGg9XFxcIjJcXFwiPjwvdGQ+XFxuXCIgK1xyXG4gICAgXCJcdFx0PHRkIG5nLXNob3c9XFxcInNob3dNZXJpZGlhblxcXCI+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVNZXJpZGlhbigpXFxcIiBjbGFzcz1cXFwiYnRuIHRleHQtY2VudGVyXFxcIj57e21lcmlkaWFufX08L2J1dHRvbj48L3RkPlxcblwiICtcclxuICAgIFwiXHQ8L3RyPlxcblwiICtcclxuICAgIFwiXHQ8dHIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj5cXG5cIiArXHJcbiAgICBcIlx0XHQ8dGQ+PGEgbmctY2xpY2s9XFxcImRlY3JlbWVudEhvdXJzKClcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPjxpIGNsYXNzPVxcXCJpY29uLWNoZXZyb24tZG93blxcXCI+PC9pPjwvYT48L3RkPlxcblwiICtcclxuICAgIFwiXHRcdDx0ZD4mbmJzcDs8L3RkPlxcblwiICtcclxuICAgIFwiXHRcdDx0ZD48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50TWludXRlcygpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIj48aSBjbGFzcz1cXFwiaWNvbi1jaGV2cm9uLWRvd25cXFwiPjwvaT48L2E+PC90ZD5cXG5cIiArXHJcbiAgICBcIlx0XHQ8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIj48L3RkPlxcblwiICtcclxuICAgIFwiXHQ8L3RyPlxcblwiICtcclxuICAgIFwiPC90YWJsZT5cIik7XHJcbn1dKTtcclxuXHJcbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcIixcclxuICAgIFwiPGEgdGFiaW5kZXg9XFxcIi0xXFxcIiBiaW5kLWh0bWwtdW5zYWZlPVxcXCJtYXRjaC5sYWJlbCB8IHR5cGVhaGVhZEhpZ2hsaWdodDpxdWVyeVxcXCI+PC9hPlwiKTtcclxufV0pO1xyXG5cclxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xyXG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiLFxyXG4gICAgXCI8dWwgY2xhc3M9XFxcInR5cGVhaGVhZCBkcm9wZG93bi1tZW51XFxcIiBuZy1zdHlsZT1cXFwie2Rpc3BsYXk6IGlzT3BlbigpJiYnYmxvY2snIHx8ICdub25lJywgdG9wOiBwb3NpdGlvbi50b3ArJ3B4JywgbGVmdDogcG9zaXRpb24ubGVmdCsncHgnfVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgPGxpIG5nLXJlcGVhdD1cXFwibWF0Y2ggaW4gbWF0Y2hlc1xcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IGlzQWN0aXZlKCRpbmRleCkgfVxcXCIgbmctbW91c2VlbnRlcj1cXFwic2VsZWN0QWN0aXZlKCRpbmRleClcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3RNYXRjaCgkaW5kZXgpXFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICAgICAgPHR5cGVhaGVhZC1tYXRjaCBpbmRleD1cXFwiJGluZGV4XFxcIiBtYXRjaD1cXFwibWF0Y2hcXFwiIHF1ZXJ5PVxcXCJxdWVyeVxcXCIgdGVtcGxhdGUtdXJsPVxcXCJ0ZW1wbGF0ZVVybFxcXCI+PC90eXBlYWhlYWQtbWF0Y2g+XFxuXCIgK1xyXG4gICAgXCIgICAgPC9saT5cXG5cIiArXHJcbiAgICBcIjwvdWw+XCIpO1xyXG59XSk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC5odG1sXCIsXHJcbiAgICBcIjx1bCBjbGFzcz1cXFwidHlwZWFoZWFkIGRyb3Bkb3duLW1lbnVcXFwiIG5nLXN0eWxlPVxcXCJ7ZGlzcGxheTogaXNPcGVuKCkmJidibG9jaycgfHwgJ25vbmUnLCB0b3A6IHBvc2l0aW9uLnRvcCsncHgnLCBsZWZ0OiBwb3NpdGlvbi5sZWZ0KydweCd9XFxcIj5cXG5cIiArXHJcbiAgICBcIiAgICA8bGkgbmctcmVwZWF0PVxcXCJtYXRjaCBpbiBtYXRjaGVzXFxcIiBuZy1jbGFzcz1cXFwie2FjdGl2ZTogaXNBY3RpdmUoJGluZGV4KSB9XFxcIiBuZy1tb3VzZWVudGVyPVxcXCJzZWxlY3RBY3RpdmUoJGluZGV4KVxcXCI+XFxuXCIgK1xyXG4gICAgXCIgICAgICAgIDxhIHRhYmluZGV4PVxcXCItMVxcXCIgbmctY2xpY2s9XFxcInNlbGVjdE1hdGNoKCRpbmRleClcXFwiIG5nLWJpbmQtaHRtbC11bnNhZmU9XFxcIm1hdGNoLmxhYmVsIHwgdHlwZWFoZWFkSGlnaGxpZ2h0OnF1ZXJ5XFxcIj48L2E+XFxuXCIgK1xyXG4gICAgXCIgICAgPC9saT5cXG5cIiArXHJcbiAgICBcIjwvdWw+XCIpO1xyXG59XSk7IiwiLyoqXHJcbiAqIFN0YXRlLWJhc2VkIHJvdXRpbmcgZm9yIEFuZ3VsYXJKU1xyXG4gKiBAdmVyc2lvbiB2MC4yLjBcclxuICogQGxpbmsgaHR0cDovL2FuZ3VsYXItdWkuZ2l0aHViLmNvbS9cclxuICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UsIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbiAqL1xyXG4oZnVuY3Rpb24gKHdpbmRvdywgYW5ndWxhciwgdW5kZWZpbmVkKSB7XHJcbi8qanNoaW50IGdsb2JhbHN0cmljdDp0cnVlKi9cclxuLypnbG9iYWwgYW5ndWxhcjpmYWxzZSovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpc0RlZmluZWQgPSBhbmd1bGFyLmlzRGVmaW5lZCxcclxuICAgIGlzRnVuY3Rpb24gPSBhbmd1bGFyLmlzRnVuY3Rpb24sXHJcbiAgICBpc1N0cmluZyA9IGFuZ3VsYXIuaXNTdHJpbmcsXHJcbiAgICBpc09iamVjdCA9IGFuZ3VsYXIuaXNPYmplY3QsXHJcbiAgICBpc0FycmF5ID0gYW5ndWxhci5pc0FycmF5LFxyXG4gICAgZm9yRWFjaCA9IGFuZ3VsYXIuZm9yRWFjaCxcclxuICAgIGV4dGVuZCA9IGFuZ3VsYXIuZXh0ZW5kLFxyXG4gICAgY29weSA9IGFuZ3VsYXIuY29weTtcclxuXHJcbmZ1bmN0aW9uIGluaGVyaXQocGFyZW50LCBleHRyYSkge1xyXG4gIHJldHVybiBleHRlbmQobmV3IChleHRlbmQoZnVuY3Rpb24oKSB7fSwgeyBwcm90b3R5cGU6IHBhcmVudCB9KSkoKSwgZXh0cmEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZShkc3QpIHtcclxuICBmb3JFYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAob2JqICE9PSBkc3QpIHtcclxuICAgICAgZm9yRWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICBpZiAoIWRzdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBkc3Rba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gZHN0O1xyXG59XHJcblxyXG4vKipcclxuICogRmluZHMgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIGJldHdlZW4gdHdvIHN0YXRlcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGZpcnN0IFRoZSBmaXJzdCBzdGF0ZS5cclxuICogQHBhcmFtIHtPYmplY3R9IHNlY29uZCBUaGUgc2Vjb25kIHN0YXRlLlxyXG4gKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZSBuYW1lcyBpbiBkZXNjZW5kaW5nIG9yZGVyLCBub3QgaW5jbHVkaW5nIHRoZSByb290LlxyXG4gKi9cclxuZnVuY3Rpb24gYW5jZXN0b3JzKGZpcnN0LCBzZWNvbmQpIHtcclxuICB2YXIgcGF0aCA9IFtdO1xyXG5cclxuICBmb3IgKHZhciBuIGluIGZpcnN0LnBhdGgpIHtcclxuICAgIGlmIChmaXJzdC5wYXRoW25dID09PSBcIlwiKSBjb250aW51ZTtcclxuICAgIGlmICghc2Vjb25kLnBhdGhbbl0pIGJyZWFrO1xyXG4gICAgcGF0aC5wdXNoKGZpcnN0LnBhdGhbbl0pO1xyXG4gIH1cclxuICByZXR1cm4gcGF0aDtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyBhIHNldCBvZiBwYXJhbWV0ZXJzIHdpdGggYWxsIHBhcmFtZXRlcnMgaW5oZXJpdGVkIGJldHdlZW4gdGhlIGNvbW1vbiBwYXJlbnRzIG9mIHRoZVxyXG4gKiBjdXJyZW50IHN0YXRlIGFuZCBhIGdpdmVuIGRlc3RpbmF0aW9uIHN0YXRlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFBhcmFtcyBUaGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgcGFyYW1ldGVycyAoJHN0YXRlUGFyYW1zKS5cclxuICogQHBhcmFtIHtPYmplY3R9IG5ld1BhcmFtcyBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgd2hpY2ggd2lsbCBiZSBjb21wb3NpdGVkIHdpdGggaW5oZXJpdGVkIHBhcmFtcy5cclxuICogQHBhcmFtIHtPYmplY3R9ICRjdXJyZW50IEludGVybmFsIGRlZmluaXRpb24gb2Ygb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZS5cclxuICogQHBhcmFtIHtPYmplY3R9ICR0byBJbnRlcm5hbCBkZWZpbml0aW9uIG9mIG9iamVjdCByZXByZXNlbnRpbmcgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by5cclxuICovXHJcbmZ1bmN0aW9uIGluaGVyaXRQYXJhbXMoY3VycmVudFBhcmFtcywgbmV3UGFyYW1zLCAkY3VycmVudCwgJHRvKSB7XHJcbiAgdmFyIHBhcmVudHMgPSBhbmNlc3RvcnMoJGN1cnJlbnQsICR0byksIHBhcmVudFBhcmFtcywgaW5oZXJpdGVkID0ge30sIGluaGVyaXRMaXN0ID0gW107XHJcblxyXG4gIGZvciAodmFyIGkgaW4gcGFyZW50cykge1xyXG4gICAgaWYgKCFwYXJlbnRzW2ldLnBhcmFtcyB8fCAhcGFyZW50c1tpXS5wYXJhbXMubGVuZ3RoKSBjb250aW51ZTtcclxuICAgIHBhcmVudFBhcmFtcyA9IHBhcmVudHNbaV0ucGFyYW1zO1xyXG5cclxuICAgIGZvciAodmFyIGogaW4gcGFyZW50UGFyYW1zKSB7XHJcbiAgICAgIGlmIChpbmhlcml0TGlzdC5pbmRleE9mKHBhcmVudFBhcmFtc1tqXSkgPj0gMCkgY29udGludWU7XHJcbiAgICAgIGluaGVyaXRMaXN0LnB1c2gocGFyZW50UGFyYW1zW2pdKTtcclxuICAgICAgaW5oZXJpdGVkW3BhcmVudFBhcmFtc1tqXV0gPSBjdXJyZW50UGFyYW1zW3BhcmVudFBhcmFtc1tqXV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBleHRlbmQoe30sIGluaGVyaXRlZCwgbmV3UGFyYW1zKTtcclxufVxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci51dGlsJywgWyduZyddKTtcclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5yb3V0ZXInLCBbJ3VpLnJvdXRlci51dGlsJ10pO1xyXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJywgWyd1aS5yb3V0ZXIucm91dGVyJywgJ3VpLnJvdXRlci51dGlsJ10pO1xyXG5hbmd1bGFyLm1vZHVsZSgndWkucm91dGVyJywgWyd1aS5yb3V0ZXIuc3RhdGUnXSk7XHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuY29tcGF0JywgWyd1aS5yb3V0ZXInXSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIFNlcnZpY2UgKGB1aS11dGlsYCkuIE1hbmFnZXMgcmVzb2x1dGlvbiBvZiAoYWN5Y2xpYykgZ3JhcGhzIG9mIHByb21pc2VzLlxyXG4gKiBAbW9kdWxlICRyZXNvbHZlXHJcbiAqIEByZXF1aXJlcyAkcVxyXG4gKiBAcmVxdWlyZXMgJGluamVjdG9yXHJcbiAqL1xyXG4kUmVzb2x2ZS4kaW5qZWN0ID0gWyckcScsICckaW5qZWN0b3InXTtcclxuZnVuY3Rpb24gJFJlc29sdmUoICAkcSwgICAgJGluamVjdG9yKSB7XHJcbiAgXHJcbiAgdmFyIFZJU0lUX0lOX1BST0dSRVNTID0gMSxcclxuICAgICAgVklTSVRfRE9ORSA9IDIsXHJcbiAgICAgIE5PVEhJTkcgPSB7fSxcclxuICAgICAgTk9fREVQRU5ERU5DSUVTID0gW10sXHJcbiAgICAgIE5PX0xPQ0FMUyA9IE5PVEhJTkcsXHJcbiAgICAgIE5PX1BBUkVOVCA9IGV4dGVuZCgkcS53aGVuKE5PVEhJTkcpLCB7ICQkcHJvbWlzZXM6IE5PVEhJTkcsICQkdmFsdWVzOiBOT1RISU5HIH0pO1xyXG4gIFxyXG5cclxuICAvKipcclxuICAgKiBTdHVkaWVzIGEgc2V0IG9mIGludm9jYWJsZXMgdGhhdCBhcmUgbGlrZWx5IHRvIGJlIHVzZWQgbXVsdGlwbGUgdGltZXMuXHJcbiAgICogICAgICAkcmVzb2x2ZS5zdHVkeShpbnZvY2FibGVzKShsb2NhbHMsIHBhcmVudCwgc2VsZilcclxuICAgKiBpcyBlcXVpdmFsZW50IHRvXHJcbiAgICogICAgICAkcmVzb2x2ZS5yZXNvbHZlKGludm9jYWJsZXMsIGxvY2FscywgcGFyZW50LCBzZWxmKVxyXG4gICAqIGJ1dCB0aGUgZm9ybWVyIGlzIG1vcmUgZWZmaWNpZW50IChpbiBmYWN0IGByZXNvbHZlYCBqdXN0IGNhbGxzIGBzdHVkeWAgaW50ZXJuYWxseSkuXHJcbiAgICogU2VlIHtAbGluayBtb2R1bGU6JHJlc29sdmUvcmVzb2x2ZX0gZm9yIGRldGFpbHMuXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGludm9jYWJsZXNcclxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cclxuICAgKi9cclxuICB0aGlzLnN0dWR5ID0gZnVuY3Rpb24gKGludm9jYWJsZXMpIHtcclxuICAgIGlmICghaXNPYmplY3QoaW52b2NhYmxlcykpIHRocm93IG5ldyBFcnJvcihcIidpbnZvY2FibGVzJyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcclxuICAgIFxyXG4gICAgLy8gUGVyZm9ybSBhIHRvcG9sb2dpY2FsIHNvcnQgb2YgaW52b2NhYmxlcyB0byBidWlsZCBhbiBvcmRlcmVkIHBsYW5cclxuICAgIHZhciBwbGFuID0gW10sIGN5Y2xlID0gW10sIHZpc2l0ZWQgPSB7fTtcclxuICAgIGZ1bmN0aW9uIHZpc2l0KHZhbHVlLCBrZXkpIHtcclxuICAgICAgaWYgKHZpc2l0ZWRba2V5XSA9PT0gVklTSVRfRE9ORSkgcmV0dXJuO1xyXG4gICAgICBcclxuICAgICAgY3ljbGUucHVzaChrZXkpO1xyXG4gICAgICBpZiAodmlzaXRlZFtrZXldID09PSBWSVNJVF9JTl9QUk9HUkVTUykge1xyXG4gICAgICAgIGN5Y2xlLnNwbGljZSgwLCBjeWNsZS5pbmRleE9mKGtleSkpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5OiBcIiArIGN5Y2xlLmpvaW4oXCIgLT4gXCIpKTtcclxuICAgICAgfVxyXG4gICAgICB2aXNpdGVkW2tleV0gPSBWSVNJVF9JTl9QUk9HUkVTUztcclxuICAgICAgXHJcbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICBwbGFuLnB1c2goa2V5LCBbIGZ1bmN0aW9uKCkgeyByZXR1cm4gJGluamVjdG9yLmdldChrZXkpOyB9XSwgTk9fREVQRU5ERU5DSUVTKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0gJGluamVjdG9yLmFubm90YXRlKHZhbHVlKTtcclxuICAgICAgICBmb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICBpZiAocGFyYW0gIT09IGtleSAmJiBpbnZvY2FibGVzLmhhc093blByb3BlcnR5KHBhcmFtKSkgdmlzaXQoaW52b2NhYmxlc1twYXJhbV0sIHBhcmFtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwbGFuLnB1c2goa2V5LCB2YWx1ZSwgcGFyYW1zKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY3ljbGUucG9wKCk7XHJcbiAgICAgIHZpc2l0ZWRba2V5XSA9IFZJU0lUX0RPTkU7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoKGludm9jYWJsZXMsIHZpc2l0KTtcclxuICAgIGludm9jYWJsZXMgPSBjeWNsZSA9IHZpc2l0ZWQgPSBudWxsOyAvLyBwbGFuIGlzIGFsbCB0aGF0J3MgcmVxdWlyZWRcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaXNSZXNvbHZlKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUudGhlbiAmJiB2YWx1ZS4kJHByb21pc2VzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxvY2FscywgcGFyZW50LCBzZWxmKSB7XHJcbiAgICAgIGlmIChpc1Jlc29sdmUobG9jYWxzKSAmJiBzZWxmID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBzZWxmID0gcGFyZW50OyBwYXJlbnQgPSBsb2NhbHM7IGxvY2FscyA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFsb2NhbHMpIGxvY2FscyA9IE5PX0xPQ0FMUztcclxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KGxvY2FscykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInbG9jYWxzJyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcclxuICAgICAgfSAgICAgICBcclxuICAgICAgaWYgKCFwYXJlbnQpIHBhcmVudCA9IE5PX1BBUkVOVDtcclxuICAgICAgZWxzZSBpZiAoIWlzUmVzb2x2ZShwYXJlbnQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3BhcmVudCcgbXVzdCBiZSBhIHByb21pc2UgcmV0dXJuZWQgYnkgJHJlc29sdmUucmVzb2x2ZSgpXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBUbyBjb21wbGV0ZSB0aGUgb3ZlcmFsbCByZXNvbHV0aW9uLCB3ZSBoYXZlIHRvIHdhaXQgZm9yIHRoZSBwYXJlbnRcclxuICAgICAgLy8gcHJvbWlzZSBhbmQgZm9yIHRoZSBwcm9taXNlIGZvciBlYWNoIGludm9rYWJsZSBpbiBvdXIgcGxhbi5cclxuICAgICAgdmFyIHJlc29sdXRpb24gPSAkcS5kZWZlcigpLFxyXG4gICAgICAgICAgcmVzdWx0ID0gcmVzb2x1dGlvbi5wcm9taXNlLFxyXG4gICAgICAgICAgcHJvbWlzZXMgPSByZXN1bHQuJCRwcm9taXNlcyA9IHt9LFxyXG4gICAgICAgICAgdmFsdWVzID0gZXh0ZW5kKHt9LCBsb2NhbHMpLFxyXG4gICAgICAgICAgd2FpdCA9IDEgKyBwbGFuLmxlbmd0aC8zLFxyXG4gICAgICAgICAgbWVyZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICBcclxuICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcclxuICAgICAgICAvLyBNZXJnZSBwYXJlbnQgdmFsdWVzIHdlIGhhdmVuJ3QgZ290IHlldCBhbmQgcHVibGlzaCBvdXIgb3duICQkdmFsdWVzXHJcbiAgICAgICAgaWYgKCEtLXdhaXQpIHtcclxuICAgICAgICAgIGlmICghbWVyZ2VkKSBtZXJnZSh2YWx1ZXMsIHBhcmVudC4kJHZhbHVlcyk7IFxyXG4gICAgICAgICAgcmVzdWx0LiQkdmFsdWVzID0gdmFsdWVzO1xyXG4gICAgICAgICAgcmVzdWx0LiQkcHJvbWlzZXMgPSB0cnVlOyAvLyBrZWVwIGZvciBpc1Jlc29sdmUoKVxyXG4gICAgICAgICAgcmVzb2x1dGlvbi5yZXNvbHZlKHZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBmdW5jdGlvbiBmYWlsKHJlYXNvbikge1xyXG4gICAgICAgIHJlc3VsdC4kJGZhaWx1cmUgPSByZWFzb247XHJcbiAgICAgICAgcmVzb2x1dGlvbi5yZWplY3QocmVhc29uKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gU2hvcnQtY2lyY3VpdCBpZiBwYXJlbnQgaGFzIGFscmVhZHkgZmFpbGVkXHJcbiAgICAgIGlmIChpc0RlZmluZWQocGFyZW50LiQkZmFpbHVyZSkpIHtcclxuICAgICAgICBmYWlsKHBhcmVudC4kJGZhaWx1cmUpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIE1lcmdlIHBhcmVudCB2YWx1ZXMgaWYgdGhlIHBhcmVudCBoYXMgYWxyZWFkeSByZXNvbHZlZCwgb3IgbWVyZ2VcclxuICAgICAgLy8gcGFyZW50IHByb21pc2VzIGFuZCB3YWl0IGlmIHRoZSBwYXJlbnQgcmVzb2x2ZSBpcyBzdGlsbCBpbiBwcm9ncmVzcy5cclxuICAgICAgaWYgKHBhcmVudC4kJHZhbHVlcykge1xyXG4gICAgICAgIG1lcmdlZCA9IG1lcmdlKHZhbHVlcywgcGFyZW50LiQkdmFsdWVzKTtcclxuICAgICAgICBkb25lKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZXh0ZW5kKHByb21pc2VzLCBwYXJlbnQuJCRwcm9taXNlcyk7XHJcbiAgICAgICAgcGFyZW50LnRoZW4oZG9uZSwgZmFpbCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBpbnZvY2FibGUgaW4gdGhlIHBsYW4sIGJ1dCBpZ25vcmUgYW55IHdoZXJlIGEgbG9jYWwgb2YgdGhlIHNhbWUgbmFtZSBleGlzdHMuXHJcbiAgICAgIGZvciAodmFyIGk9MCwgaWk9cGxhbi5sZW5ndGg7IGk8aWk7IGkrPTMpIHtcclxuICAgICAgICBpZiAobG9jYWxzLmhhc093blByb3BlcnR5KHBsYW5baV0pKSBkb25lKCk7XHJcbiAgICAgICAgZWxzZSBpbnZva2UocGxhbltpXSwgcGxhbltpKzFdLCBwbGFuW2krMl0pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBmdW5jdGlvbiBpbnZva2Uoa2V5LCBpbnZvY2FibGUsIHBhcmFtcykge1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmVycmVkIGZvciB0aGlzIGludm9jYXRpb24uIEZhaWx1cmVzIHdpbGwgcHJvcGFnYXRlIHRvIHRoZSByZXNvbHV0aW9uIGFzIHdlbGwuXHJcbiAgICAgICAgdmFyIGludm9jYXRpb24gPSAkcS5kZWZlcigpLCB3YWl0UGFyYW1zID0gMDtcclxuICAgICAgICBmdW5jdGlvbiBvbmZhaWx1cmUocmVhc29uKSB7XHJcbiAgICAgICAgICBpbnZvY2F0aW9uLnJlamVjdChyZWFzb24pO1xyXG4gICAgICAgICAgZmFpbChyZWFzb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXYWl0IGZvciBhbnkgcGFyYW1ldGVyIHRoYXQgd2UgaGF2ZSBhIHByb21pc2UgZm9yIChlaXRoZXIgZnJvbSBwYXJlbnQgb3IgZnJvbSB0aGlzXHJcbiAgICAgICAgLy8gcmVzb2x2ZTsgaW4gdGhhdCBjYXNlIHN0dWR5KCkgd2lsbCBoYXZlIG1hZGUgc3VyZSBpdCdzIG9yZGVyZWQgYmVmb3JlIHVzIGluIHRoZSBwbGFuKS5cclxuICAgICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XHJcbiAgICAgICAgICBpZiAocHJvbWlzZXMuaGFzT3duUHJvcGVydHkoZGVwKSAmJiAhbG9jYWxzLmhhc093blByb3BlcnR5KGRlcCkpIHtcclxuICAgICAgICAgICAgd2FpdFBhcmFtcysrO1xyXG4gICAgICAgICAgICBwcm9taXNlc1tkZXBdLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgIHZhbHVlc1tkZXBdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgIGlmICghKC0td2FpdFBhcmFtcykpIHByb2NlZWQoKTtcclxuICAgICAgICAgICAgfSwgb25mYWlsdXJlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXdhaXRQYXJhbXMpIHByb2NlZWQoKTtcclxuICAgICAgICBmdW5jdGlvbiBwcm9jZWVkKCkge1xyXG4gICAgICAgICAgaWYgKGlzRGVmaW5lZChyZXN1bHQuJCRmYWlsdXJlKSkgcmV0dXJuO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaW52b2NhdGlvbi5yZXNvbHZlKCRpbmplY3Rvci5pbnZva2UoaW52b2NhYmxlLCBzZWxmLCB2YWx1ZXMpKTtcclxuICAgICAgICAgICAgaW52b2NhdGlvbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgIHZhbHVlc1trZXldID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICAgICAgfSwgb25mYWlsdXJlKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgb25mYWlsdXJlKGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQdWJsaXNoIHByb21pc2Ugc3luY2hyb25vdXNseTsgaW52b2NhdGlvbnMgZnVydGhlciBkb3duIGluIHRoZSBwbGFuIG1heSBkZXBlbmQgb24gaXQuXHJcbiAgICAgICAgcHJvbWlzZXNba2V5XSA9IGludm9jYXRpb24ucHJvbWlzZTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgfTtcclxuICBcclxuICAvKipcclxuICAgKiBSZXNvbHZlcyBhIHNldCBvZiBpbnZvY2FibGVzLiBBbiBpbnZvY2FibGUgaXMgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHZpYSBgJGluamVjdG9yLmludm9rZSgpYCxcclxuICAgKiBhbmQgY2FuIGhhdmUgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBkZXBlbmRlbmNpZXMuIEFuIGludm9jYWJsZSBjYW4gZWl0aGVyIHJldHVybiBhIHZhbHVlIGRpcmVjdGx5LFxyXG4gICAqIG9yIGEgYCRxYCBwcm9taXNlLiBJZiBhIHByb21pc2UgaXMgcmV0dXJuZWQgaXQgd2lsbCBiZSByZXNvbHZlZCBhbmQgdGhlIHJlc3VsdGluZyB2YWx1ZSB3aWxsIGJlXHJcbiAgICogdXNlZCBpbnN0ZWFkLiBEZXBlbmRlbmNpZXMgb2YgaW52b2NhYmxlcyBhcmUgcmVzb2x2ZWQgKGluIHRoaXMgb3JkZXIgb2YgcHJlY2VkZW5jZSlcclxuICAgKlxyXG4gICAqIC0gZnJvbSB0aGUgc3BlY2lmaWVkIGBsb2NhbHNgXHJcbiAgICogLSBmcm9tIGFub3RoZXIgaW52b2NhYmxlIHRoYXQgaXMgcGFydCBvZiB0aGlzIGAkcmVzb2x2ZWAgY2FsbFxyXG4gICAqIC0gZnJvbSBhbiBpbnZvY2FibGUgdGhhdCBpcyBpbmhlcml0ZWQgZnJvbSBhIGBwYXJlbnRgIGNhbGwgdG8gYCRyZXNvbHZlYCAob3IgcmVjdXJzaXZlbHlcclxuICAgKiAgIGZyb20gYW55IGFuY2VzdG9yIGAkcmVzb2x2ZWAgb2YgdGhhdCBwYXJlbnQpLlxyXG4gICAqXHJcbiAgICogVGhlIHJldHVybiB2YWx1ZSBvZiBgJHJlc29sdmVgIGlzIGEgcHJvbWlzZSBmb3IgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgKGluIHRoaXMgb3JkZXIgb2YgcHJlY2VkZW5jZSlcclxuICAgKlxyXG4gICAqIC0gYW55IGBsb2NhbHNgIChpZiBzcGVjaWZpZWQpXHJcbiAgICogLSB0aGUgcmVzb2x2ZWQgcmV0dXJuIHZhbHVlcyBvZiBhbGwgaW5qZWN0YWJsZXNcclxuICAgKiAtIGFueSB2YWx1ZXMgaW5oZXJpdGVkIGZyb20gYSBgcGFyZW50YCBjYWxsIHRvIGAkcmVzb2x2ZWAgKGlmIHNwZWNpZmllZClcclxuICAgKlxyXG4gICAqIFRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSBhZnRlciB0aGUgYHBhcmVudGAgcHJvbWlzZSAoaWYgYW55KSBhbmQgYWxsIHByb21pc2VzIHJldHVybmVkIGJ5IGluamVjdGFibGVzXHJcbiAgICogaGF2ZSBiZWVuIHJlc29sdmVkLiBJZiBhbnkgaW52b2NhYmxlIChvciBgJGluamVjdG9yLmludm9rZWApIHRocm93cyBhbiBleGNlcHRpb24sIG9yIGlmIGEgcHJvbWlzZVxyXG4gICAqIHJldHVybmVkIGJ5IGFuIGludm9jYWJsZSBpcyByZWplY3RlZCwgdGhlIGAkcmVzb2x2ZWAgcHJvbWlzZSBpcyBpbW1lZGlhdGVseSByZWplY3RlZCB3aXRoIHRoZSBzYW1lIGVycm9yLlxyXG4gICAqIEEgcmVqZWN0aW9uIG9mIGEgYHBhcmVudGAgcHJvbWlzZSAoaWYgc3BlY2lmaWVkKSB3aWxsIGxpa2V3aXNlIGJlIHByb3BhZ2F0ZWQgaW1tZWRpYXRlbHkuIE9uY2UgdGhlXHJcbiAgICogYCRyZXNvbHZlYCBwcm9taXNlIGhhcyBiZWVuIHJlamVjdGVkLCBubyBmdXJ0aGVyIGludm9jYWJsZXMgd2lsbCBiZSBjYWxsZWQuXHJcbiAgICogXHJcbiAgICogQ3ljbGljIGRlcGVuZGVuY2llcyBiZXR3ZWVuIGludm9jYWJsZXMgYXJlIG5vdCBwZXJtaXR0ZWQgYW5kIHdpbGwgY2F1ZXMgYCRyZXNvbHZlYCB0byB0aHJvdyBhblxyXG4gICAqIGVycm9yLiBBcyBhIHNwZWNpYWwgY2FzZSwgYW4gaW5qZWN0YWJsZSBjYW4gZGVwZW5kIG9uIGEgcGFyYW1ldGVyIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgaW5qZWN0YWJsZSxcclxuICAgKiB3aGljaCB3aWxsIGJlIGZ1bGZpbGxlZCBmcm9tIHRoZSBgcGFyZW50YCBpbmplY3RhYmxlIG9mIHRoZSBzYW1lIG5hbWUuIFRoaXMgYWxsb3dzIGluaGVyaXRlZCB2YWx1ZXNcclxuICAgKiB0byBiZSBkZWNvcmF0ZWQuIE5vdGUgdGhhdCBpbiB0aGlzIGNhc2UgYW55IG90aGVyIGluamVjdGFibGUgaW4gdGhlIHNhbWUgYCRyZXNvbHZlYCB3aXRoIHRoZSBzYW1lXHJcbiAgICogZGVwZW5kZW5jeSB3b3VsZCBzZWUgdGhlIGRlY29yYXRlZCB2YWx1ZSwgbm90IHRoZSBpbmhlcml0ZWQgdmFsdWUuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgbWlzc2luZyBkZXBlbmRlbmNpZXMgLS0gdW5saWtlIGN5Y2xpYyBkZXBlbmRlbmNpZXMgLS0gd2lsbCBjYXVzZSBhbiAoYXN5bmNocm9ub3VzKSByZWplY3Rpb25cclxuICAgKiBvZiB0aGUgYCRyZXNvbHZlYCBwcm9taXNlIHJhdGhlciB0aGFuIGEgKHN5bmNocm9ub3VzKSBleGNlcHRpb24uXHJcbiAgICpcclxuICAgKiBJbnZvY2FibGVzIGFyZSBpbnZva2VkIGVhZ2VybHkgYXMgc29vbiBhcyBhbGwgZGVwZW5kZW5jaWVzIGFyZSBhdmFpbGFibGUuIFRoaXMgaXMgdHJ1ZSBldmVuIGZvclxyXG4gICAqIGRlcGVuZGVuY2llcyBpbmhlcml0ZWQgZnJvbSBhIGBwYXJlbnRgIGNhbGwgdG8gYCRyZXNvbHZlYC5cclxuICAgKlxyXG4gICAqIEFzIGEgc3BlY2lhbCBjYXNlLCBhbiBpbnZvY2FibGUgY2FuIGJlIGEgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGl0IGlzIHRha2VuIHRvIGJlIGEgc2VydmljZSBuYW1lXHJcbiAgICogdG8gYmUgcGFzc2VkIHRvIGAkaW5qZWN0b3IuZ2V0KClgLiBUaGlzIGlzIHN1cHBvcnRlZCBwcmltYXJpbHkgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggdGhlXHJcbiAgICogYHJlc29sdmVgIHByb3BlcnR5IG9mIGAkcm91dGVQcm92aWRlcmAgcm91dGVzLlxyXG4gICAqXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgRnVuY3Rpb258c3RyaW5nPn0gaW52b2NhYmxlcyAgZnVuY3Rpb25zIHRvIGludm9rZSBvciBgJGluamVjdG9yYCBzZXJ2aWNlcyB0byBmZXRjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPn0gW2xvY2Fsc10gIHZhbHVlcyB0byBtYWtlIGF2YWlsYWJsZSB0byB0aGUgaW5qZWN0YWJsZXNcclxuICAgKiBAcGFyYW0ge1Byb21pc2UuPE9iamVjdD59IFtwYXJlbnRdICBhIHByb21pc2UgcmV0dXJuZWQgYnkgYW5vdGhlciBjYWxsIHRvIGAkcmVzb2x2ZWAuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzZWxmXSAgdGhlIGB0aGlzYCBmb3IgdGhlIGludm9rZWQgbWV0aG9kc1xyXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPE9iamVjdD59ICBQcm9taXNlIGZvciBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgcmVzb2x2ZWQgcmV0dXJuIHZhbHVlXHJcbiAgICogICAgb2YgYWxsIGludm9jYWJsZXMsIGFzIHdlbGwgYXMgYW55IGluaGVyaXRlZCBhbmQgbG9jYWwgdmFsdWVzLlxyXG4gICAqL1xyXG4gIHRoaXMucmVzb2x2ZSA9IGZ1bmN0aW9uIChpbnZvY2FibGVzLCBsb2NhbHMsIHBhcmVudCwgc2VsZikge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R1ZHkoaW52b2NhYmxlcykobG9jYWxzLCBwYXJlbnQsIHNlbGYpO1xyXG4gIH07XHJcbn1cclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIudXRpbCcpLnNlcnZpY2UoJyRyZXNvbHZlJywgJFJlc29sdmUpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXJ2aWNlLiBNYW5hZ2VzIGxvYWRpbmcgb2YgdGVtcGxhdGVzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQG5hbWUgJHRlbXBsYXRlRmFjdG9yeVxyXG4gKiBAcmVxdWlyZXMgJGh0dHBcclxuICogQHJlcXVpcmVzICR0ZW1wbGF0ZUNhY2hlXHJcbiAqIEByZXF1aXJlcyAkaW5qZWN0b3JcclxuICovXHJcbiRUZW1wbGF0ZUZhY3RvcnkuJGluamVjdCA9IFsnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnLCAnJGluamVjdG9yJ107XHJcbmZ1bmN0aW9uICRUZW1wbGF0ZUZhY3RvcnkoICAkaHR0cCwgICAkdGVtcGxhdGVDYWNoZSwgICAkaW5qZWN0b3IpIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBjb25maWd1cmF0aW9uIG9iamVjdC4gXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgJHRlbXBsYXRlRmFjdG9yeSNmcm9tQ29uZmlnXHJcbiAgICogQG1ldGhvZE9mICR0ZW1wbGF0ZUZhY3RvcnlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICBDb25maWd1cmF0aW9uIG9iamVjdCBmb3Igd2hpY2ggdG8gbG9hZCBhIHRlbXBsYXRlLiBUaGUgZm9sbG93aW5nXHJcbiAgICogICAgcHJvcGVydGllcyBhcmUgc2VhcmNoIGluIHRoZSBzcGVjaWZpZWQgb3JkZXIsIGFuZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgZGVmaW5lZCBpc1xyXG4gICAqICAgIHVzZWQgdG8gY3JlYXRlIHRoZSB0ZW1wbGF0ZTpcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gY29uZmlnLnRlbXBsYXRlICBodG1sIHN0cmluZyB0ZW1wbGF0ZSBvciBmdW5jdGlvbiB0byBsb2FkIHZpYVxyXG4gICAqICAgIHtAbGluayAkdGVtcGxhdGVGYWN0b3J5I2Zyb21TdHJpbmcgZnJvbVN0cmluZ30uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IGNvbmZpZy50ZW1wbGF0ZVVybCAgdXJsIHRvIGxvYWQgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIHVybFxyXG4gICAqICAgIHRvIGxvYWQgdmlhIHtAbGluayAkdGVtcGxhdGVGYWN0b3J5I2Zyb21VcmwgZnJvbVVybH0uXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLnRlbXBsYXRlUHJvdmlkZXIgIGZ1bmN0aW9uIHRvIGludm9rZSB2aWFcclxuICAgKiAgICB7QGxpbmsgJHRlbXBsYXRlRmFjdG9yeSNmcm9tUHJvdmlkZXIgZnJvbVByb3ZpZGVyfS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zICBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbG9jYWxzXSBMb2NhbHMgdG8gcGFzcyB0byBgaW52b2tlYCBpZiB0aGUgdGVtcGxhdGUgaXMgbG9hZGVkIHZpYSBhXHJcbiAgICogICAgICBgdGVtcGxhdGVQcm92aWRlcmAuIERlZmF1bHRzIHRvIGB7IHBhcmFtczogcGFyYW1zIH1gLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSAgVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3IgdGhhdCBzdHJpbmcsXHJcbiAgICogICAgICBvciBgbnVsbGAgaWYgbm8gdGVtcGxhdGUgaXMgY29uZmlndXJlZC5cclxuICAgKi9cclxuICB0aGlzLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY29uZmlnLCBwYXJhbXMsIGxvY2Fscykge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgaXNEZWZpbmVkKGNvbmZpZy50ZW1wbGF0ZSkgPyB0aGlzLmZyb21TdHJpbmcoY29uZmlnLnRlbXBsYXRlLCBwYXJhbXMpIDpcclxuICAgICAgaXNEZWZpbmVkKGNvbmZpZy50ZW1wbGF0ZVVybCkgPyB0aGlzLmZyb21VcmwoY29uZmlnLnRlbXBsYXRlVXJsLCBwYXJhbXMpIDpcclxuICAgICAgaXNEZWZpbmVkKGNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyKSA/IHRoaXMuZnJvbVByb3ZpZGVyKGNvbmZpZy50ZW1wbGF0ZVByb3ZpZGVyLCBwYXJhbXMsIGxvY2FscykgOlxyXG4gICAgICBudWxsXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nLlxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBuYW1lICR0ZW1wbGF0ZUZhY3RvcnkjZnJvbVN0cmluZ1xyXG4gICAqIEBtZXRob2RPZiAkdGVtcGxhdGVGYWN0b3J5XHJcbiAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHRlbXBsYXRlICBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBodG1sXHJcbiAgICogICAgICB0ZW1wbGF0ZSBhcyBhIHN0cmluZy5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zICBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQcm9taXNlLjxzdHJpbmc+fSAgVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3IgdGhhdCBzdHJpbmcuXHJcbiAgICovXHJcbiAgdGhpcy5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBwYXJhbXMpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKHRlbXBsYXRlKSA/IHRlbXBsYXRlKHBhcmFtcykgOiB0ZW1wbGF0ZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBMb2FkcyBhIHRlbXBsYXRlIGZyb20gdGhlIGEgVVJMIHZpYSBgJGh0dHBgIGFuZCBgJHRlbXBsYXRlQ2FjaGVgLlxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBuYW1lICR0ZW1wbGF0ZUZhY3RvcnkjZnJvbVVybFxyXG4gICAqIEBtZXRob2RPZiAkdGVtcGxhdGVGYWN0b3J5XHJcbiAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHVybCAgdXJsIG9mIHRoZSB0ZW1wbGF0ZSB0byBsb2FkLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHVybC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zICBQYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHVybCBmdW5jdGlvbi5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd8UHJvbWlzZS48c3RyaW5nPn0gIFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2UgZm9yIHRoYXQgc3RyaW5nLlxyXG4gICAqL1xyXG4gIHRoaXMuZnJvbVVybCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcykge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24odXJsKSkgdXJsID0gdXJsKHBhcmFtcyk7XHJcbiAgICBpZiAodXJsID09IG51bGwpIHJldHVybiBudWxsO1xyXG4gICAgZWxzZSByZXR1cm4gJGh0dHBcclxuICAgICAgICAuZ2V0KHVybCwgeyBjYWNoZTogJHRlbXBsYXRlQ2FjaGUgfSlcclxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2UuZGF0YTsgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGJ5IGludm9raW5nIGFuIGluamVjdGFibGUgcHJvdmlkZXIgZnVuY3Rpb24uXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgJHRlbXBsYXRlRmFjdG9yeSNmcm9tVXJsXHJcbiAgICogQG1ldGhvZE9mICR0ZW1wbGF0ZUZhY3RvcnlcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm92aWRlciBGdW5jdGlvbiB0byBpbnZva2UgdmlhIGAkaW5qZWN0b3IuaW52b2tlYFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgUGFyYW1ldGVycyBmb3IgdGhlIHRlbXBsYXRlLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbG9jYWxzXSBMb2NhbHMgdG8gcGFzcyB0byBgaW52b2tlYC4gRGVmYXVsdHMgdG8gYHsgcGFyYW1zOiBwYXJhbXMgfWAuXHJcbiAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2UgZm9yIHRoYXQgc3RyaW5nLlxyXG4gICAqL1xyXG4gIHRoaXMuZnJvbVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBwYXJhbXMsIGxvY2Fscykge1xyXG4gICAgcmV0dXJuICRpbmplY3Rvci5pbnZva2UocHJvdmlkZXIsIG51bGwsIGxvY2FscyB8fCB7IHBhcmFtczogcGFyYW1zIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIudXRpbCcpLnNlcnZpY2UoJyR0ZW1wbGF0ZUZhY3RvcnknLCAkVGVtcGxhdGVGYWN0b3J5KTtcclxuXHJcbi8qKlxyXG4gKiBNYXRjaGVzIFVSTHMgYWdhaW5zdCBwYXR0ZXJucyBhbmQgZXh0cmFjdHMgbmFtZWQgcGFyYW1ldGVycyBmcm9tIHRoZSBwYXRoIG9yIHRoZSBzZWFyY2hcclxuICogcGFydCBvZiB0aGUgVVJMLiBBIFVSTCBwYXR0ZXJuIGNvbnNpc3RzIG9mIGEgcGF0aCBwYXR0ZXJuLCBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5ICc/JyBhbmQgYSBsaXN0XHJcbiAqIG9mIHNlYXJjaCBwYXJhbWV0ZXJzLiBNdWx0aXBsZSBzZWFyY2ggcGFyYW1ldGVyIG5hbWVzIGFyZSBzZXBhcmF0ZWQgYnkgJyYnLiBTZWFyY2ggcGFyYW1ldGVyc1xyXG4gKiBkbyBub3QgaW5mbHVlbmNlIHdoZXRoZXIgb3Igbm90IGEgVVJMIGlzIG1hdGNoZWQsIGJ1dCB0aGVpciB2YWx1ZXMgYXJlIHBhc3NlZCB0aHJvdWdoIGludG9cclxuICogdGhlIG1hdGNoZWQgcGFyYW1ldGVycyByZXR1cm5lZCBieSB7QGxpbmsgVXJsTWF0Y2hlciNleGVjIGV4ZWN9LlxyXG4gKiBcclxuICogUGF0aCBwYXJhbWV0ZXIgcGxhY2Vob2xkZXJzIGNhbiBiZSBzcGVjaWZpZWQgdXNpbmcgc2ltcGxlIGNvbG9uL2NhdGNoLWFsbCBzeW50YXggb3IgY3VybHkgYnJhY2VcclxuICogc3ludGF4LCB3aGljaCBvcHRpb25hbGx5IGFsbG93cyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdGhlIHBhcmFtZXRlciB0byBiZSBzcGVjaWZpZWQ6XHJcbiAqXHJcbiAqICogJzonIG5hbWUgLSBjb2xvbiBwbGFjZWhvbGRlclxyXG4gKiAqICcqJyBuYW1lIC0gY2F0Y2gtYWxsIHBsYWNlaG9sZGVyXHJcbiAqICogJ3snIG5hbWUgJ30nIC0gY3VybHkgcGxhY2Vob2xkZXJcclxuICogKiAneycgbmFtZSAnOicgcmVnZXhwICd9JyAtIGN1cmx5IHBsYWNlaG9sZGVyIHdpdGggcmVnZXhwLiBTaG91bGQgdGhlIHJlZ2V4cCBpdHNlbGYgY29udGFpblxyXG4gKiAgIGN1cmx5IGJyYWNlcywgdGhleSBtdXN0IGJlIGluIG1hdGNoZWQgcGFpcnMgb3IgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoLlxyXG4gKlxyXG4gKiBQYXJhbWV0ZXIgbmFtZXMgbWF5IGNvbnRhaW4gb25seSB3b3JkIGNoYXJhY3RlcnMgKGxhdGluIGxldHRlcnMsIGRpZ2l0cywgYW5kIHVuZGVyc2NvcmUpIGFuZFxyXG4gKiBtdXN0IGJlIHVuaXF1ZSB3aXRoaW4gdGhlIHBhdHRlcm4gKGFjcm9zcyBib3RoIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzKS4gRm9yIGNvbG9uIFxyXG4gKiBwbGFjZWhvbGRlcnMgb3IgY3VybHkgcGxhY2Vob2xkZXJzIHdpdGhvdXQgYW4gZXhwbGljaXQgcmVnZXhwLCBhIHBhdGggcGFyYW1ldGVyIG1hdGNoZXMgYW55XHJcbiAqIG51bWJlciBvZiBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gJy8nLiBGb3IgY2F0Y2gtYWxsIHBsYWNlaG9sZGVycyB0aGUgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlc1xyXG4gKiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXHJcbiAqIFxyXG4gKiAjIyMgRXhhbXBsZXNcclxuICogXHJcbiAqICogJy9oZWxsby8nIC0gTWF0Y2hlcyBvbmx5IGlmIHRoZSBwYXRoIGlzIGV4YWN0bHkgJy9oZWxsby8nLiBUaGVyZSBpcyBubyBzcGVjaWFsIHRyZWF0bWVudCBmb3JcclxuICogICB0cmFpbGluZyBzbGFzaGVzLCBhbmQgcGF0dGVybnMgaGF2ZSB0byBtYXRjaCB0aGUgZW50aXJlIHBhdGgsIG5vdCBqdXN0IGEgcHJlZml4LlxyXG4gKiAqICcvdXNlci86aWQnIC0gTWF0Y2hlcyAnL3VzZXIvYm9iJyBvciAnL3VzZXIvMTIzNCEhIScgb3IgZXZlbiAnL3VzZXIvJyBidXQgbm90ICcvdXNlcicgb3JcclxuICogICAnL3VzZXIvYm9iL2RldGFpbHMnLiBUaGUgc2Vjb25kIHBhdGggc2VnbWVudCB3aWxsIGJlIGNhcHR1cmVkIGFzIHRoZSBwYXJhbWV0ZXIgJ2lkJy5cclxuICogKiAnL3VzZXIve2lkfScgLSBTYW1lIGFzIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgdXNpbmcgY3VybHkgYnJhY2Ugc3ludGF4LlxyXG4gKiAqICcvdXNlci97aWQ6W14vXSp9JyAtIFNhbWUgYXMgdGhlIHByZXZpb3VzIGV4YW1wbGUuXHJcbiAqICogJy91c2VyL3tpZDpbMC05YS1mQS1GXXsxLDh9fScgLSBTaW1pbGFyIHRvIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgb25seSBtYXRjaGVzIGlmIHRoZSBpZFxyXG4gKiAgIHBhcmFtZXRlciBjb25zaXN0cyBvZiAxIHRvIDggaGV4IGRpZ2l0cy5cclxuICogKiAnL2ZpbGVzL3twYXRoOi4qfScgLSBNYXRjaGVzIGFueSBVUkwgc3RhcnRpbmcgd2l0aCAnL2ZpbGVzLycgYW5kIGNhcHR1cmVzIHRoZSByZXN0IG9mIHRoZVxyXG4gKiAgIHBhdGggaW50byB0aGUgcGFyYW1ldGVyICdwYXRoJy5cclxuICogKiAnL2ZpbGVzLypwYXRoJyAtIGRpdHRvLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gIHRoZSBwYXR0ZXJuIHRvIGNvbXBpbGUgaW50byBhIG1hdGNoZXIuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcmVmaXggIEEgc3RhdGljIHByZWZpeCBvZiB0aGlzIHBhdHRlcm4uIFRoZSBtYXRjaGVyIGd1YXJhbnRlZXMgdGhhdCBhbnlcclxuICogICBVUkwgbWF0Y2hpbmcgdGhpcyBtYXRjaGVyIChpLmUuIGFueSBzdHJpbmcgZm9yIHdoaWNoIHtAbGluayBVcmxNYXRjaGVyI2V4ZWMgZXhlYygpfSByZXR1cm5zXHJcbiAqICAgbm9uLW51bGwpIHdpbGwgc3RhcnQgd2l0aCB0aGlzIHByZWZpeC5cclxuICovXHJcbmZ1bmN0aW9uIFVybE1hdGNoZXIocGF0dGVybikge1xyXG5cclxuICAvLyBGaW5kIGFsbCBwbGFjZWhvbGRlcnMgYW5kIGNyZWF0ZSBhIGNvbXBpbGVkIHBhdHRlcm4sIHVzaW5nIGVpdGhlciBjbGFzc2ljIG9yIGN1cmx5IHN5bnRheDpcclxuICAvLyAgICcqJyBuYW1lXHJcbiAgLy8gICAnOicgbmFtZVxyXG4gIC8vICAgJ3snIG5hbWUgJ30nXHJcbiAgLy8gICAneycgbmFtZSAnOicgcmVnZXhwICd9J1xyXG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gaXMgc29tZXdoYXQgY29tcGxpY2F0ZWQgZHVlIHRvIHRoZSBuZWVkIHRvIGFsbG93IGN1cmx5IGJyYWNlc1xyXG4gIC8vIGluc2lkZSB0aGUgcmVndWxhciBleHByZXNzaW9uLiBUaGUgcGxhY2Vob2xkZXIgcmVnZXhwIGJyZWFrcyBkb3duIGFzIGZvbGxvd3M6XHJcbiAgLy8gICAgKFs6Kl0pKFxcdyspICAgICAgICAgICAgICAgY2xhc3NpYyBwbGFjZWhvbGRlciAoJDEgLyAkMilcclxuICAvLyAgICBcXHsoXFx3KykoPzpcXDooIC4uLiApKT9cXH0gICBjdXJseSBicmFjZSBwbGFjZWhvbGRlciAoJDMpIHdpdGggb3B0aW9uYWwgcmVnZXhwIC4uLiAoJDQpXHJcbiAgLy8gICAgKD86IC4uLiB8IC4uLiB8IC4uLiApKyAgICB0aGUgcmVnZXhwIGNvbnNpc3RzIG9mIGFueSBudW1iZXIgb2YgYXRvbXMsIGFuIGF0b20gYmVpbmcgZWl0aGVyXHJcbiAgLy8gICAgW157fVxcXFxdKyAgICAgICAgICAgICAgICAgIC0gYW55dGhpbmcgb3RoZXIgdGhhbiBjdXJseSBicmFjZXMgb3IgYmFja3NsYXNoXHJcbiAgLy8gICAgXFxcXC4gICAgICAgICAgICAgICAgICAgICAgIC0gYSBiYWNrc2xhc2ggZXNjYXBlXHJcbiAgLy8gICAgXFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9ICAgICAtIGEgbWF0Y2hlZCBzZXQgb2YgY3VybHkgYnJhY2VzIGNvbnRhaW5pbmcgb3RoZXIgYXRvbXNcclxuICB2YXIgcGxhY2Vob2xkZXIgPSAvKFs6Kl0pKFxcdyspfFxceyhcXHcrKSg/OlxcOigoPzpbXnt9XFxcXF0rfFxcXFwufFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSkrKSk/XFx9L2csXHJcbiAgICAgIG5hbWVzID0ge30sIGNvbXBpbGVkID0gJ14nLCBsYXN0ID0gMCwgbSxcclxuICAgICAgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzID0gW10sXHJcbiAgICAgIHBhcmFtcyA9IHRoaXMucGFyYW1zID0gW107XHJcblxyXG4gIGZ1bmN0aW9uIGFkZFBhcmFtZXRlcihpZCkge1xyXG4gICAgaWYgKCEvXlxcdysoLStcXHcrKSokLy50ZXN0KGlkKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgbmFtZSAnXCIgKyBpZCArIFwiJyBpbiBwYXR0ZXJuICdcIiArIHBhdHRlcm4gKyBcIidcIik7XHJcbiAgICBpZiAobmFtZXNbaWRdKSB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWUgJ1wiICsgaWQgKyBcIicgaW4gcGF0dGVybiAnXCIgKyBwYXR0ZXJuICsgXCInXCIpO1xyXG4gICAgbmFtZXNbaWRdID0gdHJ1ZTtcclxuICAgIHBhcmFtcy5wdXNoKGlkKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHF1b3RlUmVnRXhwKHN0cmluZykge1xyXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFxcXFxcW1xcXVxcXiQqKz8uKCl8e31dL2csIFwiXFxcXCQmXCIpO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuO1xyXG5cclxuICAvLyBTcGxpdCBpbnRvIHN0YXRpYyBzZWdtZW50cyBzZXBhcmF0ZWQgYnkgcGF0aCBwYXJhbWV0ZXIgcGxhY2Vob2xkZXJzLlxyXG4gIC8vIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaXMgYWx3YXlzIDEgbW9yZSB0aGFuIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycy5cclxuICB2YXIgaWQsIHJlZ2V4cCwgc2VnbWVudDtcclxuICB3aGlsZSAoKG0gPSBwbGFjZWhvbGRlci5leGVjKHBhdHRlcm4pKSkge1xyXG4gICAgaWQgPSBtWzJdIHx8IG1bM107IC8vIElFWzc4XSByZXR1cm5zICcnIGZvciB1bm1hdGNoZWQgZ3JvdXBzIGluc3RlYWQgb2YgbnVsbFxyXG4gICAgcmVnZXhwID0gbVs0XSB8fCAobVsxXSA9PSAnKicgPyAnLionIDogJ1teL10qJyk7XHJcbiAgICBzZWdtZW50ID0gcGF0dGVybi5zdWJzdHJpbmcobGFzdCwgbS5pbmRleCk7XHJcbiAgICBpZiAoc2VnbWVudC5pbmRleE9mKCc/JykgPj0gMCkgYnJlYWs7IC8vIHdlJ3JlIGludG8gdGhlIHNlYXJjaCBwYXJ0XHJcbiAgICBjb21waWxlZCArPSBxdW90ZVJlZ0V4cChzZWdtZW50KSArICcoJyArIHJlZ2V4cCArICcpJztcclxuICAgIGFkZFBhcmFtZXRlcihpZCk7XHJcbiAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xyXG4gICAgbGFzdCA9IHBsYWNlaG9sZGVyLmxhc3RJbmRleDtcclxuICB9XHJcbiAgc2VnbWVudCA9IHBhdHRlcm4uc3Vic3RyaW5nKGxhc3QpO1xyXG5cclxuICAvLyBGaW5kIGFueSBzZWFyY2ggcGFyYW1ldGVyIG5hbWVzIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsYXN0IHNlZ21lbnRcclxuICB2YXIgaSA9IHNlZ21lbnQuaW5kZXhPZignPycpO1xyXG4gIGlmIChpID49IDApIHtcclxuICAgIHZhciBzZWFyY2ggPSB0aGlzLnNvdXJjZVNlYXJjaCA9IHNlZ21lbnQuc3Vic3RyaW5nKGkpO1xyXG4gICAgc2VnbWVudCA9IHNlZ21lbnQuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgdGhpcy5zb3VyY2VQYXRoID0gcGF0dGVybi5zdWJzdHJpbmcoMCwgbGFzdCtpKTtcclxuXHJcbiAgICAvLyBBbGxvdyBwYXJhbWV0ZXJzIHRvIGJlIHNlcGFyYXRlZCBieSAnPycgYXMgd2VsbCBhcyAnJicgdG8gbWFrZSBjb25jYXQoKSBlYXNpZXJcclxuICAgIGZvckVhY2goc2VhcmNoLnN1YnN0cmluZygxKS5zcGxpdCgvWyY/XS8pLCBhZGRQYXJhbWV0ZXIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnNvdXJjZVBhdGggPSBwYXR0ZXJuO1xyXG4gICAgdGhpcy5zb3VyY2VTZWFyY2ggPSAnJztcclxuICB9XHJcblxyXG4gIGNvbXBpbGVkICs9IHF1b3RlUmVnRXhwKHNlZ21lbnQpICsgJyQnO1xyXG4gIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XHJcbiAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKGNvbXBpbGVkKTtcclxuICB0aGlzLnByZWZpeCA9IHNlZ21lbnRzWzBdO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBtYXRjaGVyIGZvciBhIHBhdHRlcm4gY29uc3RydWN0ZWQgYnkgYXBwZW5kaW5nIHRoZSBwYXRoIHBhcnQgYW5kIGFkZGluZyB0aGVcclxuICogc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhlIHNwZWNpZmllZCBwYXR0ZXJuIHRvIHRoaXMgcGF0dGVybi4gVGhlIGN1cnJlbnQgcGF0dGVybiBpcyBub3RcclxuICogbW9kaWZpZWQuIFRoaXMgY2FuIGJlIHVuZGVyc3Rvb2QgYXMgY3JlYXRpbmcgYSBwYXR0ZXJuIGZvciBVUkxzIHRoYXQgYXJlIHJlbGF0aXZlIHRvIChvclxyXG4gKiBzdWZmaXhlcyBvZikgdGhlIGN1cnJlbnQgcGF0dGVybi5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogVGhlIGZvbGxvd2luZyB0d28gbWF0Y2hlcnMgYXJlIGVxdWl2YWxlbnQ6XHJcbiAqIGBgYFxyXG4gKiBuZXcgVXJsTWF0Y2hlcignL3VzZXIve2lkfT9xJykuY29uY2F0KCcvZGV0YWlscz9kYXRlJyk7XHJcbiAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9L2RldGFpbHM/cSZkYXRlJyk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiAgVGhlIHBhdHRlcm4gdG8gYXBwZW5kLlxyXG4gKiBAcmV0dXJuIHtVcmxNYXRjaGVyfSAgQSBtYXRjaGVyIGZvciB0aGUgY29uY2F0ZW5hdGVkIHBhdHRlcm4uXHJcbiAqL1xyXG5VcmxNYXRjaGVyLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAocGF0dGVybikge1xyXG4gIC8vIEJlY2F1c2Ugb3JkZXIgb2Ygc2VhcmNoIHBhcmFtZXRlcnMgaXMgaXJyZWxldmFudCwgd2UgY2FuIGFkZCBvdXIgb3duIHNlYXJjaFxyXG4gIC8vIHBhcmFtZXRlcnMgdG8gdGhlIGVuZCBvZiB0aGUgbmV3IHBhdHRlcm4uIFBhcnNlIHRoZSBuZXcgcGF0dGVybiBieSBpdHNlbGZcclxuICAvLyBhbmQgdGhlbiBqb2luIHRoZSBiaXRzIHRvZ2V0aGVyLCBidXQgaXQncyBtdWNoIGVhc2llciB0byBkbyB0aGlzIG9uIGEgc3RyaW5nIGxldmVsLlxyXG4gIHJldHVybiBuZXcgVXJsTWF0Y2hlcih0aGlzLnNvdXJjZVBhdGggKyBwYXR0ZXJuICsgdGhpcy5zb3VyY2VTZWFyY2gpO1xyXG59O1xyXG5cclxuVXJsTWF0Y2hlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuc291cmNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIHRoZSBzcGVjaWZpZWQgcGF0aCBhZ2FpbnN0IHRoaXMgbWF0Y2hlciwgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhcHR1cmVkXHJcbiAqIHBhcmFtZXRlciB2YWx1ZXMsIG9yIG51bGwgaWYgdGhlIHBhdGggZG9lcyBub3QgbWF0Y2guIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIHZhbHVlc1xyXG4gKiBvZiBhbnkgc2VhcmNoIHBhcmFtZXRlcnMgdGhhdCBhcmUgbWVudGlvbmVkIGluIHRoZSBwYXR0ZXJuLCBidXQgdGhlaXIgdmFsdWUgbWF5IGJlIG51bGwgaWZcclxuICogdGhleSBhcmUgbm90IHByZXNlbnQgaW4gYHNlYXJjaFBhcmFtc2AuIFRoaXMgbWVhbnMgdGhhdCBzZWFyY2ggcGFyYW1ldGVycyBhcmUgYWx3YXlzIHRyZWF0ZWRcclxuICogYXMgb3B0aW9uYWwuXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYFxyXG4gKiBuZXcgVXJsTWF0Y2hlcignL3VzZXIve2lkfT9xJnInKS5leGVjKCcvdXNlci9ib2InLCB7IHg6JzEnLCBxOidoZWxsbycgfSk7XHJcbiAqIC8vIHJldHVybnMgeyBpZDonYm9iJywgcTonaGVsbG8nLCByOm51bGwgfVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggIFRoZSBVUkwgcGF0aCB0byBtYXRjaCwgZS5nLiBgJGxvY2F0aW9uLnBhdGgoKWAuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWFyY2hQYXJhbXMgIFVSTCBzZWFyY2ggcGFyYW1ldGVycywgZS5nLiBgJGxvY2F0aW9uLnNlYXJjaCgpYC5cclxuICogQHJldHVybiB7T2JqZWN0fSAgVGhlIGNhcHR1cmVkIHBhcmFtZXRlciB2YWx1ZXMuXHJcbiAqL1xyXG5VcmxNYXRjaGVyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKHBhdGgsIHNlYXJjaFBhcmFtcykge1xyXG4gIHZhciBtID0gdGhpcy5yZWdleHAuZXhlYyhwYXRoKTtcclxuICBpZiAoIW0pIHJldHVybiBudWxsO1xyXG5cclxuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXMsIG5Ub3RhbCA9IHBhcmFtcy5sZW5ndGgsXHJcbiAgICBuUGF0aCA9IHRoaXMuc2VnbWVudHMubGVuZ3RoLTEsXHJcbiAgICB2YWx1ZXMgPSB7fSwgaTtcclxuXHJcbiAgaWYgKG5QYXRoICE9PSBtLmxlbmd0aCAtIDEpIHRocm93IG5ldyBFcnJvcihcIlVuYmFsYW5jZWQgY2FwdHVyZSBncm91cCBpbiByb3V0ZSAnXCIgKyB0aGlzLnNvdXJjZSArIFwiJ1wiKTtcclxuXHJcbiAgZm9yIChpPTA7IGk8blBhdGg7IGkrKykgdmFsdWVzW3BhcmFtc1tpXV0gPSBtW2krMV07XHJcbiAgZm9yICgvKiovOyBpPG5Ub3RhbDsgaSsrKSB2YWx1ZXNbcGFyYW1zW2ldXSA9IHNlYXJjaFBhcmFtc1twYXJhbXNbaV1dO1xyXG5cclxuICByZXR1cm4gdmFsdWVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5hbWVzIG9mIGFsbCBwYXRoIGFuZCBzZWFyY2ggcGFyYW1ldGVycyBvZiB0aGlzIHBhdHRlcm4gaW4gYW4gdW5zcGVjaWZpZWQgb3JkZXIuXHJcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSAgQW4gYXJyYXkgb2YgcGFyYW1ldGVyIG5hbWVzLiBNdXN0IGJlIHRyZWF0ZWQgYXMgcmVhZC1vbmx5LiBJZiB0aGVcclxuICogICAgcGF0dGVybiBoYXMgbm8gcGFyYW1ldGVycywgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXHJcbiAqL1xyXG5VcmxNYXRjaGVyLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLnBhcmFtcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgVVJMIHRoYXQgbWF0Y2hlcyB0aGlzIHBhdHRlcm4gYnkgc3Vic3RpdHV0aW5nIHRoZSBzcGVjaWZpZWQgdmFsdWVzXHJcbiAqIGZvciB0aGUgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMuIE51bGwgdmFsdWVzIGZvciBwYXRoIHBhcmFtZXRlcnMgYXJlXHJcbiAqIHRyZWF0ZWQgYXMgZW1wdHkgc3RyaW5ncy5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgXHJcbiAqIG5ldyBVcmxNYXRjaGVyKCcvdXNlci97aWR9P3EnKS5mb3JtYXQoeyBpZDonYm9iJywgcToneWVzJyB9KTtcclxuICogLy8gcmV0dXJucyAnL3VzZXIvYm9iP3E9eWVzJ1xyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAgdGhlIHZhbHVlcyB0byBzdWJzdGl0dXRlIGZvciB0aGUgcGFyYW1ldGVycyBpbiB0aGlzIHBhdHRlcm4uXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gIHRoZSBmb3JtYXR0ZWQgVVJMIChwYXRoIGFuZCBvcHRpb25hbGx5IHNlYXJjaCBwYXJ0KS5cclxuICovXHJcblVybE1hdGNoZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcclxuICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzLCBwYXJhbXMgPSB0aGlzLnBhcmFtcztcclxuICBpZiAoIXZhbHVlcykgcmV0dXJuIHNlZ21lbnRzLmpvaW4oJycpO1xyXG5cclxuICB2YXIgblBhdGggPSBzZWdtZW50cy5sZW5ndGgtMSwgblRvdGFsID0gcGFyYW1zLmxlbmd0aCxcclxuICAgIHJlc3VsdCA9IHNlZ21lbnRzWzBdLCBpLCBzZWFyY2gsIHZhbHVlO1xyXG5cclxuICBmb3IgKGk9MDsgaTxuUGF0aDsgaSsrKSB7XHJcbiAgICB2YWx1ZSA9IHZhbHVlc1twYXJhbXNbaV1dO1xyXG4gICAgLy8gVE9ETzogTWF5YmUgd2Ugc2hvdWxkIHRocm93IG9uIG51bGwgaGVyZT8gSXQncyBub3QgcmVhbGx5IGdvb2Qgc3R5bGUgdG8gdXNlICcnIGFuZCBudWxsIGludGVyY2hhbmdlYWJsZXlcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcclxuICAgIHJlc3VsdCArPSBzZWdtZW50c1tpKzFdO1xyXG4gIH1cclxuICBmb3IgKC8qKi87IGk8blRvdGFsOyBpKyspIHtcclxuICAgIHZhbHVlID0gdmFsdWVzW3BhcmFtc1tpXV07XHJcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICByZXN1bHQgKz0gKHNlYXJjaCA/ICcmJyA6ICc/JykgKyBwYXJhbXNbaV0gKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xyXG4gICAgICBzZWFyY2ggPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXJ2aWNlLiBGYWN0b3J5IGZvciB7QGxpbmsgVXJsTWF0Y2hlcn0gaW5zdGFuY2VzLiBUaGUgZmFjdG9yeSBpcyBhbHNvIGF2YWlsYWJsZSB0byBwcm92aWRlcnNcclxuICogdW5kZXIgdGhlIG5hbWUgYCR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyYC5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBuYW1lICR1cmxNYXRjaGVyRmFjdG9yeVxyXG4gKi9cclxuZnVuY3Rpb24gJFVybE1hdGNoZXJGYWN0b3J5KCkge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSB7QGxpbmsgVXJsTWF0Y2hlcn0gZm9yIHRoZSBzcGVjaWZpZWQgcGF0dGVybi5cclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAbmFtZSAkdXJsTWF0Y2hlckZhY3RvcnkjY29tcGlsZVxyXG4gICAqIEBtZXRob2RPZiAkdXJsTWF0Y2hlckZhY3RvcnlcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiAgVGhlIFVSTCBwYXR0ZXJuLlxyXG4gICAqIEByZXR1cm4ge1VybE1hdGNoZXJ9ICBUaGUgVXJsTWF0Y2hlci5cclxuICAgKi9cclxuICB0aGlzLmNvbXBpbGUgPSBmdW5jdGlvbiAocGF0dGVybikge1xyXG4gICAgcmV0dXJuIG5ldyBVcmxNYXRjaGVyKHBhdHRlcm4pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIFVybE1hdGNoZXIsIG9yIGZhbHNlIG90aGVyd2lzZS5cclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAbmFtZSAkdXJsTWF0Y2hlckZhY3RvcnkjaXNNYXRjaGVyXHJcbiAgICogQG1ldGhvZE9mICR1cmxNYXRjaGVyRmFjdG9yeVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICB0aGlzLmlzTWF0Y2hlciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICByZXR1cm4gaXNPYmplY3QobykgJiYgaXNGdW5jdGlvbihvLmV4ZWMpICYmIGlzRnVuY3Rpb24oby5mb3JtYXQpICYmIGlzRnVuY3Rpb24oby5jb25jYXQpO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuJGdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIFJlZ2lzdGVyIGFzIGEgcHJvdmlkZXIgc28gaXQncyBhdmFpbGFibGUgdG8gb3RoZXIgcHJvdmlkZXJzXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIudXRpbCcpLnByb3ZpZGVyKCckdXJsTWF0Y2hlckZhY3RvcnknLCAkVXJsTWF0Y2hlckZhY3RvcnkpO1xyXG5cclxuXHJcbiRVcmxSb3V0ZXJQcm92aWRlci4kaW5qZWN0ID0gWyckdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlciddO1xyXG5mdW5jdGlvbiAkVXJsUm91dGVyUHJvdmlkZXIoICAkdXJsTWF0Y2hlckZhY3RvcnkpIHtcclxuICB2YXIgcnVsZXMgPSBbXSwgXHJcbiAgICAgIG90aGVyd2lzZSA9IG51bGw7XHJcblxyXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBhIHByZWZpeCBvZiBhbGwgc3RyaW5ncyBtYXRjaGluZyB0aGUgUmVnRXhwXHJcbiAgZnVuY3Rpb24gcmVnRXhwUHJlZml4KHJlKSB7XHJcbiAgICB2YXIgcHJlZml4ID0gL15cXF4oKD86XFxcXFteYS16QS1aMC05XXxbXlxcXFxcXFtcXF1cXF4kKis/LigpfHt9XSspKikvLmV4ZWMocmUuc291cmNlKTtcclxuICAgIHJldHVybiAocHJlZml4ICE9IG51bGwpID8gcHJlZml4WzFdLnJlcGxhY2UoL1xcXFwoLikvZywgXCIkMVwiKSA6ICcnO1xyXG4gIH1cclxuXHJcbiAgLy8gSW50ZXJwb2xhdGVzIG1hdGNoZWQgdmFsdWVzIGludG8gYSBTdHJpbmcucmVwbGFjZSgpLXN0eWxlIHBhdHRlcm5cclxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShwYXR0ZXJuLCBtYXRjaCkge1xyXG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvXFwkKFxcJHxcXGR7MSwyfSkvLCBmdW5jdGlvbiAobSwgd2hhdCkge1xyXG4gICAgICByZXR1cm4gbWF0Y2hbd2hhdCA9PT0gJyQnID8gMCA6IE51bWJlcih3aGF0KV07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHRoaXMucnVsZSA9XHJcbiAgICBmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICBpZiAoIWlzRnVuY3Rpb24ocnVsZSkpIHRocm93IG5ldyBFcnJvcihcIidydWxlJyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XHJcbiAgICAgIHJ1bGVzLnB1c2gocnVsZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgdGhpcy5vdGhlcndpc2UgPVxyXG4gICAgZnVuY3Rpb24gKHJ1bGUpIHtcclxuICAgICAgaWYgKGlzU3RyaW5nKHJ1bGUpKSB7XHJcbiAgICAgICAgdmFyIHJlZGlyZWN0ID0gcnVsZTtcclxuICAgICAgICBydWxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVkaXJlY3Q7IH07XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIWlzRnVuY3Rpb24ocnVsZSkpIHRocm93IG5ldyBFcnJvcihcIidydWxlJyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XHJcbiAgICAgIG90aGVyd2lzZSA9IHJ1bGU7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcblxyXG4gIGZ1bmN0aW9uIGhhbmRsZUlmTWF0Y2goJGluamVjdG9yLCBoYW5kbGVyLCBtYXRjaCkge1xyXG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIHJlc3VsdCA9ICRpbmplY3Rvci5pbnZva2UoaGFuZGxlciwgaGFuZGxlciwgeyAkbWF0Y2g6IG1hdGNoIH0pO1xyXG4gICAgcmV0dXJuIGlzRGVmaW5lZChyZXN1bHQpID8gcmVzdWx0IDogdHJ1ZTtcclxuICB9XHJcblxyXG4gIHRoaXMud2hlbiA9XHJcbiAgICBmdW5jdGlvbiAod2hhdCwgaGFuZGxlcikge1xyXG4gICAgICB2YXIgcmVkaXJlY3QsIGhhbmRsZXJJc1N0cmluZyA9IGlzU3RyaW5nKGhhbmRsZXIpO1xyXG4gICAgICBpZiAoaXNTdHJpbmcod2hhdCkpIHdoYXQgPSAkdXJsTWF0Y2hlckZhY3RvcnkuY29tcGlsZSh3aGF0KTtcclxuXHJcbiAgICAgIGlmICghaGFuZGxlcklzU3RyaW5nICYmICFpc0Z1bmN0aW9uKGhhbmRsZXIpICYmICFpc0FycmF5KGhhbmRsZXIpKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgJ2hhbmRsZXInIGluIHdoZW4oKVwiKTtcclxuXHJcbiAgICAgIHZhciBzdHJhdGVnaWVzID0ge1xyXG4gICAgICAgIG1hdGNoZXI6IGZ1bmN0aW9uICh3aGF0LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICBpZiAoaGFuZGxlcklzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJlZGlyZWN0ID0gJHVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUoaGFuZGxlcik7XHJcbiAgICAgICAgICAgIGhhbmRsZXIgPSBbJyRtYXRjaCcsIGZ1bmN0aW9uICgkbWF0Y2gpIHsgcmV0dXJuIHJlZGlyZWN0LmZvcm1hdCgkbWF0Y2gpOyB9XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCRpbmplY3RvciwgJGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVJZk1hdGNoKCRpbmplY3RvciwgaGFuZGxlciwgd2hhdC5leGVjKCRsb2NhdGlvbi5wYXRoKCksICRsb2NhdGlvbi5zZWFyY2goKSkpO1xyXG4gICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBwcmVmaXg6IGlzU3RyaW5nKHdoYXQucHJlZml4KSA/IHdoYXQucHJlZml4IDogJydcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnZXg6IGZ1bmN0aW9uICh3aGF0LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICBpZiAod2hhdC5nbG9iYWwgfHwgd2hhdC5zdGlja3kpIHRocm93IG5ldyBFcnJvcihcIndoZW4oKSBSZWdFeHAgbXVzdCBub3QgYmUgZ2xvYmFsIG9yIHN0aWNreVwiKTtcclxuXHJcbiAgICAgICAgICBpZiAoaGFuZGxlcklzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJlZGlyZWN0ID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgaGFuZGxlciA9IFsnJG1hdGNoJywgZnVuY3Rpb24gKCRtYXRjaCkgeyByZXR1cm4gaW50ZXJwb2xhdGUocmVkaXJlY3QsICRtYXRjaCk7IH1dO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoJGluamVjdG9yLCAkbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUlmTWF0Y2goJGluamVjdG9yLCBoYW5kbGVyLCB3aGF0LmV4ZWMoJGxvY2F0aW9uLnBhdGgoKSkpO1xyXG4gICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBwcmVmaXg6IHJlZ0V4cFByZWZpeCh3aGF0KVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIGNoZWNrID0geyBtYXRjaGVyOiAkdXJsTWF0Y2hlckZhY3RvcnkuaXNNYXRjaGVyKHdoYXQpLCByZWdleDogd2hhdCBpbnN0YW5jZW9mIFJlZ0V4cCB9O1xyXG5cclxuICAgICAgZm9yICh2YXIgbiBpbiBjaGVjaykge1xyXG4gICAgICAgIGlmIChjaGVja1tuXSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMucnVsZShzdHJhdGVnaWVzW25dKHdoYXQsIGhhbmRsZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgJ3doYXQnIGluIHdoZW4oKVwiKTtcclxuICAgIH07XHJcblxyXG4gIHRoaXMuJGdldCA9XHJcbiAgICBbICAgICAgICAnJGxvY2F0aW9uJywgJyRyb290U2NvcGUnLCAnJGluamVjdG9yJyxcclxuICAgIGZ1bmN0aW9uICgkbG9jYXRpb24sICAgJHJvb3RTY29wZSwgICAkaW5qZWN0b3IpIHtcclxuICAgICAgLy8gVE9ETzogT3B0aW1pemUgZ3JvdXBzIG9mIHJ1bGVzIHdpdGggbm9uLWVtcHR5IHByZWZpeCBpbnRvIHNvbWUgc29ydCBvZiBkZWNpc2lvbiB0cmVlXHJcbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjaGVjayhydWxlKSB7XHJcbiAgICAgICAgICB2YXIgaGFuZGxlZCA9IHJ1bGUoJGluamVjdG9yLCAkbG9jYXRpb24pO1xyXG4gICAgICAgICAgaWYgKGhhbmRsZWQpIHtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGhhbmRsZWQpKSAkbG9jYXRpb24ucmVwbGFjZSgpLnVybChoYW5kbGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuPXJ1bGVzLmxlbmd0aCwgaTtcclxuICAgICAgICBmb3IgKGk9MDsgaTxuOyBpKyspIHtcclxuICAgICAgICAgIGlmIChjaGVjayhydWxlc1tpXSkpIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWx3YXlzIGNoZWNrIG90aGVyd2lzZSBsYXN0IHRvIGFsbG93IGR5bmFtaWMgdXBkYXRlcyB0byB0aGUgc2V0IG9mIHJ1bGVzXHJcbiAgICAgICAgaWYgKG90aGVyd2lzZSkgY2hlY2sob3RoZXJ3aXNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJHJvb3RTY29wZS4kb24oJyRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MnLCB1cGRhdGUpO1xyXG4gICAgICByZXR1cm4ge307XHJcbiAgICB9XTtcclxufVxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5yb3V0ZXInKS5wcm92aWRlcignJHVybFJvdXRlcicsICRVcmxSb3V0ZXJQcm92aWRlcik7XHJcblxyXG4kU3RhdGVQcm92aWRlci4kaW5qZWN0ID0gWyckdXJsUm91dGVyUHJvdmlkZXInLCAnJHVybE1hdGNoZXJGYWN0b3J5UHJvdmlkZXInLCAnJGxvY2F0aW9uUHJvdmlkZXInXTtcclxuZnVuY3Rpb24gJFN0YXRlUHJvdmlkZXIoICAgJHVybFJvdXRlclByb3ZpZGVyLCAgICR1cmxNYXRjaGVyRmFjdG9yeSwgICAgICAgICAgICRsb2NhdGlvblByb3ZpZGVyKSB7XHJcblxyXG4gIHZhciByb290LCBzdGF0ZXMgPSB7fSwgJHN0YXRlO1xyXG5cclxuICAvLyBCdWlsZHMgc3RhdGUgcHJvcGVydGllcyBmcm9tIGRlZmluaXRpb24gcGFzc2VkIHRvIHJlZ2lzdGVyU3RhdGUoKVxyXG4gIHZhciBzdGF0ZUJ1aWxkZXIgPSB7XHJcblxyXG4gICAgLy8gRGVyaXZlIHBhcmVudCBzdGF0ZSBmcm9tIGEgaGllcmFyY2hpY2FsIG5hbWUgb25seSBpZiAncGFyZW50JyBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkLlxyXG4gICAgLy8gc3RhdGUuY2hpbGRyZW4gPSBbXTtcclxuICAgIC8vIGlmIChwYXJlbnQpIHBhcmVudC5jaGlsZHJlbi5wdXNoKHN0YXRlKTtcclxuICAgIHBhcmVudDogZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgICAgaWYgKGlzRGVmaW5lZChzdGF0ZS5wYXJlbnQpICYmIHN0YXRlLnBhcmVudCkgcmV0dXJuIGZpbmRTdGF0ZShzdGF0ZS5wYXJlbnQpO1xyXG4gICAgICAvLyByZWdleCBtYXRjaGVzIGFueSB2YWxpZCBjb21wb3NpdGUgc3RhdGUgbmFtZVxyXG4gICAgICAvLyB3b3VsZCBtYXRjaCBcImNvbnRhY3QubGlzdFwiIGJ1dCBub3QgXCJjb250YWN0c1wiXHJcbiAgICAgIHZhciBjb21wb3NpdGVOYW1lID0gL14oLispXFwuW14uXSskLy5leGVjKHN0YXRlLm5hbWUpO1xyXG4gICAgICByZXR1cm4gY29tcG9zaXRlTmFtZSA/IGZpbmRTdGF0ZShjb21wb3NpdGVOYW1lWzFdKSA6IHJvb3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIGluaGVyaXQgJ2RhdGEnIGZyb20gcGFyZW50IGFuZCBvdmVycmlkZSBieSBvd24gdmFsdWVzIChpZiBhbnkpXHJcbiAgICBkYXRhOiBmdW5jdGlvbihzdGF0ZSkge1xyXG4gICAgICBpZiAoc3RhdGUucGFyZW50ICYmIHN0YXRlLnBhcmVudC5kYXRhKSB7XHJcbiAgICAgICAgc3RhdGUuZGF0YSA9IHN0YXRlLnNlbGYuZGF0YSA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBzdGF0ZS5wYXJlbnQuZGF0YSwgc3RhdGUuZGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN0YXRlLmRhdGE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEJ1aWxkIGEgVVJMTWF0Y2hlciBpZiBuZWNlc3NhcnksIGVpdGhlciB2aWEgYSByZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkxcclxuICAgIHVybDogZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgICAgdmFyIHVybCA9IHN0YXRlLnVybDtcclxuXHJcbiAgICAgIGlmIChpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgICAgaWYgKHVybC5jaGFyQXQoMCkgPT0gJ14nKSB7XHJcbiAgICAgICAgICByZXR1cm4gJHVybE1hdGNoZXJGYWN0b3J5LmNvbXBpbGUodXJsLnN1YnN0cmluZygxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoc3RhdGUucGFyZW50Lm5hdmlnYWJsZSB8fCByb290KS51cmwuY29uY2F0KHVybCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgkdXJsTWF0Y2hlckZhY3RvcnkuaXNNYXRjaGVyKHVybCkgfHwgdXJsID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdXJsICdcIiArIHVybCArIFwiJyBpbiBzdGF0ZSAnXCIgKyBzdGF0ZSArIFwiJ1wiKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY2xvc2VzdCBhbmNlc3RvciBzdGF0ZSB0aGF0IGhhcyBhIFVSTCAoaS5lLiBpcyBuYXZpZ2FibGUpXHJcbiAgICBuYXZpZ2FibGU6IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgIHJldHVybiBzdGF0ZS51cmwgPyBzdGF0ZSA6IChzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQubmF2aWdhYmxlIDogbnVsbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERlcml2ZSBwYXJhbWV0ZXJzIGZvciB0aGlzIHN0YXRlIGFuZCBlbnN1cmUgdGhleSdyZSBhIHN1cGVyLXNldCBvZiBwYXJlbnQncyBwYXJhbWV0ZXJzXHJcbiAgICBwYXJhbXM6IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgIGlmICghc3RhdGUucGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlLnVybCA/IHN0YXRlLnVybC5wYXJhbWV0ZXJzKCkgOiBzdGF0ZS5wYXJlbnQucGFyYW1zO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaXNBcnJheShzdGF0ZS5wYXJhbXMpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtcyBpbiBzdGF0ZSAnXCIgKyBzdGF0ZSArIFwiJ1wiKTtcclxuICAgICAgaWYgKHN0YXRlLnVybCkgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBwYXJhbXMgYW5kIHVybCBzcGVjaWNpZmllZCBpbiBzdGF0ZSAnXCIgKyBzdGF0ZSArIFwiJ1wiKTtcclxuICAgICAgcmV0dXJuIHN0YXRlLnBhcmFtcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gZXhwbGljaXQgbXVsdGktdmlldyBjb25maWd1cmF0aW9uLCBtYWtlIG9uZSB1cCBzbyB3ZSBkb24ndCBoYXZlXHJcbiAgICAvLyB0byBoYW5kbGUgYm90aCBjYXNlcyBpbiB0aGUgdmlldyBkaXJlY3RpdmUgbGF0ZXIuIE5vdGUgdGhhdCBoYXZpbmcgYW4gZXhwbGljaXRcclxuICAgIC8vICd2aWV3cycgcHJvcGVydHkgd2lsbCBtZWFuIHRoZSBkZWZhdWx0IHVubmFtZWQgdmlldyBwcm9wZXJ0aWVzIGFyZSBpZ25vcmVkLiBUaGlzXHJcbiAgICAvLyBpcyBhbHNvIGEgZ29vZCB0aW1lIHRvIHJlc29sdmUgdmlldyBuYW1lcyB0byBhYnNvbHV0ZSBuYW1lcywgc28gZXZlcnl0aGluZyBpcyBhXHJcbiAgICAvLyBzdHJhaWdodCBsb29rdXAgYXQgbGluayB0aW1lLlxyXG4gICAgdmlld3M6IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgIHZhciB2aWV3cyA9IHt9O1xyXG5cclxuICAgICAgZm9yRWFjaChpc0RlZmluZWQoc3RhdGUudmlld3MpID8gc3RhdGUudmlld3MgOiB7ICcnOiBzdGF0ZSB9LCBmdW5jdGlvbiAodmlldywgbmFtZSkge1xyXG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ0AnKSA8IDApIG5hbWUgKz0gJ0AnICsgc3RhdGUucGFyZW50Lm5hbWU7XHJcbiAgICAgICAgdmlld3NbbmFtZV0gPSB2aWV3O1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHZpZXdzO1xyXG4gICAgfSxcclxuXHJcbiAgICBvd25QYXJhbXM6IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgIGlmICghc3RhdGUucGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlLnBhcmFtcztcclxuICAgICAgfVxyXG4gICAgICB2YXIgcGFyYW1OYW1lcyA9IHt9OyBmb3JFYWNoKHN0YXRlLnBhcmFtcywgZnVuY3Rpb24gKHApIHsgcGFyYW1OYW1lc1twXSA9IHRydWU7IH0pO1xyXG5cclxuICAgICAgZm9yRWFjaChzdGF0ZS5wYXJlbnQucGFyYW1zLCBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIGlmICghcGFyYW1OYW1lc1twXSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgJ1wiICsgcCArIFwiJyBpbiBzdGF0ZSAnXCIgKyBzdGF0ZS5uYW1lICsgXCInXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJhbU5hbWVzW3BdID0gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXIgb3duUGFyYW1zID0gW107XHJcblxyXG4gICAgICBmb3JFYWNoKHBhcmFtTmFtZXMsIGZ1bmN0aW9uIChvd24sIHApIHtcclxuICAgICAgICBpZiAob3duKSBvd25QYXJhbXMucHVzaChwKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBvd25QYXJhbXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEtlZXAgYSBmdWxsIHBhdGggZnJvbSB0aGUgcm9vdCBkb3duIHRvIHRoaXMgc3RhdGUgYXMgdGhpcyBpcyBuZWVkZWQgZm9yIHN0YXRlIGFjdGl2YXRpb24uXHJcbiAgICBwYXRoOiBmdW5jdGlvbihzdGF0ZSkge1xyXG4gICAgICByZXR1cm4gc3RhdGUucGFyZW50ID8gc3RhdGUucGFyZW50LnBhdGguY29uY2F0KHN0YXRlKSA6IFtdOyAvLyBleGNsdWRlIHJvb3QgZnJvbSBwYXRoXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFNwZWVkIHVwICRzdGF0ZS5jb250YWlucygpIGFzIGl0J3MgdXNlZCBhIGxvdFxyXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uKHN0YXRlKSB7XHJcbiAgICAgIHZhciBpbmNsdWRlcyA9IHN0YXRlLnBhcmVudCA/IGV4dGVuZCh7fSwgc3RhdGUucGFyZW50LmluY2x1ZGVzKSA6IHt9O1xyXG4gICAgICBpbmNsdWRlc1tzdGF0ZS5uYW1lXSA9IHRydWU7XHJcbiAgICAgIHJldHVybiBpbmNsdWRlcztcclxuICAgIH1cclxuICB9O1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gZmluZFN0YXRlKHN0YXRlT3JOYW1lLCBiYXNlKSB7XHJcbiAgICB2YXIgaXNTdHIgPSBpc1N0cmluZyhzdGF0ZU9yTmFtZSksXHJcbiAgICAgICAgbmFtZSAgPSBpc1N0ciA/IHN0YXRlT3JOYW1lIDogc3RhdGVPck5hbWUubmFtZSxcclxuICAgICAgICBwYXRoICA9IG5hbWUuaW5kZXhPZihcIi5cIikgPT09IDAgfHwgbmFtZS5pbmRleE9mKFwiXlwiKSA9PT0gMDtcclxuXHJcbiAgICBpZiAocGF0aCkge1xyXG4gICAgICBpZiAoIWJhc2UpIHRocm93IG5ldyBFcnJvcihcIk5vIHJlZmVyZW5jZSBwb2ludCBnaXZlbiBmb3IgcGF0aCAnXCIgICsgbmFtZSArIFwiJ1wiKTtcclxuICAgICAgdmFyIHJlbCA9IG5hbWUuc3BsaXQoXCIuXCIpLCBpID0gMCwgcGF0aExlbmd0aCA9IHJlbC5sZW5ndGgsIGN1cnJlbnQgPSBiYXNlO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBwYXRoTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocmVsW2ldID09PSBcIlwiICYmIGkgPT09IDApIHtcclxuICAgICAgICAgIGN1cnJlbnQgPSBiYXNlO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWxbaV0gPT09IFwiXlwiKSB7XHJcbiAgICAgICAgICBpZiAoIWN1cnJlbnQucGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoICdcIiArIG5hbWUgKyBcIicgbm90IHZhbGlkIGZvciBzdGF0ZSAnXCIgKyBiYXNlLm5hbWUgKyBcIidcIik7XHJcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmVsID0gcmVsLnNsaWNlKGkpLmpvaW4oXCIuXCIpO1xyXG4gICAgICBuYW1lID0gY3VycmVudC5uYW1lICsgKGN1cnJlbnQubmFtZSAmJiByZWwgPyBcIi5cIiA6IFwiXCIpICsgcmVsO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0YXRlID0gc3RhdGVzW25hbWVdO1xyXG5cclxuICAgIGlmIChzdGF0ZSAmJiAoaXNTdHIgfHwgKCFpc1N0ciAmJiAoc3RhdGUgPT09IHN0YXRlT3JOYW1lIHx8IHN0YXRlLnNlbGYgPT09IHN0YXRlT3JOYW1lKSkpKSB7XHJcbiAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gcmVnaXN0ZXJTdGF0ZShzdGF0ZSkge1xyXG4gICAgLy8gV3JhcCBhIG5ldyBvYmplY3QgYXJvdW5kIHRoZSBzdGF0ZSBzbyB3ZSBjYW4gc3RvcmUgb3VyIHByaXZhdGUgZGV0YWlscyBlYXNpbHkuXHJcbiAgICBzdGF0ZSA9IGluaGVyaXQoc3RhdGUsIHtcclxuICAgICAgc2VsZjogc3RhdGUsXHJcbiAgICAgIHJlc29sdmU6IHN0YXRlLnJlc29sdmUgfHwge30sXHJcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubmFtZTsgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIG5hbWUgPSBzdGF0ZS5uYW1lO1xyXG4gICAgaWYgKCFpc1N0cmluZyhuYW1lKSB8fCBuYW1lLmluZGV4T2YoJ0AnKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJTdGF0ZSBtdXN0IGhhdmUgYSB2YWxpZCBuYW1lXCIpO1xyXG4gICAgaWYgKHN0YXRlc1tuYW1lXSkgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgJ1wiICsgbmFtZSArIFwiJycgaXMgYWxyZWFkeSBkZWZpbmVkXCIpO1xyXG5cclxuICAgIGZvciAodmFyIGtleSBpbiBzdGF0ZUJ1aWxkZXIpIHtcclxuICAgICAgc3RhdGVba2V5XSA9IHN0YXRlQnVpbGRlcltrZXldKHN0YXRlKTtcclxuICAgIH1cclxuICAgIHN0YXRlc1tuYW1lXSA9IHN0YXRlO1xyXG5cclxuICAgIC8vIFJlZ2lzdGVyIHRoZSBzdGF0ZSBpbiB0aGUgZ2xvYmFsIHN0YXRlIGxpc3QgYW5kIHdpdGggJHVybFJvdXRlciBpZiBuZWNlc3NhcnkuXHJcbiAgICBpZiAoIXN0YXRlWydhYnN0cmFjdCddICYmIHN0YXRlLnVybCkge1xyXG4gICAgICAkdXJsUm91dGVyUHJvdmlkZXIud2hlbihzdGF0ZS51cmwsIFsnJG1hdGNoJywgJyRzdGF0ZVBhcmFtcycsIGZ1bmN0aW9uICgkbWF0Y2gsICRzdGF0ZVBhcmFtcykge1xyXG4gICAgICAgIGlmICgkc3RhdGUuJGN1cnJlbnQubmF2aWdhYmxlICE9IHN0YXRlIHx8ICFlcXVhbEZvcktleXMoJG1hdGNoLCAkc3RhdGVQYXJhbXMpKSB7XHJcbiAgICAgICAgICAkc3RhdGUudHJhbnNpdGlvblRvKHN0YXRlLCAkbWF0Y2gsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1dKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG5cclxuICAvLyBJbXBsaWNpdCByb290IHN0YXRlIHRoYXQgaXMgYWx3YXlzIGFjdGl2ZVxyXG4gIHJvb3QgPSByZWdpc3RlclN0YXRlKHtcclxuICAgIG5hbWU6ICcnLFxyXG4gICAgdXJsOiAnXicsXHJcbiAgICB2aWV3czogbnVsbCxcclxuICAgICdhYnN0cmFjdCc6IHRydWVcclxuICB9KTtcclxuICByb290Lm5hdmlnYWJsZSA9IG51bGw7XHJcblxyXG5cclxuICAvLyAuc3RhdGUoc3RhdGUpXHJcbiAgLy8gLnN0YXRlKG5hbWUsIHN0YXRlKVxyXG4gIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICBmdW5jdGlvbiBzdGF0ZShuYW1lLCBkZWZpbml0aW9uKSB7XHJcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIGlmIChpc09iamVjdChuYW1lKSkgZGVmaW5pdGlvbiA9IG5hbWU7XHJcbiAgICBlbHNlIGRlZmluaXRpb24ubmFtZSA9IG5hbWU7XHJcbiAgICByZWdpc3RlclN0YXRlKGRlZmluaXRpb24pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyAkdXJsUm91dGVyIGlzIGluamVjdGVkIGp1c3QgdG8gZW5zdXJlIGl0IGdldHMgaW5zdGFudGlhdGVkXHJcbiAgdGhpcy4kZ2V0ID0gJGdldDtcclxuICAkZ2V0LiRpbmplY3QgPSBbJyRyb290U2NvcGUnLCAnJHEnLCAnJHZpZXcnLCAnJGluamVjdG9yJywgJyRyZXNvbHZlJywgJyRzdGF0ZVBhcmFtcycsICckbG9jYXRpb24nLCAnJHVybFJvdXRlciddO1xyXG4gIGZ1bmN0aW9uICRnZXQoICAgJHJvb3RTY29wZSwgICAkcSwgICAkdmlldywgICAkaW5qZWN0b3IsICAgJHJlc29sdmUsICAgJHN0YXRlUGFyYW1zLCAgICRsb2NhdGlvbiwgICAkdXJsUm91dGVyKSB7XHJcblxyXG4gICAgdmFyIFRyYW5zaXRpb25TdXBlcnNlZGVkID0gJHEucmVqZWN0KG5ldyBFcnJvcigndHJhbnNpdGlvbiBzdXBlcnNlZGVkJykpO1xyXG4gICAgdmFyIFRyYW5zaXRpb25QcmV2ZW50ZWQgPSAkcS5yZWplY3QobmV3IEVycm9yKCd0cmFuc2l0aW9uIHByZXZlbnRlZCcpKTtcclxuXHJcbiAgICByb290LmxvY2FscyA9IHsgcmVzb2x2ZTogbnVsbCwgZ2xvYmFsczogeyAkc3RhdGVQYXJhbXM6IHt9IH0gfTtcclxuICAgICRzdGF0ZSA9IHtcclxuICAgICAgcGFyYW1zOiB7fSxcclxuICAgICAgY3VycmVudDogcm9vdC5zZWxmLFxyXG4gICAgICAkY3VycmVudDogcm9vdCxcclxuICAgICAgdHJhbnNpdGlvbjogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICAkc3RhdGUuZ28gPSBmdW5jdGlvbiBnbyh0bywgcGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0bywgcGFyYW1zLCBleHRlbmQoeyBpbmhlcml0OiB0cnVlLCByZWxhdGl2ZTogJHN0YXRlLiRjdXJyZW50IH0sIG9wdGlvbnMpKTtcclxuICAgIH07XHJcblxyXG4gICAgJHN0YXRlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25Ubyh0bywgdG9QYXJhbXMsIG9wdGlvbnMpIHtcclxuICAgICAgaWYgKCFpc0RlZmluZWQob3B0aW9ucykpIG9wdGlvbnMgPSAob3B0aW9ucyA9PT0gdHJ1ZSB8fCBvcHRpb25zID09PSBmYWxzZSkgPyB7IGxvY2F0aW9uOiBvcHRpb25zIH0gOiB7fTtcclxuICAgICAgdG9QYXJhbXMgPSB0b1BhcmFtcyB8fCB7fTtcclxuICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7IGxvY2F0aW9uOiB0cnVlLCBpbmhlcml0OiBmYWxzZSwgcmVsYXRpdmU6IG51bGwgfSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICB2YXIgdG9TdGF0ZSA9IGZpbmRTdGF0ZSh0bywgb3B0aW9ucy5yZWxhdGl2ZSk7XHJcbiAgICAgIGlmICghaXNEZWZpbmVkKHRvU3RhdGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIHN0YXRlIFwiICsgdG9TdGF0ZSk7XHJcbiAgICAgIGlmICh0b1N0YXRlWydhYnN0cmFjdCddKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJhbnNpdGlvbiB0byBhYnN0cmFjdCBzdGF0ZSAnXCIgKyB0byArIFwiJ1wiKTtcclxuICAgICAgaWYgKG9wdGlvbnMuaW5oZXJpdCkgdG9QYXJhbXMgPSBpbmhlcml0UGFyYW1zKCRzdGF0ZVBhcmFtcywgdG9QYXJhbXMgfHwge30sICRzdGF0ZS4kY3VycmVudCwgdG9TdGF0ZSk7XHJcbiAgICAgIHRvID0gdG9TdGF0ZTtcclxuXHJcbiAgICAgIHZhciB0b1BhdGggPSB0by5wYXRoLFxyXG4gICAgICAgICAgZnJvbSA9ICRzdGF0ZS4kY3VycmVudCwgZnJvbVBhcmFtcyA9ICRzdGF0ZS5wYXJhbXMsIGZyb21QYXRoID0gZnJvbS5wYXRoO1xyXG5cclxuICAgICAgLy8gU3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBvZiB0aGUgcGF0aCwga2VlcCBhbGwgbGV2ZWxzIHRoYXQgaGF2ZW4ndCBjaGFuZ2VkXHJcbiAgICAgIHZhciBrZWVwLCBzdGF0ZSwgbG9jYWxzID0gcm9vdC5sb2NhbHMsIHRvTG9jYWxzID0gW107XHJcbiAgICAgIGZvciAoa2VlcCA9IDAsIHN0YXRlID0gdG9QYXRoW2tlZXBdO1xyXG4gICAgICAgICAgIHN0YXRlICYmIHN0YXRlID09PSBmcm9tUGF0aFtrZWVwXSAmJiBlcXVhbEZvcktleXModG9QYXJhbXMsIGZyb21QYXJhbXMsIHN0YXRlLm93blBhcmFtcyk7XHJcbiAgICAgICAgICAga2VlcCsrLCBzdGF0ZSA9IHRvUGF0aFtrZWVwXSkge1xyXG4gICAgICAgIGxvY2FscyA9IHRvTG9jYWxzW2tlZXBdID0gc3RhdGUubG9jYWxzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB3ZSdyZSBnb2luZyB0byB0aGUgc2FtZSBzdGF0ZSBhbmQgYWxsIGxvY2FscyBhcmUga2VwdCwgd2UndmUgZ290IG5vdGhpbmcgdG8gZG8uXHJcbiAgICAgIC8vIEJ1dCBjbGVhciAndHJhbnNpdGlvbicsIGFzIHdlIHN0aWxsIHdhbnQgdG8gY2FuY2VsIGFueSBvdGhlciBwZW5kaW5nIHRyYW5zaXRpb25zLlxyXG4gICAgICAvLyBUT0RPOiBXZSBtYXkgbm90IHdhbnQgdG8gYnVtcCAndHJhbnNpdGlvbicgaWYgd2UncmUgY2FsbGVkIGZyb20gYSBsb2NhdGlvbiBjaGFuZ2UgdGhhdCB3ZSd2ZSBpbml0aWF0ZWQgb3Vyc2VsdmVzLFxyXG4gICAgICAvLyBiZWNhdXNlIHdlIG1pZ2h0IGFjY2lkZW50YWxseSBhYm9ydCBhIGxlZ2l0aW1hdGUgdHJhbnNpdGlvbiBpbml0aWF0ZWQgZnJvbSBjb2RlP1xyXG4gICAgICBpZiAodG8gPT09IGZyb20gJiYgbG9jYWxzID09PSBmcm9tLmxvY2Fscykge1xyXG4gICAgICAgICRzdGF0ZS50cmFuc2l0aW9uID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gJHEud2hlbigkc3RhdGUuY3VycmVudCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vcm1hbGl6ZS9maWx0ZXIgcGFyYW1ldGVycyBiZWZvcmUgd2UgcGFzcyB0aGVtIHRvIGV2ZW50IGhhbmRsZXJzIGV0Yy5cclxuICAgICAgdG9QYXJhbXMgPSBub3JtYWxpemUodG8ucGFyYW1zLCB0b1BhcmFtcyB8fCB7fSk7XHJcblxyXG4gICAgICAvLyBCcm9hZGNhc3Qgc3RhcnQgZXZlbnQgYW5kIGNhbmNlbCB0aGUgdHJhbnNpdGlvbiBpZiByZXF1ZXN0ZWRcclxuICAgICAgdmFyIGV2dCA9ICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJHN0YXRlQ2hhbmdlU3RhcnQnLCB0by5zZWxmLCB0b1BhcmFtcywgZnJvbS5zZWxmLCBmcm9tUGFyYW1zKTtcclxuICAgICAgaWYgKGV2dC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm4gVHJhbnNpdGlvblByZXZlbnRlZDtcclxuXHJcbiAgICAgIC8vIFJlc29sdmUgbG9jYWxzIGZvciB0aGUgcmVtYWluaW5nIHN0YXRlcywgYnV0IGRvbid0IHVwZGF0ZSBhbnkgZ2xvYmFsIHN0YXRlIGp1c3RcclxuICAgICAgLy8geWV0IC0tIGlmIGFueXRoaW5nIGZhaWxzIHRvIHJlc29sdmUgdGhlIGN1cnJlbnQgc3RhdGUgbmVlZHMgdG8gcmVtYWluIHVudG91Y2hlZC5cclxuICAgICAgLy8gV2UgYWxzbyBzZXQgdXAgYW4gaW5oZXJpdGFuY2UgY2hhaW4gZm9yIHRoZSBsb2NhbHMgaGVyZS4gVGhpcyBhbGxvd3MgdGhlIHZpZXcgZGlyZWN0aXZlXHJcbiAgICAgIC8vIHRvIHF1aWNrbHkgbG9vayB1cCB0aGUgY29ycmVjdCBkZWZpbml0aW9uIGZvciBlYWNoIHZpZXcgaW4gdGhlIGN1cnJlbnQgc3RhdGUuIEV2ZW5cclxuICAgICAgLy8gdGhvdWdoIHdlIGNyZWF0ZSB0aGUgbG9jYWxzIG9iamVjdCBpdHNlbGYgb3V0c2lkZSByZXNvbHZlU3RhdGUoKSwgaXQgaXMgaW5pdGlhbGx5XHJcbiAgICAgIC8vIGVtcHR5IGFuZCBnZXRzIGZpbGxlZCBhc3luY2hyb25vdXNseS4gV2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBwcm9taXNlIGZvciB0aGVcclxuICAgICAgLy8gKGZ1bGx5IHJlc29sdmVkKSBjdXJyZW50IGxvY2FscywgYW5kIHBhc3MgdGhpcyBkb3duIHRoZSBjaGFpbi5cclxuICAgICAgdmFyIHJlc29sdmVkID0gJHEud2hlbihsb2NhbHMpO1xyXG4gICAgICBmb3IgKHZhciBsPWtlZXA7IGw8dG9QYXRoLmxlbmd0aDsgbCsrLCBzdGF0ZT10b1BhdGhbbF0pIHtcclxuICAgICAgICBsb2NhbHMgPSB0b0xvY2Fsc1tsXSA9IGluaGVyaXQobG9jYWxzKTtcclxuICAgICAgICByZXNvbHZlZCA9IHJlc29sdmVTdGF0ZShzdGF0ZSwgdG9QYXJhbXMsIHN0YXRlPT09dG8sIHJlc29sdmVkLCBsb2NhbHMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPbmNlIGV2ZXJ5dGhpbmcgaXMgcmVzb2x2ZWQsIHdlciBhcmUgcmVhZHkgdG8gcGVyZm9ybSB0aGUgYWN0dWFsIHRyYW5zaXRpb25cclxuICAgICAgLy8gYW5kIHJldHVybiBhIHByb21pc2UgZm9yIHRoZSBuZXcgc3RhdGUuIFdlIGFsc28ga2VlcCB0cmFjayBvZiB3aGF0IHRoZVxyXG4gICAgICAvLyBjdXJyZW50IHByb21pc2UgaXMsIHNvIHRoYXQgd2UgY2FuIGRldGVjdCBvdmVybGFwcGluZyB0cmFuc2l0aW9ucyBhbmRcclxuICAgICAgLy8ga2VlcCBvbmx5IHRoZSBvdXRjb21lIG9mIHRoZSBsYXN0IHRyYW5zaXRpb24uXHJcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJHN0YXRlLnRyYW5zaXRpb24gPSByZXNvbHZlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbCwgZW50ZXJpbmcsIGV4aXRpbmc7XHJcblxyXG4gICAgICAgIGlmICgkc3RhdGUudHJhbnNpdGlvbiAhPT0gdHJhbnNpdGlvbikgcmV0dXJuIFRyYW5zaXRpb25TdXBlcnNlZGVkO1xyXG5cclxuICAgICAgICAvLyBFeGl0ICdmcm9tJyBzdGF0ZXMgbm90IGtlcHRcclxuICAgICAgICBmb3IgKGw9ZnJvbVBhdGgubGVuZ3RoLTE7IGw+PWtlZXA7IGwtLSkge1xyXG4gICAgICAgICAgZXhpdGluZyA9IGZyb21QYXRoW2xdO1xyXG4gICAgICAgICAgaWYgKGV4aXRpbmcuc2VsZi5vbkV4aXQpIHtcclxuICAgICAgICAgICAgJGluamVjdG9yLmludm9rZShleGl0aW5nLnNlbGYub25FeGl0LCBleGl0aW5nLnNlbGYsIGV4aXRpbmcubG9jYWxzLmdsb2JhbHMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZXhpdGluZy5sb2NhbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRW50ZXIgJ3RvJyBzdGF0ZXMgbm90IGtlcHRcclxuICAgICAgICBmb3IgKGw9a2VlcDsgbDx0b1BhdGgubGVuZ3RoOyBsKyspIHtcclxuICAgICAgICAgIGVudGVyaW5nID0gdG9QYXRoW2xdO1xyXG4gICAgICAgICAgZW50ZXJpbmcubG9jYWxzID0gdG9Mb2NhbHNbbF07XHJcbiAgICAgICAgICBpZiAoZW50ZXJpbmcuc2VsZi5vbkVudGVyKSB7XHJcbiAgICAgICAgICAgICRpbmplY3Rvci5pbnZva2UoZW50ZXJpbmcuc2VsZi5vbkVudGVyLCBlbnRlcmluZy5zZWxmLCBlbnRlcmluZy5sb2NhbHMuZ2xvYmFscyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgZ2xvYmFscyBpbiAkc3RhdGVcclxuICAgICAgICAkc3RhdGUuJGN1cnJlbnQgPSB0bztcclxuICAgICAgICAkc3RhdGUuY3VycmVudCA9IHRvLnNlbGY7XHJcbiAgICAgICAgJHN0YXRlLnBhcmFtcyA9IHRvUGFyYW1zO1xyXG4gICAgICAgIGNvcHkoJHN0YXRlLnBhcmFtcywgJHN0YXRlUGFyYW1zKTtcclxuICAgICAgICAkc3RhdGUudHJhbnNpdGlvbiA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSAkbG9jYXRpb25cclxuICAgICAgICB2YXIgdG9OYXYgPSB0by5uYXZpZ2FibGU7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb24gJiYgdG9OYXYpIHtcclxuICAgICAgICAgICRsb2NhdGlvbi51cmwodG9OYXYudXJsLmZvcm1hdCh0b05hdi5sb2NhbHMuZ2xvYmFscy4kc3RhdGVQYXJhbXMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJHN0YXRlQ2hhbmdlU3VjY2VzcycsIHRvLnNlbGYsIHRvUGFyYW1zLCBmcm9tLnNlbGYsIGZyb21QYXJhbXMpO1xyXG5cclxuICAgICAgICByZXR1cm4gJHN0YXRlLmN1cnJlbnQ7XHJcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgIGlmICgkc3RhdGUudHJhbnNpdGlvbiAhPT0gdHJhbnNpdGlvbikgcmV0dXJuIFRyYW5zaXRpb25TdXBlcnNlZGVkO1xyXG5cclxuICAgICAgICAkc3RhdGUudHJhbnNpdGlvbiA9IG51bGw7XHJcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCckc3RhdGVDaGFuZ2VFcnJvcicsIHRvLnNlbGYsIHRvUGFyYW1zLCBmcm9tLnNlbGYsIGZyb21QYXJhbXMsIGVycm9yKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICRxLnJlamVjdChlcnJvcik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHRyYW5zaXRpb247XHJcbiAgICB9O1xyXG5cclxuICAgICRzdGF0ZS5pcyA9IGZ1bmN0aW9uIGlzKHN0YXRlT3JOYW1lKSB7XHJcbiAgICAgIHZhciBzdGF0ZSA9IGZpbmRTdGF0ZShzdGF0ZU9yTmFtZSk7XHJcbiAgICAgIHJldHVybiAoaXNEZWZpbmVkKHN0YXRlKSkgPyAkc3RhdGUuJGN1cnJlbnQgPT09IHN0YXRlIDogdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAkc3RhdGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyhzdGF0ZU9yTmFtZSkge1xyXG4gICAgICB2YXIgc3RhdGUgPSBmaW5kU3RhdGUoc3RhdGVPck5hbWUpO1xyXG4gICAgICByZXR1cm4gKGlzRGVmaW5lZChzdGF0ZSkpID8gaXNEZWZpbmVkKCRzdGF0ZS4kY3VycmVudC5pbmNsdWRlc1tzdGF0ZS5uYW1lXSkgOiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgICRzdGF0ZS5ocmVmID0gZnVuY3Rpb24gaHJlZihzdGF0ZU9yTmFtZSwgcGFyYW1zLCBvcHRpb25zKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBleHRlbmQoeyBsb3NzeTogdHJ1ZSwgaW5oZXJpdDogZmFsc2UsIHJlbGF0aXZlOiAkc3RhdGUuJGN1cnJlbnQgfSwgb3B0aW9ucyB8fCB7fSk7XHJcbiAgICAgIHZhciBzdGF0ZSA9IGZpbmRTdGF0ZShzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XHJcbiAgICAgIGlmICghaXNEZWZpbmVkKHN0YXRlKSkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICBwYXJhbXMgPSBpbmhlcml0UGFyYW1zKCRzdGF0ZVBhcmFtcywgcGFyYW1zIHx8IHt9LCAkc3RhdGUuJGN1cnJlbnQsIHN0YXRlKTtcclxuICAgICAgdmFyIG5hdiA9IChzdGF0ZSAmJiBvcHRpb25zLmxvc3N5KSA/IHN0YXRlLm5hdmlnYWJsZSA6IHN0YXRlO1xyXG4gICAgICB2YXIgdXJsID0gKG5hdiAmJiBuYXYudXJsKSA/IG5hdi51cmwuZm9ybWF0KG5vcm1hbGl6ZShzdGF0ZS5wYXJhbXMsIHBhcmFtcyB8fCB7fSkpIDogbnVsbDtcclxuICAgICAgcmV0dXJuICEkbG9jYXRpb25Qcm92aWRlci5odG1sNU1vZGUoKSAmJiB1cmwgPyBcIiNcIiArIHVybCA6IHVybDtcclxuICAgIH07XHJcblxyXG4gICAgJHN0YXRlLmdldCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSkge1xyXG4gICAgICB2YXIgc3RhdGUgPSBmaW5kU3RhdGUoc3RhdGVPck5hbWUpO1xyXG4gICAgICByZXR1cm4gKHN0YXRlICYmIHN0YXRlLnNlbGYpID8gc3RhdGUuc2VsZiA6IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlc29sdmVTdGF0ZShzdGF0ZSwgcGFyYW1zLCBwYXJhbXNBcmVGaWx0ZXJlZCwgaW5oZXJpdGVkLCBkc3QpIHtcclxuICAgICAgLy8gTWFrZSBhIHJlc3RyaWN0ZWQgJHN0YXRlUGFyYW1zIHdpdGggb25seSB0aGUgcGFyYW1ldGVycyB0aGF0IGFwcGx5IHRvIHRoaXMgc3RhdGUgaWZcclxuICAgICAgLy8gbmVjZXNzYXJ5LiBJbiBhZGRpdGlvbiB0byBiZWluZyBhdmFpbGFibGUgdG8gdGhlIGNvbnRyb2xsZXIgYW5kIG9uRW50ZXIvb25FeGl0IGNhbGxiYWNrcyxcclxuICAgICAgLy8gd2UgYWxzbyBuZWVkICRzdGF0ZVBhcmFtcyB0byBiZSBhdmFpbGFibGUgZm9yIGFueSAkaW5qZWN0b3IgY2FsbHMgd2UgbWFrZSBkdXJpbmcgdGhlXHJcbiAgICAgIC8vIGRlcGVuZGVuY3kgcmVzb2x1dGlvbiBwcm9jZXNzLlxyXG4gICAgICB2YXIgJHN0YXRlUGFyYW1zID0gKHBhcmFtc0FyZUZpbHRlcmVkKSA/IHBhcmFtcyA6IGZpbHRlckJ5S2V5cyhzdGF0ZS5wYXJhbXMsIHBhcmFtcyk7XHJcbiAgICAgIHZhciBsb2NhbHMgPSB7ICRzdGF0ZVBhcmFtczogJHN0YXRlUGFyYW1zIH07XHJcblxyXG4gICAgICAvLyBSZXNvbHZlICdnbG9iYWwnIGRlcGVuZGVuY2llcyBmb3IgdGhlIHN0YXRlLCBpLmUuIHRob3NlIG5vdCBzcGVjaWZpYyB0byBhIHZpZXcuXHJcbiAgICAgIC8vIFdlJ3JlIGFsc28gaW5jbHVkaW5nICRzdGF0ZVBhcmFtcyBpbiB0aGlzOyB0aGF0IHdheSB0aGUgcGFyYW1ldGVycyBhcmUgcmVzdHJpY3RlZFxyXG4gICAgICAvLyB0byB0aGUgc2V0IHRoYXQgc2hvdWxkIGJlIHZpc2libGUgdG8gdGhlIHN0YXRlLCBhbmQgYXJlIGluZGVwZW5kZW50IG9mIHdoZW4gd2UgdXBkYXRlXHJcbiAgICAgIC8vIHRoZSBnbG9iYWwgJHN0YXRlIGFuZCAkc3RhdGVQYXJhbXMgdmFsdWVzLlxyXG4gICAgICBkc3QucmVzb2x2ZSA9ICRyZXNvbHZlLnJlc29sdmUoc3RhdGUucmVzb2x2ZSwgbG9jYWxzLCBkc3QucmVzb2x2ZSwgc3RhdGUpO1xyXG4gICAgICB2YXIgcHJvbWlzZXMgPSBbIGRzdC5yZXNvbHZlLnRoZW4oZnVuY3Rpb24gKGdsb2JhbHMpIHtcclxuICAgICAgICBkc3QuZ2xvYmFscyA9IGdsb2JhbHM7XHJcbiAgICAgIH0pIF07XHJcbiAgICAgIGlmIChpbmhlcml0ZWQpIHByb21pc2VzLnB1c2goaW5oZXJpdGVkKTtcclxuXHJcbiAgICAgIC8vIFJlc29sdmUgdGVtcGxhdGUgYW5kIGRlcGVuZGVuY2llcyBmb3IgYWxsIHZpZXdzLlxyXG4gICAgICBmb3JFYWNoKHN0YXRlLnZpZXdzLCBmdW5jdGlvbiAodmlldywgbmFtZSkge1xyXG4gICAgICAgIHZhciBpbmplY3RhYmxlcyA9ICh2aWV3LnJlc29sdmUgJiYgdmlldy5yZXNvbHZlICE9PSBzdGF0ZS5yZXNvbHZlID8gdmlldy5yZXNvbHZlIDoge30pO1xyXG4gICAgICAgIGluamVjdGFibGVzLiR0ZW1wbGF0ZSA9IFsgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuICR2aWV3LmxvYWQobmFtZSwgeyB2aWV3OiB2aWV3LCBsb2NhbHM6IGxvY2FscywgcGFyYW1zOiAkc3RhdGVQYXJhbXMsIG5vdGlmeTogZmFsc2UgfSkgfHwgJyc7XHJcbiAgICAgICAgfV07XHJcblxyXG4gICAgICAgIHByb21pc2VzLnB1c2goJHJlc29sdmUucmVzb2x2ZShpbmplY3RhYmxlcywgbG9jYWxzLCBkc3QucmVzb2x2ZSwgc3RhdGUpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgLy8gUmVmZXJlbmNlcyB0byB0aGUgY29udHJvbGxlciAob25seSBpbnN0YW50aWF0ZWQgYXQgbGluayB0aW1lKVxyXG4gICAgICAgICAgcmVzdWx0LiQkY29udHJvbGxlciA9IHZpZXcuY29udHJvbGxlcjtcclxuICAgICAgICAgIC8vIFByb3ZpZGUgYWNjZXNzIHRvIHRoZSBzdGF0ZSBpdHNlbGYgZm9yIGludGVybmFsIHVzZVxyXG4gICAgICAgICAgcmVzdWx0LiQkc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgIGRzdFtuYW1lXSA9IHJlc3VsdDtcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gV2FpdCBmb3IgYWxsIHRoZSBwcm9taXNlcyBhbmQgdGhlbiByZXR1cm4gdGhlIGFjdGl2YXRpb24gb2JqZWN0XHJcbiAgICAgIHJldHVybiAkcS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiBkc3Q7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAkc3RhdGU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBub3JtYWxpemUoa2V5cywgdmFsdWVzKSB7XHJcbiAgICB2YXIgbm9ybWFsaXplZCA9IHt9O1xyXG5cclxuICAgIGZvckVhY2goa2V5cywgZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW25hbWVdO1xyXG4gICAgICBub3JtYWxpemVkW25hbWVdID0gKHZhbHVlICE9IG51bGwpID8gU3RyaW5nKHZhbHVlKSA6IG51bGw7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBub3JtYWxpemVkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXF1YWxGb3JLZXlzKGEsIGIsIGtleXMpIHtcclxuICAgIC8vIElmIGtleXMgbm90IHByb3ZpZGVkLCBhc3N1bWUga2V5cyBmcm9tIG9iamVjdCAnYSdcclxuICAgIGlmICgha2V5cykge1xyXG4gICAgICBrZXlzID0gW107XHJcbiAgICAgIGZvciAodmFyIG4gaW4gYSkga2V5cy5wdXNoKG4pOyAvLyBVc2VkIGluc3RlYWQgb2YgT2JqZWN0LmtleXMoKSBmb3IgSUU4IGNvbXBhdGliaWxpdHlcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgayA9IGtleXNbaV07XHJcbiAgICAgIGlmIChhW2tdICE9IGJba10pIHJldHVybiBmYWxzZTsgLy8gTm90ICc9PT0nLCB2YWx1ZXMgYXJlbid0IG5lY2Vzc2FyaWx5IG5vcm1hbGl6ZWRcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmlsdGVyQnlLZXlzKGtleXMsIHZhbHVlcykge1xyXG4gICAgdmFyIGZpbHRlcmVkID0ge307XHJcblxyXG4gICAgZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICBmaWx0ZXJlZFtuYW1lXSA9IHZhbHVlc1tuYW1lXTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGZpbHRlcmVkO1xyXG4gIH1cclxufVxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXHJcbiAgLnZhbHVlKCckc3RhdGVQYXJhbXMnLCB7fSlcclxuICAucHJvdmlkZXIoJyRzdGF0ZScsICRTdGF0ZVByb3ZpZGVyKTtcclxuXHJcblxyXG4kVmlld1Byb3ZpZGVyLiRpbmplY3QgPSBbXTtcclxuZnVuY3Rpb24gJFZpZXdQcm92aWRlcigpIHtcclxuXHJcbiAgdGhpcy4kZ2V0ID0gJGdldDtcclxuICAkZ2V0LiRpbmplY3QgPSBbJyRyb290U2NvcGUnLCAnJHRlbXBsYXRlRmFjdG9yeSddO1xyXG4gIGZ1bmN0aW9uICRnZXQoICAgJHJvb3RTY29wZSwgICAkdGVtcGxhdGVGYWN0b3J5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvLyAkdmlldy5sb2FkKCdmdWxsLnZpZXdOYW1lJywgeyB0ZW1wbGF0ZTogLi4uLCBjb250cm9sbGVyOiAuLi4sIHJlc29sdmU6IC4uLiwgYXN5bmM6IGZhbHNlLCBwYXJhbXM6IC4uLiB9KVxyXG4gICAgICBsb2FkOiBmdW5jdGlvbiBsb2FkKG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcmVzdWx0LCBkZWZhdWx0cyA9IHtcclxuICAgICAgICAgIHRlbXBsYXRlOiBudWxsLCBjb250cm9sbGVyOiBudWxsLCB2aWV3OiBudWxsLCBsb2NhbHM6IG51bGwsIG5vdGlmeTogdHJ1ZSwgYXN5bmM6IHRydWUsIHBhcmFtczoge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy52aWV3KSB7XHJcbiAgICAgICAgICByZXN1bHQgPSAkdGVtcGxhdGVGYWN0b3J5LmZyb21Db25maWcob3B0aW9ucy52aWV3LCBvcHRpb25zLnBhcmFtcywgb3B0aW9ucy5sb2NhbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0ICYmIG9wdGlvbnMubm90aWZ5KSB7XHJcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyR2aWV3Q29udGVudExvYWRpbmcnLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbmFuZ3VsYXIubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5wcm92aWRlcignJHZpZXcnLCAkVmlld1Byb3ZpZGVyKTtcclxuXHJcblxyXG4kVmlld0RpcmVjdGl2ZS4kaW5qZWN0ID0gWyckc3RhdGUnLCAnJGNvbXBpbGUnLCAnJGNvbnRyb2xsZXInLCAnJGluamVjdG9yJywgJyRhbmNob3JTY3JvbGwnXTtcclxuZnVuY3Rpb24gJFZpZXdEaXJlY3RpdmUoICAgJHN0YXRlLCAgICRjb21waWxlLCAgICRjb250cm9sbGVyLCAgICRpbmplY3RvciwgICAkYW5jaG9yU2Nyb2xsKSB7XHJcbiAgLy8gVE9ETzogQ2hhbmdlIHRvICRpbmplY3Rvci5oYXMoKSB3aGVuIHdlIHZlcnNpb24gYnVtcCB0byBBbmd1bGFyIDEuMS41LlxyXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9ibG9iL21hc3Rlci9DSEFOR0VMT0cubWQjMTE1LXRyaWFuZ2xlLXNxdWFyaWZpY2F0aW9uLTIwMTMtMDUtMjJcclxuICB2YXIgJGFuaW1hdG9yOyB0cnkgeyAkYW5pbWF0b3IgPSAkaW5qZWN0b3IuZ2V0KCckYW5pbWF0b3InKTsgfSBjYXRjaCAoZSkgeyAvKiBkbyBub3RoaW5nICovIH1cclxuICB2YXIgdmlld0lzVXBkYXRpbmcgPSBmYWxzZTtcclxuXHJcbiAgdmFyIGRpcmVjdGl2ZSA9IHtcclxuICAgIHJlc3RyaWN0OiAnRUNBJyxcclxuICAgIHRlcm1pbmFsOiB0cnVlLFxyXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyLCB0cmFuc2NsdWRlKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gICAgICAgIHZhciB2aWV3U2NvcGUsIHZpZXdMb2NhbHMsXHJcbiAgICAgICAgICAgIG5hbWUgPSBhdHRyW2RpcmVjdGl2ZS5uYW1lXSB8fCBhdHRyLm5hbWUgfHwgJycsXHJcbiAgICAgICAgICAgIG9ubG9hZEV4cCA9IGF0dHIub25sb2FkIHx8ICcnLFxyXG4gICAgICAgICAgICBhbmltYXRlID0gaXNEZWZpbmVkKCRhbmltYXRvcikgJiYgJGFuaW1hdG9yKHNjb3BlLCBhdHRyKTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyBhIHNldCBvZiBET00gbWFuaXB1bGF0aW9uIGZ1bmN0aW9ucyBiYXNlZCBvbiB3aGV0aGVyIGFuaW1hdGlvblxyXG4gICAgICAgIC8vIHNob3VsZCBiZSBwZXJmb3JtZWRcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBmdW5jdGlvbihkb0FuaW1hdGUpIHtcclxuICAgICAgICAgIHJldHVybiAoe1xyXG4gICAgICAgICAgICBcInRydWVcIjoge1xyXG4gICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oZWxlbWVudCkgeyBhbmltYXRlLmxlYXZlKGVsZW1lbnQuY29udGVudHMoKSwgZWxlbWVudCk7IH0sXHJcbiAgICAgICAgICAgICAgcmVzdG9yZTogZnVuY3Rpb24oY29tcGlsZWQsIGVsZW1lbnQpIHsgYW5pbWF0ZS5lbnRlcihjb21waWxlZCwgZWxlbWVudCk7IH0sXHJcbiAgICAgICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKHRlbXBsYXRlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+PC9kaXY+JykuaHRtbCh0ZW1wbGF0ZSkuY29udGVudHMoKTtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGUuZW50ZXIoY29udGVudHMsIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJmYWxzZVwiOiB7XHJcbiAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihlbGVtZW50KSB7IGVsZW1lbnQuaHRtbCgnJyk7IH0sXHJcbiAgICAgICAgICAgICAgcmVzdG9yZTogZnVuY3Rpb24oY29tcGlsZWQsIGVsZW1lbnQpIHsgZWxlbWVudC5hcHBlbmQoY29tcGlsZWQpOyB9LFxyXG4gICAgICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbih0ZW1wbGF0ZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5odG1sKHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNvbnRlbnRzKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVtkb0FuaW1hdGUudG9TdHJpbmcoKV07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gUHV0IGJhY2sgdGhlIGNvbXBpbGVkIGluaXRpYWwgdmlld1xyXG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKHRyYW5zY2x1ZGUoc2NvcGUpKTtcclxuXHJcbiAgICAgICAgLy8gRmluZCB0aGUgZGV0YWlscyBvZiB0aGUgcGFyZW50IHZpZXcgZGlyZWN0aXZlIChpZiBhbnkpIGFuZCB1c2UgaXRcclxuICAgICAgICAvLyB0byBkZXJpdmUgb3VyIG93biBxdWFsaWZpZWQgdmlldyBuYW1lLCB0aGVuIGhhbmcgb3VyIG93biBkZXRhaWxzXHJcbiAgICAgICAgLy8gb2ZmIHRoZSBET00gc28gY2hpbGQgZGlyZWN0aXZlcyBjYW4gZmluZCBpdC5cclxuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQoKS5pbmhlcml0ZWREYXRhKCckdWlWaWV3Jyk7XHJcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignQCcpIDwgMCkgbmFtZSAgPSBuYW1lICsgJ0AnICsgKHBhcmVudCA/IHBhcmVudC5zdGF0ZS5uYW1lIDogJycpO1xyXG4gICAgICAgIHZhciB2aWV3ID0geyBuYW1lOiBuYW1lLCBzdGF0ZTogbnVsbCB9O1xyXG4gICAgICAgIGVsZW1lbnQuZGF0YSgnJHVpVmlldycsIHZpZXcpO1xyXG5cclxuICAgICAgICB2YXIgZXZlbnRIb29rID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAodmlld0lzVXBkYXRpbmcpIHJldHVybjtcclxuICAgICAgICAgIHZpZXdJc1VwZGF0aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICB0cnkgeyB1cGRhdGVWaWV3KHRydWUpOyB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHZpZXdJc1VwZGF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2aWV3SXNVcGRhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIGV2ZW50SG9vayk7XHJcbiAgICAgICAgc2NvcGUuJG9uKCckdmlld0NvbnRlbnRMb2FkaW5nJywgZXZlbnRIb29rKTtcclxuICAgICAgICB1cGRhdGVWaWV3KGZhbHNlKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmlldyhkb0FuaW1hdGUpIHtcclxuICAgICAgICAgIHZhciBsb2NhbHMgPSAkc3RhdGUuJGN1cnJlbnQgJiYgJHN0YXRlLiRjdXJyZW50LmxvY2Fsc1tuYW1lXTtcclxuICAgICAgICAgIGlmIChsb2NhbHMgPT09IHZpZXdMb2NhbHMpIHJldHVybjsgLy8gbm90aGluZyB0byBkb1xyXG4gICAgICAgICAgdmFyIHJlbmRlciA9IHJlbmRlcmVyKGFuaW1hdGUgJiYgZG9BbmltYXRlKTtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgY29udGVudFxyXG4gICAgICAgICAgcmVuZGVyLnJlbW92ZShlbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAvLyBEZXN0cm95IHByZXZpb3VzIHZpZXcgc2NvcGVcclxuICAgICAgICAgIGlmICh2aWV3U2NvcGUpIHtcclxuICAgICAgICAgICAgdmlld1Njb3BlLiRkZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHZpZXdTY29wZSA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCFsb2NhbHMpIHtcclxuICAgICAgICAgICAgdmlld0xvY2FscyA9IG51bGw7XHJcbiAgICAgICAgICAgIHZpZXcuc3RhdGUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgaW5pdGlhbCB2aWV3XHJcbiAgICAgICAgICAgIHJldHVybiByZW5kZXIucmVzdG9yZSh0cmFuc2NsdWRlKHNjb3BlKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmlld0xvY2FscyA9IGxvY2FscztcclxuICAgICAgICAgIHZpZXcuc3RhdGUgPSBsb2NhbHMuJCRzdGF0ZTtcclxuXHJcbiAgICAgICAgICB2YXIgbGluayA9ICRjb21waWxlKHJlbmRlci5wb3B1bGF0ZShsb2NhbHMuJHRlbXBsYXRlLCBlbGVtZW50KSk7XHJcbiAgICAgICAgICB2aWV3U2NvcGUgPSBzY29wZS4kbmV3KCk7XHJcblxyXG4gICAgICAgICAgaWYgKGxvY2Fscy4kJGNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgbG9jYWxzLiRzY29wZSA9IHZpZXdTY29wZTtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSAkY29udHJvbGxlcihsb2NhbHMuJCRjb250cm9sbGVyLCBsb2NhbHMpO1xyXG4gICAgICAgICAgICBlbGVtZW50LmNoaWxkcmVuKCkuZGF0YSgnJG5nQ29udHJvbGxlckNvbnRyb2xsZXInLCBjb250cm9sbGVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxpbmsodmlld1Njb3BlKTtcclxuICAgICAgICAgIHZpZXdTY29wZS4kZW1pdCgnJHZpZXdDb250ZW50TG9hZGVkJyk7XHJcbiAgICAgICAgICBpZiAob25sb2FkRXhwKSB2aWV3U2NvcGUuJGV2YWwob25sb2FkRXhwKTtcclxuXHJcbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIHNlZW1zIHN0cmFuZ2UsIHNob3VsZG4ndCAkYW5jaG9yU2Nyb2xsIGxpc3RlbiBmb3IgJHZpZXdDb250ZW50TG9hZGVkIGlmIG5lY2Vzc2FyeT9cclxuICAgICAgICAgIC8vICRhbmNob3JTY3JvbGwgbWlnaHQgbGlzdGVuIG9uIGV2ZW50Li4uXHJcbiAgICAgICAgICAkYW5jaG9yU2Nyb2xsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbiAgcmV0dXJuIGRpcmVjdGl2ZTtcclxufVxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLmRpcmVjdGl2ZSgndWlWaWV3JywgJFZpZXdEaXJlY3RpdmUpO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VTdGF0ZVJlZihyZWYpIHtcclxuICB2YXIgcGFyc2VkID0gcmVmLm1hdGNoKC9eKFteKF0rPylcXHMqKFxcKCguKilcXCkpPyQvKTtcclxuICBpZiAoIXBhcnNlZCB8fCBwYXJzZWQubGVuZ3RoICE9PSA0KSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIHJlZiAnXCIgKyByZWYgKyBcIidcIik7XHJcbiAgcmV0dXJuIHsgc3RhdGU6IHBhcnNlZFsxXSwgcGFyYW1FeHByOiBwYXJzZWRbM10gfHwgbnVsbCB9O1xyXG59XHJcblxyXG4kU3RhdGVSZWZEaXJlY3RpdmUuJGluamVjdCA9IFsnJHN0YXRlJ107XHJcbmZ1bmN0aW9uICRTdGF0ZVJlZkRpcmVjdGl2ZSgkc3RhdGUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG4gICAgICB2YXIgcmVmID0gcGFyc2VTdGF0ZVJlZihhdHRycy51aVNyZWYpO1xyXG4gICAgICB2YXIgcGFyYW1zID0gbnVsbCwgdXJsID0gbnVsbCwgYmFzZSA9ICRzdGF0ZS4kY3VycmVudDtcclxuICAgICAgdmFyIGlzRm9ybSA9IGVsZW1lbnRbMF0ubm9kZU5hbWUgPT09IFwiRk9STVwiO1xyXG4gICAgICB2YXIgYXR0ciA9IGlzRm9ybSA/IFwiYWN0aW9uXCIgOiBcImhyZWZcIiwgbmF2ID0gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciBzdGF0ZURhdGEgPSBlbGVtZW50LnBhcmVudCgpLmluaGVyaXRlZERhdGEoJyR1aVZpZXcnKTtcclxuXHJcbiAgICAgIGlmIChzdGF0ZURhdGEgJiYgc3RhdGVEYXRhLnN0YXRlICYmIHN0YXRlRGF0YS5zdGF0ZS5uYW1lKSB7XHJcbiAgICAgICAgYmFzZSA9IHN0YXRlRGF0YS5zdGF0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKG5ld1ZhbCkge1xyXG4gICAgICAgIGlmIChuZXdWYWwpIHBhcmFtcyA9IG5ld1ZhbDtcclxuICAgICAgICBpZiAoIW5hdikgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgbmV3SHJlZiA9ICRzdGF0ZS5ocmVmKHJlZi5zdGF0ZSwgcGFyYW1zLCB7IHJlbGF0aXZlOiBiYXNlIH0pO1xyXG5cclxuICAgICAgICBpZiAoIW5ld0hyZWYpIHtcclxuICAgICAgICAgIG5hdiA9IGZhbHNlO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbGVtZW50WzBdW2F0dHJdID0gbmV3SHJlZjtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChyZWYucGFyYW1FeHByKSB7XHJcbiAgICAgICAgc2NvcGUuJHdhdGNoKHJlZi5wYXJhbUV4cHIsIGZ1bmN0aW9uKG5ld1ZhbCwgb2xkVmFsKSB7XHJcbiAgICAgICAgICBpZiAobmV3VmFsICE9PSBvbGRWYWwpIHVwZGF0ZShuZXdWYWwpO1xyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIHBhcmFtcyA9IHNjb3BlLiRldmFsKHJlZi5wYXJhbUV4cHIpO1xyXG4gICAgICB9XHJcbiAgICAgIHVwZGF0ZSgpO1xyXG5cclxuICAgICAgaWYgKGlzRm9ybSkgcmV0dXJuO1xyXG5cclxuICAgICAgZWxlbWVudC5iaW5kKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGlmICgoZS53aGljaCA9PSAxKSAmJiAhZS5jdHJsS2V5ICYmICFlLm1ldGFLZXkgJiYgIWUuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICRzdGF0ZS5nbyhyZWYuc3RhdGUsIHBhcmFtcywgeyByZWxhdGl2ZTogYmFzZSB9KTtcclxuICAgICAgICAgIHNjb3BlLiRhcHBseSgpO1xyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLmRpcmVjdGl2ZSgndWlTcmVmJywgJFN0YXRlUmVmRGlyZWN0aXZlKTtcclxuXHJcbiRSb3V0ZVByb3ZpZGVyLiRpbmplY3QgPSBbJyRzdGF0ZVByb3ZpZGVyJywgJyR1cmxSb3V0ZXJQcm92aWRlciddO1xyXG5mdW5jdGlvbiAkUm91dGVQcm92aWRlciggICRzdGF0ZVByb3ZpZGVyLCAgICAkdXJsUm91dGVyUHJvdmlkZXIpIHtcclxuXHJcbiAgdmFyIHJvdXRlcyA9IFtdO1xyXG5cclxuICBvbkVudGVyUm91dGUuJGluamVjdCA9IFsnJCRzdGF0ZSddO1xyXG4gIGZ1bmN0aW9uIG9uRW50ZXJSb3V0ZSggICAkJHN0YXRlKSB7XHJcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHRoaXMubG9jYWxzID0gJCRzdGF0ZS5sb2NhbHMuZ2xvYmFscztcclxuICAgIHRoaXMucGFyYW1zID0gdGhpcy5sb2NhbHMuJHN0YXRlUGFyYW1zO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb25FeGl0Um91dGUoKSB7XHJcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHRoaXMubG9jYWxzID0gbnVsbDtcclxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcclxuICB9XHJcblxyXG4gIHRoaXMud2hlbiA9IHdoZW47XHJcbiAgZnVuY3Rpb24gd2hlbih1cmwsIHJvdXRlKSB7XHJcbiAgICAvKmpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIGlmIChyb3V0ZS5yZWRpcmVjdFRvICE9IG51bGwpIHtcclxuICAgICAgLy8gUmVkaXJlY3QsIGNvbmZpZ3VyZSBkaXJlY3RseSBvbiAkdXJsUm91dGVyUHJvdmlkZXJcclxuICAgICAgdmFyIHJlZGlyZWN0ID0gcm91dGUucmVkaXJlY3RUbywgaGFuZGxlcjtcclxuICAgICAgaWYgKGlzU3RyaW5nKHJlZGlyZWN0KSkge1xyXG4gICAgICAgIGhhbmRsZXIgPSByZWRpcmVjdDsgLy8gbGVhdmUgJHVybFJvdXRlclByb3ZpZGVyIHRvIGhhbmRsZVxyXG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocmVkaXJlY3QpKSB7XHJcbiAgICAgICAgLy8gQWRhcHQgdG8gJHVybFJvdXRlclByb3ZpZGVyIEFQSVxyXG4gICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAocGFyYW1zLCAkbG9jYXRpb24pIHtcclxuICAgICAgICAgIHJldHVybiByZWRpcmVjdChwYXJhbXMsICRsb2NhdGlvbi5wYXRoKCksICRsb2NhdGlvbi5zZWFyY2goKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkICdyZWRpcmVjdFRvJyBpbiB3aGVuKClcIik7XHJcbiAgICAgIH1cclxuICAgICAgJHVybFJvdXRlclByb3ZpZGVyLndoZW4odXJsLCBoYW5kbGVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFJlZ3VsYXIgcm91dGUsIGNvbmZpZ3VyZSBhcyBzdGF0ZVxyXG4gICAgICAkc3RhdGVQcm92aWRlci5zdGF0ZShpbmhlcml0KHJvdXRlLCB7XHJcbiAgICAgICAgcGFyZW50OiBudWxsLFxyXG4gICAgICAgIG5hbWU6ICdyb3V0ZTonICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCksXHJcbiAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgb25FbnRlcjogb25FbnRlclJvdXRlLFxyXG4gICAgICAgIG9uRXhpdDogb25FeGl0Um91dGVcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgcm91dGVzLnB1c2gocm91dGUpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICB0aGlzLiRnZXQgPSAkZ2V0O1xyXG4gICRnZXQuJGluamVjdCA9IFsnJHN0YXRlJywgJyRyb290U2NvcGUnLCAnJHJvdXRlUGFyYW1zJ107XHJcbiAgZnVuY3Rpb24gJGdldCggICAkc3RhdGUsICAgJHJvb3RTY29wZSwgICAkcm91dGVQYXJhbXMpIHtcclxuXHJcbiAgICB2YXIgJHJvdXRlID0ge1xyXG4gICAgICByb3V0ZXM6IHJvdXRlcyxcclxuICAgICAgcGFyYW1zOiAkcm91dGVQYXJhbXMsXHJcbiAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBzdGF0ZUFzUm91dGUoc3RhdGUpIHtcclxuICAgICAgcmV0dXJuIChzdGF0ZS5uYW1lICE9PSAnJykgPyBzdGF0ZSA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbiAoZXYsIHRvLCB0b1BhcmFtcywgZnJvbSwgZnJvbVBhcmFtcykge1xyXG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRyb3V0ZUNoYW5nZVN0YXJ0Jywgc3RhdGVBc1JvdXRlKHRvKSwgc3RhdGVBc1JvdXRlKGZyb20pKTtcclxuICAgIH0pO1xyXG5cclxuICAgICRyb290U2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdWNjZXNzJywgZnVuY3Rpb24gKGV2LCB0bywgdG9QYXJhbXMsIGZyb20sIGZyb21QYXJhbXMpIHtcclxuICAgICAgJHJvdXRlLmN1cnJlbnQgPSBzdGF0ZUFzUm91dGUodG8pO1xyXG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRyb3V0ZUNoYW5nZVN1Y2Nlc3MnLCBzdGF0ZUFzUm91dGUodG8pLCBzdGF0ZUFzUm91dGUoZnJvbSkpO1xyXG4gICAgICBjb3B5KHRvUGFyYW1zLCAkcm91dGUucGFyYW1zKTtcclxuICAgIH0pO1xyXG5cclxuICAgICRyb290U2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VFcnJvcicsIGZ1bmN0aW9uIChldiwgdG8sIHRvUGFyYW1zLCBmcm9tLCBmcm9tUGFyYW1zLCBlcnJvcikge1xyXG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRyb3V0ZUNoYW5nZUVycm9yJywgc3RhdGVBc1JvdXRlKHRvKSwgc3RhdGVBc1JvdXRlKGZyb20pLCBlcnJvcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gJHJvdXRlO1xyXG4gIH1cclxufVxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ3VpLnJvdXRlci5jb21wYXQnKVxyXG4gIC5wcm92aWRlcignJHJvdXRlJywgJFJvdXRlUHJvdmlkZXIpXHJcbiAgLmRpcmVjdGl2ZSgnbmdWaWV3JywgJFZpZXdEaXJlY3RpdmUpO1xyXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTsiLCIvKipcclxuICogQGxpY2Vuc2UgQW5ndWxhckpTIHYxLjIuMC1yYy4yXHJcbiAqIChjKSAyMDEwLTIwMTIgR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXHJcbiAqIExpY2Vuc2U6IE1JVFxyXG4gKi9cclxuKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhciwgdW5kZWZpbmVkKSB7J3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvdmVydmlld1xyXG4gKiBAbmFtZSBuZ0Nvb2tpZXNcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqICMgbmdDb29raWVzXHJcbiAqXHJcbiAqIFByb3ZpZGVzIHRoZSB7QGxpbmsgbmdDb29raWVzLiRjb29raWVzIGAkY29va2llc2B9IGFuZFxyXG4gKiB7QGxpbmsgbmdDb29raWVzLiRjb29raWVTdG9yZSBgJGNvb2tpZVN0b3JlYH0gc2VydmljZXMuXHJcbiAqXHJcbiAqIHtAaW5zdGFsbE1vZHVsZSBjb29raWVzfVxyXG4gKlxyXG4gKiBTZWUge0BsaW5rIG5nQ29va2llcy4kY29va2llcyBgJGNvb2tpZXNgfSBhbmRcclxuICoge0BsaW5rIG5nQ29va2llcy4kY29va2llU3RvcmUgYCRjb29raWVTdG9yZWB9IGZvciB1c2FnZS5cclxuICovXHJcblxyXG5cclxuYW5ndWxhci5tb2R1bGUoJ25nQ29va2llcycsIFsnbmcnXSkuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG9iamVjdFxyXG4gICAqIEBuYW1lIG5nQ29va2llcy4kY29va2llc1xyXG4gICAqIEByZXF1aXJlcyAkYnJvd3NlclxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogUHJvdmlkZXMgcmVhZC93cml0ZSBhY2Nlc3MgdG8gYnJvd3NlcidzIGNvb2tpZXMuXHJcbiAgICpcclxuICAgKiBPbmx5IGEgc2ltcGxlIE9iamVjdCBpcyBleHBvc2VkIGFuZCBieSBhZGRpbmcgb3IgcmVtb3ZpbmcgcHJvcGVydGllcyB0by9mcm9tXHJcbiAgICogdGhpcyBvYmplY3QsIG5ldyBjb29raWVzIGFyZSBjcmVhdGVkL2RlbGV0ZWQgYXQgdGhlIGVuZCBvZiBjdXJyZW50ICRldmFsLlxyXG4gICAqXHJcbiAgICogUmVxdWlyZXMgdGhlIHtAbGluayBuZ0Nvb2tpZXMgYG5nQ29va2llc2B9IG1vZHVsZSB0byBiZSBpbnN0YWxsZWQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICBmdW5jdGlvbiBFeGFtcGxlQ29udHJvbGxlcigkY29va2llcykge1xyXG4gICAgICAgICAgIC8vIFJldHJpZXZpbmcgYSBjb29raWVcclxuICAgICAgICAgICB2YXIgZmF2b3JpdGVDb29raWUgPSAkY29va2llcy5teUZhdm9yaXRlO1xyXG4gICAgICAgICAgIC8vIFNldHRpbmcgYSBjb29raWVcclxuICAgICAgICAgICAkY29va2llcy5teUZhdm9yaXRlID0gJ29hdG1lYWwnO1xyXG4gICAgICAgICB9XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAgICovXHJcbiAgIGZhY3RvcnkoJyRjb29raWVzJywgWyckcm9vdFNjb3BlJywgJyRicm93c2VyJywgZnVuY3Rpb24gKCRyb290U2NvcGUsICRicm93c2VyKSB7XHJcbiAgICAgIHZhciBjb29raWVzID0ge30sXHJcbiAgICAgICAgICBsYXN0Q29va2llcyA9IHt9LFxyXG4gICAgICAgICAgbGFzdEJyb3dzZXJDb29raWVzLFxyXG4gICAgICAgICAgcnVuRXZhbCA9IGZhbHNlLFxyXG4gICAgICAgICAgY29weSA9IGFuZ3VsYXIuY29weSxcclxuICAgICAgICAgIGlzVW5kZWZpbmVkID0gYW5ndWxhci5pc1VuZGVmaW5lZDtcclxuXHJcbiAgICAgIC8vY3JlYXRlcyBhIHBvbGxlciBmbiB0aGF0IGNvcGllcyBhbGwgY29va2llcyBmcm9tIHRoZSAkYnJvd3NlciB0byBzZXJ2aWNlICYgaW5pdHMgdGhlIHNlcnZpY2VcclxuICAgICAgJGJyb3dzZXIuYWRkUG9sbEZuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50Q29va2llcyA9ICRicm93c2VyLmNvb2tpZXMoKTtcclxuICAgICAgICBpZiAobGFzdEJyb3dzZXJDb29raWVzICE9IGN1cnJlbnRDb29raWVzKSB7IC8vcmVsaWVzIG9uIGJyb3dzZXIuY29va2llcygpIGltcGxcclxuICAgICAgICAgIGxhc3RCcm93c2VyQ29va2llcyA9IGN1cnJlbnRDb29raWVzO1xyXG4gICAgICAgICAgY29weShjdXJyZW50Q29va2llcywgbGFzdENvb2tpZXMpO1xyXG4gICAgICAgICAgY29weShjdXJyZW50Q29va2llcywgY29va2llcyk7XHJcbiAgICAgICAgICBpZiAocnVuRXZhbCkgJHJvb3RTY29wZS4kYXBwbHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pKCk7XHJcblxyXG4gICAgICBydW5FdmFsID0gdHJ1ZTtcclxuXHJcbiAgICAgIC8vYXQgdGhlIGVuZCBvZiBlYWNoIGV2YWwsIHB1c2ggY29va2llc1xyXG4gICAgICAvL1RPRE86IHRoaXMgc2hvdWxkIGhhcHBlbiBiZWZvcmUgdGhlIFwiZGVsYXllZFwiIHdhdGNoZXMgZmlyZSwgYmVjYXVzZSBpZiBzb21lIGNvb2tpZXMgYXJlIG5vdFxyXG4gICAgICAvLyAgICAgIHN0cmluZ3Mgb3IgYnJvd3NlciByZWZ1c2VzIHRvIHN0b3JlIHNvbWUgY29va2llcywgd2UgdXBkYXRlIHRoZSBtb2RlbCBpbiB0aGUgcHVzaCBmbi5cclxuICAgICAgJHJvb3RTY29wZS4kd2F0Y2gocHVzaCk7XHJcblxyXG4gICAgICByZXR1cm4gY29va2llcztcclxuXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUHVzaGVzIGFsbCB0aGUgY29va2llcyBmcm9tIHRoZSBzZXJ2aWNlIHRvIHRoZSBicm93c2VyIGFuZCB2ZXJpZmllcyBpZiBhbGwgY29va2llcyB3ZXJlIHN0b3JlZC5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHB1c2goKSB7XHJcbiAgICAgICAgdmFyIG5hbWUsXHJcbiAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICBicm93c2VyQ29va2llcyxcclxuICAgICAgICAgICAgdXBkYXRlZDtcclxuXHJcbiAgICAgICAgLy9kZWxldGUgYW55IGNvb2tpZXMgZGVsZXRlZCBpbiAkY29va2llc1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBsYXN0Q29va2llcykge1xyXG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGNvb2tpZXNbbmFtZV0pKSB7XHJcbiAgICAgICAgICAgICRicm93c2VyLmNvb2tpZXMobmFtZSwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdXBkYXRlIGFsbCBjb29raWVzIHVwZGF0ZWQgaW4gJGNvb2tpZXNcclxuICAgICAgICBmb3IobmFtZSBpbiBjb29raWVzKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IGNvb2tpZXNbbmFtZV07XHJcbiAgICAgICAgICBpZiAoIWFuZ3VsYXIuaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChsYXN0Q29va2llc1tuYW1lXSkpIHtcclxuICAgICAgICAgICAgICBjb29raWVzW25hbWVdID0gbGFzdENvb2tpZXNbbmFtZV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZGVsZXRlIGNvb2tpZXNbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IGxhc3RDb29raWVzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICRicm93c2VyLmNvb2tpZXMobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdmVyaWZ5IHdoYXQgd2FzIGFjdHVhbGx5IHN0b3JlZFxyXG4gICAgICAgIGlmICh1cGRhdGVkKXtcclxuICAgICAgICAgIHVwZGF0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgIGJyb3dzZXJDb29raWVzID0gJGJyb3dzZXIuY29va2llcygpO1xyXG5cclxuICAgICAgICAgIGZvciAobmFtZSBpbiBjb29raWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChjb29raWVzW25hbWVdICE9PSBicm93c2VyQ29va2llc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgIC8vZGVsZXRlIG9yIHJlc2V0IGFsbCBjb29raWVzIHRoYXQgdGhlIGJyb3dzZXIgZHJvcHBlZCBmcm9tICRjb29raWVzXHJcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGJyb3dzZXJDb29raWVzW25hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvb2tpZXNbbmFtZV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvb2tpZXNbbmFtZV0gPSBicm93c2VyQ29va2llc1tuYW1lXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1dKS5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBvYmplY3RcclxuICAgKiBAbmFtZSBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlXHJcbiAgICogQHJlcXVpcmVzICRjb29raWVzXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBQcm92aWRlcyBhIGtleS12YWx1ZSAoc3RyaW5nLW9iamVjdCkgc3RvcmFnZSwgdGhhdCBpcyBiYWNrZWQgYnkgc2Vzc2lvbiBjb29raWVzLlxyXG4gICAqIE9iamVjdHMgcHV0IG9yIHJldHJpZXZlZCBmcm9tIHRoaXMgc3RvcmFnZSBhcmUgYXV0b21hdGljYWxseSBzZXJpYWxpemVkIG9yXHJcbiAgICogZGVzZXJpYWxpemVkIGJ5IGFuZ3VsYXIncyB0b0pzb24vZnJvbUpzb24uXHJcbiAgICpcclxuICAgKiBSZXF1aXJlcyB0aGUge0BsaW5rIG5nQ29va2llcyBgbmdDb29raWVzYH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICovXHJcbiAgIGZhY3RvcnkoJyRjb29raWVTdG9yZScsIFsnJGNvb2tpZXMnLCBmdW5jdGlvbigkY29va2llcykge1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAgICogQG5hbWUgbmdDb29raWVzLiRjb29raWVTdG9yZSNnZXRcclxuICAgICAgICAgKiBAbWV0aG9kT2YgbmdDb29raWVzLiRjb29raWVTdG9yZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgZ2l2ZW4gY29va2llIGtleVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBJZCB0byB1c2UgZm9yIGxvb2t1cC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBEZXNlcmlhbGl6ZWQgY29va2llIHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkY29va2llc1trZXldO1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlID8gYW5ndWxhci5mcm9tSnNvbih2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAgICogQG5hbWUgbmdDb29raWVzLiRjb29raWVTdG9yZSNwdXRcclxuICAgICAgICAgKiBAbWV0aG9kT2YgbmdDb29raWVzLiRjb29raWVTdG9yZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICogU2V0cyBhIHZhbHVlIGZvciBnaXZlbiBjb29raWUga2V5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IElkIGZvciB0aGUgYHZhbHVlYC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVmFsdWUgdG8gYmUgc3RvcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1dDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgJGNvb2tpZXNba2V5XSA9IGFuZ3VsYXIudG9Kc29uKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAgICogQG5hbWUgbmdDb29raWVzLiRjb29raWVTdG9yZSNyZW1vdmVcclxuICAgICAgICAgKiBAbWV0aG9kT2YgbmdDb29raWVzLiRjb29raWVTdG9yZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICogUmVtb3ZlIGdpdmVuIGNvb2tpZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBJZCBvZiB0aGUga2V5LXZhbHVlIHBhaXIgdG8gZGVsZXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICBkZWxldGUgJGNvb2tpZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgfV0pO1xyXG5cclxuXHJcbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpOyIsIi8qKlxyXG4gKiBAbGljZW5zZSBBbmd1bGFySlMgdjEuMi4wLXJjLjJcclxuICogKGMpIDIwMTAtMjAxMiBHb29nbGUsIEluYy4gaHR0cDovL2FuZ3VsYXJqcy5vcmdcclxuICogTGljZW5zZTogTUlUXHJcbiAqL1xyXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7J3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBUaGlzIG9iamVjdCBwcm92aWRlcyBhIHV0aWxpdHkgZm9yIHByb2R1Y2luZyByaWNoIEVycm9yIG1lc3NhZ2VzIHdpdGhpblxyXG4gKiBBbmd1bGFyLiBJdCBjYW4gYmUgY2FsbGVkIGFzIGZvbGxvd3M6XHJcbiAqXHJcbiAqIHZhciBleGFtcGxlTWluRXJyID0gbWluRXJyKCdleGFtcGxlJyk7XHJcbiAqIHRocm93IGV4YW1wbGVNaW5FcnIoJ29uZScsICdUaGlzIHswfSBpcyB7MX0nLCBmb28sIGJhcik7XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjcmVhdGVzIGFuIGluc3RhbmNlIG9mIG1pbkVyciBpbiB0aGUgZXhhbXBsZSBuYW1lc3BhY2UuIFRoZVxyXG4gKiByZXN1bHRpbmcgZXJyb3Igd2lsbCBoYXZlIGEgbmFtZXNwYWNlZCBlcnJvciBjb2RlIG9mIGV4YW1wbGUub25lLiAgVGhlXHJcbiAqIHJlc3VsdGluZyBlcnJvciB3aWxsIHJlcGxhY2UgezB9IHdpdGggdGhlIHZhbHVlIG9mIGZvbywgYW5kIHsxfSB3aXRoIHRoZVxyXG4gKiB2YWx1ZSBvZiBiYXIuIFRoZSBvYmplY3QgaXMgbm90IHJlc3RyaWN0ZWQgaW4gdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXQgY2FuXHJcbiAqIHRha2UuXHJcbiAqXHJcbiAqIElmIGZld2VyIGFyZ3VtZW50cyBhcmUgc3BlY2lmaWVkIHRoYW4gbmVjZXNzYXJ5IGZvciBpbnRlcnBvbGF0aW9uLCB0aGUgZXh0cmFcclxuICogaW50ZXJwb2xhdGlvbiBtYXJrZXJzIHdpbGwgYmUgcHJlc2VydmVkIGluIHRoZSBmaW5hbCBzdHJpbmcuXHJcbiAqXHJcbiAqIFNpbmNlIGRhdGEgd2lsbCBiZSBwYXJzZWQgc3RhdGljYWxseSBkdXJpbmcgYSBidWlsZCBzdGVwLCBzb21lIHJlc3RyaWN0aW9uc1xyXG4gKiBhcmUgYXBwbGllZCB3aXRoIHJlc3BlY3QgdG8gaG93IG1pbkVyciBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQgYW5kIGNhbGxlZC5cclxuICogSW5zdGFuY2VzIHNob3VsZCBoYXZlIG5hbWVzIG9mIHRoZSBmb3JtIG5hbWVzcGFjZU1pbkVyciBmb3IgYSBtaW5FcnIgY3JlYXRlZFxyXG4gKiB1c2luZyBtaW5FcnIoJ25hbWVzcGFjZScpIC4gRXJyb3IgY29kZXMsIG5hbWVzcGFjZXMgYW5kIHRlbXBsYXRlIHN0cmluZ3NcclxuICogc2hvdWxkIGFsbCBiZSBzdGF0aWMgc3RyaW5ncywgbm90IHZhcmlhYmxlcyBvciBnZW5lcmFsIGV4cHJlc3Npb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlIFRoZSBuYW1lc3BhY2UgdG8gdXNlIGZvciB0aGUgbmV3IG1pbkVyciBpbnN0YW5jZS5cclxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nLCAuLi4pOiBFcnJvcn0gaW5zdGFuY2VcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaW5FcnIobW9kdWxlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjb2RlID0gYXJndW1lbnRzWzBdLFxyXG4gICAgICBwcmVmaXggPSAnWycgKyAobW9kdWxlID8gbW9kdWxlICsgJzonIDogJycpICsgY29kZSArICddICcsXHJcbiAgICAgIHRlbXBsYXRlID0gYXJndW1lbnRzWzFdLFxyXG4gICAgICB0ZW1wbGF0ZUFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYmopKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCkucmVwbGFjZSgvIFxce1tcXHNcXFNdKiQvLCAnJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc1VuZGVmaW5lZChvYmopKSB7XHJcbiAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XHJcbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpbmcob2JqKSkge1xyXG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgIH0sXHJcbiAgICAgIG1lc3NhZ2UsIGk7XHJcblxyXG4gICAgbWVzc2FnZSA9IHByZWZpeCArIHRlbXBsYXRlLnJlcGxhY2UoL1xce1xcZCtcXH0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgIHZhciBpbmRleCA9ICttYXRjaC5zbGljZSgxLCAtMSksIGFyZztcclxuXHJcbiAgICAgIGlmIChpbmRleCArIDIgPCB0ZW1wbGF0ZUFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgYXJnID0gdGVtcGxhdGVBcmdzW2luZGV4ICsgMl07XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpLnJlcGxhY2UoLyA/XFx7W1xcc1xcU10qJC8sICcnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzVW5kZWZpbmVkKGFyZykpIHtcclxuICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcclxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmluZyhhcmcpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdG9Kc29uKGFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcmc7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgKyAnXFxuaHR0cDovL2Vycm9ycy5hbmd1bGFyanMub3JnLycgKyB2ZXJzaW9uLmZ1bGwgKyAnLycgK1xyXG4gICAgICAobW9kdWxlID8gbW9kdWxlICsgJy8nIDogJycpICsgY29kZTtcclxuICAgIGZvciAoaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgKyAoaSA9PSAyID8gJz8nIDogJyYnKSArICdwJyArIChpLTIpICsgJz0nICtcclxuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5KGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgfTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogaGFzT3duUHJvcGVydHkgbWF5IGJlIG92ZXJ3cml0dGVuIGJ5IGEgcHJvcGVydHkgb2YgdGhlIHNhbWUgbmFtZSwgb3IgZW50aXJlbHlcclxuICogYWJzZW50IGZyb20gYW4gb2JqZWN0IHRoYXQgZG9lcyBub3QgaW5oZXJpdCBPYmplY3QucHJvdG90eXBlOyB0aGlzIGNvcHkgaXNcclxuICogdXNlZCBpbnN0ZWFkXHJcbiAqL1xyXG52YXIgaGFzT3duUHJvcGVydHlGbiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbnZhciBoYXNPd25Qcm9wZXJ0eUxvY2FsID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcclxuICByZXR1cm4gaGFzT3duUHJvcGVydHlGbi5jYWxsKG9iaiwga2V5KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5sb3dlcmNhc2VcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvbiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHN0cmluZyB0byBsb3dlcmNhc2UuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGJlIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IExvd2VyY2FzZWQgc3RyaW5nLlxyXG4gKi9cclxudmFyIGxvd2VyY2FzZSA9IGZ1bmN0aW9uKHN0cmluZyl7cmV0dXJuIGlzU3RyaW5nKHN0cmluZykgPyBzdHJpbmcudG9Mb3dlckNhc2UoKSA6IHN0cmluZzt9O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci51cHBlcmNhc2VcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvbiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHN0cmluZyB0byB1cHBlcmNhc2UuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGJlIGNvbnZlcnRlZCB0byB1cHBlcmNhc2UuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVwcGVyY2FzZWQgc3RyaW5nLlxyXG4gKi9cclxudmFyIHVwcGVyY2FzZSA9IGZ1bmN0aW9uKHN0cmluZyl7cmV0dXJuIGlzU3RyaW5nKHN0cmluZykgPyBzdHJpbmcudG9VcHBlckNhc2UoKSA6IHN0cmluZzt9O1xyXG5cclxuXHJcbnZhciBtYW51YWxMb3dlcmNhc2UgPSBmdW5jdGlvbihzKSB7XHJcbiAgcmV0dXJuIGlzU3RyaW5nKHMpXHJcbiAgICAgID8gcy5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbihjaCkge3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoLmNoYXJDb2RlQXQoMCkgfCAzMik7fSlcclxuICAgICAgOiBzO1xyXG59O1xyXG52YXIgbWFudWFsVXBwZXJjYXNlID0gZnVuY3Rpb24ocykge1xyXG4gIHJldHVybiBpc1N0cmluZyhzKVxyXG4gICAgICA/IHMucmVwbGFjZSgvW2Etel0vZywgZnVuY3Rpb24oY2gpIHtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaC5jaGFyQ29kZUF0KDApICYgfjMyKTt9KVxyXG4gICAgICA6IHM7XHJcbn07XHJcblxyXG5cclxuLy8gU3RyaW5nI3RvTG93ZXJDYXNlIGFuZCBTdHJpbmcjdG9VcHBlckNhc2UgZG9uJ3QgcHJvZHVjZSBjb3JyZWN0IHJlc3VsdHMgaW4gYnJvd3NlcnMgd2l0aCBUdXJraXNoXHJcbi8vIGxvY2FsZSwgZm9yIHRoaXMgcmVhc29uIHdlIG5lZWQgdG8gZGV0ZWN0IHRoaXMgY2FzZSBhbmQgcmVkZWZpbmUgbG93ZXJjYXNlL3VwcGVyY2FzZSBtZXRob2RzXHJcbi8vIHdpdGggY29ycmVjdCBidXQgc2xvd2VyIGFsdGVybmF0aXZlcy5cclxuaWYgKCdpJyAhPT0gJ0knLnRvTG93ZXJDYXNlKCkpIHtcclxuICBsb3dlcmNhc2UgPSBtYW51YWxMb3dlcmNhc2U7XHJcbiAgdXBwZXJjYXNlID0gbWFudWFsVXBwZXJjYXNlO1xyXG59XHJcblxyXG5cclxudmFyIC8qKiBob2xkcyBtYWpvciB2ZXJzaW9uIG51bWJlciBmb3IgSUUgb3IgTmFOIGZvciByZWFsIGJyb3dzZXJzICovXHJcbiAgICBtc2llLFxyXG4gICAganFMaXRlLCAgICAgICAgICAgLy8gZGVsYXkgYmluZGluZyBzaW5jZSBqUXVlcnkgY291bGQgYmUgbG9hZGVkIGFmdGVyIHVzLlxyXG4gICAgalF1ZXJ5LCAgICAgICAgICAgLy8gZGVsYXkgYmluZGluZ1xyXG4gICAgc2xpY2UgICAgICAgICAgICAgPSBbXS5zbGljZSxcclxuICAgIHB1c2ggICAgICAgICAgICAgID0gW10ucHVzaCxcclxuICAgIHRvU3RyaW5nICAgICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcclxuICAgIG5nTWluRXJyICAgICAgICAgID0gbWluRXJyKCduZycpLFxyXG5cclxuXHJcbiAgICBfYW5ndWxhciAgICAgICAgICA9IHdpbmRvdy5hbmd1bGFyLFxyXG4gICAgLyoqIEBuYW1lIGFuZ3VsYXIgKi9cclxuICAgIGFuZ3VsYXIgICAgICAgICAgID0gd2luZG93LmFuZ3VsYXIgfHwgKHdpbmRvdy5hbmd1bGFyID0ge30pLFxyXG4gICAgYW5ndWxhck1vZHVsZSxcclxuICAgIG5vZGVOYW1lXyxcclxuICAgIHVpZCAgICAgICAgICAgICAgID0gWycwJywgJzAnLCAnMCddO1xyXG5cclxuLyoqXHJcbiAqIElFIDExIGNoYW5nZWQgdGhlIGZvcm1hdCBvZiB0aGUgVXNlckFnZW50IHN0cmluZy5cclxuICogU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNzUwMy5hc3B4XHJcbiAqL1xyXG5tc2llID0gaW50KCgvbXNpZSAoXFxkKykvLmV4ZWMobG93ZXJjYXNlKG5hdmlnYXRvci51c2VyQWdlbnQpKSB8fCBbXSlbMV0pO1xyXG5pZiAoaXNOYU4obXNpZSkpIHtcclxuICBtc2llID0gaW50KCgvdHJpZGVudFxcLy4qOyBydjooXFxkKykvLmV4ZWMobG93ZXJjYXNlKG5hdmlnYXRvci51c2VyQWdlbnQpKSB8fCBbXSlbMV0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gb2JqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBgb2JqYCBpcyBhbiBhcnJheSBvciBhcnJheS1saWtlIG9iamVjdCAoTm9kZUxpc3QsIEFyZ3VtZW50cywgLi4uKVxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcnJheUxpa2Uob2JqKSB7XHJcbiAgaWYgKG9iaiA9PSBudWxsIHx8IGlzV2luZG93KG9iaikpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgXHJcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XHJcblxyXG4gIGlmIChvYmoubm9kZVR5cGUgPT09IDEgJiYgbGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpc0FycmF5KG9iaikgfHwgIWlzRnVuY3Rpb24ob2JqKSAmJiAoXHJcbiAgICBsZW5ndGggPT09IDAgfHwgdHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmIChsZW5ndGggLSAxKSBpbiBvYmpcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuZm9yRWFjaFxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEludm9rZXMgdGhlIGBpdGVyYXRvcmAgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBpdGVtIGluIGBvYmpgIGNvbGxlY3Rpb24sIHdoaWNoIGNhbiBiZSBlaXRoZXIgYW5cclxuICogb2JqZWN0IG9yIGFuIGFycmF5LiBUaGUgYGl0ZXJhdG9yYCBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggYGl0ZXJhdG9yKHZhbHVlLCBrZXkpYCwgd2hlcmUgYHZhbHVlYFxyXG4gKiBpcyB0aGUgdmFsdWUgb2YgYW4gb2JqZWN0IHByb3BlcnR5IG9yIGFuIGFycmF5IGVsZW1lbnQgYW5kIGBrZXlgIGlzIHRoZSBvYmplY3QgcHJvcGVydHkga2V5IG9yXHJcbiAqIGFycmF5IGVsZW1lbnQgaW5kZXguIFNwZWNpZnlpbmcgYSBgY29udGV4dGAgZm9yIHRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbC5cclxuICpcclxuICogTm90ZTogdGhpcyBmdW5jdGlvbiB3YXMgcHJldmlvdXNseSBrbm93biBhcyBgYW5ndWxhci5mb3JlYWNoYC5cclxuICpcclxuICAgPHByZT5cclxuICAgICB2YXIgdmFsdWVzID0ge25hbWU6ICdtaXNrbycsIGdlbmRlcjogJ21hbGUnfTtcclxuICAgICB2YXIgbG9nID0gW107XHJcbiAgICAgYW5ndWxhci5mb3JFYWNoKHZhbHVlcywgZnVuY3Rpb24odmFsdWUsIGtleSl7XHJcbiAgICAgICB0aGlzLnB1c2goa2V5ICsgJzogJyArIHZhbHVlKTtcclxuICAgICB9LCBsb2cpO1xyXG4gICAgIGV4cGVjdChsb2cpLnRvRXF1YWwoWyduYW1lOiBtaXNrbycsICdnZW5kZXI6bWFsZSddKTtcclxuICAgPC9wcmU+XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogT2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3IgSXRlcmF0b3IgZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dCBPYmplY3QgdG8gYmVjb21lIGNvbnRleHQgKGB0aGlzYCkgZm9yIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cclxuICogQHJldHVybnMge09iamVjdHxBcnJheX0gUmVmZXJlbmNlIHRvIGBvYmpgLlxyXG4gKi9cclxuZnVuY3Rpb24gZm9yRWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XHJcbiAgdmFyIGtleTtcclxuICBpZiAob2JqKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihvYmopKXtcclxuICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKGtleSAhPSAncHJvdG90eXBlJyAmJiBrZXkgIT0gJ2xlbmd0aCcgJiYga2V5ICE9ICduYW1lJyAmJiBvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAob2JqLmZvckVhY2ggJiYgb2JqLmZvckVhY2ggIT09IGZvckVhY2gpIHtcclxuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZShvYmopKSB7XHJcbiAgICAgIGZvciAoa2V5ID0gMDsga2V5IDwgb2JqLmxlbmd0aDsga2V5KyspXHJcbiAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAoa2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuZnVuY3Rpb24gc29ydGVkS2V5cyhvYmopIHtcclxuICB2YXIga2V5cyA9IFtdO1xyXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGtleXMuc29ydCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JFYWNoU29ydGVkKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcclxuICB2YXIga2V5cyA9IHNvcnRlZEtleXMob2JqKTtcclxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXlzW2ldXSwga2V5c1tpXSk7XHJcbiAgfVxyXG4gIHJldHVybiBrZXlzO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIHdoZW4gdXNpbmcgZm9yRWFjaCB0aGUgcGFyYW1zIGFyZSB2YWx1ZSwga2V5LCBidXQgaXQgaXMgb2Z0ZW4gdXNlZnVsIHRvIGhhdmUga2V5LCB2YWx1ZS5cclxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsICopfSBpdGVyYXRvckZuXHJcbiAqIEByZXR1cm5zIHtmdW5jdGlvbigqLCBzdHJpbmcpfVxyXG4gKi9cclxuZnVuY3Rpb24gcmV2ZXJzZVBhcmFtcyhpdGVyYXRvckZuKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHsgaXRlcmF0b3JGbihrZXksIHZhbHVlKSB9O1xyXG59XHJcblxyXG4vKipcclxuICogQSBjb25zaXN0ZW50IHdheSBvZiBjcmVhdGluZyB1bmlxdWUgSURzIGluIGFuZ3VsYXIuIFRoZSBJRCBpcyBhIHNlcXVlbmNlIG9mIGFscGhhIG51bWVyaWNcclxuICogY2hhcmFjdGVycyBzdWNoIGFzICcwMTJBQkMnLiBUaGUgcmVhc29uIHdoeSB3ZSBhcmUgbm90IHVzaW5nIHNpbXBseSBhIG51bWJlciBjb3VudGVyIGlzIHRoYXRcclxuICogdGhlIG51bWJlciBzdHJpbmcgZ2V0cyBsb25nZXIgb3ZlciB0aW1lLCBhbmQgaXQgY2FuIGFsc28gb3ZlcmZsb3csIHdoZXJlIGFzIHRoZSBuZXh0SWRcclxuICogd2lsbCBncm93IG11Y2ggc2xvd2VyLCBpdCBpcyBhIHN0cmluZywgYW5kIGl0IHdpbGwgbmV2ZXIgb3ZlcmZsb3cuXHJcbiAqXHJcbiAqIEByZXR1cm5zIGFuIHVuaXF1ZSBhbHBoYS1udW1lcmljIHN0cmluZ1xyXG4gKi9cclxuZnVuY3Rpb24gbmV4dFVpZCgpIHtcclxuICB2YXIgaW5kZXggPSB1aWQubGVuZ3RoO1xyXG4gIHZhciBkaWdpdDtcclxuXHJcbiAgd2hpbGUoaW5kZXgpIHtcclxuICAgIGluZGV4LS07XHJcbiAgICBkaWdpdCA9IHVpZFtpbmRleF0uY2hhckNvZGVBdCgwKTtcclxuICAgIGlmIChkaWdpdCA9PSA1NyAvKic5JyovKSB7XHJcbiAgICAgIHVpZFtpbmRleF0gPSAnQSc7XHJcbiAgICAgIHJldHVybiB1aWQuam9pbignJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlnaXQgPT0gOTAgIC8qJ1onKi8pIHtcclxuICAgICAgdWlkW2luZGV4XSA9ICcwJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHVpZFtpbmRleF0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRpZ2l0ICsgMSk7XHJcbiAgICAgIHJldHVybiB1aWQuam9pbignJyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHVpZC51bnNoaWZ0KCcwJyk7XHJcbiAgcmV0dXJuIHVpZC5qb2luKCcnKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXQgb3IgY2xlYXIgdGhlIGhhc2hrZXkgZm9yIGFuIG9iamVjdC5cclxuICogQHBhcmFtIG9iaiBvYmplY3RcclxuICogQHBhcmFtIGggdGhlIGhhc2hrZXkgKCF0cnV0aHkgdG8gZGVsZXRlIHRoZSBoYXNoa2V5KVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0SGFzaEtleShvYmosIGgpIHtcclxuICBpZiAoaCkge1xyXG4gICAgb2JqLiQkaGFzaEtleSA9IGg7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgZGVsZXRlIG9iai4kJGhhc2hLZXk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuZXh0ZW5kXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRXh0ZW5kcyB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGBkc3RgIGJ5IGNvcHlpbmcgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGBzcmNgIG9iamVjdChzKVxyXG4gKiB0byBgZHN0YC4gWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIGBzcmNgIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0LlxyXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc3JjIFNvdXJjZSBvYmplY3QocykuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlZmVyZW5jZSB0byBgZHN0YC5cclxuICovXHJcbmZ1bmN0aW9uIGV4dGVuZChkc3QpIHtcclxuICB2YXIgaCA9IGRzdC4kJGhhc2hLZXk7XHJcbiAgZm9yRWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKG9iail7XHJcbiAgICBpZiAob2JqICE9PSBkc3QpIHtcclxuICAgICAgZm9yRWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xyXG4gICAgICAgIGRzdFtrZXldID0gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBzZXRIYXNoS2V5KGRzdCxoKTtcclxuICByZXR1cm4gZHN0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnQoc3RyKSB7XHJcbiAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTApO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gaW5oZXJpdChwYXJlbnQsIGV4dHJhKSB7XHJcbiAgcmV0dXJuIGV4dGVuZChuZXcgKGV4dGVuZChmdW5jdGlvbigpIHt9LCB7cHJvdG90eXBlOnBhcmVudH0pKSgpLCBleHRyYSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5ub29wXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIG5vIG9wZXJhdGlvbnMuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY29kZSBpbiB0aGVcclxuICogZnVuY3Rpb25hbCBzdHlsZS5cclxuICAgPHByZT5cclxuICAgICBmdW5jdGlvbiBmb28oY2FsbGJhY2spIHtcclxuICAgICAgIHZhciByZXN1bHQgPSBjYWxjdWxhdGVSZXN1bHQoKTtcclxuICAgICAgIChjYWxsYmFjayB8fCBhbmd1bGFyLm5vb3ApKHJlc3VsdCk7XHJcbiAgICAgfVxyXG4gICA8L3ByZT5cclxuICovXHJcbmZ1bmN0aW9uIG5vb3AoKSB7fVxyXG5ub29wLiRpbmplY3QgPSBbXTtcclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuaWRlbnRpdHlcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBpdHMgZmlyc3QgYXJndW1lbnQuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjb2RlIGluIHRoZVxyXG4gKiBmdW5jdGlvbmFsIHN0eWxlLlxyXG4gKlxyXG4gICA8cHJlPlxyXG4gICAgIGZ1bmN0aW9uIHRyYW5zZm9ybWVyKHRyYW5zZm9ybWF0aW9uRm4sIHZhbHVlKSB7XHJcbiAgICAgICByZXR1cm4gKHRyYW5zZm9ybWF0aW9uRm4gfHwgYW5ndWxhci5pZGVudGl0eSkodmFsdWUpO1xyXG4gICAgIH07XHJcbiAgIDwvcHJlPlxyXG4gKi9cclxuZnVuY3Rpb24gaWRlbnRpdHkoJCkge3JldHVybiAkO31cclxuaWRlbnRpdHkuJGluamVjdCA9IFtdO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHZhbHVlRm4odmFsdWUpIHtyZXR1cm4gZnVuY3Rpb24oKSB7cmV0dXJuIHZhbHVlO307fVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmlzVW5kZWZpbmVkXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGV0ZXJtaW5lcyBpZiBhIHJlZmVyZW5jZSBpcyB1bmRlZmluZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnO31cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuaXNEZWZpbmVkXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGV0ZXJtaW5lcyBpZiBhIHJlZmVyZW5jZSBpcyBkZWZpbmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBkZWZpbmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlICE9ICd1bmRlZmluZWQnO31cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuaXNPYmplY3RcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEZXRlcm1pbmVzIGlmIGEgcmVmZXJlbmNlIGlzIGFuIGBPYmplY3RgLiBVbmxpa2UgYHR5cGVvZmAgaW4gSmF2YVNjcmlwdCwgYG51bGxgcyBhcmUgbm90XHJcbiAqIGNvbnNpZGVyZWQgdG8gYmUgb2JqZWN0cy5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBSZWZlcmVuY2UgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgYW4gYE9iamVjdGAgYnV0IG5vdCBgbnVsbGAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSl7cmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO31cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuaXNTdHJpbmdcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEZXRlcm1pbmVzIGlmIGEgcmVmZXJlbmNlIGlzIGEgYFN0cmluZ2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGEgYFN0cmluZ2AuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSl7cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJzt9XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmlzTnVtYmVyXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGV0ZXJtaW5lcyBpZiBhIHJlZmVyZW5jZSBpcyBhIGBOdW1iZXJgLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhIGBOdW1iZXJgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpe3JldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcic7fVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5pc0RhdGVcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEZXRlcm1pbmVzIGlmIGEgdmFsdWUgaXMgYSBkYXRlLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhIGBEYXRlYC5cclxuICovXHJcbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSl7XHJcbiAgcmV0dXJuIHRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PSAnW29iamVjdCBEYXRlXSc7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuaXNBcnJheVxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERldGVybWluZXMgaWYgYSByZWZlcmVuY2UgaXMgYW4gYEFycmF5YC5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSBSZWZlcmVuY2UgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgYW4gYEFycmF5YC5cclxuICovXHJcbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcclxuICByZXR1cm4gdG9TdHJpbmcuYXBwbHkodmFsdWUpID09ICdbb2JqZWN0IEFycmF5XSc7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIGFuZ3VsYXIuaXNGdW5jdGlvblxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERldGVybWluZXMgaWYgYSByZWZlcmVuY2UgaXMgYSBgRnVuY3Rpb25gLlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhIGBGdW5jdGlvbmAuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbic7fVxyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIGEgdmFsdWUgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhIGBSZWdFeHBgLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcclxuICByZXR1cm4gdG9TdHJpbmcuYXBwbHkodmFsdWUpID09ICdbb2JqZWN0IFJlZ0V4cF0nO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBgb2JqYCBpcyBhIHdpbmRvdyBvYmplY3QuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdCB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqYCBpcyBhIHdpbmRvdyBvYmouXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcclxuICByZXR1cm4gb2JqICYmIG9iai5kb2N1bWVudCAmJiBvYmoubG9jYXRpb24gJiYgb2JqLmFsZXJ0ICYmIG9iai5zZXRJbnRlcnZhbDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGlzU2NvcGUob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAmJiBvYmouJGV2YWxBc3luYyAmJiBvYmouJHdhdGNoO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gaXNGaWxlKG9iaikge1xyXG4gIHJldHVybiB0b1N0cmluZy5hcHBseShvYmopID09PSAnW29iamVjdCBGaWxlXSc7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdib29sZWFuJztcclxufVxyXG5cclxuXHJcbnZhciB0cmltID0gKGZ1bmN0aW9uKCkge1xyXG4gIC8vIG5hdGl2ZSB0cmltIGlzIHdheSBmYXN0ZXI6IGh0dHA6Ly9qc3BlcmYuY29tL2FuZ3VsYXItdHJpbS10ZXN0XHJcbiAgLy8gYnV0IElFIGRvZXNuJ3QgaGF2ZSBpdC4uLiA6LShcclxuICAvLyBUT0RPOiB3ZSBzaG91bGQgbW92ZSB0aGlzIGludG8gSUUvRVM1IHBvbHlmaWxsXHJcbiAgaWYgKCFTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gdmFsdWUucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJykgOiB2YWx1ZTtcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmlzRWxlbWVudFxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERldGVybWluZXMgaWYgYSByZWZlcmVuY2UgaXMgYSBET00gZWxlbWVudCAob3Igd3JhcHBlZCBqUXVlcnkgZWxlbWVudCkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQgKG9yIHdyYXBwZWQgalF1ZXJ5IGVsZW1lbnQpLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcclxuICByZXR1cm4gbm9kZSAmJlxyXG4gICAgKG5vZGUubm9kZU5hbWUgIC8vIHdlIGFyZSBhIGRpcmVjdCBlbGVtZW50XHJcbiAgICB8fCAobm9kZS5vbiAmJiBub2RlLmZpbmQpKTsgIC8vIHdlIGhhdmUgYW4gb24gYW5kIGZpbmQgbWV0aG9kIHBhcnQgb2YgalF1ZXJ5IEFQSVxyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHN0ciAna2V5MSxrZXkyLC4uLidcclxuICogQHJldHVybnMge29iamVjdH0gaW4gdGhlIGZvcm0gb2Yge2tleTE6dHJ1ZSwga2V5Mjp0cnVlLCAuLi59XHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTWFwKHN0cil7XHJcbiAgdmFyIG9iaiA9IHt9LCBpdGVtcyA9IHN0ci5zcGxpdChcIixcIiksIGk7XHJcbiAgZm9yICggaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKyApXHJcbiAgICBvYmpbIGl0ZW1zW2ldIF0gPSB0cnVlO1xyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcblxyXG5pZiAobXNpZSA8IDkpIHtcclxuICBub2RlTmFtZV8gPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50ID0gZWxlbWVudC5ub2RlTmFtZSA/IGVsZW1lbnQgOiBlbGVtZW50WzBdO1xyXG4gICAgcmV0dXJuIChlbGVtZW50LnNjb3BlTmFtZSAmJiBlbGVtZW50LnNjb3BlTmFtZSAhPSAnSFRNTCcpXHJcbiAgICAgID8gdXBwZXJjYXNlKGVsZW1lbnQuc2NvcGVOYW1lICsgJzonICsgZWxlbWVudC5ub2RlTmFtZSkgOiBlbGVtZW50Lm5vZGVOYW1lO1xyXG4gIH07XHJcbn0gZWxzZSB7XHJcbiAgbm9kZU5hbWVfID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUgPyBlbGVtZW50Lm5vZGVOYW1lIDogZWxlbWVudFswXS5ub2RlTmFtZTtcclxuICB9O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gbWFwKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcclxuICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gIGZvckVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgIHJlc3VsdHMucHVzaChpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpO1xyXG4gIH0pO1xyXG4gIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gYXJyYXksIHRoZSBudW1iZXIgb2YgcHJvcGVydGllcyBhbiBvYmplY3QgaGFzLCBvclxyXG4gKiB0aGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKlxyXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXVnbWVudCB0aGUgT2JqZWN0IHR5cGUgaW4gQW5ndWxhciBleHByZXNzaW9ucy4gU2VlXHJcbiAqIHtAbGluayBhbmd1bGFyLk9iamVjdH0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgQW5ndWxhciBhcnJheXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fHN0cmluZ30gb2JqIE9iamVjdCwgYXJyYXksIG9yIHN0cmluZyB0byBpbnNwZWN0LlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvd25Qcm9wc09ubHk9ZmFsc2VdIENvdW50IG9ubHkgXCJvd25cIiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc2l6ZSBvZiBgb2JqYCBvciBgMGAgaWYgYG9iamAgaXMgbmVpdGhlciBhbiBvYmplY3Qgbm9yIGFuIGFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gc2l6ZShvYmosIG93blByb3BzT25seSkge1xyXG4gIHZhciBzaXplID0gMCwga2V5O1xyXG5cclxuICBpZiAoaXNBcnJheShvYmopIHx8IGlzU3RyaW5nKG9iaikpIHtcclxuICAgIHJldHVybiBvYmoubGVuZ3RoO1xyXG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qob2JqKSl7XHJcbiAgICBmb3IgKGtleSBpbiBvYmopXHJcbiAgICAgIGlmICghb3duUHJvcHNPbmx5IHx8IG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHNpemUrKztcclxuICB9XHJcblxyXG4gIHJldHVybiBzaXplO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIG9iaikge1xyXG4gIHJldHVybiBpbmRleE9mKGFycmF5LCBvYmopICE9IC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbmRleE9mKGFycmF5LCBvYmopIHtcclxuICBpZiAoYXJyYXkuaW5kZXhPZikgcmV0dXJuIGFycmF5LmluZGV4T2Yob2JqKTtcclxuXHJcbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChvYmogPT09IGFycmF5W2ldKSByZXR1cm4gaTtcclxuICB9XHJcbiAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheVJlbW92ZShhcnJheSwgdmFsdWUpIHtcclxuICB2YXIgaW5kZXggPSBpbmRleE9mKGFycmF5LCB2YWx1ZSk7XHJcbiAgaWYgKGluZGV4ID49MClcclxuICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0xlYWZOb2RlIChub2RlKSB7XHJcbiAgaWYgKG5vZGUpIHtcclxuICAgIHN3aXRjaCAobm9kZS5ub2RlTmFtZSkge1xyXG4gICAgY2FzZSBcIk9QVElPTlwiOlxyXG4gICAgY2FzZSBcIlBSRVwiOlxyXG4gICAgY2FzZSBcIlRJVExFXCI6XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5jb3B5XHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiBgc291cmNlYCwgd2hpY2ggc2hvdWxkIGJlIGFuIG9iamVjdCBvciBhbiBhcnJheS5cclxuICpcclxuICogKiBJZiBubyBkZXN0aW5hdGlvbiBpcyBzdXBwbGllZCwgYSBjb3B5IG9mIHRoZSBvYmplY3Qgb3IgYXJyYXkgaXMgY3JlYXRlZC5cclxuICogKiBJZiBhIGRlc3RpbmF0aW9uIGlzIHByb3ZpZGVkLCBhbGwgb2YgaXRzIGVsZW1lbnRzIChmb3IgYXJyYXkpIG9yIHByb3BlcnRpZXMgKGZvciBvYmplY3RzKVxyXG4gKiAgIGFyZSBkZWxldGVkIGFuZCB0aGVuIGFsbCBlbGVtZW50cy9wcm9wZXJ0aWVzIGZyb20gdGhlIHNvdXJjZSBhcmUgY29waWVkIHRvIGl0LlxyXG4gKiAqIElmICBgc291cmNlYCBpcyBub3QgYW4gb2JqZWN0IG9yIGFycmF5LCBgc291cmNlYCBpcyByZXR1cm5lZC5cclxuICpcclxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF1Z21lbnQgdGhlIE9iamVjdCB0eXBlIGluIEFuZ3VsYXIgZXhwcmVzc2lvbnMuIFNlZVxyXG4gKiB7QGxpbmsgbmcuJGZpbHRlcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgQW5ndWxhciBhcnJheXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gc291cmNlIFRoZSBzb3VyY2UgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWFrZSBhIGNvcHkuXHJcbiAqICAgICAgICAgICAgICAgICAgIENhbiBiZSBhbnkgdHlwZSwgaW5jbHVkaW5nIHByaW1pdGl2ZXMsIGBudWxsYCwgYW5kIGB1bmRlZmluZWRgLlxyXG4gKiBAcGFyYW0geyhPYmplY3R8QXJyYXkpPX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gaW50byB3aGljaCB0aGUgc291cmNlIGlzIGNvcGllZC4gSWZcclxuICogICAgIHByb3ZpZGVkLCBtdXN0IGJlIG9mIHRoZSBzYW1lIHR5cGUgYXMgYHNvdXJjZWAuXHJcbiAqIEByZXR1cm5zIHsqfSBUaGUgY29weSBvciB1cGRhdGVkIGBkZXN0aW5hdGlvbmAsIGlmIGBkZXN0aW5hdGlvbmAgd2FzIHNwZWNpZmllZC5cclxuICovXHJcbmZ1bmN0aW9uIGNvcHkoc291cmNlLCBkZXN0aW5hdGlvbil7XHJcbiAgaWYgKGlzV2luZG93KHNvdXJjZSkgfHwgaXNTY29wZShzb3VyY2UpKSB7XHJcbiAgICB0aHJvdyBuZ01pbkVycignY3B3cycsIFwiQ2FuJ3QgY29weSEgTWFraW5nIGNvcGllcyBvZiBXaW5kb3cgb3IgU2NvcGUgaW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFkZXN0aW5hdGlvbikge1xyXG4gICAgZGVzdGluYXRpb24gPSBzb3VyY2U7XHJcbiAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICBkZXN0aW5hdGlvbiA9IGNvcHkoc291cmNlLCBbXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKHNvdXJjZSkpIHtcclxuICAgICAgICBkZXN0aW5hdGlvbiA9IG5ldyBEYXRlKHNvdXJjZS5nZXRUaW1lKCkpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzUmVnRXhwKHNvdXJjZSkpIHtcclxuICAgICAgICBkZXN0aW5hdGlvbiA9IG5ldyBSZWdFeHAoc291cmNlLnNvdXJjZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uID0gY29weShzb3VyY2UsIHt9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoc291cmNlID09PSBkZXN0aW5hdGlvbikgdGhyb3cgbmdNaW5FcnIoJ2NwaScsIFwiQ2FuJ3QgY29weSEgU291cmNlIGFuZCBkZXN0aW5hdGlvbiBhcmUgaWRlbnRpY2FsLlwiKTtcclxuICAgIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgZGVzdGluYXRpb24ubGVuZ3RoID0gMDtcclxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZGVzdGluYXRpb24ucHVzaChjb3B5KHNvdXJjZVtpXSkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgaCA9IGRlc3RpbmF0aW9uLiQkaGFzaEtleTtcclxuICAgICAgZm9yRWFjaChkZXN0aW5hdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSl7XHJcbiAgICAgICAgZGVsZXRlIGRlc3RpbmF0aW9uW2tleV07XHJcbiAgICAgIH0pO1xyXG4gICAgICBmb3IgKCB2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBjb3B5KHNvdXJjZVtrZXldKTtcclxuICAgICAgfVxyXG4gICAgICBzZXRIYXNoS2V5KGRlc3RpbmF0aW9uLGgpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZGVzdGluYXRpb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBzaGFsbG93IGNvcHkgb2YgYW4gb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93Q29weShzcmMsIGRzdCkge1xyXG4gIGRzdCA9IGRzdCB8fCB7fTtcclxuXHJcbiAgZm9yKHZhciBrZXkgaW4gc3JjKSB7XHJcbiAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gJyQkJykge1xyXG4gICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRzdDtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5lcXVhbHNcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBEZXRlcm1pbmVzIGlmIHR3byBvYmplY3RzIG9yIHR3byB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQuIFN1cHBvcnRzIHZhbHVlIHR5cGVzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBhcnJheXMgYW5kXHJcbiAqIG9iamVjdHMuXHJcbiAqXHJcbiAqIFR3byBvYmplY3RzIG9yIHZhbHVlcyBhcmUgY29uc2lkZXJlZCBlcXVpdmFsZW50IGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XHJcbiAqXHJcbiAqICogQm90aCBvYmplY3RzIG9yIHZhbHVlcyBwYXNzIGA9PT1gIGNvbXBhcmlzb24uXHJcbiAqICogQm90aCBvYmplY3RzIG9yIHZhbHVlcyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmQgYWxsIG9mIHRoZWlyIHByb3BlcnRpZXMgcGFzcyBgPT09YCBjb21wYXJpc29uLlxyXG4gKiAqIEJvdGggdmFsdWVzIGFyZSBOYU4uIChJbiBKYXZhc1NjcmlwdCwgTmFOID09IE5hTiA9PiBmYWxzZS4gQnV0IHdlIGNvbnNpZGVyIHR3byBOYU4gYXMgZXF1YWwpXHJcbiAqICogQm90aCB2YWx1ZXMgcmVwcmVzZW50IHRoZSBzYW1lIHJlZ3VsYXIgZXhwcmVzc2lvbiAoSW4gSmF2YXNTY3JpcHQsXHJcbiAqICAgL2FiYy8gPT0gL2FiYy8gPT4gZmFsc2UuIEJ1dCB3ZSBjb25zaWRlciB0d28gcmVndWxhciBleHByZXNzaW9ucyBhcyBlcXVhbCB3aGVuIHRoZWlyIHRleHR1YWxcclxuICogICByZXByZXNlbnRhdGlvbiBtYXRjaGVzKS5cclxuICpcclxuICogRHVyaW5nIGEgcHJvcGVydHkgY29tcGFyaXNvbiwgcHJvcGVydGllcyBvZiBgZnVuY3Rpb25gIHR5cGUgYW5kIHByb3BlcnRpZXMgd2l0aCBuYW1lc1xyXG4gKiB0aGF0IGJlZ2luIHdpdGggYCRgIGFyZSBpZ25vcmVkLlxyXG4gKlxyXG4gKiBTY29wZSBhbmQgRE9NV2luZG93IG9iamVjdHMgYXJlIGJlaW5nIGNvbXBhcmVkIG9ubHkgYnkgaWRlbnRpZnkgKGA9PT1gKS5cclxuICpcclxuICogQHBhcmFtIHsqfSBvMSBPYmplY3Qgb3IgdmFsdWUgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIHsqfSBvMiBPYmplY3Qgb3IgdmFsdWUgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYXJndW1lbnRzIGFyZSBlcXVhbC5cclxuICovXHJcbmZ1bmN0aW9uIGVxdWFscyhvMSwgbzIpIHtcclxuICBpZiAobzEgPT09IG8yKSByZXR1cm4gdHJ1ZTtcclxuICBpZiAobzEgPT09IG51bGwgfHwgbzIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcclxuICBpZiAobzEgIT09IG8xICYmIG8yICE9PSBvMikgcmV0dXJuIHRydWU7IC8vIE5hTiA9PT0gTmFOXHJcbiAgdmFyIHQxID0gdHlwZW9mIG8xLCB0MiA9IHR5cGVvZiBvMiwgbGVuZ3RoLCBrZXksIGtleVNldDtcclxuICBpZiAodDEgPT0gdDIpIHtcclxuICAgIGlmICh0MSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICBpZiAoaXNBcnJheShvMSkpIHtcclxuICAgICAgICBpZiAoIWlzQXJyYXkobzIpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKChsZW5ndGggPSBvMS5sZW5ndGgpID09IG8yLmxlbmd0aCkge1xyXG4gICAgICAgICAgZm9yKGtleT0wOyBrZXk8bGVuZ3RoOyBrZXkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWVxdWFscyhvMVtrZXldLCBvMltrZXldKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGlzRGF0ZShvMSkpIHtcclxuICAgICAgICByZXR1cm4gaXNEYXRlKG8yKSAmJiBvMS5nZXRUaW1lKCkgPT0gbzIuZ2V0VGltZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzUmVnRXhwKG8xKSAmJiBpc1JlZ0V4cChvMikpIHtcclxuICAgICAgICByZXR1cm4gbzEudG9TdHJpbmcoKSA9PSBvMi50b1N0cmluZygpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpc1Njb3BlKG8xKSB8fCBpc1Njb3BlKG8yKSB8fCBpc1dpbmRvdyhvMSkgfHwgaXNXaW5kb3cobzIpIHx8IGlzQXJyYXkobzIpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAga2V5U2V0ID0ge307XHJcbiAgICAgICAgZm9yKGtleSBpbiBvMSkge1xyXG4gICAgICAgICAgaWYgKGtleS5jaGFyQXQoMCkgPT09ICckJyB8fCBpc0Z1bmN0aW9uKG8xW2tleV0pKSBjb250aW51ZTtcclxuICAgICAgICAgIGlmICghZXF1YWxzKG8xW2tleV0sIG8yW2tleV0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICBrZXlTZXRba2V5XSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihrZXkgaW4gbzIpIHtcclxuICAgICAgICAgIGlmICgha2V5U2V0Lmhhc093blByb3BlcnR5KGtleSkgJiZcclxuICAgICAgICAgICAgICBrZXkuY2hhckF0KDApICE9PSAnJCcgJiZcclxuICAgICAgICAgICAgICBvMltrZXldICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAhaXNGdW5jdGlvbihvMltrZXldKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBjb25jYXQoYXJyYXkxLCBhcnJheTIsIGluZGV4KSB7XHJcbiAgcmV0dXJuIGFycmF5MS5jb25jYXQoc2xpY2UuY2FsbChhcnJheTIsIGluZGV4KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNsaWNlQXJncyhhcmdzLCBzdGFydEluZGV4KSB7XHJcbiAgcmV0dXJuIHNsaWNlLmNhbGwoYXJncywgc3RhcnRJbmRleCB8fCAwKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgYW5ndWxhci5iaW5kXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGNhbGxzIGZ1bmN0aW9uIGBmbmAgYm91bmQgdG8gYHNlbGZgIChgc2VsZmAgYmVjb21lcyB0aGUgYHRoaXNgIGZvclxyXG4gKiBgZm5gKS4gWW91IGNhbiBzdXBwbHkgb3B0aW9uYWwgYGFyZ3NgIHRoYXQgYXJlIHByZWJvdW5kIHRvIHRoZSBmdW5jdGlvbi4gVGhpcyBmZWF0dXJlIGlzIGFsc29cclxuICoga25vd24gYXMgW2Z1bmN0aW9uIGN1cnJ5aW5nXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1cnJ5aW5nKS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgQ29udGV4dCB3aGljaCBgZm5gIHNob3VsZCBiZSBldmFsdWF0ZWQgaW4uXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm4gRnVuY3Rpb24gdG8gYmUgYm91bmQuXHJcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBPcHRpb25hbCBhcmd1bWVudHMgdG8gYmUgcHJlYm91bmQgdG8gdGhlIGBmbmAgZnVuY3Rpb24gY2FsbC5cclxuICogQHJldHVybnMge2Z1bmN0aW9uKCl9IEZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlIGBmbmAgd2l0aCBhbGwgdGhlIHNwZWNpZmllZCBiaW5kaW5ncy5cclxuICovXHJcbmZ1bmN0aW9uIGJpbmQoc2VsZiwgZm4pIHtcclxuICB2YXIgY3VycnlBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBzbGljZUFyZ3MoYXJndW1lbnRzLCAyKSA6IFtdO1xyXG4gIGlmIChpc0Z1bmN0aW9uKGZuKSAmJiAhKGZuIGluc3RhbmNlb2YgUmVnRXhwKSkge1xyXG4gICAgcmV0dXJuIGN1cnJ5QXJncy5sZW5ndGhcclxuICAgICAgPyBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXHJcbiAgICAgICAgICAgID8gZm4uYXBwbHkoc2VsZiwgY3VycnlBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKVxyXG4gICAgICAgICAgICA6IGZuLmFwcGx5KHNlbGYsIGN1cnJ5QXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcclxuICAgICAgICAgICAgPyBmbi5hcHBseShzZWxmLCBhcmd1bWVudHMpXHJcbiAgICAgICAgICAgIDogZm4uY2FsbChzZWxmKTtcclxuICAgICAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBpbiBJRSwgbmF0aXZlIG1ldGhvZHMgYXJlIG5vdCBmdW5jdGlvbnMgc28gdGhleSBjYW5ub3QgYmUgYm91bmQgKG5vdGU6IHRoZXkgZG9uJ3QgbmVlZCB0byBiZSlcclxuICAgIHJldHVybiBmbjtcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiB0b0pzb25SZXBsYWNlcihrZXksIHZhbHVlKSB7XHJcbiAgdmFyIHZhbCA9IHZhbHVlO1xyXG5cclxuICBpZiAoL15cXCQrLy50ZXN0KGtleSkpIHtcclxuICAgIHZhbCA9IHVuZGVmaW5lZDtcclxuICB9IGVsc2UgaWYgKGlzV2luZG93KHZhbHVlKSkge1xyXG4gICAgdmFsID0gJyRXSU5ET1cnO1xyXG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgIGRvY3VtZW50ID09PSB2YWx1ZSkge1xyXG4gICAgdmFsID0gJyRET0NVTUVOVCc7XHJcbiAgfSBlbHNlIGlmIChpc1Njb3BlKHZhbHVlKSkge1xyXG4gICAgdmFsID0gJyRTQ09QRSc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdmFsO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLnRvSnNvblxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFNlcmlhbGl6ZXMgaW5wdXQgaW50byBhIEpTT04tZm9ybWF0dGVkIHN0cmluZy4gUHJvcGVydGllcyB3aXRoIGxlYWRpbmcgJCBjaGFyYWN0ZXJzIHdpbGwgYmVcclxuICogc3RyaXBwZWQgc2luY2UgYW5ndWxhciB1c2VzIHRoaXMgbm90YXRpb24gaW50ZXJuYWxseS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8RGF0ZXxzdHJpbmd8bnVtYmVyfSBvYmogSW5wdXQgdG8gYmUgc2VyaWFsaXplZCBpbnRvIEpTT04uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHByZXR0eSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIEpTT04gb3V0cHV0IHdpbGwgY29udGFpbiBuZXdsaW5lcyBhbmQgd2hpdGVzcGFjZS5cclxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IEpTT04taWZpZWQgc3RyaW5nIHJlcHJlc2VudGluZyBgb2JqYC5cclxuICovXHJcbmZ1bmN0aW9uIHRvSnNvbihvYmosIHByZXR0eSkge1xyXG4gIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHVuZGVmaW5lZDtcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCB0b0pzb25SZXBsYWNlciwgcHJldHR5ID8gJyAgJyA6IG51bGwpO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmZyb21Kc29uXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGVzZXJpYWxpemVzIGEgSlNPTiBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc29uIEpTT04gc3RyaW5nIHRvIGRlc2VyaWFsaXplLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fEFycmF5fERhdGV8c3RyaW5nfG51bWJlcn0gRGVzZXJpYWxpemVkIHRoaW5neS5cclxuICovXHJcbmZ1bmN0aW9uIGZyb21Kc29uKGpzb24pIHtcclxuICByZXR1cm4gaXNTdHJpbmcoanNvbilcclxuICAgICAgPyBKU09OLnBhcnNlKGpzb24pXHJcbiAgICAgIDoganNvbjtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xyXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggIT09IDApIHtcclxuICAgIHZhciB2ID0gbG93ZXJjYXNlKFwiXCIgKyB2YWx1ZSk7XHJcbiAgICB2YWx1ZSA9ICEodiA9PSAnZicgfHwgdiA9PSAnMCcgfHwgdiA9PSAnZmFsc2UnIHx8IHYgPT0gJ25vJyB8fCB2ID09ICduJyB8fCB2ID09ICdbXScpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YWx1ZSA9IGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVsZW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFydGluZ1RhZyhlbGVtZW50KSB7XHJcbiAgZWxlbWVudCA9IGpxTGl0ZShlbGVtZW50KS5jbG9uZSgpO1xyXG4gIHRyeSB7XHJcbiAgICAvLyB0dXJucyBvdXQgSUUgZG9lcyBub3QgbGV0IHlvdSBzZXQgLmh0bWwoKSBvbiBlbGVtZW50cyB3aGljaFxyXG4gICAgLy8gYXJlIG5vdCBhbGxvd2VkIHRvIGhhdmUgY2hpbGRyZW4uIFNvIHdlIGp1c3QgaWdub3JlIGl0LlxyXG4gICAgZWxlbWVudC5odG1sKCcnKTtcclxuICB9IGNhdGNoKGUpIHt9XHJcbiAgLy8gQXMgUGVyIERPTSBTdGFuZGFyZHNcclxuICB2YXIgVEVYVF9OT0RFID0gMztcclxuICB2YXIgZWxlbUh0bWwgPSBqcUxpdGUoJzxkaXY+JykuYXBwZW5kKGVsZW1lbnQpLmh0bWwoKTtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGVsZW1lbnRbMF0ubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IGxvd2VyY2FzZShlbGVtSHRtbCkgOlxyXG4gICAgICAgIGVsZW1IdG1sLlxyXG4gICAgICAgICAgbWF0Y2goL14oPFtePl0rPikvKVsxXS5cclxuICAgICAgICAgIHJlcGxhY2UoL148KFtcXHdcXC1dKykvLCBmdW5jdGlvbihtYXRjaCwgbm9kZU5hbWUpIHsgcmV0dXJuICc8JyArIGxvd2VyY2FzZShub2RlTmFtZSk7IH0pO1xyXG4gIH0gY2F0Y2goZSkge1xyXG4gICAgcmV0dXJuIGxvd2VyY2FzZShlbGVtSHRtbCk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBUcmllcyB0byBkZWNvZGUgdGhlIFVSSSBjb21wb25lbnQgd2l0aG91dCB0aHJvd2luZyBhbiBleGNlcHRpb24uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSBzdHIgdmFsdWUgcG90ZW50aWFsIFVSSSBjb21wb25lbnQgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgY2FuIGJlIGRlY29kZWRcclxuICogd2l0aCB0aGUgZGVjb2RlVVJJQ29tcG9uZW50IGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJ5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xyXG4gIH0gY2F0Y2goZSkge1xyXG4gICAgLy8gSWdub3JlIGFueSBpbnZhbGlkIHVyaSBjb21wb25lbnRcclxuICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogUGFyc2VzIGFuIGVzY2FwZWQgdXJsIHF1ZXJ5IHN0cmluZyBpbnRvIGtleS12YWx1ZSBwYWlycy5cclxuICogQHJldHVybnMgT2JqZWN0Ljwoc3RyaW5nfGJvb2xlYW4pPlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VLZXlWYWx1ZSgvKipzdHJpbmcqL2tleVZhbHVlKSB7XHJcbiAgdmFyIG9iaiA9IHt9LCBrZXlfdmFsdWUsIGtleTtcclxuICBmb3JFYWNoKChrZXlWYWx1ZSB8fCBcIlwiKS5zcGxpdCgnJicpLCBmdW5jdGlvbihrZXlWYWx1ZSl7XHJcbiAgICBpZiAoIGtleVZhbHVlICkge1xyXG4gICAgICBrZXlfdmFsdWUgPSBrZXlWYWx1ZS5zcGxpdCgnPScpO1xyXG4gICAgICBrZXkgPSB0cnlEZWNvZGVVUklDb21wb25lbnQoa2V5X3ZhbHVlWzBdKTtcclxuICAgICAgaWYgKCBpc0RlZmluZWQoa2V5KSApIHtcclxuICAgICAgICB2YXIgdmFsID0gaXNEZWZpbmVkKGtleV92YWx1ZVsxXSkgPyB0cnlEZWNvZGVVUklDb21wb25lbnQoa2V5X3ZhbHVlWzFdKSA6IHRydWU7XHJcbiAgICAgICAgaWYgKCFvYmpba2V5XSkge1xyXG4gICAgICAgICAgb2JqW2tleV0gPSB2YWw7XHJcbiAgICAgICAgfSBlbHNlIGlmKGlzQXJyYXkob2JqW2tleV0pKSB7XHJcbiAgICAgICAgICBvYmpba2V5XS5wdXNoKHZhbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9ialtrZXldID0gW29ialtrZXldLHZhbF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9LZXlWYWx1ZShvYmopIHtcclxuICB2YXIgcGFydHMgPSBbXTtcclxuICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKGFycmF5VmFsdWUpIHtcclxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZVVyaVF1ZXJ5KGtleSwgdHJ1ZSkgKyAoYXJyYXlWYWx1ZSA9PT0gdHJ1ZSA/ICcnIDogJz0nICsgZW5jb2RlVXJpUXVlcnkoYXJyYXlWYWx1ZSwgdHJ1ZSkpKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgcGFydHMucHVzaChlbmNvZGVVcmlRdWVyeShrZXksIHRydWUpICsgKHZhbHVlID09PSB0cnVlID8gJycgOiAnPScgKyBlbmNvZGVVcmlRdWVyeSh2YWx1ZSwgdHJ1ZSkpKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcGFydHMubGVuZ3RoID8gcGFydHMuam9pbignJicpIDogJyc7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogV2UgbmVlZCBvdXIgY3VzdG9tIG1ldGhvZCBiZWNhdXNlIGVuY29kZVVSSUNvbXBvbmVudCBpcyB0b28gYWdncmVzc2l2ZSBhbmQgZG9lc24ndCBmb2xsb3dcclxuICogaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzk4Ni50eHQgd2l0aCByZWdhcmRzIHRvIHRoZSBjaGFyYWN0ZXIgc2V0IChwY2hhcikgYWxsb3dlZCBpbiBwYXRoXHJcbiAqIHNlZ21lbnRzOlxyXG4gKiAgICBzZWdtZW50ICAgICAgID0gKnBjaGFyXHJcbiAqICAgIHBjaGFyICAgICAgICAgPSB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgLyBcIkBcIlxyXG4gKiAgICBwY3QtZW5jb2RlZCAgID0gXCIlXCIgSEVYRElHIEhFWERJR1xyXG4gKiAgICB1bnJlc2VydmVkICAgID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXHJcbiAqICAgIHN1Yi1kZWxpbXMgICAgPSBcIiFcIiAvIFwiJFwiIC8gXCImXCIgLyBcIidcIiAvIFwiKFwiIC8gXCIpXCJcclxuICogICAgICAgICAgICAgICAgICAgICAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZVVyaVNlZ21lbnQodmFsKSB7XHJcbiAgcmV0dXJuIGVuY29kZVVyaVF1ZXJ5KHZhbCwgdHJ1ZSkuXHJcbiAgICAgICAgICAgICByZXBsYWNlKC8lMjYvZ2ksICcmJykuXHJcbiAgICAgICAgICAgICByZXBsYWNlKC8lM0QvZ2ksICc9JykuXHJcbiAgICAgICAgICAgICByZXBsYWNlKC8lMkIvZ2ksICcrJyk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGVuY29kaW5nICprZXkqIG9yICp2YWx1ZSogcGFydHMgb2YgcXVlcnkgY29tcG9uZW50LiBXZSBuZWVkIGEgY3VzdG9tXHJcbiAqIG1ldGhvZCBiZWNhdXNlIGVuY29kZVVSSUNvbXBvbmVudCBpcyB0b28gYWdncmVzc2l2ZSBhbmQgZW5jb2RlcyBzdHVmZiB0aGF0IGRvZXNuJ3QgaGF2ZSB0byBiZVxyXG4gKiBlbmNvZGVkIHBlciBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2OlxyXG4gKiAgICBxdWVyeSAgICAgICA9ICooIHBjaGFyIC8gXCIvXCIgLyBcIj9cIiApXHJcbiAqICAgIHBjaGFyICAgICAgICAgPSB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgLyBcIkBcIlxyXG4gKiAgICB1bnJlc2VydmVkICAgID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXHJcbiAqICAgIHBjdC1lbmNvZGVkICAgPSBcIiVcIiBIRVhESUcgSEVYRElHXHJcbiAqICAgIHN1Yi1kZWxpbXMgICAgPSBcIiFcIiAvIFwiJFwiIC8gXCImXCIgLyBcIidcIiAvIFwiKFwiIC8gXCIpXCJcclxuICogICAgICAgICAgICAgICAgICAgICAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZVVyaVF1ZXJ5KHZhbCwgcGN0RW5jb2RlU3BhY2VzKSB7XHJcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxyXG4gICAgICAgICAgICAgcmVwbGFjZSgvJTQwL2dpLCAnQCcpLlxyXG4gICAgICAgICAgICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxyXG4gICAgICAgICAgICAgcmVwbGFjZSgvJTI0L2csICckJykuXHJcbiAgICAgICAgICAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXHJcbiAgICAgICAgICAgICByZXBsYWNlKC8lMjAvZywgKHBjdEVuY29kZVNwYWNlcyA/ICclMjAnIDogJysnKSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdBcHBcclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7YW5ndWxhci5Nb2R1bGV9IG5nQXBwIGFuIG9wdGlvbmFsIGFwcGxpY2F0aW9uXHJcbiAqICAge0BsaW5rIGFuZ3VsYXIubW9kdWxlIG1vZHVsZX0gbmFtZSB0byBsb2FkLlxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogVXNlIHRoaXMgZGlyZWN0aXZlIHRvIGF1dG8tYm9vdHN0cmFwIGFuIGFwcGxpY2F0aW9uLiBPbmx5XHJcbiAqIG9uZSBuZ0FwcCBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgcGVyIEhUTUwgZG9jdW1lbnQuIFRoZSBkaXJlY3RpdmVcclxuICogZGVzaWduYXRlcyB0aGUgcm9vdCBvZiB0aGUgYXBwbGljYXRpb24gYW5kIGlzIHR5cGljYWxseSBwbGFjZWRcclxuICogYXQgdGhlIHJvb3Qgb2YgdGhlIHBhZ2UuXHJcbiAqXHJcbiAqIFRoZSBmaXJzdCBuZ0FwcCBmb3VuZCBpbiB0aGUgZG9jdW1lbnQgd2lsbCBiZSBhdXRvLWJvb3RzdHJhcHBlZC4gVG8gdXNlIG11bHRpcGxlIGFwcGxpY2F0aW9ucyBpbiBhblxyXG4gKiBIVE1MIGRvY3VtZW50IHlvdSBtdXN0IG1hbnVhbGx5IGJvb3RzdHJhcCB0aGVtIHVzaW5nIHtAbGluayBhbmd1bGFyLmJvb3RzdHJhcH0uXHJcbiAqIEFwcGxpY2F0aW9ucyBjYW5ub3QgYmUgbmVzdGVkLlxyXG4gKlxyXG4gKiBJbiB0aGUgZXhhbXBsZSBiZWxvdyBpZiB0aGUgYG5nQXBwYCBkaXJlY3RpdmUgd291bGQgbm90IGJlIHBsYWNlZFxyXG4gKiBvbiB0aGUgYGh0bWxgIGVsZW1lbnQgdGhlbiB0aGUgZG9jdW1lbnQgd291bGQgbm90IGJlIGNvbXBpbGVkXHJcbiAqIGFuZCB0aGUgYHt7IDErMiB9fWAgd291bGQgbm90IGJlIHJlc29sdmVkIHRvIGAzYC5cclxuICpcclxuICogYG5nQXBwYCBpcyB0aGUgZWFzaWVzdCB3YXkgdG8gYm9vdHN0cmFwIGFuIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gPGRvYzpleGFtcGxlPlxyXG4gICA8ZG9jOnNvdXJjZT5cclxuICAgIEkgY2FuIGFkZDogMSArIDIgPSAge3sgMSsyIH19XHJcbiAgIDwvZG9jOnNvdXJjZT5cclxuIDwvZG9jOmV4YW1wbGU+XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhbmd1bGFySW5pdChlbGVtZW50LCBib290c3RyYXApIHtcclxuICB2YXIgZWxlbWVudHMgPSBbZWxlbWVudF0sXHJcbiAgICAgIGFwcEVsZW1lbnQsXHJcbiAgICAgIG1vZHVsZSxcclxuICAgICAgbmFtZXMgPSBbJ25nOmFwcCcsICduZy1hcHAnLCAneC1uZy1hcHAnLCAnZGF0YS1uZy1hcHAnXSxcclxuICAgICAgTkdfQVBQX0NMQVNTX1JFR0VYUCA9IC9cXHNuZ1s6XFwtXWFwcCg6XFxzKihbXFx3XFxkX10rKTs/KT9cXHMvO1xyXG5cclxuICBmdW5jdGlvbiBhcHBlbmQoZWxlbWVudCkge1xyXG4gICAgZWxlbWVudCAmJiBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgZm9yRWFjaChuYW1lcywgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgbmFtZXNbbmFtZV0gPSB0cnVlO1xyXG4gICAgYXBwZW5kKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5hbWUpKTtcclxuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoJzonLCAnXFxcXDonKTtcclxuICAgIGlmIChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpIHtcclxuICAgICAgZm9yRWFjaChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgbmFtZSksIGFwcGVuZCk7XHJcbiAgICAgIGZvckVhY2goZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIG5hbWUgKyAnXFxcXDonKSwgYXBwZW5kKTtcclxuICAgICAgZm9yRWFjaChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgbmFtZSArICddJyksIGFwcGVuZCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGlmICghYXBwRWxlbWVudCkge1xyXG4gICAgICB2YXIgY2xhc3NOYW1lID0gJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICc7XHJcbiAgICAgIHZhciBtYXRjaCA9IE5HX0FQUF9DTEFTU19SRUdFWFAuZXhlYyhjbGFzc05hbWUpO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBhcHBFbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICBtb2R1bGUgPSAobWF0Y2hbMl0gfHwgJycpLnJlcGxhY2UoL1xccysvZywgJywnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3JFYWNoKGVsZW1lbnQuYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xyXG4gICAgICAgICAgaWYgKCFhcHBFbGVtZW50ICYmIG5hbWVzW2F0dHIubmFtZV0pIHtcclxuICAgICAgICAgICAgYXBwRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIG1vZHVsZSA9IGF0dHIudmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuICBpZiAoYXBwRWxlbWVudCkge1xyXG4gICAgYm9vdHN0cmFwKGFwcEVsZW1lbnQsIG1vZHVsZSA/IFttb2R1bGVdIDogW10pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmJvb3RzdHJhcFxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gbWFudWFsbHkgc3RhcnQgdXAgYW5ndWxhciBhcHBsaWNhdGlvbi5cclxuICpcclxuICogU2VlOiB7QGxpbmsgZ3VpZGUvYm9vdHN0cmFwIEJvb3RzdHJhcH1cclxuICpcclxuICogTm90ZSB0aGF0IG5nU2NlbmFyaW8tYmFzZWQgZW5kLXRvLWVuZCB0ZXN0cyBjYW5ub3QgdXNlIHRoaXMgZnVuY3Rpb24gdG8gYm9vdHN0cmFwIG1hbnVhbGx5LlxyXG4gKiBUaGV5IG11c3QgdXNlIHtAbGluayBhcGkvbmcuZGlyZWN0aXZlOm5nQXBwIG5nQXBwfS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IERPTSBlbGVtZW50IHdoaWNoIGlzIHRoZSByb290IG9mIGFuZ3VsYXIgYXBwbGljYXRpb24uXHJcbiAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nfEZ1bmN0aW9uPj19IG1vZHVsZXMgYW4gYXJyYXkgb2YgbW9kdWxlIGRlY2xhcmF0aW9ucy4gU2VlOiB7QGxpbmsgYW5ndWxhci5tb2R1bGUgbW9kdWxlc31cclxuICogQHJldHVybnMge0FVVE8uJGluamVjdG9yfSBSZXR1cm5zIHRoZSBuZXdseSBjcmVhdGVkIGluamVjdG9yIGZvciB0aGlzIGFwcC5cclxuICovXHJcbmZ1bmN0aW9uIGJvb3RzdHJhcChlbGVtZW50LCBtb2R1bGVzKSB7XHJcbiAgdmFyIGRvQm9vdHN0cmFwID0gZnVuY3Rpb24oKSB7XHJcbiAgICBlbGVtZW50ID0ganFMaXRlKGVsZW1lbnQpO1xyXG5cclxuICAgIGlmIChlbGVtZW50LmluamVjdG9yKCkpIHtcclxuICAgICAgdmFyIHRhZyA9IChlbGVtZW50WzBdID09PSBkb2N1bWVudCkgPyAnZG9jdW1lbnQnIDogc3RhcnRpbmdUYWcoZWxlbWVudCk7XHJcbiAgICAgIHRocm93IG5nTWluRXJyKCdidHN0cnBkJywgXCJBcHAgQWxyZWFkeSBCb290c3RyYXBwZWQgd2l0aCB0aGlzIEVsZW1lbnQgJ3swfSdcIiwgdGFnKTtcclxuICAgIH1cclxuXHJcbiAgICBtb2R1bGVzID0gbW9kdWxlcyB8fCBbXTtcclxuICAgIG1vZHVsZXMudW5zaGlmdChbJyRwcm92aWRlJywgZnVuY3Rpb24oJHByb3ZpZGUpIHtcclxuICAgICAgJHByb3ZpZGUudmFsdWUoJyRyb290RWxlbWVudCcsIGVsZW1lbnQpO1xyXG4gICAgfV0pO1xyXG4gICAgbW9kdWxlcy51bnNoaWZ0KCduZycpO1xyXG4gICAgdmFyIGluamVjdG9yID0gY3JlYXRlSW5qZWN0b3IobW9kdWxlcyk7XHJcbiAgICBpbmplY3Rvci5pbnZva2UoWyckcm9vdFNjb3BlJywgJyRyb290RWxlbWVudCcsICckY29tcGlsZScsICckaW5qZWN0b3InLCAnJGFuaW1hdGUnLFxyXG4gICAgICAgZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGNvbXBpbGUsIGluamVjdG9yLCBhbmltYXRlKSB7XHJcbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgZWxlbWVudC5kYXRhKCckaW5qZWN0b3InLCBpbmplY3Rvcik7XHJcbiAgICAgICAgICBjb21waWxlKGVsZW1lbnQpKHNjb3BlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhbmltYXRlLmVuYWJsZWQodHJ1ZSk7XHJcbiAgICAgIH1dXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIGluamVjdG9yO1xyXG4gIH07XHJcblxyXG4gIHZhciBOR19ERUZFUl9CT09UU1RSQVAgPSAvXk5HX0RFRkVSX0JPT1RTVFJBUCEvO1xyXG5cclxuICBpZiAod2luZG93ICYmICFOR19ERUZFUl9CT09UU1RSQVAudGVzdCh3aW5kb3cubmFtZSkpIHtcclxuICAgIHJldHVybiBkb0Jvb3RzdHJhcCgpO1xyXG4gIH1cclxuXHJcbiAgd2luZG93Lm5hbWUgPSB3aW5kb3cubmFtZS5yZXBsYWNlKE5HX0RFRkVSX0JPT1RTVFJBUCwgJycpO1xyXG4gIGFuZ3VsYXIucmVzdW1lQm9vdHN0cmFwID0gZnVuY3Rpb24oZXh0cmFNb2R1bGVzKSB7XHJcbiAgICBmb3JFYWNoKGV4dHJhTW9kdWxlcywgZnVuY3Rpb24obW9kdWxlKSB7XHJcbiAgICAgIG1vZHVsZXMucHVzaChtb2R1bGUpO1xyXG4gICAgfSk7XHJcbiAgICBkb0Jvb3RzdHJhcCgpO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBTTkFLRV9DQVNFX1JFR0VYUCA9IC9bQS1aXS9nO1xyXG5mdW5jdGlvbiBzbmFrZV9jYXNlKG5hbWUsIHNlcGFyYXRvcil7XHJcbiAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8ICdfJztcclxuICByZXR1cm4gbmFtZS5yZXBsYWNlKFNOQUtFX0NBU0VfUkVHRVhQLCBmdW5jdGlvbihsZXR0ZXIsIHBvcykge1xyXG4gICAgcmV0dXJuIChwb3MgPyBzZXBhcmF0b3IgOiAnJykgKyBsZXR0ZXIudG9Mb3dlckNhc2UoKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYmluZEpRdWVyeSgpIHtcclxuICAvLyBiaW5kIHRvIGpRdWVyeSBpZiBwcmVzZW50O1xyXG4gIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XHJcbiAgLy8gcmVzZXQgdG8galF1ZXJ5IG9yIGRlZmF1bHQgdG8gdXMuXHJcbiAgaWYgKGpRdWVyeSkge1xyXG4gICAganFMaXRlID0galF1ZXJ5O1xyXG4gICAgZXh0ZW5kKGpRdWVyeS5mbiwge1xyXG4gICAgICBzY29wZTogSlFMaXRlUHJvdG90eXBlLnNjb3BlLFxyXG4gICAgICBjb250cm9sbGVyOiBKUUxpdGVQcm90b3R5cGUuY29udHJvbGxlcixcclxuICAgICAgaW5qZWN0b3I6IEpRTGl0ZVByb3RvdHlwZS5pbmplY3RvcixcclxuICAgICAgaW5oZXJpdGVkRGF0YTogSlFMaXRlUHJvdG90eXBlLmluaGVyaXRlZERhdGFcclxuICAgIH0pO1xyXG4gICAgLy8gTWV0aG9kIHNpZ25hdHVyZTogSlFMaXRlUGF0Y2hKUXVlcnlSZW1vdmUobmFtZSwgZGlzcGF0Y2hUaGlzLCBmaWx0ZXJFbGVtcywgZ2V0dGVySWZOb0FyZ3VtZW50cylcclxuICAgIEpRTGl0ZVBhdGNoSlF1ZXJ5UmVtb3ZlKCdyZW1vdmUnLCB0cnVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICBKUUxpdGVQYXRjaEpRdWVyeVJlbW92ZSgnZW1wdHknLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcclxuICAgIEpRTGl0ZVBhdGNoSlF1ZXJ5UmVtb3ZlKCdodG1sJywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAganFMaXRlID0gSlFMaXRlO1xyXG4gIH1cclxuICBhbmd1bGFyLmVsZW1lbnQgPSBqcUxpdGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB0aHJvdyBlcnJvciBpZiB0aGUgYXJndW1lbnQgaXMgZmFsc3kuXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnRBcmcoYXJnLCBuYW1lLCByZWFzb24pIHtcclxuICBpZiAoIWFyZykge1xyXG4gICAgdGhyb3cgbmdNaW5FcnIoJ2FyZXEnLCBcIkFyZ3VtZW50ICd7MH0nIGlzIHsxfVwiLCAobmFtZSB8fCAnPycpLCAocmVhc29uIHx8IFwicmVxdWlyZWRcIikpO1xyXG4gIH1cclxuICByZXR1cm4gYXJnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhc3NlcnRBcmdGbihhcmcsIG5hbWUsIGFjY2VwdEFycmF5QW5ub3RhdGlvbikge1xyXG4gIGlmIChhY2NlcHRBcnJheUFubm90YXRpb24gJiYgaXNBcnJheShhcmcpKSB7XHJcbiAgICAgIGFyZyA9IGFyZ1thcmcubGVuZ3RoIC0gMV07XHJcbiAgfVxyXG5cclxuICBhc3NlcnRBcmcoaXNGdW5jdGlvbihhcmcpLCBuYW1lLCAnbm90IGEgZnVuY3Rpb24sIGdvdCAnICtcclxuICAgICAgKGFyZyAmJiB0eXBlb2YgYXJnID09ICdvYmplY3QnID8gYXJnLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCcgOiB0eXBlb2YgYXJnKSk7XHJcbiAgcmV0dXJuIGFyZztcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgdmFsdWUgYWNjZXNzaWJsZSBmcm9tIHRoZSBvYmplY3QgYnkgcGF0aC4gQW55IHVuZGVmaW5lZCB0cmF2ZXJzYWxzIGFyZSBpZ25vcmVkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogc3RhcnRpbmcgb2JqZWN0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gdHJhdmVyc2VcclxuICogQHBhcmFtIHtib29sZWFuPXRydWV9IGJpbmRGblRvU2NvcGVcclxuICogQHJldHVybnMgdmFsdWUgYXMgYWNjZXNzaWJsZSBieSBwYXRoXHJcbiAqL1xyXG4vL1RPRE8obWlza28pOiB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJlbW92ZWRcclxuZnVuY3Rpb24gZ2V0dGVyKG9iaiwgcGF0aCwgYmluZEZuVG9TY29wZSkge1xyXG4gIGlmICghcGF0aCkgcmV0dXJuIG9iajtcclxuICB2YXIga2V5cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICB2YXIga2V5O1xyXG4gIHZhciBsYXN0SW5zdGFuY2UgPSBvYmo7XHJcbiAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgaWYgKG9iaikge1xyXG4gICAgICBvYmogPSAobGFzdEluc3RhbmNlID0gb2JqKVtrZXldO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIWJpbmRGblRvU2NvcGUgJiYgaXNGdW5jdGlvbihvYmopKSB7XHJcbiAgICByZXR1cm4gYmluZChsYXN0SW5zdGFuY2UsIG9iaik7XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgaW50ZXJmYWNlXHJcbiAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBJbnRlcmZhY2UgZm9yIGNvbmZpZ3VyaW5nIGFuZ3VsYXIge0BsaW5rIGFuZ3VsYXIubW9kdWxlIG1vZHVsZXN9LlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNldHVwTW9kdWxlTG9hZGVyKHdpbmRvdykge1xyXG5cclxuICBmdW5jdGlvbiBlbnN1cmUob2JqLCBuYW1lLCBmYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gb2JqW25hbWVdIHx8IChvYmpbbmFtZV0gPSBmYWN0b3J5KCkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVuc3VyZShlbnN1cmUod2luZG93LCAnYW5ndWxhcicsIE9iamVjdCksICdtb2R1bGUnLCBmdW5jdGlvbigpIHtcclxuICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIGFuZ3VsYXIuTW9kdWxlPn0gKi9cclxuICAgIHZhciBtb2R1bGVzID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIGFuZ3VsYXIubW9kdWxlXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqXHJcbiAgICAgKiBUaGUgYGFuZ3VsYXIubW9kdWxlYCBpcyBhIGdsb2JhbCBwbGFjZSBmb3IgY3JlYXRpbmcsIHJlZ2lzdGVyaW5nIGFuZCByZXRyaWV2aW5nIEFuZ3VsYXIgbW9kdWxlcy5cclxuICAgICAqIEFsbCBtb2R1bGVzIChhbmd1bGFyIGNvcmUgb3IgM3JkIHBhcnR5KSB0aGF0IHNob3VsZCBiZSBhdmFpbGFibGUgdG8gYW4gYXBwbGljYXRpb24gbXVzdCBiZVxyXG4gICAgICogcmVnaXN0ZXJlZCB1c2luZyB0aGlzIG1lY2hhbmlzbS5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHBhc3NlZCB0d28gb3IgbW9yZSBhcmd1bWVudHMsIGEgbmV3IG1vZHVsZSBpcyBjcmVhdGVkLiAgSWYgcGFzc2VkIG9ubHkgb25lIGFyZ3VtZW50LCBhblxyXG4gICAgICogZXhpc3RpbmcgbW9kdWxlICh0aGUgbmFtZSBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGBtb2R1bGVgKSBpcyByZXRyaWV2ZWQuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICMgTW9kdWxlXHJcbiAgICAgKlxyXG4gICAgICogQSBtb2R1bGUgaXMgYSBjb2xsZWN0aW9uIG9mIHNlcnZpY2VzLCBkaXJlY3RpdmVzLCBmaWx0ZXJzLCBhbmQgY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbi5cclxuICAgICAqIGBhbmd1bGFyLm1vZHVsZWAgaXMgdXNlZCB0byBjb25maWd1cmUgdGhlIHtAbGluayBBVVRPLiRpbmplY3RvciAkaW5qZWN0b3J9LlxyXG4gICAgICpcclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiAvLyBDcmVhdGUgYSBuZXcgbW9kdWxlXHJcbiAgICAgKiB2YXIgbXlNb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnbXlNb2R1bGUnLCBbXSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gcmVnaXN0ZXIgYSBuZXcgc2VydmljZVxyXG4gICAgICogbXlNb2R1bGUudmFsdWUoJ2FwcE5hbWUnLCAnTXlDb29sQXBwJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gY29uZmlndXJlIGV4aXN0aW5nIHNlcnZpY2VzIGluc2lkZSBpbml0aWFsaXphdGlvbiBibG9ja3MuXHJcbiAgICAgKiBteU1vZHVsZS5jb25maWcoZnVuY3Rpb24oJGxvY2F0aW9uUHJvdmlkZXIpIHtcclxuICAgICAqICAgLy8gQ29uZmlndXJlIGV4aXN0aW5nIHByb3ZpZGVyc1xyXG4gICAgICogICAkbG9jYXRpb25Qcm92aWRlci5oYXNoUHJlZml4KCchJyk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIDwvcHJlPlxyXG4gICAgICpcclxuICAgICAqIFRoZW4geW91IGNhbiBjcmVhdGUgYW4gaW5qZWN0b3IgYW5kIGxvYWQgeW91ciBtb2R1bGVzIGxpa2UgdGhpczpcclxuICAgICAqXHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICogdmFyIGluamVjdG9yID0gYW5ndWxhci5pbmplY3RvcihbJ25nJywgJ015TW9kdWxlJ10pXHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqXHJcbiAgICAgKiBIb3dldmVyIGl0J3MgbW9yZSBsaWtlbHkgdGhhdCB5b3UnbGwganVzdCB1c2VcclxuICAgICAqIHtAbGluayBuZy5kaXJlY3RpdmU6bmdBcHAgbmdBcHB9IG9yXHJcbiAgICAgKiB7QGxpbmsgYW5ndWxhci5ib290c3RyYXB9IHRvIHNpbXBsaWZ5IHRoaXMgcHJvY2VzcyBmb3IgeW91LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbW9kdWxlIHRvIGNyZWF0ZSBvciByZXRyaWV2ZS5cclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz49fSByZXF1aXJlcyBJZiBzcGVjaWZpZWQgdGhlbiBuZXcgbW9kdWxlIGlzIGJlaW5nIGNyZWF0ZWQuIElmIHVuc3BlY2lmaWVkIHRoZW4gdGhlXHJcbiAgICAgKiAgICAgICAgdGhlIG1vZHVsZSBpcyBiZWluZyByZXRyaWV2ZWQgZm9yIGZ1cnRoZXIgY29uZmlndXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZ0ZuIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBtb2R1bGUuIFNhbWUgYXNcclxuICAgICAqICAgICAgICB7QGxpbmsgYW5ndWxhci5Nb2R1bGUjY29uZmlnIE1vZHVsZSNjb25maWcoKX0uXHJcbiAgICAgKiBAcmV0dXJucyB7bW9kdWxlfSBuZXcgbW9kdWxlIHdpdGggdGhlIHtAbGluayBhbmd1bGFyLk1vZHVsZX0gYXBpLlxyXG4gICAgICovXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbW9kdWxlKG5hbWUsIHJlcXVpcmVzLCBjb25maWdGbikge1xyXG4gICAgICBpZiAocmVxdWlyZXMgJiYgbW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgIG1vZHVsZXNbbmFtZV0gPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBlbnN1cmUobW9kdWxlcywgbmFtZSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCFyZXF1aXJlcykge1xyXG4gICAgICAgICAgdGhyb3cgbWluRXJyKCckaW5qZWN0b3InKSgnbm9tb2QnLCBcIk1vZHVsZSAnezB9JyBpcyBub3QgYXZhaWxhYmxlISBZb3UgZWl0aGVyIG1pc3NwZWxsZWQgdGhlIG1vZHVsZSBuYW1lIFwiICtcclxuICAgICAgICAgICAgICBcIm9yIGZvcmdvdCB0byBsb2FkIGl0LiBJZiByZWdpc3RlcmluZyBhIG1vZHVsZSBlbnN1cmUgdGhhdCB5b3Ugc3BlY2lmeSB0aGUgZGVwZW5kZW5jaWVzIGFzIHRoZSBzZWNvbmQgXCIgK1xyXG4gICAgICAgICAgICAgIFwiYXJndW1lbnQuXCIsIG5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHshQXJyYXkuPEFycmF5LjwqPj59ICovXHJcbiAgICAgICAgdmFyIGludm9rZVF1ZXVlID0gW107XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSB7IUFycmF5LjxGdW5jdGlvbj59ICovXHJcbiAgICAgICAgdmFyIHJ1bkJsb2NrcyA9IFtdO1xyXG5cclxuICAgICAgICB2YXIgY29uZmlnID0gaW52b2tlTGF0ZXIoJyRpbmplY3RvcicsICdpbnZva2UnKTtcclxuXHJcbiAgICAgICAgLyoqIEB0eXBlIHthbmd1bGFyLk1vZHVsZX0gKi9cclxuICAgICAgICB2YXIgbW9kdWxlSW5zdGFuY2UgPSB7XHJcbiAgICAgICAgICAvLyBQcml2YXRlIHN0YXRlXHJcbiAgICAgICAgICBfaW52b2tlUXVldWU6IGludm9rZVF1ZXVlLFxyXG4gICAgICAgICAgX3J1bkJsb2NrczogcnVuQmxvY2tzLFxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQG5nZG9jIHByb3BlcnR5XHJcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNyZXF1aXJlc1xyXG4gICAgICAgICAgICogQHByb3BlcnR5T2YgYW5ndWxhci5Nb2R1bGVcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gTGlzdCBvZiBtb2R1bGUgbmFtZXMgd2hpY2ggbXVzdCBiZSBsb2FkZWQgYmVmb3JlIHRoaXMgbW9kdWxlLlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKiBIb2xkcyB0aGUgbGlzdCBvZiBtb2R1bGVzIHdoaWNoIHRoZSBpbmplY3RvciB3aWxsIGxvYWQgYmVmb3JlIHRoZSBjdXJyZW50IG1vZHVsZSBpcyBsb2FkZWQuXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIHJlcXVpcmVzOiByZXF1aXJlcyxcclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBuZ2RvYyBwcm9wZXJ0eVxyXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjbmFtZVxyXG4gICAgICAgICAgICogQHByb3BlcnR5T2YgYW5ndWxhci5Nb2R1bGVcclxuICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IE5hbWUgb2YgdGhlIG1vZHVsZS5cclxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICBuYW1lOiBuYW1lLFxyXG5cclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI3Byb3ZpZGVyXHJcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHNlcnZpY2UgbmFtZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvdmlkZXJUeXBlIENvbnN0cnVjdGlvbiBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlIG9mIHRoZSBzZXJ2aWNlLlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKiBTZWUge0BsaW5rIEFVVE8uJHByb3ZpZGUjcHJvdmlkZXIgJHByb3ZpZGUucHJvdmlkZXIoKX0uXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIHByb3ZpZGVyOiBpbnZva2VMYXRlcignJHByb3ZpZGUnLCAncHJvdmlkZXInKSxcclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI2ZhY3RvcnlcclxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgc2VydmljZSBuYW1lXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm92aWRlckZ1bmN0aW9uIEZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2Ugb2YgdGhlIHNlcnZpY2UuXHJcbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSNmYWN0b3J5ICRwcm92aWRlLmZhY3RvcnkoKX0uXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIGZhY3Rvcnk6IGludm9rZUxhdGVyKCckcHJvdmlkZScsICdmYWN0b3J5JyksXHJcblxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNzZXJ2aWNlXHJcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHNlcnZpY2UgbmFtZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW5zdGFudGlhdGVkLlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKiBTZWUge0BsaW5rIEFVVE8uJHByb3ZpZGUjc2VydmljZSAkcHJvdmlkZS5zZXJ2aWNlKCl9LlxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICBzZXJ2aWNlOiBpbnZva2VMYXRlcignJHByb3ZpZGUnLCAnc2VydmljZScpLFxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjdmFsdWVcclxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgc2VydmljZSBuYW1lXHJcbiAgICAgICAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBTZXJ2aWNlIGluc3RhbmNlIG9iamVjdC5cclxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICogU2VlIHtAbGluayBBVVRPLiRwcm92aWRlI3ZhbHVlICRwcm92aWRlLnZhbHVlKCl9LlxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICB2YWx1ZTogaW52b2tlTGF0ZXIoJyRwcm92aWRlJywgJ3ZhbHVlJyksXHJcblxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNjb25zdGFudFxyXG4gICAgICAgICAgICogQG1ldGhvZE9mIGFuZ3VsYXIuTW9kdWxlXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb25zdGFudCBuYW1lXHJcbiAgICAgICAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBDb25zdGFudCB2YWx1ZS5cclxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICogQmVjYXVzZSB0aGUgY29uc3RhbnQgYXJlIGZpeGVkLCB0aGV5IGdldCBhcHBsaWVkIGJlZm9yZSBvdGhlciBwcm92aWRlIG1ldGhvZHMuXHJcbiAgICAgICAgICAgKiBTZWUge0BsaW5rIEFVVE8uJHByb3ZpZGUjY29uc3RhbnQgJHByb3ZpZGUuY29uc3RhbnQoKX0uXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIGNvbnN0YW50OiBpbnZva2VMYXRlcignJHByb3ZpZGUnLCAnY29uc3RhbnQnLCAndW5zaGlmdCcpLFxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjYW5pbWF0aW9uXHJcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcclxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGFuaW1hdGlvbiBuYW1lXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhbmltYXRpb25GYWN0b3J5IEZhY3RvcnkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZSBvZiBhbiBhbmltYXRpb24uXHJcbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiAqKk5PVEUqKjogYW5pbWF0aW9ucyBhcmUgdGFrZSBlZmZlY3Qgb25seSBpZiB0aGUgKipuZ0FuaW1hdGUqKiBtb2R1bGUgaXMgbG9hZGVkLlxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBEZWZpbmVzIGFuIGFuaW1hdGlvbiBob29rIHRoYXQgY2FuIGJlIGxhdGVyIHVzZWQgd2l0aCB7QGxpbmsgbmdBbmltYXRlLiRhbmltYXRlICRhbmltYXRlfSBzZXJ2aWNlIGFuZFxyXG4gICAgICAgICAgICogZGlyZWN0aXZlcyB0aGF0IHVzZSB0aGlzIHNlcnZpY2UuXHJcbiAgICAgICAgICAgKlxyXG4gICAgICAgICAgICogPHByZT5cclxuICAgICAgICAgICAqIG1vZHVsZS5hbmltYXRpb24oJy5hbmltYXRpb24tbmFtZScsIGZ1bmN0aW9uKCRpbmplY3QxLCAkaW5qZWN0Mikge1xyXG4gICAgICAgICAgICogICByZXR1cm4ge1xyXG4gICAgICAgICAgICogICAgIGV2ZW50TmFtZSA6IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmUpIHtcclxuICAgICAgICAgICAqICAgICAgIC8vY29kZSB0byBydW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAgICogICAgICAgLy9vbmNlIGNvbXBsZXRlLCB0aGVuIHJ1biBkb25lKClcclxuICAgICAgICAgICAqICAgICAgIHJldHVybiBmdW5jdGlvbiBjYW5jZWxsYXRpb25GdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgICAgKiAgICAgICAgIC8vY29kZSB0byBjYW5jZWwgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAgICogICAgICAgfVxyXG4gICAgICAgICAgICogICAgIH1cclxuICAgICAgICAgICAqICAgfVxyXG4gICAgICAgICAgICogfSlcclxuICAgICAgICAgICAqIDwvcHJlPlxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgbmdBbmltYXRlLiRhbmltYXRlUHJvdmlkZXIjcmVnaXN0ZXIgJGFuaW1hdGVQcm92aWRlci5yZWdpc3RlcigpfSBhbmRcclxuICAgICAgICAgICAqIHtAbGluayBuZ0FuaW1hdGUgbmdBbmltYXRlIG1vZHVsZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIGFuaW1hdGlvbjogaW52b2tlTGF0ZXIoJyRhbmltYXRlUHJvdmlkZXInLCAncmVnaXN0ZXInKSxcclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI2ZpbHRlclxyXG4gICAgICAgICAgICogQG1ldGhvZE9mIGFuZ3VsYXIuTW9kdWxlXHJcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWx0ZXIgbmFtZS5cclxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlckZhY3RvcnkgRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlIG9mIGZpbHRlci5cclxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICogU2VlIHtAbGluayBuZy4kZmlsdGVyUHJvdmlkZXIjcmVnaXN0ZXIgJGZpbHRlclByb3ZpZGVyLnJlZ2lzdGVyKCl9LlxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICBmaWx0ZXI6IGludm9rZUxhdGVyKCckZmlsdGVyUHJvdmlkZXInLCAncmVnaXN0ZXInKSxcclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI2NvbnRyb2xsZXJcclxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ29udHJvbGxlciBuYW1lLlxyXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ29udHJvbGxlciBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cclxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICogU2VlIHtAbGluayBuZy4kY29udHJvbGxlclByb3ZpZGVyI3JlZ2lzdGVyICRjb250cm9sbGVyUHJvdmlkZXIucmVnaXN0ZXIoKX0uXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIGNvbnRyb2xsZXI6IGludm9rZUxhdGVyKCckY29udHJvbGxlclByb3ZpZGVyJywgJ3JlZ2lzdGVyJyksXHJcblxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNkaXJlY3RpdmVcclxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxyXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgZGlyZWN0aXZlIG5hbWVcclxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRpcmVjdGl2ZUZhY3RvcnkgRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlIG9mXHJcbiAgICAgICAgICAgKiBkaXJlY3RpdmVzLlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKiBTZWUge0BsaW5rIG5nLiRjb21waWxlUHJvdmlkZXIjZGlyZWN0aXZlICRjb21waWxlUHJvdmlkZXIuZGlyZWN0aXZlKCl9LlxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICBkaXJlY3RpdmU6IGludm9rZUxhdGVyKCckY29tcGlsZVByb3ZpZGVyJywgJ2RpcmVjdGl2ZScpLFxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjY29uZmlnXHJcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcclxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZ0ZuIEV4ZWN1dGUgdGhpcyBmdW5jdGlvbiBvbiBtb2R1bGUgbG9hZC4gVXNlZnVsIGZvciBzZXJ2aWNlXHJcbiAgICAgICAgICAgKiAgICBjb25maWd1cmF0aW9uLlxyXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gcmVnaXN0ZXIgd29yayB3aGljaCBuZWVkcyB0byBiZSBwZXJmb3JtZWQgb24gbW9kdWxlIGxvYWRpbmcuXHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxyXG5cclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjcnVuXHJcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcclxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGluaXRpYWxpemF0aW9uRm4gRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIGFmdGVyIGluamVjdG9yIGNyZWF0aW9uLlxyXG4gICAgICAgICAgICogICAgVXNlZnVsIGZvciBhcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvbi5cclxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlZ2lzdGVyIHdvcmsgd2hpY2ggc2hvdWxkIGJlIHBlcmZvcm1lZCB3aGVuIHRoZSBpbmplY3RvciBpcyBkb25lXHJcbiAgICAgICAgICAgKiBsb2FkaW5nIGFsbCBtb2R1bGVzLlxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICBydW46IGZ1bmN0aW9uKGJsb2NrKSB7XHJcbiAgICAgICAgICAgIHJ1bkJsb2Nrcy5wdXNoKGJsb2NrKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZ0ZuKSB7XHJcbiAgICAgICAgICBjb25maWcoY29uZmlnRm4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICBtb2R1bGVJbnN0YW5jZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gaW5zZXJ0TWV0aG9kXHJcbiAgICAgICAgICogQHJldHVybnMge2FuZ3VsYXIuTW9kdWxlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGludm9rZUxhdGVyKHByb3ZpZGVyLCBtZXRob2QsIGluc2VydE1ldGhvZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpbnZva2VRdWV1ZVtpbnNlcnRNZXRob2QgfHwgJ3B1c2gnXShbcHJvdmlkZXIsIG1ldGhvZCwgYXJndW1lbnRzXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVJbnN0YW5jZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgcHJvcGVydHlcclxuICogQG5hbWUgYW5ndWxhci52ZXJzaW9uXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBbiBvYmplY3QgdGhhdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBBbmd1bGFySlMgdmVyc2lvbi4gVGhpcyBvYmplY3QgaGFzIHRoZVxyXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICpcclxuICogLSBgZnVsbGAgw6LigqzigJwgYHtzdHJpbmd9YCDDouKCrOKAnCBGdWxsIHZlcnNpb24gc3RyaW5nLCBzdWNoIGFzIFwiMC45LjE4XCIuXHJcbiAqIC0gYG1ham9yYCDDouKCrOKAnCBge251bWJlcn1gIMOi4oKs4oCcIE1ham9yIHZlcnNpb24gbnVtYmVyLCBzdWNoIGFzIFwiMFwiLlxyXG4gKiAtIGBtaW5vcmAgw6LigqzigJwgYHtudW1iZXJ9YCDDouKCrOKAnCBNaW5vciB2ZXJzaW9uIG51bWJlciwgc3VjaCBhcyBcIjlcIi5cclxuICogLSBgZG90YCDDouKCrOKAnCBge251bWJlcn1gIMOi4oKs4oCcIERvdCB2ZXJzaW9uIG51bWJlciwgc3VjaCBhcyBcIjE4XCIuXHJcbiAqIC0gYGNvZGVOYW1lYCDDouKCrOKAnCBge3N0cmluZ31gIMOi4oKs4oCcIENvZGUgbmFtZSBvZiB0aGUgcmVsZWFzZSwgc3VjaCBhcyBcImppZ2dsaW5nLWFybWZhdFwiLlxyXG4gKi9cclxudmFyIHZlcnNpb24gPSB7XHJcbiAgZnVsbDogJzEuMi4wLXJjLjInLCAgICAvLyBhbGwgb2YgdGhlc2UgcGxhY2Vob2xkZXIgc3RyaW5ncyB3aWxsIGJlIHJlcGxhY2VkIGJ5IGdydW50J3NcclxuICBtYWpvcjogMSwgICAgLy8gcGFja2FnZSB0YXNrXHJcbiAgbWlub3I6IDIsXHJcbiAgZG90OiAwLFxyXG4gIGNvZGVOYW1lOiAnYmFyZWhhbmQtYXRvbXNwbGl0dGluZydcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBwdWJsaXNoRXh0ZXJuYWxBUEkoYW5ndWxhcil7XHJcbiAgZXh0ZW5kKGFuZ3VsYXIsIHtcclxuICAgICdib290c3RyYXAnOiBib290c3RyYXAsXHJcbiAgICAnY29weSc6IGNvcHksXHJcbiAgICAnZXh0ZW5kJzogZXh0ZW5kLFxyXG4gICAgJ2VxdWFscyc6IGVxdWFscyxcclxuICAgICdlbGVtZW50JzoganFMaXRlLFxyXG4gICAgJ2ZvckVhY2gnOiBmb3JFYWNoLFxyXG4gICAgJ2luamVjdG9yJzogY3JlYXRlSW5qZWN0b3IsXHJcbiAgICAnbm9vcCc6bm9vcCxcclxuICAgICdiaW5kJzpiaW5kLFxyXG4gICAgJ3RvSnNvbic6IHRvSnNvbixcclxuICAgICdmcm9tSnNvbic6IGZyb21Kc29uLFxyXG4gICAgJ2lkZW50aXR5JzppZGVudGl0eSxcclxuICAgICdpc1VuZGVmaW5lZCc6IGlzVW5kZWZpbmVkLFxyXG4gICAgJ2lzRGVmaW5lZCc6IGlzRGVmaW5lZCxcclxuICAgICdpc1N0cmluZyc6IGlzU3RyaW5nLFxyXG4gICAgJ2lzRnVuY3Rpb24nOiBpc0Z1bmN0aW9uLFxyXG4gICAgJ2lzT2JqZWN0JzogaXNPYmplY3QsXHJcbiAgICAnaXNOdW1iZXInOiBpc051bWJlcixcclxuICAgICdpc0VsZW1lbnQnOiBpc0VsZW1lbnQsXHJcbiAgICAnaXNBcnJheSc6IGlzQXJyYXksXHJcbiAgICAnJCRtaW5FcnInOiBtaW5FcnIsXHJcbiAgICAndmVyc2lvbic6IHZlcnNpb24sXHJcbiAgICAnaXNEYXRlJzogaXNEYXRlLFxyXG4gICAgJ2xvd2VyY2FzZSc6IGxvd2VyY2FzZSxcclxuICAgICd1cHBlcmNhc2UnOiB1cHBlcmNhc2UsXHJcbiAgICAnY2FsbGJhY2tzJzoge2NvdW50ZXI6IDB9XHJcbiAgfSk7XHJcblxyXG4gIGFuZ3VsYXJNb2R1bGUgPSBzZXR1cE1vZHVsZUxvYWRlcih3aW5kb3cpO1xyXG4gIHRyeSB7XHJcbiAgICBhbmd1bGFyTW9kdWxlKCduZ0xvY2FsZScpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGFuZ3VsYXJNb2R1bGUoJ25nTG9jYWxlJywgW10pLnByb3ZpZGVyKCckbG9jYWxlJywgJExvY2FsZVByb3ZpZGVyKTtcclxuICB9XHJcblxyXG4gIGFuZ3VsYXJNb2R1bGUoJ25nJywgWyduZ0xvY2FsZSddLCBbJyRwcm92aWRlJyxcclxuICAgIGZ1bmN0aW9uIG5nTW9kdWxlKCRwcm92aWRlKSB7XHJcbiAgICAgICRwcm92aWRlLnByb3ZpZGVyKCckY29tcGlsZScsICRDb21waWxlUHJvdmlkZXIpLlxyXG4gICAgICAgIGRpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIGE6IGh0bWxBbmNob3JEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dERpcmVjdGl2ZSxcclxuICAgICAgICAgICAgdGV4dGFyZWE6IGlucHV0RGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBmb3JtOiBmb3JtRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBzY3JpcHQ6IHNjcmlwdERpcmVjdGl2ZSxcclxuICAgICAgICAgICAgc2VsZWN0OiBzZWxlY3REaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZURpcmVjdGl2ZSxcclxuICAgICAgICAgICAgb3B0aW9uOiBvcHRpb25EaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nQmluZDogbmdCaW5kRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0JpbmRIdG1sOiBuZ0JpbmRIdG1sRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0JpbmRUZW1wbGF0ZTogbmdCaW5kVGVtcGxhdGVEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nQ2xhc3M6IG5nQ2xhc3NEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nQ2xhc3NFdmVuOiBuZ0NsYXNzRXZlbkRpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdDbGFzc09kZDogbmdDbGFzc09kZERpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdDc3A6IG5nQ3NwRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0Nsb2FrOiBuZ0Nsb2FrRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0NvbnRyb2xsZXI6IG5nQ29udHJvbGxlckRpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdGb3JtOiBuZ0Zvcm1EaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nSGlkZTogbmdIaWRlRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0lmOiBuZ0lmRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ0luY2x1ZGU6IG5nSW5jbHVkZURpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdJbml0OiBuZ0luaXREaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nTm9uQmluZGFibGU6IG5nTm9uQmluZGFibGVEaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nUGx1cmFsaXplOiBuZ1BsdXJhbGl6ZURpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdSZXBlYXQ6IG5nUmVwZWF0RGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ1Nob3c6IG5nU2hvd0RpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdTdHlsZTogbmdTdHlsZURpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdTd2l0Y2g6IG5nU3dpdGNoRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ1N3aXRjaFdoZW46IG5nU3dpdGNoV2hlbkRpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdTd2l0Y2hEZWZhdWx0OiBuZ1N3aXRjaERlZmF1bHREaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nT3B0aW9uczogbmdPcHRpb25zRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ1RyYW5zY2x1ZGU6IG5nVHJhbnNjbHVkZURpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdNb2RlbDogbmdNb2RlbERpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdMaXN0OiBuZ0xpc3REaXJlY3RpdmUsXHJcbiAgICAgICAgICAgIG5nQ2hhbmdlOiBuZ0NoYW5nZURpcmVjdGl2ZSxcclxuICAgICAgICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkRGlyZWN0aXZlLFxyXG4gICAgICAgICAgICBuZ1JlcXVpcmVkOiByZXF1aXJlZERpcmVjdGl2ZSxcclxuICAgICAgICAgICAgbmdWYWx1ZTogbmdWYWx1ZURpcmVjdGl2ZVxyXG4gICAgICAgIH0pLlxyXG4gICAgICAgIGRpcmVjdGl2ZShuZ0F0dHJpYnV0ZUFsaWFzRGlyZWN0aXZlcykuXHJcbiAgICAgICAgZGlyZWN0aXZlKG5nRXZlbnREaXJlY3RpdmVzKTtcclxuICAgICAgJHByb3ZpZGUucHJvdmlkZXIoe1xyXG4gICAgICAgICRhbmNob3JTY3JvbGw6ICRBbmNob3JTY3JvbGxQcm92aWRlcixcclxuICAgICAgICAkYW5pbWF0ZTogJEFuaW1hdGVQcm92aWRlcixcclxuICAgICAgICAkYnJvd3NlcjogJEJyb3dzZXJQcm92aWRlcixcclxuICAgICAgICAkY2FjaGVGYWN0b3J5OiAkQ2FjaGVGYWN0b3J5UHJvdmlkZXIsXHJcbiAgICAgICAgJGNvbnRyb2xsZXI6ICRDb250cm9sbGVyUHJvdmlkZXIsXHJcbiAgICAgICAgJGRvY3VtZW50OiAkRG9jdW1lbnRQcm92aWRlcixcclxuICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcjogJEV4Y2VwdGlvbkhhbmRsZXJQcm92aWRlcixcclxuICAgICAgICAkZmlsdGVyOiAkRmlsdGVyUHJvdmlkZXIsXHJcbiAgICAgICAgJGludGVycG9sYXRlOiAkSW50ZXJwb2xhdGVQcm92aWRlcixcclxuICAgICAgICAkaHR0cDogJEh0dHBQcm92aWRlcixcclxuICAgICAgICAkaHR0cEJhY2tlbmQ6ICRIdHRwQmFja2VuZFByb3ZpZGVyLFxyXG4gICAgICAgICRsb2NhdGlvbjogJExvY2F0aW9uUHJvdmlkZXIsXHJcbiAgICAgICAgJGxvZzogJExvZ1Byb3ZpZGVyLFxyXG4gICAgICAgICRwYXJzZTogJFBhcnNlUHJvdmlkZXIsXHJcbiAgICAgICAgJHJvb3RTY29wZTogJFJvb3RTY29wZVByb3ZpZGVyLFxyXG4gICAgICAgICRxOiAkUVByb3ZpZGVyLFxyXG4gICAgICAgICRzY2U6ICRTY2VQcm92aWRlcixcclxuICAgICAgICAkc2NlRGVsZWdhdGU6ICRTY2VEZWxlZ2F0ZVByb3ZpZGVyLFxyXG4gICAgICAgICRzbmlmZmVyOiAkU25pZmZlclByb3ZpZGVyLFxyXG4gICAgICAgICR0ZW1wbGF0ZUNhY2hlOiAkVGVtcGxhdGVDYWNoZVByb3ZpZGVyLFxyXG4gICAgICAgICR0aW1lb3V0OiAkVGltZW91dFByb3ZpZGVyLFxyXG4gICAgICAgICR3aW5kb3c6ICRXaW5kb3dQcm92aWRlcixcclxuICAgICAgICAkJHVybFV0aWxzOiAkJFVybFV0aWxzUHJvdmlkZXJcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgXSk7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy9KUUxpdGVcclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmVsZW1lbnRcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBXcmFwcyBhIHJhdyBET00gZWxlbWVudCBvciBIVE1MIHN0cmluZyBhcyBhIFtqUXVlcnldKGh0dHA6Ly9qcXVlcnkuY29tKSBlbGVtZW50LlxyXG4gKiBgYW5ndWxhci5lbGVtZW50YCBjYW4gYmUgZWl0aGVyIGFuIGFsaWFzIGZvciBbalF1ZXJ5XShodHRwOi8vYXBpLmpxdWVyeS5jb20valF1ZXJ5LykgZnVuY3Rpb24sIGlmXHJcbiAqIGpRdWVyeSBpcyBhdmFpbGFibGUsIG9yIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgZWxlbWVudCBvciBzdHJpbmcgaW4gQW5ndWxhcidzIGpRdWVyeSBsaXRlXHJcbiAqIGltcGxlbWVudGF0aW9uIChjb21tb25seSByZWZlcnJlZCB0byBhcyBqcUxpdGUpLlxyXG4gKlxyXG4gKiBSZWFsIGpRdWVyeSBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGpxTGl0ZSwgcHJvdmlkZWQgaXQgd2FzIGxvYWRlZCBiZWZvcmUgYERPTUNvbnRlbnRMb2FkZWRgXHJcbiAqIGV2ZW50IGZpcmVkLlxyXG4gKlxyXG4gKiBqcUxpdGUgaXMgYSB0aW55LCBBUEktY29tcGF0aWJsZSBzdWJzZXQgb2YgalF1ZXJ5IHRoYXQgYWxsb3dzXHJcbiAqIEFuZ3VsYXIgdG8gbWFuaXB1bGF0ZSB0aGUgRE9NLiBqcUxpdGUgaW1wbGVtZW50cyBvbmx5IHRoZSBtb3N0IGNvbW1vbmx5IG5lZWRlZCBmdW5jdGlvbmFsaXR5XHJcbiAqIHdpdGhpbiBhIHZlcnkgc21hbGwgZm9vdHByaW50LCBzbyBvbmx5IGEgc3Vic2V0IG9mIHRoZSBqUXVlcnkgQVBJIC0gbWV0aG9kcywgYXJndW1lbnRzIGFuZFxyXG4gKiBpbnZvY2F0aW9uIHN0eWxlcyAtIGFyZSBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIE5vdGU6IEFsbCBlbGVtZW50IHJlZmVyZW5jZXMgaW4gQW5ndWxhciBhcmUgYWx3YXlzIHdyYXBwZWQgd2l0aCBqUXVlcnkgb3IganFMaXRlOyB0aGV5IGFyZSBuZXZlclxyXG4gKiByYXcgRE9NIHJlZmVyZW5jZXMuXHJcbiAqXHJcbiAqICMjIEFuZ3VsYXIncyBqcUxpdGVcclxuICogQW5ndWxhcidzIGxpdGUgdmVyc2lvbiBvZiBqUXVlcnkgcHJvdmlkZXMgb25seSB0aGUgZm9sbG93aW5nIGpRdWVyeSBtZXRob2RzOlxyXG4gKlxyXG4gKiAtIFthZGRDbGFzcygpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vYWRkQ2xhc3MvKVxyXG4gKiAtIFthZnRlcigpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vYWZ0ZXIvKVxyXG4gKiAtIFthcHBlbmQoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2FwcGVuZC8pXHJcbiAqIC0gW2F0dHIoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2F0dHIvKVxyXG4gKiAtIFtiaW5kKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9vbi8pIC0gRG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzLCBzZWxlY3RvcnMgb3IgZXZlbnREYXRhXHJcbiAqIC0gW2NoaWxkcmVuKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9jaGlsZHJlbi8pIC0gRG9lcyBub3Qgc3VwcG9ydCBzZWxlY3RvcnNcclxuICogLSBbY2xvbmUoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2Nsb25lLylcclxuICogLSBbY29udGVudHMoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2NvbnRlbnRzLylcclxuICogLSBbY3NzKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9jc3MvKVxyXG4gKiAtIFtkYXRhKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9kYXRhLylcclxuICogLSBbZXEoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2VxLylcclxuICogLSBbZmluZCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vZmluZC8pIC0gTGltaXRlZCB0byBsb29rdXBzIGJ5IHRhZyBuYW1lXHJcbiAqIC0gW2hhc0NsYXNzKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9oYXNDbGFzcy8pXHJcbiAqIC0gW2h0bWwoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2h0bWwvKVxyXG4gKiAtIFtuZXh0KCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9uZXh0LykgLSBEb2VzIG5vdCBzdXBwb3J0IHNlbGVjdG9yc1xyXG4gKiAtIFtvbigpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vb24vKSAtIERvZXMgbm90IHN1cHBvcnQgbmFtZXNwYWNlcywgc2VsZWN0b3JzIG9yIGV2ZW50RGF0YVxyXG4gKiAtIFtvZmYoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL29mZi8pIC0gRG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzIG9yIHNlbGVjdG9yc1xyXG4gKiAtIFtwYXJlbnQoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3BhcmVudC8pIC0gRG9lcyBub3Qgc3VwcG9ydCBzZWxlY3RvcnNcclxuICogLSBbcHJlcGVuZCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcHJlcGVuZC8pXHJcbiAqIC0gW3Byb3AoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3Byb3AvKVxyXG4gKiAtIFtyZWFkeSgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcmVhZHkvKVxyXG4gKiAtIFtyZW1vdmUoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3JlbW92ZS8pXHJcbiAqIC0gW3JlbW92ZUF0dHIoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3JlbW92ZUF0dHIvKVxyXG4gKiAtIFtyZW1vdmVDbGFzcygpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcmVtb3ZlQ2xhc3MvKVxyXG4gKiAtIFtyZW1vdmVEYXRhKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9yZW1vdmVEYXRhLylcclxuICogLSBbcmVwbGFjZVdpdGgoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3JlcGxhY2VXaXRoLylcclxuICogLSBbdGV4dCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vdGV4dC8pXHJcbiAqIC0gW3RvZ2dsZUNsYXNzKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS90b2dnbGVDbGFzcy8pXHJcbiAqIC0gW3RyaWdnZXJIYW5kbGVyKCldKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS90cmlnZ2VySGFuZGxlci8pIC0gUGFzc2VzIGEgZHVtbXkgZXZlbnQgb2JqZWN0IHRvIGhhbmRsZXJzLlxyXG4gKiAtIFt1bmJpbmQoKV0oaHR0cDovL2FwaS5qcXVlcnkuY29tL29mZi8pIC0gRG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzXHJcbiAqIC0gW3ZhbCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vdmFsLylcclxuICogLSBbd3JhcCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vd3JhcC8pXHJcbiAqXHJcbiAqICMjIGpRdWVyeS9qcUxpdGUgRXh0cmFzXHJcbiAqIEFuZ3VsYXIgYWxzbyBwcm92aWRlcyB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgbWV0aG9kcyBhbmQgZXZlbnRzIHRvIGJvdGggalF1ZXJ5IGFuZCBqcUxpdGU6XHJcbiAqXHJcbiAqICMjIyBFdmVudHNcclxuICogLSBgJGRlc3Ryb3lgIC0gQW5ndWxhckpTIGludGVyY2VwdHMgYWxsIGpxTGl0ZS9qUXVlcnkncyBET00gZGVzdHJ1Y3Rpb24gYXBpcyBhbmQgZmlyZXMgdGhpcyBldmVudFxyXG4gKiAgICBvbiBhbGwgRE9NIG5vZGVzIGJlaW5nIHJlbW92ZWQuICBUaGlzIGNhbiBiZSB1c2VkIHRvIGNsZWFuIHVwIGFuZCAzcmQgcGFydHkgYmluZGluZ3MgdG8gdGhlIERPTVxyXG4gKiAgICBlbGVtZW50IGJlZm9yZSBpdCBpcyByZW1vdmVkLlxyXG4gKiAjIyMgTWV0aG9kc1xyXG4gKiAtIGBjb250cm9sbGVyKG5hbWUpYCAtIHJldHJpZXZlcyB0aGUgY29udHJvbGxlciBvZiB0aGUgY3VycmVudCBlbGVtZW50IG9yIGl0cyBwYXJlbnQuIEJ5IGRlZmF1bHRcclxuICogICByZXRyaWV2ZXMgY29udHJvbGxlciBhc3NvY2lhdGVkIHdpdGggdGhlIGBuZ0NvbnRyb2xsZXJgIGRpcmVjdGl2ZS4gSWYgYG5hbWVgIGlzIHByb3ZpZGVkIGFzXHJcbiAqICAgY2FtZWxDYXNlIGRpcmVjdGl2ZSBuYW1lLCB0aGVuIHRoZSBjb250cm9sbGVyIGZvciB0aGlzIGRpcmVjdGl2ZSB3aWxsIGJlIHJldHJpZXZlZCAoZS5nLlxyXG4gKiAgIGAnbmdNb2RlbCdgKS5cclxuICogLSBgaW5qZWN0b3IoKWAgLSByZXRyaWV2ZXMgdGhlIGluamVjdG9yIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgb3IgaXRzIHBhcmVudC5cclxuICogLSBgc2NvcGUoKWAgLSByZXRyaWV2ZXMgdGhlIHtAbGluayBhcGkvbmcuJHJvb3RTY29wZS5TY29wZSBzY29wZX0gb2YgdGhlIGN1cnJlbnRcclxuICogICBlbGVtZW50IG9yIGl0cyBwYXJlbnQuXHJcbiAqIC0gYGluaGVyaXRlZERhdGEoKWAgLSBzYW1lIGFzIGBkYXRhKClgLCBidXQgd2Fsa3MgdXAgdGhlIERPTSB1bnRpbCBhIHZhbHVlIGlzIGZvdW5kIG9yIHRoZSB0b3BcclxuICogICBwYXJlbnQgZWxlbWVudCBpcyByZWFjaGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xET01FbGVtZW50fSBlbGVtZW50IEhUTUwgc3RyaW5nIG9yIERPTUVsZW1lbnQgdG8gYmUgd3JhcHBlZCBpbnRvIGpRdWVyeS5cclxuICogQHJldHVybnMge09iamVjdH0galF1ZXJ5IG9iamVjdC5cclxuICovXHJcblxyXG52YXIganFDYWNoZSA9IEpRTGl0ZS5jYWNoZSA9IHt9LFxyXG4gICAganFOYW1lID0gSlFMaXRlLmV4cGFuZG8gPSAnbmctJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxyXG4gICAganFJZCA9IDEsXHJcbiAgICBhZGRFdmVudExpc3RlbmVyRm4gPSAod2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXJcclxuICAgICAgPyBmdW5jdGlvbihlbGVtZW50LCB0eXBlLCBmbikge2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgZmFsc2UpO31cclxuICAgICAgOiBmdW5jdGlvbihlbGVtZW50LCB0eXBlLCBmbikge2VsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGZuKTt9KSxcclxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJGbiA9ICh3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lclxyXG4gICAgICA/IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGZuKSB7ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7IH1cclxuICAgICAgOiBmdW5jdGlvbihlbGVtZW50LCB0eXBlLCBmbikge2VsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGZuKTsgfSk7XHJcblxyXG5mdW5jdGlvbiBqcU5leHRJZCgpIHsgcmV0dXJuICsranFJZDsgfVxyXG5cclxuXHJcbnZhciBTUEVDSUFMX0NIQVJTX1JFR0VYUCA9IC8oW1xcOlxcLVxcX10rKC4pKS9nO1xyXG52YXIgTU9aX0hBQ0tfUkVHRVhQID0gL15tb3ooW0EtWl0pLztcclxudmFyIGpxTGl0ZU1pbkVyciA9IG1pbkVycignanFMaXRlJyk7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgc25ha2VfY2FzZSB0byBjYW1lbENhc2UuXHJcbiAqIEFsc28gdGhlcmUgaXMgc3BlY2lhbCBjYXNlIGZvciBNb3ogcHJlZml4IHN0YXJ0aW5nIHdpdGggdXBwZXIgY2FzZSBsZXR0ZXIuXHJcbiAqIEBwYXJhbSBuYW1lIE5hbWUgdG8gbm9ybWFsaXplXHJcbiAqL1xyXG5mdW5jdGlvbiBjYW1lbENhc2UobmFtZSkge1xyXG4gIHJldHVybiBuYW1lLlxyXG4gICAgcmVwbGFjZShTUEVDSUFMX0NIQVJTX1JFR0VYUCwgZnVuY3Rpb24oXywgc2VwYXJhdG9yLCBsZXR0ZXIsIG9mZnNldCkge1xyXG4gICAgICByZXR1cm4gb2Zmc2V0ID8gbGV0dGVyLnRvVXBwZXJDYXNlKCkgOiBsZXR0ZXI7XHJcbiAgICB9KS5cclxuICAgIHJlcGxhY2UoTU9aX0hBQ0tfUkVHRVhQLCAnTW96JDEnKTtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIGpRdWVyeSBtdXRhdGlvbiBwYXRjaFxyXG4vL1xyXG4vLyBJbiBjb25qdW5jdGlvbiB3aXRoIGJpbmRKUXVlcnkgaW50ZXJjZXB0cyBhbGwgalF1ZXJ5J3MgRE9NIGRlc3RydWN0aW9uIGFwaXMgYW5kIGZpcmVzIGFcclxuLy8gJGRlc3Ryb3kgZXZlbnQgb24gYWxsIERPTSBub2RlcyBiZWluZyByZW1vdmVkLlxyXG4vL1xyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmZ1bmN0aW9uIEpRTGl0ZVBhdGNoSlF1ZXJ5UmVtb3ZlKG5hbWUsIGRpc3BhdGNoVGhpcywgZmlsdGVyRWxlbXMsIGdldHRlcklmTm9Bcmd1bWVudHMpIHtcclxuICB2YXIgb3JpZ2luYWxKcUZuID0galF1ZXJ5LmZuW25hbWVdO1xyXG4gIG9yaWdpbmFsSnFGbiA9IG9yaWdpbmFsSnFGbi4kb3JpZ2luYWwgfHwgb3JpZ2luYWxKcUZuO1xyXG4gIHJlbW92ZVBhdGNoLiRvcmlnaW5hbCA9IG9yaWdpbmFsSnFGbjtcclxuICBqUXVlcnkuZm5bbmFtZV0gPSByZW1vdmVQYXRjaDtcclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlUGF0Y2gocGFyYW0pIHtcclxuICAgIHZhciBsaXN0ID0gZmlsdGVyRWxlbXMgJiYgcGFyYW0gPyBbdGhpcy5maWx0ZXIocGFyYW0pXSA6IFt0aGlzXSxcclxuICAgICAgICBmaXJlRXZlbnQgPSBkaXNwYXRjaFRoaXMsXHJcbiAgICAgICAgc2V0LCBzZXRJbmRleCwgc2V0TGVuZ3RoLFxyXG4gICAgICAgIGVsZW1lbnQsIGNoaWxkSW5kZXgsIGNoaWxkTGVuZ3RoLCBjaGlsZHJlbjtcclxuXHJcbiAgICBpZiAoIWdldHRlcklmTm9Bcmd1bWVudHMgfHwgcGFyYW0gIT0gbnVsbCkge1xyXG4gICAgICB3aGlsZShsaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgIHNldCA9IGxpc3Quc2hpZnQoKTtcclxuICAgICAgICBmb3Ioc2V0SW5kZXggPSAwLCBzZXRMZW5ndGggPSBzZXQubGVuZ3RoOyBzZXRJbmRleCA8IHNldExlbmd0aDsgc2V0SW5kZXgrKykge1xyXG4gICAgICAgICAgZWxlbWVudCA9IGpxTGl0ZShzZXRbc2V0SW5kZXhdKTtcclxuICAgICAgICAgIGlmIChmaXJlRXZlbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC50cmlnZ2VySGFuZGxlcignJGRlc3Ryb3knKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZpcmVFdmVudCA9ICFmaXJlRXZlbnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmb3IoY2hpbGRJbmRleCA9IDAsIGNoaWxkTGVuZ3RoID0gKGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbigpKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgY2hpbGRJbmRleCA8IGNoaWxkTGVuZ3RoO1xyXG4gICAgICAgICAgICAgIGNoaWxkSW5kZXgrKykge1xyXG4gICAgICAgICAgICBsaXN0LnB1c2goalF1ZXJ5KGNoaWxkcmVuW2NoaWxkSW5kZXhdKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3JpZ2luYWxKcUZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG59XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuZnVuY3Rpb24gSlFMaXRlKGVsZW1lbnQpIHtcclxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEpRTGl0ZSkge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgfVxyXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBKUUxpdGUpKSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoZWxlbWVudCkgJiYgZWxlbWVudC5jaGFyQXQoMCkgIT0gJzwnKSB7XHJcbiAgICAgIHRocm93IGpxTGl0ZU1pbkVycignbm9zZWwnLCAnTG9va2luZyB1cCBlbGVtZW50cyB2aWEgc2VsZWN0b3JzIGlzIG5vdCBzdXBwb3J0ZWQgYnkganFMaXRlISBTZWU6IGh0dHA6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL2FuZ3VsYXIuZWxlbWVudCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBKUUxpdGUoZWxlbWVudCk7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNTdHJpbmcoZWxlbWVudCkpIHtcclxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIC8vIFJlYWQgYWJvdXQgdGhlIE5vU2NvcGUgZWxlbWVudHMgaGVyZTpcclxuICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMzg5NyhWUy44NSkuYXNweFxyXG4gICAgZGl2LmlubmVySFRNTCA9ICc8ZGl2PiYjMTYwOzwvZGl2PicgKyBlbGVtZW50OyAvLyBJRSBpbnNhbml0eSB0byBtYWtlIE5vU2NvcGUgZWxlbWVudHMgd29yayFcclxuICAgIGRpdi5yZW1vdmVDaGlsZChkaXYuZmlyc3RDaGlsZCk7IC8vIHJlbW92ZSB0aGUgc3VwZXJmbHVvdXMgZGl2XHJcbiAgICBKUUxpdGVBZGROb2Rlcyh0aGlzLCBkaXYuY2hpbGROb2Rlcyk7XHJcbiAgICB2YXIgZnJhZ21lbnQgPSBqcUxpdGUoZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKTtcclxuICAgIGZyYWdtZW50LmFwcGVuZCh0aGlzKTsgLy8gZGV0YWNoIHRoZSBlbGVtZW50cyBmcm9tIHRoZSB0ZW1wb3JhcnkgRE9NIGRpdi5cclxuICB9IGVsc2Uge1xyXG4gICAgSlFMaXRlQWRkTm9kZXModGhpcywgZWxlbWVudCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVDbG9uZShlbGVtZW50KSB7XHJcbiAgcmV0dXJuIGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVEZWFsb2MoZWxlbWVudCl7XHJcbiAgSlFMaXRlUmVtb3ZlRGF0YShlbGVtZW50KTtcclxuICBmb3IgKCB2YXIgaSA9IDAsIGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZE5vZGVzIHx8IFtdOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIEpRTGl0ZURlYWxvYyhjaGlsZHJlbltpXSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVPZmYoZWxlbWVudCwgdHlwZSwgZm4sIHVuc3VwcG9ydGVkKSB7XHJcbiAgaWYgKGlzRGVmaW5lZCh1bnN1cHBvcnRlZCkpIHRocm93IGpxTGl0ZU1pbkVycignb2ZmYXJncycsICdqcUxpdGUjb2ZmKCkgZG9lcyBub3Qgc3VwcG9ydCB0aGUgYHNlbGVjdG9yYCBhcmd1bWVudCcpO1xyXG5cclxuICB2YXIgZXZlbnRzID0gSlFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsICdldmVudHMnKSxcclxuICAgICAgaGFuZGxlID0gSlFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsICdoYW5kbGUnKTtcclxuXHJcbiAgaWYgKCFoYW5kbGUpIHJldHVybjsgLy9ubyBsaXN0ZW5lcnMgcmVnaXN0ZXJlZFxyXG5cclxuICBpZiAoaXNVbmRlZmluZWQodHlwZSkpIHtcclxuICAgIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldmVudEhhbmRsZXIsIHR5cGUpIHtcclxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lckZuKGVsZW1lbnQsIHR5cGUsIGV2ZW50SGFuZGxlcik7XHJcbiAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgZm9yRWFjaCh0eXBlLnNwbGl0KCcgJyksIGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgaWYgKGlzVW5kZWZpbmVkKGZuKSkge1xyXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJGbihlbGVtZW50LCB0eXBlLCBldmVudHNbdHlwZV0pO1xyXG4gICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXJyYXlSZW1vdmUoZXZlbnRzW3R5cGVdIHx8IFtdLCBmbik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gSlFMaXRlUmVtb3ZlRGF0YShlbGVtZW50LCBuYW1lKSB7XHJcbiAgdmFyIGV4cGFuZG9JZCA9IGVsZW1lbnRbanFOYW1lXSxcclxuICAgICAgZXhwYW5kb1N0b3JlID0ganFDYWNoZVtleHBhbmRvSWRdO1xyXG5cclxuICBpZiAoZXhwYW5kb1N0b3JlKSB7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICBkZWxldGUganFDYWNoZVtleHBhbmRvSWRdLmRhdGFbbmFtZV07XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXhwYW5kb1N0b3JlLmhhbmRsZSkge1xyXG4gICAgICBleHBhbmRvU3RvcmUuZXZlbnRzLiRkZXN0cm95ICYmIGV4cGFuZG9TdG9yZS5oYW5kbGUoe30sICckZGVzdHJveScpO1xyXG4gICAgICBKUUxpdGVPZmYoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUganFDYWNoZVtleHBhbmRvSWRdO1xyXG4gICAgZWxlbWVudFtqcU5hbWVdID0gdW5kZWZpbmVkOyAvLyBpZSBkb2VzIG5vdCBhbGxvdyBkZWxldGlvbiBvZiBhdHRyaWJ1dGVzIG9uIGVsZW1lbnRzLlxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gSlFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcclxuICB2YXIgZXhwYW5kb0lkID0gZWxlbWVudFtqcU5hbWVdLFxyXG4gICAgICBleHBhbmRvU3RvcmUgPSBqcUNhY2hlW2V4cGFuZG9JZCB8fCAtMV07XHJcblxyXG4gIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICBpZiAoIWV4cGFuZG9TdG9yZSkge1xyXG4gICAgICBlbGVtZW50W2pxTmFtZV0gPSBleHBhbmRvSWQgPSBqcU5leHRJZCgpO1xyXG4gICAgICBleHBhbmRvU3RvcmUgPSBqcUNhY2hlW2V4cGFuZG9JZF0gPSB7fTtcclxuICAgIH1cclxuICAgIGV4cGFuZG9TdG9yZVtrZXldID0gdmFsdWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBleHBhbmRvU3RvcmUgJiYgZXhwYW5kb1N0b3JlW2tleV07XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVEYXRhKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcclxuICB2YXIgZGF0YSA9IEpRTGl0ZUV4cGFuZG9TdG9yZShlbGVtZW50LCAnZGF0YScpLFxyXG4gICAgICBpc1NldHRlciA9IGlzRGVmaW5lZCh2YWx1ZSksXHJcbiAgICAgIGtleURlZmluZWQgPSAhaXNTZXR0ZXIgJiYgaXNEZWZpbmVkKGtleSksXHJcbiAgICAgIGlzU2ltcGxlR2V0dGVyID0ga2V5RGVmaW5lZCAmJiAhaXNPYmplY3Qoa2V5KTtcclxuXHJcbiAgaWYgKCFkYXRhICYmICFpc1NpbXBsZUdldHRlcikge1xyXG4gICAgSlFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsICdkYXRhJywgZGF0YSA9IHt9KTtcclxuICB9XHJcblxyXG4gIGlmIChpc1NldHRlcikge1xyXG4gICAgZGF0YVtrZXldID0gdmFsdWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChrZXlEZWZpbmVkKSB7XHJcbiAgICAgIGlmIChpc1NpbXBsZUdldHRlcikge1xyXG4gICAgICAgIC8vIGRvbid0IGNyZWF0ZSBkYXRhIGluIHRoaXMgY2FzZS5cclxuICAgICAgICByZXR1cm4gZGF0YSAmJiBkYXRhW2tleV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZXh0ZW5kKGRhdGEsIGtleSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gSlFMaXRlSGFzQ2xhc3MoZWxlbWVudCwgc2VsZWN0b3IpIHtcclxuICByZXR1cm4gKChcIiBcIiArIGVsZW1lbnQuY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UoL1tcXG5cXHRdL2csIFwiIFwiKS5cclxuICAgICAgaW5kZXhPZiggXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiICkgPiAtMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEpRTGl0ZVJlbW92ZUNsYXNzKGVsZW1lbnQsIGNzc0NsYXNzZXMpIHtcclxuICBpZiAoY3NzQ2xhc3Nlcykge1xyXG4gICAgZm9yRWFjaChjc3NDbGFzc2VzLnNwbGl0KCcgJyksIGZ1bmN0aW9uKGNzc0NsYXNzKSB7XHJcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdHJpbShcclxuICAgICAgICAgIChcIiBcIiArIGVsZW1lbnQuY2xhc3NOYW1lICsgXCIgXCIpXHJcbiAgICAgICAgICAucmVwbGFjZSgvW1xcblxcdF0vZywgXCIgXCIpXHJcbiAgICAgICAgICAucmVwbGFjZShcIiBcIiArIHRyaW0oY3NzQ2xhc3MpICsgXCIgXCIsIFwiIFwiKVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVBZGRDbGFzcyhlbGVtZW50LCBjc3NDbGFzc2VzKSB7XHJcbiAgaWYgKGNzc0NsYXNzZXMpIHtcclxuICAgIGZvckVhY2goY3NzQ2xhc3Nlcy5zcGxpdCgnICcpLCBmdW5jdGlvbihjc3NDbGFzcykge1xyXG4gICAgICBpZiAoIUpRTGl0ZUhhc0NsYXNzKGVsZW1lbnQsIGNzc0NsYXNzKSkge1xyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gdHJpbShlbGVtZW50LmNsYXNzTmFtZSArICcgJyArIHRyaW0oY3NzQ2xhc3MpKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVBZGROb2Rlcyhyb290LCBlbGVtZW50cykge1xyXG4gIGlmIChlbGVtZW50cykge1xyXG4gICAgZWxlbWVudHMgPSAoIWVsZW1lbnRzLm5vZGVOYW1lICYmIGlzRGVmaW5lZChlbGVtZW50cy5sZW5ndGgpICYmICFpc1dpbmRvdyhlbGVtZW50cykpXHJcbiAgICAgID8gZWxlbWVudHNcclxuICAgICAgOiBbIGVsZW1lbnRzIF07XHJcbiAgICBmb3IodmFyIGk9MDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJvb3QucHVzaChlbGVtZW50c1tpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBKUUxpdGVDb250cm9sbGVyKGVsZW1lbnQsIG5hbWUpIHtcclxuICByZXR1cm4gSlFMaXRlSW5oZXJpdGVkRGF0YShlbGVtZW50LCAnJCcgKyAobmFtZSB8fCAnbmdDb250cm9sbGVyJyApICsgJ0NvbnRyb2xsZXInKTtcclxufVxyXG5cclxuZnVuY3Rpb24gSlFMaXRlSW5oZXJpdGVkRGF0YShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xyXG4gIGVsZW1lbnQgPSBqcUxpdGUoZWxlbWVudCk7XHJcblxyXG4gIC8vIGlmIGVsZW1lbnQgaXMgdGhlIGRvY3VtZW50IG9iamVjdCB3b3JrIHdpdGggdGhlIGh0bWwgZWxlbWVudCBpbnN0ZWFkXHJcbiAgLy8gdGhpcyBtYWtlcyAkKGRvY3VtZW50KS5zY29wZSgpIHBvc3NpYmxlXHJcbiAgaWYoZWxlbWVudFswXS5ub2RlVHlwZSA9PSA5KSB7XHJcbiAgICBlbGVtZW50ID0gZWxlbWVudC5maW5kKCdodG1sJyk7XHJcbiAgfVxyXG5cclxuICB3aGlsZSAoZWxlbWVudC5sZW5ndGgpIHtcclxuICAgIGlmICgodmFsdWUgPSBlbGVtZW50LmRhdGEobmFtZSkpICE9PSB1bmRlZmluZWQpIHJldHVybiB2YWx1ZTtcclxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCgpO1xyXG4gIH1cclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIEZ1bmN0aW9ucyB3aGljaCBhcmUgZGVjbGFyZWQgZGlyZWN0bHkuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG52YXIgSlFMaXRlUHJvdG90eXBlID0gSlFMaXRlLnByb3RvdHlwZSA9IHtcclxuICByZWFkeTogZnVuY3Rpb24oZm4pIHtcclxuICAgIHZhciBmaXJlZCA9IGZhbHNlO1xyXG5cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXIoKSB7XHJcbiAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xyXG4gICAgICBmaXJlZCA9IHRydWU7XHJcbiAgICAgIGZuKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2hlY2sgaWYgZG9jdW1lbnQgYWxyZWFkeSBpcyBsb2FkZWRcclxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKXtcclxuICAgICAgc2V0VGltZW91dCh0cmlnZ2VyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMub24oJ0RPTUNvbnRlbnRMb2FkZWQnLCB0cmlnZ2VyKTsgLy8gd29ya3MgZm9yIG1vZGVybiBicm93c2VycyBhbmQgSUU5XHJcbiAgICAgIC8vIHdlIGNhbiBub3QgdXNlIGpxTGl0ZSBzaW5jZSB3ZSBhcmUgbm90IGRvbmUgbG9hZGluZyBhbmQgalF1ZXJ5IGNvdWxkIGJlIGxvYWRlZCBsYXRlci5cclxuICAgICAgSlFMaXRlKHdpbmRvdykub24oJ2xvYWQnLCB0cmlnZ2VyKTsgLy8gZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCBmb3Igb3RoZXJzXHJcbiAgICB9XHJcbiAgfSxcclxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBbXTtcclxuICAgIGZvckVhY2godGhpcywgZnVuY3Rpb24oZSl7IHZhbHVlLnB1c2goJycgKyBlKTt9KTtcclxuICAgIHJldHVybiAnWycgKyB2YWx1ZS5qb2luKCcsICcpICsgJ10nO1xyXG4gIH0sXHJcblxyXG4gIGVxOiBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgICByZXR1cm4gKGluZGV4ID49IDApID8ganFMaXRlKHRoaXNbaW5kZXhdKSA6IGpxTGl0ZSh0aGlzW3RoaXMubGVuZ3RoICsgaW5kZXhdKTtcclxuICB9LFxyXG5cclxuICBsZW5ndGg6IDAsXHJcbiAgcHVzaDogcHVzaCxcclxuICBzb3J0OiBbXS5zb3J0LFxyXG4gIHNwbGljZTogW10uc3BsaWNlXHJcbn07XHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gRnVuY3Rpb25zIGl0ZXJhdGluZyBnZXR0ZXIvc2V0dGVycy5cclxuLy8gdGhlc2UgZnVuY3Rpb25zIHJldHVybiBzZWxmIG9uIHNldHRlciBhbmRcclxuLy8gdmFsdWUgb24gZ2V0LlxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxudmFyIEJPT0xFQU5fQVRUUiA9IHt9O1xyXG5mb3JFYWNoKCdtdWx0aXBsZSxzZWxlY3RlZCxjaGVja2VkLGRpc2FibGVkLHJlYWRPbmx5LHJlcXVpcmVkLG9wZW4nLnNwbGl0KCcsJyksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgQk9PTEVBTl9BVFRSW2xvd2VyY2FzZSh2YWx1ZSldID0gdmFsdWU7XHJcbn0pO1xyXG52YXIgQk9PTEVBTl9FTEVNRU5UUyA9IHt9O1xyXG5mb3JFYWNoKCdpbnB1dCxzZWxlY3Qsb3B0aW9uLHRleHRhcmVhLGJ1dHRvbixmb3JtLGRldGFpbHMnLnNwbGl0KCcsJyksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgQk9PTEVBTl9FTEVNRU5UU1t1cHBlcmNhc2UodmFsdWUpXSA9IHRydWU7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZ2V0Qm9vbGVhbkF0dHJOYW1lKGVsZW1lbnQsIG5hbWUpIHtcclxuICAvLyBjaGVjayBkb20gbGFzdCBzaW5jZSB3ZSB3aWxsIG1vc3QgbGlrZWx5IGZhaWwgb24gbmFtZVxyXG4gIHZhciBib29sZWFuQXR0ciA9IEJPT0xFQU5fQVRUUltuYW1lLnRvTG93ZXJDYXNlKCldO1xyXG5cclxuICAvLyBib29sZWFuQXR0ciBpcyBoZXJlIHR3aWNlIHRvIG1pbmltaXplIERPTSBhY2Nlc3NcclxuICByZXR1cm4gYm9vbGVhbkF0dHIgJiYgQk9PTEVBTl9FTEVNRU5UU1tlbGVtZW50Lm5vZGVOYW1lXSAmJiBib29sZWFuQXR0cjtcclxufVxyXG5cclxuZm9yRWFjaCh7XHJcbiAgZGF0YTogSlFMaXRlRGF0YSxcclxuICBpbmhlcml0ZWREYXRhOiBKUUxpdGVJbmhlcml0ZWREYXRhLFxyXG5cclxuICBzY29wZTogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIEpRTGl0ZUluaGVyaXRlZERhdGEoZWxlbWVudCwgJyRzY29wZScpO1xyXG4gIH0sXHJcblxyXG4gIGNvbnRyb2xsZXI6IEpRTGl0ZUNvbnRyb2xsZXIgLFxyXG5cclxuICBpbmplY3RvcjogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIEpRTGl0ZUluaGVyaXRlZERhdGEoZWxlbWVudCwgJyRpbmplY3RvcicpO1xyXG4gIH0sXHJcblxyXG4gIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKGVsZW1lbnQsbmFtZSkge1xyXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XHJcbiAgfSxcclxuXHJcbiAgaGFzQ2xhc3M6IEpRTGl0ZUhhc0NsYXNzLFxyXG5cclxuICBjc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICBuYW1lID0gY2FtZWxDYXNlKG5hbWUpO1xyXG5cclxuICAgIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciB2YWw7XHJcblxyXG4gICAgICBpZiAobXNpZSA8PSA4KSB7XHJcbiAgICAgICAgLy8gdGhpcyBpcyBzb21lIElFIHNwZWNpZmljIHdlaXJkbmVzcyB0aGF0IGpRdWVyeSAxLjYuNCBkb2VzIG5vdCBzdXJlIHdoeVxyXG4gICAgICAgIHZhbCA9IGVsZW1lbnQuY3VycmVudFN0eWxlICYmIGVsZW1lbnQuY3VycmVudFN0eWxlW25hbWVdO1xyXG4gICAgICAgIGlmICh2YWwgPT09ICcnKSB2YWwgPSAnYXV0byc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhbCA9IHZhbCB8fCBlbGVtZW50LnN0eWxlW25hbWVdO1xyXG5cclxuICAgICAgaWYgKG1zaWUgPD0gOCkge1xyXG4gICAgICAgIC8vIGpxdWVyeSB3ZWlyZG5lc3MgOi0vXHJcbiAgICAgICAgdmFsID0gKHZhbCA9PT0gJycpID8gdW5kZWZpbmVkIDogdmFsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gIHZhbDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhdHRyOiBmdW5jdGlvbihlbGVtZW50LCBuYW1lLCB2YWx1ZSl7XHJcbiAgICB2YXIgbG93ZXJjYXNlZE5hbWUgPSBsb3dlcmNhc2UobmFtZSk7XHJcbiAgICBpZiAoQk9PTEVBTl9BVFRSW2xvd2VyY2FzZWROYW1lXSkge1xyXG4gICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgIGlmICghIXZhbHVlKSB7XHJcbiAgICAgICAgICBlbGVtZW50W25hbWVdID0gdHJ1ZTtcclxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIGxvd2VyY2FzZWROYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZWxlbWVudFtuYW1lXSA9IGZhbHNlO1xyXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobG93ZXJjYXNlZE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gKGVsZW1lbnRbbmFtZV0gfHxcclxuICAgICAgICAgICAgICAgICAoZWxlbWVudC5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbShuYW1lKXx8IG5vb3ApLnNwZWNpZmllZClcclxuICAgICAgICAgICAgICAgPyBsb3dlcmNhc2VkTmFtZVxyXG4gICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcclxuICAgICAgLy8gdGhlIGV4dHJhIGFyZ3VtZW50IFwiMlwiIGlzIHRvIGdldCB0aGUgcmlnaHQgdGhpbmcgZm9yIGEuaHJlZiBpbiBJRSwgc2VlIGpRdWVyeSBjb2RlXHJcbiAgICAgIC8vIHNvbWUgZWxlbWVudHMgKGUuZy4gRG9jdW1lbnQpIGRvbid0IGhhdmUgZ2V0IGF0dHJpYnV0ZSwgc28gcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgICB2YXIgcmV0ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSwgMik7XHJcbiAgICAgIC8vIG5vcm1hbGl6ZSBub24tZXhpc3RpbmcgYXR0cmlidXRlcyB0byB1bmRlZmluZWQgKGFzIGpRdWVyeSlcclxuICAgICAgcmV0dXJuIHJldCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBwcm9wOiBmdW5jdGlvbihlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgZWxlbWVudFtuYW1lXSA9IHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnRbbmFtZV07XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgdGV4dDogKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIE5PREVfVFlQRV9URVhUX1BST1BFUlRZID0gW107XHJcbiAgICBpZiAobXNpZSA8IDkpIHtcclxuICAgICAgTk9ERV9UWVBFX1RFWFRfUFJPUEVSVFlbMV0gPSAnaW5uZXJUZXh0JzsgICAgLyoqIEVsZW1lbnQgKiovXHJcbiAgICAgIE5PREVfVFlQRV9URVhUX1BST1BFUlRZWzNdID0gJ25vZGVWYWx1ZSc7ICAgIC8qKiBUZXh0ICoqL1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgTk9ERV9UWVBFX1RFWFRfUFJPUEVSVFlbMV0gPSAgICAgICAgICAgICAgICAgLyoqIEVsZW1lbnQgKiovXHJcbiAgICAgIE5PREVfVFlQRV9URVhUX1BST1BFUlRZWzNdID0gJ3RleHRDb250ZW50JzsgIC8qKiBUZXh0ICoqL1xyXG4gICAgfVxyXG4gICAgZ2V0VGV4dC4kZHYgPSAnJztcclxuICAgIHJldHVybiBnZXRUZXh0O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFRleHQoZWxlbWVudCwgdmFsdWUpIHtcclxuICAgICAgdmFyIHRleHRQcm9wID0gTk9ERV9UWVBFX1RFWFRfUFJPUEVSVFlbZWxlbWVudC5ub2RlVHlwZV1cclxuICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB0ZXh0UHJvcCA/IGVsZW1lbnRbdGV4dFByb3BdIDogJyc7XHJcbiAgICAgIH1cclxuICAgICAgZWxlbWVudFt0ZXh0UHJvcF0gPSB2YWx1ZTtcclxuICAgIH1cclxuICB9KSgpLFxyXG5cclxuICB2YWw6IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlKSB7XHJcbiAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgIGlmIChub2RlTmFtZV8oZWxlbWVudCkgPT09ICdTRUxFQ1QnICYmIGVsZW1lbnQubXVsdGlwbGUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yRWFjaChlbGVtZW50Lm9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gob3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGVsZW1lbnQudmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbGVtZW50LnZhbHVlID0gdmFsdWU7XHJcbiAgfSxcclxuXHJcbiAgaHRtbDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcclxuICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGNoaWxkTm9kZXMgPSBlbGVtZW50LmNoaWxkTm9kZXM7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIEpRTGl0ZURlYWxvYyhjaGlsZE5vZGVzW2ldKTtcclxuICAgIH1cclxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdmFsdWU7XHJcbiAgfVxyXG59LCBmdW5jdGlvbihmbiwgbmFtZSl7XHJcbiAgLyoqXHJcbiAgICogUHJvcGVydGllczogd3JpdGVzIHJldHVybiBzZWxlY3Rpb24sIHJlYWRzIHJldHVybiBmaXJzdCB2YWx1ZVxyXG4gICAqL1xyXG4gIEpRTGl0ZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbihhcmcxLCBhcmcyKSB7XHJcbiAgICB2YXIgaSwga2V5O1xyXG5cclxuICAgIC8vIEpRTGl0ZUhhc0NsYXNzIGhhcyBvbmx5IHR3byBhcmd1bWVudHMsIGJ1dCBpcyBhIGdldHRlci1vbmx5IGZuLCBzbyB3ZSBuZWVkIHRvIHNwZWNpYWwtY2FzZSBpdFxyXG4gICAgLy8gaW4gYSB3YXkgdGhhdCBzdXJ2aXZlcyBtaW5pZmljYXRpb24uXHJcbiAgICBpZiAoKChmbi5sZW5ndGggPT0gMiAmJiAoZm4gIT09IEpRTGl0ZUhhc0NsYXNzICYmIGZuICE9PSBKUUxpdGVDb250cm9sbGVyKSkgPyBhcmcxIDogYXJnMikgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAoaXNPYmplY3QoYXJnMSkpIHtcclxuXHJcbiAgICAgICAgLy8gd2UgYXJlIGEgd3JpdGUsIGJ1dCB0aGUgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHRoZSBrZXkvdmFsdWVzXHJcbiAgICAgICAgZm9yKGk9MDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChmbiA9PT0gSlFMaXRlRGF0YSkge1xyXG4gICAgICAgICAgICAvLyBkYXRhKCkgdGFrZXMgdGhlIHdob2xlIG9iamVjdCBpbiBqUXVlcnlcclxuICAgICAgICAgICAgZm4odGhpc1tpXSwgYXJnMSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBhcmcxKSB7XHJcbiAgICAgICAgICAgICAgZm4odGhpc1tpXSwga2V5LCBhcmcxW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldHVybiBzZWxmIGZvciBjaGFpbmluZ1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHdlIGFyZSBhIHJlYWQsIHNvIHJlYWQgdGhlIGZpcnN0IGNoaWxkLlxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGZuLiRkdjtcclxuICAgICAgICAvLyBPbmx5IGlmIHdlIGhhdmUgJGR2IGRvIHdlIGl0ZXJhdGUgb3ZlciBhbGwsIG90aGVyd2lzZSBpdCBpcyBqdXN0IHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIHZhciBqaiA9IHZhbHVlID09IHVuZGVmaW5lZCA/IE1hdGgubWluKHRoaXMubGVuZ3RoLCAxKSA6IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgICAgdmFyIG5vZGVWYWx1ZSA9IGZuKHRoaXNbal0sIGFyZzEsIGFyZzIpO1xyXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA/IHZhbHVlICsgbm9kZVZhbHVlIDogbm9kZVZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHdlIGFyZSBhIHdyaXRlLCBzbyBhcHBseSB0byBhbGwgY2hpbGRyZW5cclxuICAgICAgZm9yKGk9MDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmbih0aGlzW2ldLCBhcmcxLCBhcmcyKTtcclxuICAgICAgfVxyXG4gICAgICAvLyByZXR1cm4gc2VsZiBmb3IgY2hhaW5pbmdcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFdmVudEhhbmRsZXIoZWxlbWVudCwgZXZlbnRzKSB7XHJcbiAgdmFyIGV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCwgdHlwZSkge1xyXG4gICAgaWYgKCFldmVudC5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7IC8vaWVcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xyXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlOyAvL2llXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFldmVudC50YXJnZXQpIHtcclxuICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNVbmRlZmluZWQoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkpIHtcclxuICAgICAgdmFyIHByZXZlbnQgPSBldmVudC5wcmV2ZW50RGVmYXVsdDtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcclxuICAgICAgICBwcmV2ZW50LmNhbGwoZXZlbnQpO1xyXG4gICAgICB9O1xyXG4gICAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBldmVudC5kZWZhdWx0UHJldmVudGVkIHx8IGV2ZW50LnJldHVyblZhbHVlID09IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBmb3JFYWNoKGV2ZW50c1t0eXBlIHx8IGV2ZW50LnR5cGVdLCBmdW5jdGlvbihmbikge1xyXG4gICAgICBmbi5jYWxsKGVsZW1lbnQsIGV2ZW50KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlbW92ZSBtb25rZXktcGF0Y2hlZCBtZXRob2RzIChJRSksXHJcbiAgICAvLyBhcyB0aGV5IHdvdWxkIGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBJRTguXHJcbiAgICBpZiAobXNpZSA8PSA4KSB7XHJcbiAgICAgIC8vIElFNy84IGRvZXMgbm90IGFsbG93IHRvIGRlbGV0ZSBwcm9wZXJ0eSBvbiBuYXRpdmUgb2JqZWN0XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gbnVsbDtcclxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gbnVsbDtcclxuICAgICAgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkID0gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEl0IHNob3VsZG4ndCBhZmZlY3Qgbm9ybWFsIGJyb3dzZXJzIChuYXRpdmUgbWV0aG9kcyBhcmUgZGVmaW5lZCBvbiBwcm90b3R5cGUpLlxyXG4gICAgICBkZWxldGUgZXZlbnQucHJldmVudERlZmF1bHQ7XHJcbiAgICAgIGRlbGV0ZSBldmVudC5zdG9wUHJvcGFnYXRpb247XHJcbiAgICAgIGRlbGV0ZSBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQ7XHJcbiAgICB9XHJcbiAgfTtcclxuICBldmVudEhhbmRsZXIuZWxlbSA9IGVsZW1lbnQ7XHJcbiAgcmV0dXJuIGV2ZW50SGFuZGxlcjtcclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbi8vIEZ1bmN0aW9ucyBpdGVyYXRpbmcgdHJhdmVyc2FsLlxyXG4vLyBUaGVzZSBmdW5jdGlvbnMgY2hhaW4gcmVzdWx0cyBpbnRvIGEgc2luZ2xlXHJcbi8vIHNlbGVjdG9yLlxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuZm9yRWFjaCh7XHJcbiAgcmVtb3ZlRGF0YTogSlFMaXRlUmVtb3ZlRGF0YSxcclxuXHJcbiAgZGVhbG9jOiBKUUxpdGVEZWFsb2MsXHJcblxyXG4gIG9uOiBmdW5jdGlvbiBvbkZuKGVsZW1lbnQsIHR5cGUsIGZuLCB1bnN1cHBvcnRlZCl7XHJcbiAgICBpZiAoaXNEZWZpbmVkKHVuc3VwcG9ydGVkKSkgdGhyb3cganFMaXRlTWluRXJyKCdvbmFyZ3MnLCAnanFMaXRlI29uKCkgZG9lcyBub3Qgc3VwcG9ydCB0aGUgYHNlbGVjdG9yYCBvciBgZXZlbnREYXRhYCBwYXJhbWV0ZXJzJyk7XHJcblxyXG4gICAgdmFyIGV2ZW50cyA9IEpRTGl0ZUV4cGFuZG9TdG9yZShlbGVtZW50LCAnZXZlbnRzJyksXHJcbiAgICAgICAgaGFuZGxlID0gSlFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsICdoYW5kbGUnKTtcclxuXHJcbiAgICBpZiAoIWV2ZW50cykgSlFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsICdldmVudHMnLCBldmVudHMgPSB7fSk7XHJcbiAgICBpZiAoIWhhbmRsZSkgSlFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsICdoYW5kbGUnLCBoYW5kbGUgPSBjcmVhdGVFdmVudEhhbmRsZXIoZWxlbWVudCwgZXZlbnRzKSk7XHJcblxyXG4gICAgZm9yRWFjaCh0eXBlLnNwbGl0KCcgJyksIGZ1bmN0aW9uKHR5cGUpe1xyXG4gICAgICB2YXIgZXZlbnRGbnMgPSBldmVudHNbdHlwZV07XHJcblxyXG4gICAgICBpZiAoIWV2ZW50Rm5zKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21vdXNlZW50ZXInIHx8IHR5cGUgPT0gJ21vdXNlbGVhdmUnKSB7XHJcbiAgICAgICAgICB2YXIgY29udGFpbnMgPSBkb2N1bWVudC5ib2R5LmNvbnRhaW5zIHx8IGRvY3VtZW50LmJvZHkuY29tcGFyZURvY3VtZW50UG9zaXRpb24gP1xyXG4gICAgICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XHJcbiAgICAgICAgICAgIHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXHJcbiAgICAgICAgICAgIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcclxuICAgICAgICAgICAgICBhZG93bi5jb250YWlucyA/XHJcbiAgICAgICAgICAgICAgYWRvd24uY29udGFpbnMoIGJ1cCApIDpcclxuICAgICAgICAgICAgICBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcclxuICAgICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgfSA6XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKCBhLCBiICkge1xyXG4gICAgICAgICAgICAgIGlmICggYiApIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoIGIgPT09IGEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IFtdO1xyXG5cclxuICAgICAgICAgIC8vIFJlZmVyIHRvIGpRdWVyeSdzIGltcGxlbWVudGF0aW9uIG9mIG1vdXNlZW50ZXIgJiBtb3VzZWxlYXZlXHJcbiAgICAgICAgICAvLyBSZWFkIGFib3V0IG1vdXNlZW50ZXIgYW5kIG1vdXNlbGVhdmU6XHJcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19tb3VzZS5odG1sI2xpbms4XHJcbiAgICAgICAgICB2YXIgZXZlbnRtYXAgPSB7IG1vdXNlbGVhdmUgOiBcIm1vdXNlb3V0XCIsIG1vdXNlZW50ZXIgOiBcIm1vdXNlb3ZlclwifTtcclxuXHJcbiAgICAgICAgICBvbkZuKGVsZW1lbnQsIGV2ZW50bWFwW3R5cGVdLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcywgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XHJcbiAgICAgICAgICAgIC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgLy8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcclxuICAgICAgICAgICAgaWYgKCAhcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFjb250YWlucyh0YXJnZXQsIHJlbGF0ZWQpKSApe1xyXG4gICAgICAgICAgICAgIGhhbmRsZShldmVudCwgdHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lckZuKGVsZW1lbnQsIHR5cGUsIGhhbmRsZSk7XHJcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRGbnMgPSBldmVudHNbdHlwZV1cclxuICAgICAgfVxyXG4gICAgICBldmVudEZucy5wdXNoKGZuKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIG9mZjogSlFMaXRlT2ZmLFxyXG5cclxuICByZXBsYWNlV2l0aDogZnVuY3Rpb24oZWxlbWVudCwgcmVwbGFjZU5vZGUpIHtcclxuICAgIHZhciBpbmRleCwgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgSlFMaXRlRGVhbG9jKGVsZW1lbnQpO1xyXG4gICAgZm9yRWFjaChuZXcgSlFMaXRlKHJlcGxhY2VOb2RlKSwgZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgIGlmIChpbmRleCkge1xyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgaW5kZXgubmV4dFNpYmxpbmcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZSwgZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgICAgaW5kZXggPSBub2RlO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgY2hpbGRyZW46IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG4gICAgZm9yRWFjaChlbGVtZW50LmNoaWxkTm9kZXMsIGZ1bmN0aW9uKGVsZW1lbnQpe1xyXG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMSlcclxuICAgICAgICBjaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgfSxcclxuXHJcbiAgY29udGVudHM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBlbGVtZW50LmNoaWxkTm9kZXMgfHwgW107XHJcbiAgfSxcclxuXHJcbiAgYXBwZW5kOiBmdW5jdGlvbihlbGVtZW50LCBub2RlKSB7XHJcbiAgICBmb3JFYWNoKG5ldyBKUUxpdGUobm9kZSksIGZ1bmN0aW9uKGNoaWxkKXtcclxuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDEgfHwgZWxlbWVudC5ub2RlVHlwZSA9PT0gMTEpIHtcclxuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgcHJlcGVuZDogZnVuY3Rpb24oZWxlbWVudCwgbm9kZSkge1xyXG4gICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgdmFyIGluZGV4ID0gZWxlbWVudC5maXJzdENoaWxkO1xyXG4gICAgICBmb3JFYWNoKG5ldyBKUUxpdGUobm9kZSksIGZ1bmN0aW9uKGNoaWxkKXtcclxuICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShjaGlsZCwgaW5kZXgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB3cmFwOiBmdW5jdGlvbihlbGVtZW50LCB3cmFwTm9kZSkge1xyXG4gICAgd3JhcE5vZGUgPSBqcUxpdGUod3JhcE5vZGUpWzBdO1xyXG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh3cmFwTm9kZSwgZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICB3cmFwTm9kZS5hcHBlbmRDaGlsZChlbGVtZW50KTtcclxuICB9LFxyXG5cclxuICByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIEpRTGl0ZURlYWxvYyhlbGVtZW50KTtcclxuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XHJcbiAgfSxcclxuXHJcbiAgYWZ0ZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIG5ld0VsZW1lbnQpIHtcclxuICAgIHZhciBpbmRleCA9IGVsZW1lbnQsIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuICAgIGZvckVhY2gobmV3IEpRTGl0ZShuZXdFbGVtZW50KSwgZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgaW5kZXgubmV4dFNpYmxpbmcpO1xyXG4gICAgICBpbmRleCA9IG5vZGU7XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBhZGRDbGFzczogSlFMaXRlQWRkQ2xhc3MsXHJcbiAgcmVtb3ZlQ2xhc3M6IEpRTGl0ZVJlbW92ZUNsYXNzLFxyXG5cclxuICB0b2dnbGVDbGFzczogZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3IsIGNvbmRpdGlvbikge1xyXG4gICAgaWYgKGlzVW5kZWZpbmVkKGNvbmRpdGlvbikpIHtcclxuICAgICAgY29uZGl0aW9uID0gIUpRTGl0ZUhhc0NsYXNzKGVsZW1lbnQsIHNlbGVjdG9yKTtcclxuICAgIH1cclxuICAgIChjb25kaXRpb24gPyBKUUxpdGVBZGRDbGFzcyA6IEpRTGl0ZVJlbW92ZUNsYXNzKShlbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgfSxcclxuXHJcbiAgcGFyZW50OiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcclxuICB9LFxyXG5cclxuICBuZXh0OiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICBpZiAoZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElFOCBkb2Vzbid0IGhhdmUgbmV4dEVsZW1lbnRTaWJsaW5nXHJcbiAgICB2YXIgZWxtID0gZWxlbWVudC5uZXh0U2libGluZztcclxuICAgIHdoaWxlIChlbG0gIT0gbnVsbCAmJiBlbG0ubm9kZVR5cGUgIT09IDEpIHtcclxuICAgICAgZWxtID0gZWxtLm5leHRTaWJsaW5nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsbTtcclxuICB9LFxyXG5cclxuICBmaW5kOiBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3Rvcikge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpO1xyXG4gIH0sXHJcblxyXG4gIGNsb25lOiBKUUxpdGVDbG9uZSxcclxuXHJcbiAgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgZXZlbnREYXRhKSB7XHJcbiAgICB2YXIgZXZlbnRGbnMgPSAoSlFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsICdldmVudHMnKSB8fCB7fSlbZXZlbnROYW1lXTtcclxuICAgIGV2ZW50RGF0YSA9IGV2ZW50RGF0YSB8fCB7XHJcbiAgICAgIHByZXZlbnREZWZhdWx0OiBub29wLFxyXG4gICAgICBzdG9wUHJvcGFnYXRpb246IG5vb3BcclxuICAgIH07XHJcblxyXG4gICAgZm9yRWFjaChldmVudEZucywgZnVuY3Rpb24oZm4pIHtcclxuICAgICAgZm4uY2FsbChlbGVtZW50LCBldmVudERhdGEpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59LCBmdW5jdGlvbihmbiwgbmFtZSl7XHJcbiAgLyoqXHJcbiAgICogY2hhaW5pbmcgZnVuY3Rpb25zXHJcbiAgICovXHJcbiAgSlFMaXRlLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGFyZzMpIHtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIGZvcih2YXIgaT0wOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFsdWUgPSBmbih0aGlzW2ldLCBhcmcxLCBhcmcyLCBhcmczKTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgLy8gYW55IGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSB2YWx1ZSBuZWVkcyB0byBiZSB3cmFwcGVkXHJcbiAgICAgICAgICB2YWx1ZSA9IGpxTGl0ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIEpRTGl0ZUFkZE5vZGVzKHZhbHVlLCBmbih0aGlzW2ldLCBhcmcxLCBhcmcyLCBhcmczKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZSA9PSB1bmRlZmluZWQgPyB0aGlzIDogdmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gYmluZCBsZWdhY3kgYmluZC91bmJpbmQgdG8gb24vb2ZmXHJcbiAgSlFMaXRlLnByb3RvdHlwZS5iaW5kID0gSlFMaXRlLnByb3RvdHlwZS5vbjtcclxuICBKUUxpdGUucHJvdG90eXBlLnVuYmluZCA9IEpRTGl0ZS5wcm90b3R5cGUub2ZmO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhIGhhc2ggb2YgYW4gJ29iaicuXHJcbiAqIEhhc2ggb2YgYTpcclxuICogIHN0cmluZyBpcyBzdHJpbmdcclxuICogIG51bWJlciBpcyBudW1iZXIgYXMgc3RyaW5nXHJcbiAqICBvYmplY3QgaXMgZWl0aGVyIHJlc3VsdCBvZiBjYWxsaW5nICQkaGFzaEtleSBmdW5jdGlvbiBvbiB0aGUgb2JqZWN0IG9yIHVuaXF1ZWx5IGdlbmVyYXRlZCBpZCxcclxuICogICAgICAgICB0aGF0IGlzIGFsc28gYXNzaWduZWQgdG8gdGhlICQkaGFzaEtleSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGhhc2ggc3RyaW5nIHN1Y2ggdGhhdCB0aGUgc2FtZSBpbnB1dCB3aWxsIGhhdmUgdGhlIHNhbWUgaGFzaCBzdHJpbmcuXHJcbiAqICAgICAgICAgVGhlIHJlc3VsdGluZyBzdHJpbmcga2V5IGlzIGluICd0eXBlOmhhc2hLZXknIGZvcm1hdC5cclxuICovXHJcbmZ1bmN0aW9uIGhhc2hLZXkob2JqKSB7XHJcbiAgdmFyIG9ialR5cGUgPSB0eXBlb2Ygb2JqLFxyXG4gICAgICBrZXk7XHJcblxyXG4gIGlmIChvYmpUeXBlID09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xyXG4gICAgaWYgKHR5cGVvZiAoa2V5ID0gb2JqLiQkaGFzaEtleSkgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAvLyBtdXN0IGludm9rZSBvbiBvYmplY3QgdG8ga2VlcCB0aGUgcmlnaHQgdGhpc1xyXG4gICAgICBrZXkgPSBvYmouJCRoYXNoS2V5KCk7XHJcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGtleSA9IG9iai4kJGhhc2hLZXkgPSBuZXh0VWlkKCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGtleSA9IG9iajtcclxuICB9XHJcblxyXG4gIHJldHVybiBvYmpUeXBlICsgJzonICsga2V5O1xyXG59XHJcblxyXG4vKipcclxuICogSGFzaE1hcCB3aGljaCBjYW4gdXNlIG9iamVjdHMgYXMga2V5c1xyXG4gKi9cclxuZnVuY3Rpb24gSGFzaE1hcChhcnJheSl7XHJcbiAgZm9yRWFjaChhcnJheSwgdGhpcy5wdXQsIHRoaXMpO1xyXG59XHJcbkhhc2hNYXAucHJvdG90eXBlID0ge1xyXG4gIC8qKlxyXG4gICAqIFN0b3JlIGtleSB2YWx1ZSBwYWlyXHJcbiAgICogQHBhcmFtIGtleSBrZXkgdG8gc3RvcmUgY2FuIGJlIGFueSB0eXBlXHJcbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIHN0b3JlIGNhbiBiZSBhbnkgdHlwZVxyXG4gICAqL1xyXG4gIHB1dDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgdGhpc1toYXNoS2V5KGtleSldID0gdmFsdWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIGtleVxyXG4gICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBmb3IgdGhlIGtleVxyXG4gICAqL1xyXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICByZXR1cm4gdGhpc1toYXNoS2V5KGtleSldO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUga2V5L3ZhbHVlIHBhaXJcclxuICAgKiBAcGFyYW0ga2V5XHJcbiAgICovXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcclxuICAgIHZhciB2YWx1ZSA9IHRoaXNba2V5ID0gaGFzaEtleShrZXkpXTtcclxuICAgIGRlbGV0ZSB0aGlzW2tleV07XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBhbmd1bGFyLmluamVjdG9yXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlcyBhbiBpbmplY3RvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGZvciByZXRyaWV2aW5nIHNlcnZpY2VzIGFzIHdlbGwgYXMgZm9yXHJcbiAqIGRlcGVuZGVuY3kgaW5qZWN0aW9uIChzZWUge0BsaW5rIGd1aWRlL2RpIGRlcGVuZGVuY3kgaW5qZWN0aW9ufSkuXHJcbiAqXHJcblxyXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmd8RnVuY3Rpb24+fSBtb2R1bGVzIEEgbGlzdCBvZiBtb2R1bGUgZnVuY3Rpb25zIG9yIHRoZWlyIGFsaWFzZXMuIFNlZVxyXG4gKiAgICAgICAge0BsaW5rIGFuZ3VsYXIubW9kdWxlfS4gVGhlIGBuZ2AgbW9kdWxlIG11c3QgYmUgZXhwbGljaXRseSBhZGRlZC5cclxuICogQHJldHVybnMge2Z1bmN0aW9uKCl9IEluamVjdG9yIGZ1bmN0aW9uLiBTZWUge0BsaW5rIEFVVE8uJGluamVjdG9yICRpbmplY3Rvcn0uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFR5cGljYWwgdXNhZ2VcclxuICogPHByZT5cclxuICogICAvLyBjcmVhdGUgYW4gaW5qZWN0b3JcclxuICogICB2YXIgJGluamVjdG9yID0gYW5ndWxhci5pbmplY3RvcihbJ25nJ10pO1xyXG4gKlxyXG4gKiAgIC8vIHVzZSB0aGUgaW5qZWN0b3IgdG8ga2ljayBvZmYgeW91ciBhcHBsaWNhdGlvblxyXG4gKiAgIC8vIHVzZSB0aGUgdHlwZSBpbmZlcmVuY2UgdG8gYXV0byBpbmplY3QgYXJndW1lbnRzLCBvciB1c2UgaW1wbGljaXQgaW5qZWN0aW9uXHJcbiAqICAgJGluamVjdG9yLmludm9rZShmdW5jdGlvbigkcm9vdFNjb3BlLCAkY29tcGlsZSwgJGRvY3VtZW50KXtcclxuICogICAgICRjb21waWxlKCRkb2N1bWVudCkoJHJvb3RTY29wZSk7XHJcbiAqICAgICAkcm9vdFNjb3BlLiRkaWdlc3QoKTtcclxuICogICB9KTtcclxuICogPC9wcmU+XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcclxuICogQG5hbWUgQVVUT1xyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogSW1wbGljaXQgbW9kdWxlIHdoaWNoIGdldHMgYXV0b21hdGljYWxseSBhZGRlZCB0byBlYWNoIHtAbGluayBBVVRPLiRpbmplY3RvciAkaW5qZWN0b3J9LlxyXG4gKi9cclxuXHJcbnZhciBGTl9BUkdTID0gL15mdW5jdGlvblxccypbXlxcKF0qXFwoXFxzKihbXlxcKV0qKVxcKS9tO1xyXG52YXIgRk5fQVJHX1NQTElUID0gLywvO1xyXG52YXIgRk5fQVJHID0gL15cXHMqKF8/KShcXFMrPylcXDFcXHMqJC87XHJcbnZhciBTVFJJUF9DT01NRU5UUyA9IC8oKFxcL1xcLy4qJCl8KFxcL1xcKltcXHNcXFNdKj9cXCpcXC8pKS9tZztcclxudmFyICRpbmplY3Rvck1pbkVyciA9IG1pbkVycignJGluamVjdG9yJyk7XHJcbmZ1bmN0aW9uIGFubm90YXRlKGZuKSB7XHJcbiAgdmFyICRpbmplY3QsXHJcbiAgICAgIGZuVGV4dCxcclxuICAgICAgYXJnRGVjbCxcclxuICAgICAgbGFzdDtcclxuXHJcbiAgaWYgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBpZiAoISgkaW5qZWN0ID0gZm4uJGluamVjdCkpIHtcclxuICAgICAgJGluamVjdCA9IFtdO1xyXG4gICAgICBpZiAoZm4ubGVuZ3RoKSB7XHJcbiAgICAgICAgZm5UZXh0ID0gZm4udG9TdHJpbmcoKS5yZXBsYWNlKFNUUklQX0NPTU1FTlRTLCAnJyk7XHJcbiAgICAgICAgYXJnRGVjbCA9IGZuVGV4dC5tYXRjaChGTl9BUkdTKTtcclxuICAgICAgICBmb3JFYWNoKGFyZ0RlY2xbMV0uc3BsaXQoRk5fQVJHX1NQTElUKSwgZnVuY3Rpb24oYXJnKXtcclxuICAgICAgICAgIGFyZy5yZXBsYWNlKEZOX0FSRywgZnVuY3Rpb24oYWxsLCB1bmRlcnNjb3JlLCBuYW1lKXtcclxuICAgICAgICAgICAgJGluamVjdC5wdXNoKG5hbWUpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZm4uJGluamVjdCA9ICRpbmplY3Q7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChpc0FycmF5KGZuKSkge1xyXG4gICAgbGFzdCA9IGZuLmxlbmd0aCAtIDE7XHJcbiAgICBhc3NlcnRBcmdGbihmbltsYXN0XSwgJ2ZuJyk7XHJcbiAgICAkaW5qZWN0ID0gZm4uc2xpY2UoMCwgbGFzdCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGFzc2VydEFyZ0ZuKGZuLCAnZm4nLCB0cnVlKTtcclxuICB9XHJcbiAgcmV0dXJuICRpbmplY3Q7XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgQVVUTy4kaW5qZWN0b3JcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBgJGluamVjdG9yYCBpcyB1c2VkIHRvIHJldHJpZXZlIG9iamVjdCBpbnN0YW5jZXMgYXMgZGVmaW5lZCBieVxyXG4gKiB7QGxpbmsgQVVUTy4kcHJvdmlkZSBwcm92aWRlcn0sIGluc3RhbnRpYXRlIHR5cGVzLCBpbnZva2UgbWV0aG9kcyxcclxuICogYW5kIGxvYWQgbW9kdWxlcy5cclxuICpcclxuICogVGhlIGZvbGxvd2luZyBhbHdheXMgaG9sZHMgdHJ1ZTpcclxuICpcclxuICogPHByZT5cclxuICogICB2YXIgJGluamVjdG9yID0gYW5ndWxhci5pbmplY3RvcigpO1xyXG4gKiAgIGV4cGVjdCgkaW5qZWN0b3IuZ2V0KCckaW5qZWN0b3InKSkudG9CZSgkaW5qZWN0b3IpO1xyXG4gKiAgIGV4cGVjdCgkaW5qZWN0b3IuaW52b2tlKGZ1bmN0aW9uKCRpbmplY3Rvcil7XHJcbiAqICAgICByZXR1cm4gJGluamVjdG9yO1xyXG4gKiAgIH0pLnRvQmUoJGluamVjdG9yKTtcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqICMgSW5qZWN0aW9uIEZ1bmN0aW9uIEFubm90YXRpb25cclxuICpcclxuICogSmF2YVNjcmlwdCBkb2VzIG5vdCBoYXZlIGFubm90YXRpb25zLCBhbmQgYW5ub3RhdGlvbnMgYXJlIG5lZWRlZCBmb3IgZGVwZW5kZW5jeSBpbmplY3Rpb24uIFRoZVxyXG4gKiBmb2xsb3dpbmcgYXJlIGFsbCB2YWxpZCB3YXlzIG9mIGFubm90YXRpbmcgZnVuY3Rpb24gd2l0aCBpbmplY3Rpb24gYXJndW1lbnRzIGFuZCBhcmUgZXF1aXZhbGVudC5cclxuICpcclxuICogPHByZT5cclxuICogICAvLyBpbmZlcnJlZCAob25seSB3b3JrcyBpZiBjb2RlIG5vdCBtaW5pZmllZC9vYmZ1c2NhdGVkKVxyXG4gKiAgICRpbmplY3Rvci5pbnZva2UoZnVuY3Rpb24oc2VydmljZUEpe30pO1xyXG4gKlxyXG4gKiAgIC8vIGFubm90YXRlZFxyXG4gKiAgIGZ1bmN0aW9uIGV4cGxpY2l0KHNlcnZpY2VBKSB7fTtcclxuICogICBleHBsaWNpdC4kaW5qZWN0ID0gWydzZXJ2aWNlQSddO1xyXG4gKiAgICRpbmplY3Rvci5pbnZva2UoZXhwbGljaXQpO1xyXG4gKlxyXG4gKiAgIC8vIGlubGluZVxyXG4gKiAgICRpbmplY3Rvci5pbnZva2UoWydzZXJ2aWNlQScsIGZ1bmN0aW9uKHNlcnZpY2VBKXt9XSk7XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiAjIyBJbmZlcmVuY2VcclxuICpcclxuICogSW4gSmF2YVNjcmlwdCBjYWxsaW5nIGB0b1N0cmluZygpYCBvbiBhIGZ1bmN0aW9uIHJldHVybnMgdGhlIGZ1bmN0aW9uIGRlZmluaXRpb24uIFRoZSBkZWZpbml0aW9uIGNhbiB0aGVuIGJlXHJcbiAqIHBhcnNlZCBhbmQgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50cyBjYW4gYmUgZXh0cmFjdGVkLiAqTk9URToqIFRoaXMgZG9lcyBub3Qgd29yayB3aXRoIG1pbmlmaWNhdGlvbiwgYW5kIG9iZnVzY2F0aW9uXHJcbiAqIHRvb2xzIHNpbmNlIHRoZXNlIHRvb2xzIGNoYW5nZSB0aGUgYXJndW1lbnQgbmFtZXMuXHJcbiAqXHJcbiAqICMjIGAkaW5qZWN0YCBBbm5vdGF0aW9uXHJcbiAqIEJ5IGFkZGluZyBhIGAkaW5qZWN0YCBwcm9wZXJ0eSBvbnRvIGEgZnVuY3Rpb24gdGhlIGluamVjdGlvbiBwYXJhbWV0ZXJzIGNhbiBiZSBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqICMjIElubGluZVxyXG4gKiBBcyBhbiBhcnJheSBvZiBpbmplY3Rpb24gbmFtZXMsIHdoZXJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGFycmF5IGlzIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgbWV0aG9kXHJcbiAqIEBuYW1lIEFVVE8uJGluamVjdG9yI2dldFxyXG4gKiBAbWV0aG9kT2YgQVVUTy4kaW5qZWN0b3JcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFJldHVybiBhbiBpbnN0YW5jZSBvZiB0aGUgc2VydmljZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGluc3RhbmNlIHRvIHJldHJpZXZlLlxyXG4gKiBAcmV0dXJuIHsqfSBUaGUgaW5zdGFuY2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBtZXRob2RcclxuICogQG5hbWUgQVVUTy4kaW5qZWN0b3IjaW52b2tlXHJcbiAqIEBtZXRob2RPZiBBVVRPLiRpbmplY3RvclxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogSW52b2tlIHRoZSBtZXRob2QgYW5kIHN1cHBseSB0aGUgbWV0aG9kIGFyZ3VtZW50cyBmcm9tIHRoZSBgJGluamVjdG9yYC5cclxuICpcclxuICogQHBhcmFtIHshZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuIFRoZSBmdW5jdGlvbiBhcmd1bWVudHMgY29tZSBmb3JtIHRoZSBmdW5jdGlvbiBhbm5vdGF0aW9uLlxyXG4gKiBAcGFyYW0ge09iamVjdD19IHNlbGYgVGhlIGB0aGlzYCBmb3IgdGhlIGludm9rZWQgbWV0aG9kLlxyXG4gKiBAcGFyYW0ge09iamVjdD19IGxvY2FscyBPcHRpb25hbCBvYmplY3QuIElmIHByZXNldCB0aGVuIGFueSBhcmd1bWVudCBuYW1lcyBhcmUgcmVhZCBmcm9tIHRoaXMgb2JqZWN0IGZpcnN0LCBiZWZvcmVcclxuICogICB0aGUgYCRpbmplY3RvcmAgaXMgY29uc3VsdGVkLlxyXG4gKiBAcmV0dXJucyB7Kn0gdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBpbnZva2VkIGBmbmAgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBtZXRob2RcclxuICogQG5hbWUgQVVUTy4kaW5qZWN0b3IjaGFzXHJcbiAqIEBtZXRob2RPZiBBVVRPLiRpbmplY3RvclxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQWxsb3dzIHRoZSB1c2VyIHRvIHF1ZXJ5IGlmIHRoZSBwYXJ0aWN1bGFyIHNlcnZpY2UgZXhpc3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBOYW1lIG9mIHRoZSBzZXJ2aWNlIHRvIHF1ZXJ5LlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIGluamVjdG9yIGhhcyBnaXZlbiBzZXJ2aWNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgbWV0aG9kXHJcbiAqIEBuYW1lIEFVVE8uJGluamVjdG9yI2luc3RhbnRpYXRlXHJcbiAqIEBtZXRob2RPZiBBVVRPLiRpbmplY3RvclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEpTIHR5cGUuIFRoZSBtZXRob2QgdGFrZXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpbnZva2VzIHRoZSBuZXcgb3BlcmF0b3IgYW5kIHN1cHBsaWVzXHJcbiAqIGFsbCBvZiB0aGUgYXJndW1lbnRzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBhcyBzcGVjaWZpZWQgYnkgdGhlIGNvbnN0cnVjdG9yIGFubm90YXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFR5cGUgQW5ub3RhdGVkIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gKiBAcGFyYW0ge09iamVjdD19IGxvY2FscyBPcHRpb25hbCBvYmplY3QuIElmIHByZXNldCB0aGVuIGFueSBhcmd1bWVudCBuYW1lcyBhcmUgcmVhZCBmcm9tIHRoaXMgb2JqZWN0IGZpcnN0LCBiZWZvcmVcclxuICogICB0aGUgYCRpbmplY3RvcmAgaXMgY29uc3VsdGVkLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXcgaW5zdGFuY2Ugb2YgYFR5cGVgLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgbWV0aG9kXHJcbiAqIEBuYW1lIEFVVE8uJGluamVjdG9yI2Fubm90YXRlXHJcbiAqIEBtZXRob2RPZiBBVVRPLiRpbmplY3RvclxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogUmV0dXJucyBhbiBhcnJheSBvZiBzZXJ2aWNlIG5hbWVzIHdoaWNoIHRoZSBmdW5jdGlvbiBpcyByZXF1ZXN0aW5nIGZvciBpbmplY3Rpb24uIFRoaXMgQVBJIGlzIHVzZWQgYnkgdGhlIGluamVjdG9yXHJcbiAqIHRvIGRldGVybWluZSB3aGljaCBzZXJ2aWNlcyBuZWVkIHRvIGJlIGluamVjdGVkIGludG8gdGhlIGZ1bmN0aW9uIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGludm9rZWQuIFRoZXJlIGFyZSB0aHJlZVxyXG4gKiB3YXlzIGluIHdoaWNoIHRoZSBmdW5jdGlvbiBjYW4gYmUgYW5ub3RhdGVkIHdpdGggdGhlIG5lZWRlZCBkZXBlbmRlbmNpZXMuXHJcbiAqXHJcbiAqICMgQXJndW1lbnQgbmFtZXNcclxuICpcclxuICogVGhlIHNpbXBsZXN0IGZvcm0gaXMgdG8gZXh0cmFjdCB0aGUgZGVwZW5kZW5jaWVzIGZyb20gdGhlIGFyZ3VtZW50cyBvZiB0aGUgZnVuY3Rpb24uIFRoaXMgaXMgZG9uZSBieSBjb252ZXJ0aW5nXHJcbiAqIHRoZSBmdW5jdGlvbiBpbnRvIGEgc3RyaW5nIHVzaW5nIGB0b1N0cmluZygpYCBtZXRob2QgYW5kIGV4dHJhY3RpbmcgdGhlIGFyZ3VtZW50IG5hbWVzLlxyXG4gKiA8cHJlPlxyXG4gKiAgIC8vIEdpdmVuXHJcbiAqICAgZnVuY3Rpb24gTXlDb250cm9sbGVyKCRzY29wZSwgJHJvdXRlKSB7XHJcbiAqICAgICAvLyAuLi5cclxuICogICB9XHJcbiAqXHJcbiAqICAgLy8gVGhlblxyXG4gKiAgIGV4cGVjdChpbmplY3Rvci5hbm5vdGF0ZShNeUNvbnRyb2xsZXIpKS50b0VxdWFsKFsnJHNjb3BlJywgJyRyb3V0ZSddKTtcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHdvcmsgd2l0aCBjb2RlIG1pbmlmaWNhdGlvbiAvIG9iZnVzY2F0aW9uLiBGb3IgdGhpcyByZWFzb24gdGhlIGZvbGxvd2luZyBhbm5vdGF0aW9uIHN0cmF0ZWdpZXNcclxuICogYXJlIHN1cHBvcnRlZC5cclxuICpcclxuICogIyBUaGUgYCRpbmplY3RgIHByb3BlcnR5XHJcbiAqXHJcbiAqIElmIGEgZnVuY3Rpb24gaGFzIGFuIGAkaW5qZWN0YCBwcm9wZXJ0eSBhbmQgaXRzIHZhbHVlIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZW4gdGhlIHN0cmluZ3MgcmVwcmVzZW50IG5hbWVzIG9mXHJcbiAqIHNlcnZpY2VzIHRvIGJlIGluamVjdGVkIGludG8gdGhlIGZ1bmN0aW9uLlxyXG4gKiA8cHJlPlxyXG4gKiAgIC8vIEdpdmVuXHJcbiAqICAgdmFyIE15Q29udHJvbGxlciA9IGZ1bmN0aW9uKG9iZnVzY2F0ZWRTY29wZSwgb2JmdXNjYXRlZFJvdXRlKSB7XHJcbiAqICAgICAvLyAuLi5cclxuICogICB9XHJcbiAqICAgLy8gRGVmaW5lIGZ1bmN0aW9uIGRlcGVuZGVuY2llc1xyXG4gKiAgIE15Q29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJHJvdXRlJ107XHJcbiAqXHJcbiAqICAgLy8gVGhlblxyXG4gKiAgIGV4cGVjdChpbmplY3Rvci5hbm5vdGF0ZShNeUNvbnRyb2xsZXIpKS50b0VxdWFsKFsnJHNjb3BlJywgJyRyb3V0ZSddKTtcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqICMgVGhlIGFycmF5IG5vdGF0aW9uXHJcbiAqXHJcbiAqIEl0IGlzIG9mdGVuIGRlc2lyYWJsZSB0byBpbmxpbmUgSW5qZWN0ZWQgZnVuY3Rpb25zIGFuZCB0aGF0J3Mgd2hlbiBzZXR0aW5nIHRoZSBgJGluamVjdGAgcHJvcGVydHkgaXMgdmVyeVxyXG4gKiBpbmNvbnZlbmllbnQuIEluIHRoZXNlIHNpdHVhdGlvbnMgdXNpbmcgdGhlIGFycmF5IG5vdGF0aW9uIHRvIHNwZWNpZnkgdGhlIGRlcGVuZGVuY2llcyBpbiBhIHdheSB0aGF0IHN1cnZpdmVzXHJcbiAqIG1pbmlmaWNhdGlvbiBpcyBhIGJldHRlciBjaG9pY2U6XHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqICAgLy8gV2Ugd2lzaCB0byB3cml0ZSB0aGlzIChub3QgbWluaWZpY2F0aW9uIC8gb2JmdXNjYXRpb24gc2FmZSlcclxuICogICBpbmplY3Rvci5pbnZva2UoZnVuY3Rpb24oJGNvbXBpbGUsICRyb290U2NvcGUpIHtcclxuICogICAgIC8vIC4uLlxyXG4gKiAgIH0pO1xyXG4gKlxyXG4gKiAgIC8vIFdlIGFyZSBmb3JjZWQgdG8gd3JpdGUgYnJlYWsgaW5saW5pbmdcclxuICogICB2YXIgdG1wRm4gPSBmdW5jdGlvbihvYmZ1c2NhdGVkQ29tcGlsZSwgb2JmdXNjYXRlZFJvb3RTY29wZSkge1xyXG4gKiAgICAgLy8gLi4uXHJcbiAqICAgfTtcclxuICogICB0bXBGbi4kaW5qZWN0ID0gWyckY29tcGlsZScsICckcm9vdFNjb3BlJ107XHJcbiAqICAgaW5qZWN0b3IuaW52b2tlKHRtcEZuKTtcclxuICpcclxuICogICAvLyBUbyBiZXR0ZXIgc3VwcG9ydCBpbmxpbmUgZnVuY3Rpb24gdGhlIGlubGluZSBhbm5vdGF0aW9uIGlzIHN1cHBvcnRlZFxyXG4gKiAgIGluamVjdG9yLmludm9rZShbJyRjb21waWxlJywgJyRyb290U2NvcGUnLCBmdW5jdGlvbihvYmZDb21waWxlLCBvYmZSb290U2NvcGUpIHtcclxuICogICAgIC8vIC4uLlxyXG4gKiAgIH1dKTtcclxuICpcclxuICogICAvLyBUaGVyZWZvcmVcclxuICogICBleHBlY3QoaW5qZWN0b3IuYW5ub3RhdGUoXHJcbiAqICAgICAgWyckY29tcGlsZScsICckcm9vdFNjb3BlJywgZnVuY3Rpb24ob2JmdXNfJGNvbXBpbGUsIG9iZnVzXyRyb290U2NvcGUpIHt9XSlcclxuICogICAgKS50b0VxdWFsKFsnJGNvbXBpbGUnLCAnJHJvb3RTY29wZSddKTtcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb258QXJyYXkuPHN0cmluZ3xGdW5jdGlvbj59IGZuIEZ1bmN0aW9uIGZvciB3aGljaCBkZXBlbmRlbnQgc2VydmljZSBuYW1lcyBuZWVkIHRvIGJlIHJldHJpZXZlZCBhcyBkZXNjcmliZWRcclxuICogICBhYm92ZS5cclxuICpcclxuICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSBUaGUgbmFtZXMgb2YgdGhlIHNlcnZpY2VzIHdoaWNoIHRoZSBmdW5jdGlvbiByZXF1aXJlcy5cclxuICovXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBBVVRPLiRwcm92aWRlXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBVc2UgYCRwcm92aWRlYCB0byByZWdpc3RlciBuZXcgcHJvdmlkZXJzIHdpdGggdGhlIGAkaW5qZWN0b3JgLiBUaGUgcHJvdmlkZXJzIGFyZSB0aGUgZmFjdG9yaWVzIGZvciB0aGUgaW5zdGFuY2UuXHJcbiAqIFRoZSBwcm92aWRlcnMgc2hhcmUgdGhlIHNhbWUgbmFtZSBhcyB0aGUgaW5zdGFuY2UgdGhleSBjcmVhdGUgd2l0aCBgUHJvdmlkZXJgIHN1ZmZpeGVkIHRvIHRoZW0uXHJcbiAqXHJcbiAqIEEgcHJvdmlkZXIgaXMgYW4gb2JqZWN0IHdpdGggYSBgJGdldCgpYCBtZXRob2QuIFRoZSBpbmplY3RvciBjYWxscyB0aGUgYCRnZXRgIG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2ZcclxuICogYSBzZXJ2aWNlLiBUaGUgUHJvdmlkZXIgY2FuIGhhdmUgYWRkaXRpb25hbCBtZXRob2RzIHdoaWNoIHdvdWxkIGFsbG93IGZvciBjb25maWd1cmF0aW9uIG9mIHRoZSBwcm92aWRlci5cclxuICpcclxuICogPHByZT5cclxuICogICBmdW5jdGlvbiBHcmVldFByb3ZpZGVyKCkge1xyXG4gKiAgICAgdmFyIHNhbHV0YXRpb24gPSAnSGVsbG8nO1xyXG4gKlxyXG4gKiAgICAgdGhpcy5zYWx1dGF0aW9uID0gZnVuY3Rpb24odGV4dCkge1xyXG4gKiAgICAgICBzYWx1dGF0aW9uID0gdGV4dDtcclxuICogICAgIH07XHJcbiAqXHJcbiAqICAgICB0aGlzLiRnZXQgPSBmdW5jdGlvbigpIHtcclxuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAqICAgICAgICAgcmV0dXJuIHNhbHV0YXRpb24gKyAnICcgKyBuYW1lICsgJyEnO1xyXG4gKiAgICAgICB9O1xyXG4gKiAgICAgfTtcclxuICogICB9XHJcbiAqXHJcbiAqICAgZGVzY3JpYmUoJ0dyZWV0ZXInLCBmdW5jdGlvbigpe1xyXG4gKlxyXG4gKiAgICAgYmVmb3JlRWFjaChtb2R1bGUoZnVuY3Rpb24oJHByb3ZpZGUpIHtcclxuICogICAgICAgJHByb3ZpZGUucHJvdmlkZXIoJ2dyZWV0JywgR3JlZXRQcm92aWRlcik7XHJcbiAqICAgICB9KSk7XHJcbiAqXHJcbiAqICAgICBpdCgnc2hvdWxkIGdyZWV0JywgaW5qZWN0KGZ1bmN0aW9uKGdyZWV0KSB7XHJcbiAqICAgICAgIGV4cGVjdChncmVldCgnYW5ndWxhcicpKS50b0VxdWFsKCdIZWxsbyBhbmd1bGFyIScpO1xyXG4gKiAgICAgfSkpO1xyXG4gKlxyXG4gKiAgICAgaXQoJ3Nob3VsZCBhbGxvdyBjb25maWd1cmF0aW9uIG9mIHNhbHV0YXRpb24nLCBmdW5jdGlvbigpIHtcclxuICogICAgICAgbW9kdWxlKGZ1bmN0aW9uKGdyZWV0UHJvdmlkZXIpIHtcclxuICogICAgICAgICBncmVldFByb3ZpZGVyLnNhbHV0YXRpb24oJ0Fob2onKTtcclxuICogICAgICAgfSk7XHJcbiAqICAgICAgIGluamVjdChmdW5jdGlvbihncmVldCkge1xyXG4gKiAgICAgICAgIGV4cGVjdChncmVldCgnYW5ndWxhcicpKS50b0VxdWFsKCdBaG9qIGFuZ3VsYXIhJyk7XHJcbiAqICAgICAgIH0pO1xyXG4gKiAgICAgfSk7XHJcbiAqIDwvcHJlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgbWV0aG9kXHJcbiAqIEBuYW1lIEFVVE8uJHByb3ZpZGUjcHJvdmlkZXJcclxuICogQG1ldGhvZE9mIEFVVE8uJHByb3ZpZGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFJlZ2lzdGVyIGEgcHJvdmlkZXIgZm9yIGEgc2VydmljZS4gVGhlIHByb3ZpZGVycyBjYW4gYmUgcmV0cmlldmVkIGFuZCBjYW4gaGF2ZSBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gbWV0aG9kcy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGluc3RhbmNlLiBOT1RFOiB0aGUgcHJvdmlkZXIgd2lsbCBiZSBhdmFpbGFibGUgdW5kZXIgYG5hbWUgKyAnUHJvdmlkZXInYCBrZXkuXHJcbiAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbigpKX0gcHJvdmlkZXIgSWYgdGhlIHByb3ZpZGVyIGlzOlxyXG4gKlxyXG4gKiAgIC0gYE9iamVjdGA6IHRoZW4gaXQgc2hvdWxkIGhhdmUgYSBgJGdldGAgbWV0aG9kLiBUaGUgYCRnZXRgIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgdXNpbmdcclxuICogICAgICAgICAgICAgICB7QGxpbmsgQVVUTy4kaW5qZWN0b3IjaW52b2tlICRpbmplY3Rvci5pbnZva2UoKX0gd2hlbiBhbiBpbnN0YW5jZSBuZWVkcyB0byBiZSBjcmVhdGVkLlxyXG4gKiAgIC0gYENvbnN0cnVjdG9yYDogYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHByb3ZpZGVyIHdpbGwgYmUgY3JlYXRlZCB1c2luZ1xyXG4gKiAgICAgICAgICAgICAgIHtAbGluayBBVVRPLiRpbmplY3RvciNpbnN0YW50aWF0ZSAkaW5qZWN0b3IuaW5zdGFudGlhdGUoKX0sIHRoZW4gdHJlYXRlZCBhcyBgb2JqZWN0YC5cclxuICpcclxuICogQHJldHVybnMge09iamVjdH0gcmVnaXN0ZXJlZCBwcm92aWRlciBpbnN0YW5jZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgbWV0aG9kXHJcbiAqIEBuYW1lIEFVVE8uJHByb3ZpZGUjZmFjdG9yeVxyXG4gKiBAbWV0aG9kT2YgQVVUTy4kcHJvdmlkZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogQSBzaG9ydCBoYW5kIGZvciBjb25maWd1cmluZyBzZXJ2aWNlcyBpZiBvbmx5IGAkZ2V0YCBtZXRob2QgaXMgcmVxdWlyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtmdW5jdGlvbigpfSAkZ2V0Rm4gVGhlICRnZXRGbiBmb3IgdGhlIGluc3RhbmNlIGNyZWF0aW9uLiBJbnRlcm5hbGx5IHRoaXMgaXMgYSBzaG9ydCBoYW5kIGZvclxyXG4gKiBgJHByb3ZpZGUucHJvdmlkZXIobmFtZSwgeyRnZXQ6ICRnZXRGbn0pYC5cclxuICogQHJldHVybnMge09iamVjdH0gcmVnaXN0ZXJlZCBwcm92aWRlciBpbnN0YW5jZVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIG1ldGhvZFxyXG4gKiBAbmFtZSBBVVRPLiRwcm92aWRlI3NlcnZpY2VcclxuICogQG1ldGhvZE9mIEFVVE8uJHByb3ZpZGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIEEgc2hvcnQgaGFuZCBmb3IgcmVnaXN0ZXJpbmcgc2VydmljZSBvZiBnaXZlbiBjbGFzcy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBBIGNsYXNzIChjb25zdHJ1Y3RvciBmdW5jdGlvbikgdGhhdCB3aWxsIGJlIGluc3RhbnRpYXRlZC5cclxuICogQHJldHVybnMge09iamVjdH0gcmVnaXN0ZXJlZCBwcm92aWRlciBpbnN0YW5jZVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIG1ldGhvZFxyXG4gKiBAbmFtZSBBVVRPLiRwcm92aWRlI3ZhbHVlXHJcbiAqIEBtZXRob2RPZiBBVVRPLiRwcm92aWRlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBBIHNob3J0IGhhbmQgZm9yIGNvbmZpZ3VyaW5nIHNlcnZpY2VzIGlmIHRoZSBgJGdldGAgbWV0aG9kIGlzIGEgY29uc3RhbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IHJlZ2lzdGVyZWQgcHJvdmlkZXIgaW5zdGFuY2VcclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBtZXRob2RcclxuICogQG5hbWUgQVVUTy4kcHJvdmlkZSNjb25zdGFudFxyXG4gKiBAbWV0aG9kT2YgQVVUTy4kcHJvdmlkZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogQSBjb25zdGFudCB2YWx1ZSwgYnV0IHVubGlrZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSN2YWx1ZSB2YWx1ZX0gaXQgY2FuIGJlIGluamVjdGVkXHJcbiAqIGludG8gY29uZmlndXJhdGlvbiBmdW5jdGlvbiAob3RoZXIgbW9kdWxlcykgYW5kIGl0IGlzIG5vdCBpbnRlcmNlcHRhYmxlIGJ5XHJcbiAqIHtAbGluayBBVVRPLiRwcm92aWRlI2RlY29yYXRvciBkZWNvcmF0b3J9LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29uc3RhbnQuXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGNvbnN0YW50IHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSByZWdpc3RlcmVkIGluc3RhbmNlXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgbWV0aG9kXHJcbiAqIEBuYW1lIEFVVE8uJHByb3ZpZGUjZGVjb3JhdG9yXHJcbiAqIEBtZXRob2RPZiBBVVRPLiRwcm92aWRlXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBEZWNvcmF0aW9uIG9mIHNlcnZpY2UsIGFsbG93cyB0aGUgZGVjb3JhdG9yIHRvIGludGVyY2VwdCB0aGUgc2VydmljZSBpbnN0YW5jZSBjcmVhdGlvbi4gVGhlXHJcbiAqIHJldHVybmVkIGluc3RhbmNlIG1heSBiZSB0aGUgb3JpZ2luYWwgaW5zdGFuY2UsIG9yIGEgbmV3IGluc3RhbmNlIHdoaWNoIGRlbGVnYXRlcyB0byB0aGVcclxuICogb3JpZ2luYWwgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzZXJ2aWNlIHRvIGRlY29yYXRlLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGRlY29yYXRvciBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBzZXJ2aWNlIG5lZWRzIHRvIGJlXHJcbiAqICAgIGluc3RhbnRpYXRlZC4gVGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB1c2luZyB0aGUge0BsaW5rIEFVVE8uJGluamVjdG9yI2ludm9rZVxyXG4gKiAgICBpbmplY3Rvci5pbnZva2V9IG1ldGhvZCBhbmQgaXMgdGhlcmVmb3JlIGZ1bGx5IGluamVjdGFibGUuIExvY2FsIGluamVjdGlvbiBhcmd1bWVudHM6XHJcbiAqXHJcbiAqICAgICogYCRkZWxlZ2F0ZWAgLSBUaGUgb3JpZ2luYWwgc2VydmljZSBpbnN0YW5jZSwgd2hpY2ggY2FuIGJlIG1vbmtleSBwYXRjaGVkLCBjb25maWd1cmVkLFxyXG4gKiAgICAgIGRlY29yYXRlZCBvciBkZWxlZ2F0ZWQgdG8uXHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUluamVjdG9yKG1vZHVsZXNUb0xvYWQpIHtcclxuICB2YXIgSU5TVEFOVElBVElORyA9IHt9LFxyXG4gICAgICBwcm92aWRlclN1ZmZpeCA9ICdQcm92aWRlcicsXHJcbiAgICAgIHBhdGggPSBbXSxcclxuICAgICAgbG9hZGVkTW9kdWxlcyA9IG5ldyBIYXNoTWFwKCksXHJcbiAgICAgIHByb3ZpZGVyQ2FjaGUgPSB7XHJcbiAgICAgICAgJHByb3ZpZGU6IHtcclxuICAgICAgICAgICAgcHJvdmlkZXI6IHN1cHBvcnRPYmplY3QocHJvdmlkZXIpLFxyXG4gICAgICAgICAgICBmYWN0b3J5OiBzdXBwb3J0T2JqZWN0KGZhY3RvcnkpLFxyXG4gICAgICAgICAgICBzZXJ2aWNlOiBzdXBwb3J0T2JqZWN0KHNlcnZpY2UpLFxyXG4gICAgICAgICAgICB2YWx1ZTogc3VwcG9ydE9iamVjdCh2YWx1ZSksXHJcbiAgICAgICAgICAgIGNvbnN0YW50OiBzdXBwb3J0T2JqZWN0KGNvbnN0YW50KSxcclxuICAgICAgICAgICAgZGVjb3JhdG9yOiBkZWNvcmF0b3JcclxuICAgICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgcHJvdmlkZXJJbmplY3RvciA9IChwcm92aWRlckNhY2hlLiRpbmplY3RvciA9XHJcbiAgICAgICAgICBjcmVhdGVJbnRlcm5hbEluamVjdG9yKHByb3ZpZGVyQ2FjaGUsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aHJvdyAkaW5qZWN0b3JNaW5FcnIoJ3VucHInLCBcIlVua25vd24gcHJvdmlkZXI6IHswfVwiLCBwYXRoLmpvaW4oJyA8LSAnKSk7XHJcbiAgICAgICAgICB9KSksXHJcbiAgICAgIGluc3RhbmNlQ2FjaGUgPSB7fSxcclxuICAgICAgaW5zdGFuY2VJbmplY3RvciA9IChpbnN0YW5jZUNhY2hlLiRpbmplY3RvciA9XHJcbiAgICAgICAgICBjcmVhdGVJbnRlcm5hbEluamVjdG9yKGluc3RhbmNlQ2FjaGUsIGZ1bmN0aW9uKHNlcnZpY2VuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IHByb3ZpZGVySW5qZWN0b3IuZ2V0KHNlcnZpY2VuYW1lICsgcHJvdmlkZXJTdWZmaXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VJbmplY3Rvci5pbnZva2UocHJvdmlkZXIuJGdldCwgcHJvdmlkZXIpO1xyXG4gICAgICAgICAgfSkpO1xyXG5cclxuXHJcbiAgZm9yRWFjaChsb2FkTW9kdWxlcyhtb2R1bGVzVG9Mb2FkKSwgZnVuY3Rpb24oZm4pIHsgaW5zdGFuY2VJbmplY3Rvci5pbnZva2UoZm4gfHwgbm9vcCk7IH0pO1xyXG5cclxuICByZXR1cm4gaW5zdGFuY2VJbmplY3RvcjtcclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gJHByb3ZpZGVyXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4gIGZ1bmN0aW9uIHN1cHBvcnRPYmplY3QoZGVsZWdhdGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XHJcbiAgICAgICAgZm9yRWFjaChrZXksIHJldmVyc2VQYXJhbXMoZGVsZWdhdGUpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZGVsZWdhdGUoa2V5LCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHByb3ZpZGVyKG5hbWUsIHByb3ZpZGVyXykge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24ocHJvdmlkZXJfKSB8fCBpc0FycmF5KHByb3ZpZGVyXykpIHtcclxuICAgICAgcHJvdmlkZXJfID0gcHJvdmlkZXJJbmplY3Rvci5pbnN0YW50aWF0ZShwcm92aWRlcl8pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFwcm92aWRlcl8uJGdldCkge1xyXG4gICAgICB0aHJvdyAkaW5qZWN0b3JNaW5FcnIoJ3BnZXQnLCBcIlByb3ZpZGVyICd7MH0nIG11c3QgZGVmaW5lICRnZXQgZmFjdG9yeSBtZXRob2QuXCIsIG5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3ZpZGVyQ2FjaGVbbmFtZSArIHByb3ZpZGVyU3VmZml4XSA9IHByb3ZpZGVyXztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGZhY3RvcnkobmFtZSwgZmFjdG9yeUZuKSB7IHJldHVybiBwcm92aWRlcihuYW1lLCB7ICRnZXQ6IGZhY3RvcnlGbiB9KTsgfVxyXG5cclxuICBmdW5jdGlvbiBzZXJ2aWNlKG5hbWUsIGNvbnN0cnVjdG9yKSB7XHJcbiAgICByZXR1cm4gZmFjdG9yeShuYW1lLCBbJyRpbmplY3RvcicsIGZ1bmN0aW9uKCRpbmplY3Rvcikge1xyXG4gICAgICByZXR1cm4gJGluamVjdG9yLmluc3RhbnRpYXRlKGNvbnN0cnVjdG9yKTtcclxuICAgIH1dKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHZhbHVlKG5hbWUsIHZhbHVlKSB7IHJldHVybiBmYWN0b3J5KG5hbWUsIHZhbHVlRm4odmFsdWUpKTsgfVxyXG5cclxuICBmdW5jdGlvbiBjb25zdGFudChuYW1lLCB2YWx1ZSkge1xyXG4gICAgcHJvdmlkZXJDYWNoZVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgaW5zdGFuY2VDYWNoZVtuYW1lXSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVjb3JhdG9yKHNlcnZpY2VOYW1lLCBkZWNvckZuKSB7XHJcbiAgICB2YXIgb3JpZ1Byb3ZpZGVyID0gcHJvdmlkZXJJbmplY3Rvci5nZXQoc2VydmljZU5hbWUgKyBwcm92aWRlclN1ZmZpeCksXHJcbiAgICAgICAgb3JpZyRnZXQgPSBvcmlnUHJvdmlkZXIuJGdldDtcclxuXHJcbiAgICBvcmlnUHJvdmlkZXIuJGdldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgb3JpZ0luc3RhbmNlID0gaW5zdGFuY2VJbmplY3Rvci5pbnZva2Uob3JpZyRnZXQsIG9yaWdQcm92aWRlcik7XHJcbiAgICAgIHJldHVybiBpbnN0YW5jZUluamVjdG9yLmludm9rZShkZWNvckZuLCBudWxsLCB7JGRlbGVnYXRlOiBvcmlnSW5zdGFuY2V9KTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBNb2R1bGUgTG9hZGluZ1xyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIGZ1bmN0aW9uIGxvYWRNb2R1bGVzKG1vZHVsZXNUb0xvYWQpe1xyXG4gICAgdmFyIHJ1bkJsb2NrcyA9IFtdO1xyXG4gICAgZm9yRWFjaChtb2R1bGVzVG9Mb2FkLCBmdW5jdGlvbihtb2R1bGUpIHtcclxuICAgICAgaWYgKGxvYWRlZE1vZHVsZXMuZ2V0KG1vZHVsZSkpIHJldHVybjtcclxuICAgICAgbG9hZGVkTW9kdWxlcy5wdXQobW9kdWxlLCB0cnVlKTtcclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG1vZHVsZSkpIHtcclxuICAgICAgICAgIHZhciBtb2R1bGVGbiA9IGFuZ3VsYXJNb2R1bGUobW9kdWxlKTtcclxuICAgICAgICAgIHJ1bkJsb2NrcyA9IHJ1bkJsb2Nrcy5jb25jYXQobG9hZE1vZHVsZXMobW9kdWxlRm4ucmVxdWlyZXMpKS5jb25jYXQobW9kdWxlRm4uX3J1bkJsb2Nrcyk7XHJcblxyXG4gICAgICAgICAgZm9yKHZhciBpbnZva2VRdWV1ZSA9IG1vZHVsZUZuLl9pbnZva2VRdWV1ZSwgaSA9IDAsIGlpID0gaW52b2tlUXVldWUubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaW52b2tlQXJncyA9IGludm9rZVF1ZXVlW2ldLFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBwcm92aWRlckluamVjdG9yLmdldChpbnZva2VBcmdzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIHByb3ZpZGVyW2ludm9rZUFyZ3NbMV1dLmFwcGx5KHByb3ZpZGVyLCBpbnZva2VBcmdzWzJdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24obW9kdWxlKSkge1xyXG4gICAgICAgICAgICBydW5CbG9ja3MucHVzaChwcm92aWRlckluamVjdG9yLmludm9rZShtb2R1bGUpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkobW9kdWxlKSkge1xyXG4gICAgICAgICAgICBydW5CbG9ja3MucHVzaChwcm92aWRlckluamVjdG9yLmludm9rZShtb2R1bGUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYXNzZXJ0QXJnRm4obW9kdWxlLCAnbW9kdWxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkobW9kdWxlKSkge1xyXG4gICAgICAgICAgbW9kdWxlID0gbW9kdWxlW21vZHVsZS5sZW5ndGggLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGUubWVzc2FnZSAmJiBlLnN0YWNrICYmIGUuc3RhY2suaW5kZXhPZihlLm1lc3NhZ2UpID09IC0xKSB7XHJcbiAgICAgICAgICAvLyBTYWZhcmkgJiBGRidzIHN0YWNrIHRyYWNlcyBkb24ndCBjb250YWluIGVycm9yLm1lc3NhZ2UgY29udGVudCB1bmxpa2UgdGhvc2Ugb2YgQ2hyb21lIGFuZCBJRVxyXG4gICAgICAgICAgLy8gU28gaWYgc3RhY2sgZG9lc24ndCBjb250YWluIG1lc3NhZ2UsIHdlIGNyZWF0ZSBhIG5ldyBzdHJpbmcgdGhhdCBjb250YWlucyBib3RoLlxyXG4gICAgICAgICAgLy8gU2luY2UgZXJyb3Iuc3RhY2sgaXMgcmVhZC1vbmx5IGluIFNhZmFyaSwgSSdtIG92ZXJyaWRpbmcgZSBhbmQgbm90IGUuc3RhY2sgaGVyZS5cclxuICAgICAgICAgIGUgPSBlLm1lc3NhZ2UgKyAnXFxuJyArIGUuc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93ICRpbmplY3Rvck1pbkVycignbW9kdWxlcnInLCBcIkZhaWxlZCB0byBpbnN0YW50aWF0ZSBtb2R1bGUgezB9IGR1ZSB0bzpcXG57MX1cIiwgbW9kdWxlLCBlLnN0YWNrIHx8IGUubWVzc2FnZSB8fCBlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcnVuQmxvY2tzO1xyXG4gIH1cclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgLy8gaW50ZXJuYWwgSW5qZWN0b3JcclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxJbmplY3RvcihjYWNoZSwgZmFjdG9yeSkge1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNlcnZpY2Uoc2VydmljZU5hbWUpIHtcclxuICAgICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KHNlcnZpY2VOYW1lKSkge1xyXG4gICAgICAgIGlmIChjYWNoZVtzZXJ2aWNlTmFtZV0gPT09IElOU1RBTlRJQVRJTkcpIHtcclxuICAgICAgICAgIHRocm93ICRpbmplY3Rvck1pbkVycignY2RlcCcsICdDaXJjdWxhciBkZXBlbmRlbmN5IGZvdW5kOiB7MH0nLCBwYXRoLmpvaW4oJyA8LSAnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjYWNoZVtzZXJ2aWNlTmFtZV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHBhdGgudW5zaGlmdChzZXJ2aWNlTmFtZSk7XHJcbiAgICAgICAgICBjYWNoZVtzZXJ2aWNlTmFtZV0gPSBJTlNUQU5USUFUSU5HO1xyXG4gICAgICAgICAgcmV0dXJuIGNhY2hlW3NlcnZpY2VOYW1lXSA9IGZhY3Rvcnkoc2VydmljZU5hbWUpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBwYXRoLnNoaWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW52b2tlKGZuLCBzZWxmLCBsb2NhbHMpe1xyXG4gICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgJGluamVjdCA9IGFubm90YXRlKGZuKSxcclxuICAgICAgICAgIGxlbmd0aCwgaSxcclxuICAgICAgICAgIGtleTtcclxuXHJcbiAgICAgIGZvcihpID0gMCwgbGVuZ3RoID0gJGluamVjdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGtleSA9ICRpbmplY3RbaV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICB0aHJvdyAkaW5qZWN0b3JNaW5FcnIoJ2l0a24nLCAnSW5jb3JyZWN0IGluamVjdGlvbiB0b2tlbiEgRXhwZWN0ZWQgc2VydmljZSBuYW1lIGFzIHN0cmluZywgZ290IHswfScsIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFyZ3MucHVzaChcclxuICAgICAgICAgIGxvY2FscyAmJiBsb2NhbHMuaGFzT3duUHJvcGVydHkoa2V5KVxyXG4gICAgICAgICAgPyBsb2NhbHNba2V5XVxyXG4gICAgICAgICAgOiBnZXRTZXJ2aWNlKGtleSlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghZm4uJGluamVjdCkge1xyXG4gICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB3ZSBtdXN0IGJlIGFuIGFycmF5LlxyXG4gICAgICAgIGZuID0gZm5bbGVuZ3RoXTtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogaHR0cDovL2pzcGVyZi5jb20vYXBwbHktdnMtY2FsbC12cy1pbnZva2VcclxuICAgICAgc3dpdGNoIChzZWxmID8gLTEgOiBhcmdzLmxlbmd0aCkge1xyXG4gICAgICAgIGNhc2UgIDA6IHJldHVybiBmbigpO1xyXG4gICAgICAgIGNhc2UgIDE6IHJldHVybiBmbihhcmdzWzBdKTtcclxuICAgICAgICBjYXNlICAyOiByZXR1cm4gZm4oYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICAgICAgY2FzZSAgMzogcmV0dXJuIGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xyXG4gICAgICAgIGNhc2UgIDQ6IHJldHVybiBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcclxuICAgICAgICBjYXNlICA1OiByZXR1cm4gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XHJcbiAgICAgICAgY2FzZSAgNjogcmV0dXJuIGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xyXG4gICAgICAgIGNhc2UgIDc6IHJldHVybiBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcclxuICAgICAgICBjYXNlICA4OiByZXR1cm4gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSwgYXJnc1s3XSk7XHJcbiAgICAgICAgY2FzZSAgOTogcmV0dXJuIGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0sIGFyZ3NbN10sIGFyZ3NbOF0pO1xyXG4gICAgICAgIGNhc2UgMTA6IHJldHVybiBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdLCBhcmdzWzddLCBhcmdzWzhdLCBhcmdzWzldKTtcclxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gZm4uYXBwbHkoc2VsZiwgYXJncyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnN0YW50aWF0ZShUeXBlLCBsb2NhbHMpIHtcclxuICAgICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7fSxcclxuICAgICAgICAgIGluc3RhbmNlLCByZXR1cm5lZFZhbHVlO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgVHlwZSBpcyBhbm5vdGF0ZWQgYW5kIHVzZSBqdXN0IHRoZSBnaXZlbiBmdW5jdGlvbiBhdCBuLTEgYXMgcGFyYW1ldGVyXHJcbiAgICAgIC8vIGUuZy4gc29tZU1vZHVsZS5mYWN0b3J5KCdncmVldGVyJywgWyckd2luZG93JywgZnVuY3Rpb24ocmVuYW1lZCR3aW5kb3cpIHt9XSk7XHJcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IChpc0FycmF5KFR5cGUpID8gVHlwZVtUeXBlLmxlbmd0aCAtIDFdIDogVHlwZSkucHJvdG90eXBlO1xyXG4gICAgICBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xyXG4gICAgICByZXR1cm5lZFZhbHVlID0gaW52b2tlKFR5cGUsIGluc3RhbmNlLCBsb2NhbHMpO1xyXG5cclxuICAgICAgcmV0dXJuIGlzT2JqZWN0KHJldHVybmVkVmFsdWUpID8gcmV0dXJuZWRWYWx1ZSA6IGluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGludm9rZTogaW52b2tlLFxyXG4gICAgICBpbnN0YW50aWF0ZTogaW5zdGFudGlhdGUsXHJcbiAgICAgIGdldDogZ2V0U2VydmljZSxcclxuICAgICAgYW5ub3RhdGU6IGFubm90YXRlLFxyXG4gICAgICBoYXM6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXJDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lICsgcHJvdmlkZXJTdWZmaXgpIHx8IGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBuZy4kYW5jaG9yU2Nyb2xsXHJcbiAqIEByZXF1aXJlcyAkd2luZG93XHJcbiAqIEByZXF1aXJlcyAkbG9jYXRpb25cclxuICogQHJlcXVpcmVzICRyb290U2NvcGVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFdoZW4gY2FsbGVkLCBpdCBjaGVja3MgY3VycmVudCB2YWx1ZSBvZiBgJGxvY2F0aW9uLmhhc2goKWAgYW5kIHNjcm9sbCB0byByZWxhdGVkIGVsZW1lbnQsXHJcbiAqIGFjY29yZGluZyB0byBydWxlcyBzcGVjaWZpZWQgaW5cclxuICoge0BsaW5rIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCN0aGUtaW5kaWNhdGVkLXBhcnQtb2YtdGhlLWRvY3VtZW50IEh0bWw1IHNwZWN9LlxyXG4gKlxyXG4gKiBJdCBhbHNvIHdhdGNoZXMgdGhlIGAkbG9jYXRpb24uaGFzaCgpYCBhbmQgc2Nyb2xsIHdoZW5ldmVyIGl0IGNoYW5nZXMgdG8gbWF0Y2ggYW55IGFuY2hvci5cclxuICogVGhpcyBjYW4gYmUgZGlzYWJsZWQgYnkgY2FsbGluZyBgJGFuY2hvclNjcm9sbFByb3ZpZGVyLmRpc2FibGVBdXRvU2Nyb2xsaW5nKClgLlxyXG4gKi9cclxuZnVuY3Rpb24gJEFuY2hvclNjcm9sbFByb3ZpZGVyKCkge1xyXG5cclxuICB2YXIgYXV0b1Njcm9sbGluZ0VuYWJsZWQgPSB0cnVlO1xyXG5cclxuICB0aGlzLmRpc2FibGVBdXRvU2Nyb2xsaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICBhdXRvU2Nyb2xsaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsICckbG9jYXRpb24nLCAnJHJvb3RTY29wZScsIGZ1bmN0aW9uKCR3aW5kb3csICRsb2NhdGlvbiwgJHJvb3RTY29wZSkge1xyXG4gICAgdmFyIGRvY3VtZW50ID0gJHdpbmRvdy5kb2N1bWVudDtcclxuXHJcbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGZpcnN0IGFuY2hvciBmcm9tIGEgTm9kZUxpc3RcclxuICAgIC8vIGNhbid0IHVzZSBmaWx0ZXIuZmlsdGVyLCBhcyBpdCBhY2NlcHRzIG9ubHkgaW5zdGFuY2VzIG9mIEFycmF5XHJcbiAgICAvLyBhbmQgSUUgY2FuJ3QgY29udmVydCBOb2RlTGlzdCB0byBhbiBhcnJheSB1c2luZyBbXS5zbGljZVxyXG4gICAgLy8gVE9ETyh2b2p0YSk6IHVzZSBmaWx0ZXIgaWYgd2UgY2hhbmdlIGl0IHRvIGFjY2VwdCBsaXN0cyBhcyB3ZWxsXHJcbiAgICBmdW5jdGlvbiBnZXRGaXJzdEFuY2hvcihsaXN0KSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSBudWxsO1xyXG4gICAgICBmb3JFYWNoKGxpc3QsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoIXJlc3VsdCAmJiBsb3dlcmNhc2UoZWxlbWVudC5ub2RlTmFtZSkgPT09ICdhJykgcmVzdWx0ID0gZWxlbWVudDtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2Nyb2xsKCkge1xyXG4gICAgICB2YXIgaGFzaCA9ICRsb2NhdGlvbi5oYXNoKCksIGVsbTtcclxuXHJcbiAgICAgIC8vIGVtcHR5IGhhc2gsIHNjcm9sbCB0byB0aGUgdG9wIG9mIHRoZSBwYWdlXHJcbiAgICAgIGlmICghaGFzaCkgJHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcclxuXHJcbiAgICAgIC8vIGVsZW1lbnQgd2l0aCBnaXZlbiBpZFxyXG4gICAgICBlbHNlIGlmICgoZWxtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCkpKSBlbG0uc2Nyb2xsSW50b1ZpZXcoKTtcclxuXHJcbiAgICAgIC8vIGZpcnN0IGFuY2hvciB3aXRoIGdpdmVuIG5hbWUgOi1EXHJcbiAgICAgIGVsc2UgaWYgKChlbG0gPSBnZXRGaXJzdEFuY2hvcihkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoKSkpKSBlbG0uc2Nyb2xsSW50b1ZpZXcoKTtcclxuXHJcbiAgICAgIC8vIG5vIGVsZW1lbnQgYW5kIGhhc2ggPT0gJ3RvcCcsIHNjcm9sbCB0byB0aGUgdG9wIG9mIHRoZSBwYWdlXHJcbiAgICAgIGVsc2UgaWYgKGhhc2ggPT09ICd0b3AnKSAkd2luZG93LnNjcm9sbFRvKDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRvZXMgbm90IHNjcm9sbCB3aGVuIHVzZXIgY2xpY2tzIG9uIGFuY2hvciBsaW5rIHRoYXQgaXMgY3VycmVudGx5IG9uXHJcbiAgICAvLyAobm8gdXJsIGNoYW5nZSwgbm8gJGxvY2F0aW9uLmhhc2goKSBjaGFuZ2UpLCBicm93c2VyIG5hdGl2ZSBkb2VzIHNjcm9sbFxyXG4gICAgaWYgKGF1dG9TY3JvbGxpbmdFbmFibGVkKSB7XHJcbiAgICAgICRyb290U2NvcGUuJHdhdGNoKGZ1bmN0aW9uIGF1dG9TY3JvbGxXYXRjaCgpIHtyZXR1cm4gJGxvY2F0aW9uLmhhc2goKTt9LFxyXG4gICAgICAgIGZ1bmN0aW9uIGF1dG9TY3JvbGxXYXRjaEFjdGlvbigpIHtcclxuICAgICAgICAgICRyb290U2NvcGUuJGV2YWxBc3luYyhzY3JvbGwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzY3JvbGw7XHJcbiAgfV07XHJcbn1cclxuXHJcbnZhciAkYW5pbWF0ZU1pbkVyciA9IG1pbkVycignJGFuaW1hdGUnKTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRhbmltYXRlUHJvdmlkZXJcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgJGFuaW1hdGUgdGhhdCBkb2Vzbid0IHBlcmZvcm0gYW55IGFuaW1hdGlvbnMsIGluc3RlYWQganVzdCBzeW5jaHJvbm91c2x5IHBlcmZvcm1zIERPTVxyXG4gKiB1cGRhdGVzIGFuZCBjYWxscyBkb25lKCkgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBJbiBvcmRlciB0byBlbmFibGUgYW5pbWF0aW9ucyB0aGUgbmdBbmltYXRlIG1vZHVsZSBoYXMgdG8gYmUgbG9hZGVkLlxyXG4gKlxyXG4gKiBUbyBzZWUgdGhlIGZ1bmN0aW9uYWwgaW1wbGVtZW50YXRpb24gY2hlY2sgb3V0IHNyYy9uZ0FuaW1hdGUvYW5pbWF0ZS5qc1xyXG4gKi9cclxudmFyICRBbmltYXRlUHJvdmlkZXIgPSBbJyRwcm92aWRlJywgZnVuY3Rpb24oJHByb3ZpZGUpIHtcclxuXHJcbiAgdGhpcy4kJHNlbGVjdG9ycyA9IHt9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgbmcuJGFuaW1hdGVQcm92aWRlciNyZWdpc3RlclxyXG4gICAqIEBtZXRob2RPZiBuZy4kYW5pbWF0ZVByb3ZpZGVyXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBSZWdpc3RlcnMgYSBuZXcgaW5qZWN0YWJsZSBhbmltYXRpb24gZmFjdG9yeSBmdW5jdGlvbi4gVGhlIGZhY3RvcnkgZnVuY3Rpb24gcHJvZHVjZXMgdGhlIGFuaW1hdGlvbiBvYmplY3Qgd2hpY2hcclxuICAgKiBjb250YWlucyBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbmltYXRlZC5cclxuICAgKlxyXG4gICAqICAgKiBgZXZlbnRGbmA6IGBmdW5jdGlvbihFbGVtZW50LCBkb25lRnVuY3Rpb24pYCBUaGUgZWxlbWVudCB0byBhbmltYXRlLCB0aGUgYGRvbmVGdW5jdGlvbmAgbXVzdCBiZSBjYWxsZWQgb25jZSB0aGVcclxuICAgKiAgIGVsZW1lbnQgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLiBJZiBhIGZ1bmN0aW9uIGlzIHJldHVybmVkIHRoZW4gdGhlIGFuaW1hdGlvbiBzZXJ2aWNlIHdpbGwgdXNlIHRoaXMgZnVuY3Rpb24gdG9cclxuICAgKiAgIGNhbmNlbCB0aGUgYW5pbWF0aW9uIHdoZW5ldmVyIGEgY2FuY2VsIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgKlxyXG4gICAqXHJcbiAgICo8cHJlPlxyXG4gICAqICAgcmV0dXJuIHtcclxuICAgICAqICAgICBldmVudEZuIDogZnVuY3Rpb24oZWxlbWVudCwgZG9uZSkge1xyXG4gICAgICogICAgICAgLy9jb2RlIHRvIHJ1biB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiAgICAgICAvL29uY2UgY29tcGxldGUsIHRoZW4gcnVuIGRvbmUoKVxyXG4gICAgICogICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNhbmNlbGxhdGlvbkZ1bmN0aW9uKCkge1xyXG4gICAgICogICAgICAgICAvL2NvZGUgdG8gY2FuY2VsIHRoZSBhbmltYXRpb25cclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgKjwvcHJlPlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmYWN0b3J5IFRoZSBmYWN0b3J5IGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB0byByZXR1cm4gdGhlIGFuaW1hdGlvbiBvYmplY3QuXHJcbiAgICovXHJcbiAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIGZhY3RvcnkpIHtcclxuICAgIHZhciBrZXkgPSBuYW1lICsgJy1hbmltYXRpb24nO1xyXG4gICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgIT0gJy4nKSB0aHJvdyAkYW5pbWF0ZU1pbkVycignbm90Y3NlbCcsXHJcbiAgICAgICAgXCJFeHBlY3RpbmcgY2xhc3Mgc2VsZWN0b3Igc3RhcnRpbmcgd2l0aCAnLicgZ290ICd7MH0nLlwiLCBuYW1lKTtcclxuICAgIHRoaXMuJCRzZWxlY3RvcnNbbmFtZS5zdWJzdHIoMSldID0ga2V5O1xyXG4gICAgJHByb3ZpZGUuZmFjdG9yeShrZXksIGZhY3RvcnkpO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuJGdldCA9IFsnJHRpbWVvdXQnLCBmdW5jdGlvbigkdGltZW91dCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG9iamVjdFxyXG4gICAgICogQG5hbWUgbmcuJGFuaW1hdGVcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFRoZSAkYW5pbWF0ZSBzZXJ2aWNlIHByb3ZpZGVzIHJ1ZGltZW50YXJ5IERPTSBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIHRvIGluc2VydCwgcmVtb3ZlLCBtb3ZlIGVsZW1lbnRzIHdpdGhpblxyXG4gICAgICogdGhlIERPTSBhcyB3ZWxsIGFzIGFkZGluZyBhbmQgcmVtb3ZpbmcgY2xhc3Nlcy4gVGhpcyBzZXJ2aWNlIGlzIHRoZSBjb3JlIHNlcnZpY2UgdXNlZCBieSB0aGUgbmdBbmltYXRlICRhbmltYXRvclxyXG4gICAgICogc2VydmljZSB3aGljaCBwcm92aWRlcyBoaWdoLWxldmVsIGFuaW1hdGlvbiBob29rcyBmb3IgQ1NTIGFuZCBKYXZhU2NyaXB0LiBcclxuICAgICAqXHJcbiAgICAgKiAkYW5pbWF0ZSBpcyBhdmFpbGFibGUgaW4gdGhlIEFuZ3VsYXJKUyBjb3JlLCBob3dldmVyLCB0aGUgbmdBbmltYXRlIG1vZHVsZSBtdXN0IGJlIGluY2x1ZGVkIHRvIGVuYWJsZSBmdWxsIG91dFxyXG4gICAgICogYW5pbWF0aW9uIHN1cHBvcnQuIE90aGVyd2lzZSwgJGFuaW1hdGUgd2lsbCBvbmx5IHBlcmZvcm0gc2ltcGxlIERPTSBtYW5pcHVsYXRpb24gb3BlcmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBUbyBsZWFybiBtb3JlIGFib3V0IGVuYWJsaW5nIGFuaW1hdGlvbiBzdXBwb3J0LCBjbGljayBoZXJlIHRvIHZpc2l0IHRoZSB7QGxpbmsgbmdBbmltYXRlIG5nQW5pbWF0ZSBtb2R1bGUgcGFnZX1cclxuICAgICAqIGFzIHdlbGwgYXMgdGhlIHtAbGluayBuZ0FuaW1hdGUuJGFuaW1hdGUgbmdBbmltYXRlICRhbmltYXRlIHNlcnZpY2UgcGFnZX0uXHJcbiAgICAgKi9cclxuICAgIHJldHVybiB7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRhbmltYXRlI2VudGVyXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kYW5pbWF0ZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIEluc2VydHMgdGhlIGVsZW1lbnQgaW50byB0aGUgRE9NIGVpdGhlciBhZnRlciB0aGUgYGFmdGVyYCBlbGVtZW50IG9yIHdpdGhpbiB0aGUgYHBhcmVudGAgZWxlbWVudC4gT25jZSBjb21wbGV0ZSxcclxuICAgICAgICogdGhlIGRvbmUoKSBjYWxsYmFjayB3aWxsIGJlIGZpcmVkIChpZiBwcm92aWRlZCkuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHdoaWNoIHdpbGwgYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NXHJcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBwYXJlbnQgdGhlIHBhcmVudCBlbGVtZW50IHdoaWNoIHdpbGwgYXBwZW5kIHRoZSBlbGVtZW50IGFzIGEgY2hpbGQgKGlmIHRoZSBhZnRlciBlbGVtZW50IGlzIG5vdCBwcmVzZW50KVxyXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gYWZ0ZXIgdGhlIHNpYmxpbmcgZWxlbWVudCB3aGljaCB3aWxsIGFwcGVuZCB0aGUgZWxlbWVudCBhZnRlciBpdHNlbGZcclxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbj19IGRvbmUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgZWxlbWVudCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBET01cclxuICAgICAgICovXHJcbiAgICAgIGVudGVyIDogZnVuY3Rpb24oZWxlbWVudCwgcGFyZW50LCBhZnRlciwgZG9uZSkge1xyXG4gICAgICAgIHZhciBhZnRlck5vZGUgPSBhZnRlciAmJiBhZnRlclthZnRlci5sZW5ndGggLSAxXTtcclxuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHBhcmVudCAmJiBwYXJlbnRbMF0gfHwgYWZ0ZXJOb2RlICYmIGFmdGVyTm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICAgIC8vIElFIGRvZXMgbm90IGxpa2UgdW5kZWZpbmVkIHNvIHdlIGhhdmUgdG8gcGFzcyBudWxsLlxyXG4gICAgICAgIHZhciBhZnRlck5leHRTaWJsaW5nID0gKGFmdGVyTm9kZSAmJiBhZnRlck5vZGUubmV4dFNpYmxpbmcpIHx8IG51bGw7XHJcbiAgICAgICAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBhZnRlck5leHRTaWJsaW5nKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBkb25lICYmICR0aW1lb3V0KGRvbmUsIDAsIGZhbHNlKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJGFuaW1hdGUjbGVhdmVcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRhbmltYXRlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00uIE9uY2UgY29tcGxldGUsIHRoZSBkb25lKCkgY2FsbGJhY2sgd2lsbCBiZSBmaXJlZCAoaWYgcHJvdmlkZWQpLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB3aGljaCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXHJcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBkb25lIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBET01cclxuICAgICAgICovXHJcbiAgICAgIGxlYXZlIDogZnVuY3Rpb24oZWxlbWVudCwgZG9uZSkge1xyXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgZG9uZSAmJiAkdGltZW91dChkb25lLCAwLCBmYWxzZSk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRhbmltYXRlI21vdmVcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRhbmltYXRlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogTW92ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBlbGVtZW50IHdpdGhpbiB0aGUgRE9NIHRvIGJlIHBsYWNlZCBlaXRoZXIgYWZ0ZXIgdGhlIGBhZnRlcmAgZWxlbWVudCBvciBpbnNpZGUgb2YgdGhlIGBwYXJlbnRgIGVsZW1lbnQuXHJcbiAgICAgICAqIE9uY2UgY29tcGxldGUsIHRoZSBkb25lKCkgY2FsbGJhY2sgd2lsbCBiZSBmaXJlZCAoaWYgcHJvdmlkZWQpLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB3aGljaCB3aWxsIGJlIG1vdmVkIGFyb3VuZCB3aXRoaW4gdGhlIERPTVxyXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gcGFyZW50IHRoZSBwYXJlbnQgZWxlbWVudCB3aGVyZSB0aGUgZWxlbWVudCB3aWxsIGJlIGluc2VydGVkIGludG8gKGlmIHRoZSBhZnRlciBlbGVtZW50IGlzIG5vdCBwcmVzZW50KVxyXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gYWZ0ZXIgdGhlIHNpYmxpbmcgZWxlbWVudCB3aGVyZSB0aGUgZWxlbWVudCB3aWxsIGJlIHBvc2l0aW9uZWQgbmV4dCB0b1xyXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gZG9uZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKGlmIHByb3ZpZGVkKSB0aGF0IHdpbGwgYmUgZmlyZWQgYWZ0ZXIgdGhlIGVsZW1lbnQgaGFzIGJlZW4gbW92ZWQgdG8gaXQncyBuZXcgcG9zaXRpb25cclxuICAgICAgICovXHJcbiAgICAgIG1vdmUgOiBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnQsIGFmdGVyLCBkb25lKSB7XHJcbiAgICAgICAgLy8gRG8gbm90IHJlbW92ZSBlbGVtZW50IGJlZm9yZSBpbnNlcnQuIFJlbW92aW5nIHdpbGwgY2F1c2UgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlXHJcbiAgICAgICAgLy8gZWxlbWVudCB0byBiZSBkcm9wcGVkLiBJbnNlcnQgd2lsbCBpbXBsaWNpdGx5IGRvIHRoZSByZW1vdmUuXHJcbiAgICAgICAgdGhpcy5lbnRlcihlbGVtZW50LCBwYXJlbnQsIGFmdGVyLCBkb25lKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJGFuaW1hdGUjYWRkQ2xhc3NcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRhbmltYXRlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogQWRkcyB0aGUgcHJvdmlkZWQgY2xhc3NOYW1lIENTUyBjbGFzcyB2YWx1ZSB0byB0aGUgcHJvdmlkZWQgZWxlbWVudC4gT25jZSBjb21wbGV0ZSwgdGhlIGRvbmUoKSBjYWxsYmFjayB3aWxsIGJlIGZpcmVkIChpZiBwcm92aWRlZCkuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHdoaWNoIHdpbGwgaGF2ZSB0aGUgY2xhc3NOYW1lIHZhbHVlIGFkZGVkIHRvIGl0XHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyB3aGljaCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbGVtZW50XHJcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBkb25lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAoaWYgcHJvdmlkZWQpIHRoYXQgd2lsbCBiZSBmaXJlZCBhZnRlciB0aGUgY2xhc3NOYW1lIHZhbHVlIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBlbGVtZW50XHJcbiAgICAgICAqL1xyXG4gICAgICBhZGRDbGFzcyA6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSwgZG9uZSkge1xyXG4gICAgICAgIGNsYXNzTmFtZSA9IGlzU3RyaW5nKGNsYXNzTmFtZSkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lIDpcclxuICAgICAgICAgICAgICAgICAgICAgIGlzQXJyYXkoY2xhc3NOYW1lKSA/IGNsYXNzTmFtZS5qb2luKCcgJykgOiAnJztcclxuICAgICAgICBlbGVtZW50LmFkZENsYXNzKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgZG9uZSAmJiAkdGltZW91dChkb25lLCAwLCBmYWxzZSk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRhbmltYXRlI3JlbW92ZUNsYXNzXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kYW5pbWF0ZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFJlbW92ZXMgdGhlIHByb3ZpZGVkIGNsYXNzTmFtZSBDU1MgY2xhc3MgdmFsdWUgZnJvbSB0aGUgcHJvdmlkZWQgZWxlbWVudC4gT25jZSBjb21wbGV0ZSwgdGhlIGRvbmUoKSBjYWxsYmFjayB3aWxsIGJlIGZpcmVkIChpZiBwcm92aWRlZCkuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHdoaWNoIHdpbGwgaGF2ZSB0aGUgY2xhc3NOYW1lIHZhbHVlIHJlbW92ZWQgZnJvbSBpdFxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3Mgd2hpY2ggd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnRcclxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbj19IGRvbmUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIChpZiBwcm92aWRlZCkgdGhhdCB3aWxsIGJlIGZpcmVkIGFmdGVyIHRoZSBjbGFzc05hbWUgdmFsdWUgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50XHJcbiAgICAgICAqL1xyXG4gICAgICByZW1vdmVDbGFzcyA6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSwgZG9uZSkge1xyXG4gICAgICAgIGNsYXNzTmFtZSA9IGlzU3RyaW5nKGNsYXNzTmFtZSkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lIDpcclxuICAgICAgICAgICAgICAgICAgICAgIGlzQXJyYXkoY2xhc3NOYW1lKSA/IGNsYXNzTmFtZS5qb2luKCcgJykgOiAnJztcclxuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgZG9uZSAmJiAkdGltZW91dChkb25lLCAwLCBmYWxzZSk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBlbmFibGVkIDogbm9vcFxyXG4gICAgfTtcclxuICB9XTtcclxufV07XHJcblxyXG4vKipcclxuICogISBUaGlzIGlzIGEgcHJpdmF0ZSB1bmRvY3VtZW50ZWQgc2VydmljZSAhXHJcbiAqXHJcbiAqIEBuYW1lIG5nLiRicm93c2VyXHJcbiAqIEByZXF1aXJlcyAkbG9nXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGlzIG9iamVjdCBoYXMgdHdvIGdvYWxzOlxyXG4gKlxyXG4gKiAtIGhpZGUgYWxsIHRoZSBnbG9iYWwgc3RhdGUgaW4gdGhlIGJyb3dzZXIgY2F1c2VkIGJ5IHRoZSB3aW5kb3cgb2JqZWN0XHJcbiAqIC0gYWJzdHJhY3QgYXdheSBhbGwgdGhlIGJyb3dzZXIgc3BlY2lmaWMgZmVhdHVyZXMgYW5kIGluY29uc2lzdGVuY2llc1xyXG4gKlxyXG4gKiBGb3IgdGVzdHMgd2UgcHJvdmlkZSB7QGxpbmsgbmdNb2NrLiRicm93c2VyIG1vY2sgaW1wbGVtZW50YXRpb259IG9mIHRoZSBgJGJyb3dzZXJgXHJcbiAqIHNlcnZpY2UsIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBjb252ZW5pZW50IHRlc3Rpbmcgb2YgdGhlIGFwcGxpY2F0aW9uIHdpdGhvdXQgdGhlIGludGVyYWN0aW9uIHdpdGhcclxuICogdGhlIHJlYWwgYnJvd3NlciBhcGlzLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB3aW5kb3cgVGhlIGdsb2JhbCB3aW5kb3cgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZG9jdW1lbnQgalF1ZXJ5IHdyYXBwZWQgZG9jdW1lbnQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gWEhSIFhNTEh0dHBSZXF1ZXN0IGNvbnN0cnVjdG9yLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gJGxvZyBjb25zb2xlLmxvZyBvciBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBpbnRlcmZhY2UuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSAkc25pZmZlciAkc25pZmZlciBzZXJ2aWNlXHJcbiAqL1xyXG5mdW5jdGlvbiBCcm93c2VyKHdpbmRvdywgZG9jdW1lbnQsICRsb2csICRzbmlmZmVyKSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICByYXdEb2N1bWVudCA9IGRvY3VtZW50WzBdLFxyXG4gICAgICBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcclxuICAgICAgaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5LFxyXG4gICAgICBzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQsXHJcbiAgICAgIGNsZWFyVGltZW91dCA9IHdpbmRvdy5jbGVhclRpbWVvdXQsXHJcbiAgICAgIHBlbmRpbmdEZWZlcklkcyA9IHt9O1xyXG5cclxuICBzZWxmLmlzTW9jayA9IGZhbHNlO1xyXG5cclxuICB2YXIgb3V0c3RhbmRpbmdSZXF1ZXN0Q291bnQgPSAwO1xyXG4gIHZhciBvdXRzdGFuZGluZ1JlcXVlc3RDYWxsYmFja3MgPSBbXTtcclxuXHJcbiAgLy8gVE9ETyh2b2p0YSk6IHJlbW92ZSB0aGlzIHRlbXBvcmFyeSBhcGlcclxuICBzZWxmLiQkY29tcGxldGVPdXRzdGFuZGluZ1JlcXVlc3QgPSBjb21wbGV0ZU91dHN0YW5kaW5nUmVxdWVzdDtcclxuICBzZWxmLiQkaW5jT3V0c3RhbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbigpIHsgb3V0c3RhbmRpbmdSZXF1ZXN0Q291bnQrKzsgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZXMgdGhlIGBmbmAgZnVuY3Rpb24oc3VwcG9ydHMgY3VycnlpbmcpIGFuZCBkZWNyZW1lbnRzIHRoZSBgb3V0c3RhbmRpbmdSZXF1ZXN0Q2FsbGJhY2tzYFxyXG4gICAqIGNvdW50ZXIuIElmIHRoZSBjb3VudGVyIHJlYWNoZXMgMCwgYWxsIHRoZSBgb3V0c3RhbmRpbmdSZXF1ZXN0Q2FsbGJhY2tzYCBhcmUgZXhlY3V0ZWQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY29tcGxldGVPdXRzdGFuZGluZ1JlcXVlc3QoZm4pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZuLmFwcGx5KG51bGwsIHNsaWNlQXJncyhhcmd1bWVudHMsIDEpKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIG91dHN0YW5kaW5nUmVxdWVzdENvdW50LS07XHJcbiAgICAgIGlmIChvdXRzdGFuZGluZ1JlcXVlc3RDb3VudCA9PT0gMCkge1xyXG4gICAgICAgIHdoaWxlKG91dHN0YW5kaW5nUmVxdWVzdENhbGxiYWNrcy5sZW5ndGgpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG91dHN0YW5kaW5nUmVxdWVzdENhbGxiYWNrcy5wb3AoKSgpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAkbG9nLmVycm9yKGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyB1c2VkIG9ubHkgYnkgc2NlbmFyaW8gcnVubmVyXHJcbiAgICogVE9ETyh2b2p0YSk6IHByZWZpeCB0aGlzIG1ldGhvZCB3aXRoICQkID9cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBubyBvdXRzdGFuZGluZyByZXF1ZXN0XHJcbiAgICovXHJcbiAgc2VsZi5ub3RpZnlXaGVuTm9PdXRzdGFuZGluZ1JlcXVlc3RzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgIC8vIGZvcmNlIGJyb3dzZXIgdG8gZXhlY3V0ZSBhbGwgcG9sbEZucyAtIHRoaXMgaXMgbmVlZGVkIHNvIHRoYXQgY29va2llcyBhbmQgb3RoZXIgcG9sbGVycyBmaXJlXHJcbiAgICAvLyBhdCBzb21lIGRldGVybWluaXN0aWMgdGltZSBpbiByZXNwZWN0IHRvIHRoZSB0ZXN0IHJ1bm5lcidzIGFjdGlvbnMuIExlYXZpbmcgdGhpbmdzIHVwIHRvIHRoZVxyXG4gICAgLy8gcmVndWxhciBwb2xsZXIgd291bGQgcmVzdWx0IGluIGZsYWt5IHRlc3RzLlxyXG4gICAgZm9yRWFjaChwb2xsRm5zLCBmdW5jdGlvbihwb2xsRm4peyBwb2xsRm4oKTsgfSk7XHJcblxyXG4gICAgaWYgKG91dHN0YW5kaW5nUmVxdWVzdENvdW50ID09PSAwKSB7XHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvdXRzdGFuZGluZ1JlcXVlc3RDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAvLyBQb2xsIFdhdGNoZXIgQVBJXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICB2YXIgcG9sbEZucyA9IFtdLFxyXG4gICAgICBwb2xsVGltZW91dDtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgbmcuJGJyb3dzZXIjYWRkUG9sbEZuXHJcbiAgICogQG1ldGhvZE9mIG5nLiRicm93c2VyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuIFBvbGwgZnVuY3Rpb24gdG8gYWRkXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBBZGRzIGEgZnVuY3Rpb24gdG8gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIHRoYXQgcG9sbGVyIHBlcmlvZGljYWxseSBleGVjdXRlcyxcclxuICAgKiBhbmQgc3RhcnRzIHBvbGxpbmcgaWYgbm90IHN0YXJ0ZWQgeWV0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Z1bmN0aW9uKCl9IHRoZSBhZGRlZCBmdW5jdGlvblxyXG4gICAqL1xyXG4gIHNlbGYuYWRkUG9sbEZuID0gZnVuY3Rpb24oZm4pIHtcclxuICAgIGlmIChpc1VuZGVmaW5lZChwb2xsVGltZW91dCkpIHN0YXJ0UG9sbGVyKDEwMCwgc2V0VGltZW91dCk7XHJcbiAgICBwb2xsRm5zLnB1c2goZm4pO1xyXG4gICAgcmV0dXJuIGZuO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbCBIb3cgb2Z0ZW4gc2hvdWxkIGJyb3dzZXIgY2FsbCBwb2xsIGZ1bmN0aW9ucyAobXMpXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBzZXRUaW1lb3V0IFJlZmVyZW5jZSB0byBhIHJlYWwgb3IgZmFrZSBgc2V0VGltZW91dGAgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBDb25maWd1cmVzIHRoZSBwb2xsZXIgdG8gcnVuIGluIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWxzLCB1c2luZyB0aGUgc3BlY2lmaWVkXHJcbiAgICogc2V0VGltZW91dCBmbiBhbmQga2lja3MgaXQgb2ZmLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHN0YXJ0UG9sbGVyKGludGVydmFsLCBzZXRUaW1lb3V0KSB7XHJcbiAgICAoZnVuY3Rpb24gY2hlY2soKSB7XHJcbiAgICAgIGZvckVhY2gocG9sbEZucywgZnVuY3Rpb24ocG9sbEZuKXsgcG9sbEZuKCk7IH0pO1xyXG4gICAgICBwb2xsVGltZW91dCA9IHNldFRpbWVvdXQoY2hlY2ssIGludGVydmFsKTtcclxuICAgIH0pKCk7XHJcbiAgfVxyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIFVSTCBBUElcclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICB2YXIgbGFzdEJyb3dzZXJVcmwgPSBsb2NhdGlvbi5ocmVmLFxyXG4gICAgICBiYXNlRWxlbWVudCA9IGRvY3VtZW50LmZpbmQoJ2Jhc2UnKSxcclxuICAgICAgcmVwbGFjZWRVcmwgPSBudWxsO1xyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBuZy4kYnJvd3NlciN1cmxcclxuICAgKiBAbWV0aG9kT2YgbmcuJGJyb3dzZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIEdFVFRFUjpcclxuICAgKiBXaXRob3V0IGFueSBhcmd1bWVudCwgdGhpcyBtZXRob2QganVzdCByZXR1cm5zIGN1cnJlbnQgdmFsdWUgb2YgbG9jYXRpb24uaHJlZi5cclxuICAgKlxyXG4gICAqIFNFVFRFUjpcclxuICAgKiBXaXRoIGF0IGxlYXN0IG9uZSBhcmd1bWVudCwgdGhpcyBtZXRob2Qgc2V0cyB1cmwgdG8gbmV3IHZhbHVlLlxyXG4gICAqIElmIGh0bWw1IGhpc3RvcnkgYXBpIHN1cHBvcnRlZCwgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSBpcyB1c2VkLCBvdGhlcndpc2VcclxuICAgKiBsb2NhdGlvbi5ocmVmL2xvY2F0aW9uLnJlcGxhY2UgaXMgdXNlZC5cclxuICAgKiBSZXR1cm5zIGl0cyBvd24gaW5zdGFuY2UgdG8gYWxsb3cgY2hhaW5pbmdcclxuICAgKlxyXG4gICAqIE5PVEU6IHRoaXMgYXBpIGlzIGludGVuZGVkIGZvciB1c2Ugb25seSBieSB0aGUgJGxvY2F0aW9uIHNlcnZpY2UuIFBsZWFzZSB1c2UgdGhlXHJcbiAgICoge0BsaW5rIG5nLiRsb2NhdGlvbiAkbG9jYXRpb24gc2VydmljZX0gdG8gY2hhbmdlIHVybC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgTmV3IHVybCAod2hlbiB1c2VkIGFzIHNldHRlcilcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZXBsYWNlIFNob3VsZCBuZXcgdXJsIHJlcGxhY2UgY3VycmVudCBoaXN0b3J5IHJlY29yZCA/XHJcbiAgICovXHJcbiAgc2VsZi51cmwgPSBmdW5jdGlvbih1cmwsIHJlcGxhY2UpIHtcclxuICAgIC8vIHNldHRlclxyXG4gICAgaWYgKHVybCkge1xyXG4gICAgICBpZiAobGFzdEJyb3dzZXJVcmwgPT0gdXJsKSByZXR1cm47XHJcbiAgICAgIGxhc3RCcm93c2VyVXJsID0gdXJsO1xyXG4gICAgICBpZiAoJHNuaWZmZXIuaGlzdG9yeSkge1xyXG4gICAgICAgIGlmIChyZXBsYWNlKSBoaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCAnJywgdXJsKTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKG51bGwsICcnLCB1cmwpO1xyXG4gICAgICAgICAgLy8gQ3JhenkgT3BlcmEgQnVnOiBodHRwOi8vbXkub3BlcmEuY29tL2NvbW11bml0eS9mb3J1bXMvdG9waWMuZG1sP2lkPTExODU0NjJcclxuICAgICAgICAgIGJhc2VFbGVtZW50LmF0dHIoJ2hyZWYnLCBiYXNlRWxlbWVudC5hdHRyKCdocmVmJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAocmVwbGFjZSkge1xyXG4gICAgICAgICAgbG9jYXRpb24ucmVwbGFjZSh1cmwpO1xyXG4gICAgICAgICAgcmVwbGFjZWRVcmwgPSB1cmw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgICByZXBsYWNlZFVybCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgLy8gZ2V0dGVyXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyAtIHRoZSByZXBsYWNlZFVybCBpcyBhIHdvcmthcm91bmQgZm9yIGFuIElFOC05IGlzc3VlIHdpdGggbG9jYXRpb24ucmVwbGFjZSBtZXRob2QgdGhhdCBkb2Vzbid0IHVwZGF0ZVxyXG4gICAgICAvLyAgIGxvY2F0aW9uLmhyZWYgc3luY2hyb25vdXNseVxyXG4gICAgICAvLyAtIHRoZSByZXBsYWNlbWVudCBpcyBhIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQwNzE3MlxyXG4gICAgICByZXR1cm4gcmVwbGFjZWRVcmwgfHwgbG9jYXRpb24uaHJlZi5yZXBsYWNlKC8lMjcvZyxcIidcIik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIHVybENoYW5nZUxpc3RlbmVycyA9IFtdLFxyXG4gICAgICB1cmxDaGFuZ2VJbml0ID0gZmFsc2U7XHJcblxyXG4gIGZ1bmN0aW9uIGZpcmVVcmxDaGFuZ2UoKSB7XHJcbiAgICBpZiAobGFzdEJyb3dzZXJVcmwgPT0gc2VsZi51cmwoKSkgcmV0dXJuO1xyXG5cclxuICAgIGxhc3RCcm93c2VyVXJsID0gc2VsZi51cmwoKTtcclxuICAgIGZvckVhY2godXJsQ2hhbmdlTGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lcikge1xyXG4gICAgICBsaXN0ZW5lcihzZWxmLnVybCgpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgbmcuJGJyb3dzZXIjb25VcmxDaGFuZ2VcclxuICAgKiBAbWV0aG9kT2YgbmcuJGJyb3dzZXJcclxuICAgKiBAVE9ETyh2b2p0YSk6IHJlZmFjdG9yIHRvIHVzZSBub2RlJ3Mgc3ludGF4IGZvciBldmVudHNcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFJlZ2lzdGVyIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQsIHdoZW4gdXJsIGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiBJdCdzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIHVybCBpcyBjaGFuZ2VkIGJ5IG91dHNpZGUgb2YgYW5ndWxhcjpcclxuICAgKiAtIHVzZXIgdHlwZXMgZGlmZmVyZW50IHVybCBpbnRvIGFkZHJlc3MgYmFyXHJcbiAgICogLSB1c2VyIGNsaWNrcyBvbiBoaXN0b3J5IChmb3J3YXJkL2JhY2spIGJ1dHRvblxyXG4gICAqIC0gdXNlciBjbGlja3Mgb24gYSBsaW5rXHJcbiAgICpcclxuICAgKiBJdCdzIG5vdCBjYWxsZWQgd2hlbiB1cmwgaXMgY2hhbmdlZCBieSAkYnJvd3Nlci51cmwoKSBtZXRob2RcclxuICAgKlxyXG4gICAqIFRoZSBsaXN0ZW5lciBnZXRzIGNhbGxlZCB3aXRoIG5ldyB1cmwgYXMgcGFyYW1ldGVyLlxyXG4gICAqXHJcbiAgICogTk9URTogdGhpcyBhcGkgaXMgaW50ZW5kZWQgZm9yIHVzZSBvbmx5IGJ5IHRoZSAkbG9jYXRpb24gc2VydmljZS4gUGxlYXNlIHVzZSB0aGVcclxuICAgKiB7QGxpbmsgbmcuJGxvY2F0aW9uICRsb2NhdGlvbiBzZXJ2aWNlfSB0byBtb25pdG9yIHVybCBjaGFuZ2VzIGluIGFuZ3VsYXIgYXBwcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKX0gbGlzdGVuZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdXJsIGNoYW5nZXMuXHJcbiAgICogQHJldHVybiB7ZnVuY3Rpb24oc3RyaW5nKX0gUmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBsaXN0ZW5lciBmbiAtIGhhbmR5IGlmIHRoZSBmbiBpcyBhbm9ueW1vdXMuXHJcbiAgICovXHJcbiAgc2VsZi5vblVybENoYW5nZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoIXVybENoYW5nZUluaXQpIHtcclxuICAgICAgLy8gV2UgbGlzdGVuIG9uIGJvdGggKGhhc2hjaGFuZ2UvcG9wc3RhdGUpIHdoZW4gYXZhaWxhYmxlLCBhcyBzb21lIGJyb3dzZXJzIChlLmcuIE9wZXJhKVxyXG4gICAgICAvLyBkb24ndCBmaXJlIHBvcHN0YXRlIHdoZW4gdXNlciBjaGFuZ2UgdGhlIGFkZHJlc3MgYmFyIGFuZCBkb24ndCBmaXJlIGhhc2hjaGFuZ2Ugd2hlbiB1cmxcclxuICAgICAgLy8gY2hhbmdlZCBieSBwdXNoL3JlcGxhY2VTdGF0ZVxyXG5cclxuICAgICAgLy8gaHRtbDUgaGlzdG9yeSBhcGkgLSBwb3BzdGF0ZSBldmVudFxyXG4gICAgICBpZiAoJHNuaWZmZXIuaGlzdG9yeSkganFMaXRlKHdpbmRvdykub24oJ3BvcHN0YXRlJywgZmlyZVVybENoYW5nZSk7XHJcbiAgICAgIC8vIGhhc2hjaGFuZ2UgZXZlbnRcclxuICAgICAgaWYgKCRzbmlmZmVyLmhhc2hjaGFuZ2UpIGpxTGl0ZSh3aW5kb3cpLm9uKCdoYXNoY2hhbmdlJywgZmlyZVVybENoYW5nZSk7XHJcbiAgICAgIC8vIHBvbGxpbmdcclxuICAgICAgZWxzZSBzZWxmLmFkZFBvbGxGbihmaXJlVXJsQ2hhbmdlKTtcclxuXHJcbiAgICAgIHVybENoYW5nZUluaXQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHVybENoYW5nZUxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIHJldHVybiBjYWxsYmFjaztcclxuICB9O1xyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIE1pc2MgQVBJXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IDxiYXNlIGhyZWY+XHJcbiAgICogKGFsd2F5cyByZWxhdGl2ZSAtIHdpdGhvdXQgZG9tYWluKVxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZz19XHJcbiAgICovXHJcbiAgc2VsZi5iYXNlSHJlZiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGhyZWYgPSBiYXNlRWxlbWVudC5hdHRyKCdocmVmJyk7XHJcbiAgICByZXR1cm4gaHJlZiA/IGhyZWYucmVwbGFjZSgvXmh0dHBzP1xcOlxcL1xcL1teXFwvXSovLCAnJykgOiAnJztcclxuICB9O1xyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIC8vIENvb2tpZXMgQVBJXHJcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICB2YXIgbGFzdENvb2tpZXMgPSB7fTtcclxuICB2YXIgbGFzdENvb2tpZVN0cmluZyA9ICcnO1xyXG4gIHZhciBjb29raWVQYXRoID0gc2VsZi5iYXNlSHJlZigpO1xyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBuZy4kYnJvd3NlciNjb29raWVzXHJcbiAgICogQG1ldGhvZE9mIG5nLiRicm93c2VyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgQ29va2llIG5hbWVcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHZhbHVlIENvb2tpZSB2YWx1ZVxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogVGhlIGNvb2tpZXMgbWV0aG9kIHByb3ZpZGVzIGEgJ3ByaXZhdGUnIGxvdyBsZXZlbCBhY2Nlc3MgdG8gYnJvd3NlciBjb29raWVzLlxyXG4gICAqIEl0IGlzIG5vdCBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LCB1c2UgdGhlICRjb29raWUgc2VydmljZSBpbnN0ZWFkLlxyXG4gICAqXHJcbiAgICogVGhlIHJldHVybiB2YWx1ZXMgdmFyeSBkZXBlbmRpbmcgb24gdGhlIGFyZ3VtZW50cyB0aGF0IHRoZSBtZXRob2Qgd2FzIGNhbGxlZCB3aXRoIGFzIGZvbGxvd3M6XHJcbiAgICogPHVsPlxyXG4gICAqICAgPGxpPmNvb2tpZXMoKSAtPiBoYXNoIG9mIGFsbCBjb29raWVzLCB0aGlzIGlzIE5PVCBhIGNvcHkgb2YgdGhlIGludGVybmFsIHN0YXRlLCBzbyBkbyBub3QgbW9kaWZ5IGl0PC9saT5cclxuICAgKiAgIDxsaT5jb29raWVzKG5hbWUsIHZhbHVlKSAtPiBzZXQgbmFtZSB0byB2YWx1ZSwgaWYgdmFsdWUgaXMgdW5kZWZpbmVkIGRlbGV0ZSB0aGUgY29va2llPC9saT5cclxuICAgKiAgIDxsaT5jb29raWVzKG5hbWUpIC0+IHRoZSBzYW1lIGFzIChuYW1lLCB1bmRlZmluZWQpID09IERFTEVURVMgKG5vIG9uZSBjYWxscyBpdCByaWdodCBub3cgdGhhdCB3YXkpPC9saT5cclxuICAgKiA8L3VsPlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09iamVjdH0gSGFzaCBvZiBhbGwgY29va2llcyAoaWYgY2FsbGVkIHdpdGhvdXQgYW55IHBhcmFtZXRlcilcclxuICAgKi9cclxuICBzZWxmLmNvb2tpZXMgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgdmFyIGNvb2tpZUxlbmd0aCwgY29va2llQXJyYXksIGNvb2tpZSwgaSwgaW5kZXg7XHJcblxyXG4gICAgaWYgKG5hbWUpIHtcclxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByYXdEb2N1bWVudC5jb29raWUgPSBlc2NhcGUobmFtZSkgKyBcIj07cGF0aD1cIiArIGNvb2tpZVBhdGggKyBcIjtleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UXCI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgY29va2llTGVuZ3RoID0gKHJhd0RvY3VtZW50LmNvb2tpZSA9IGVzY2FwZShuYW1lKSArICc9JyArIGVzY2FwZSh2YWx1ZSkgKyAnO3BhdGg9JyArIGNvb2tpZVBhdGgpLmxlbmd0aCArIDE7XHJcblxyXG4gICAgICAgICAgLy8gcGVyIGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIxMDkudHh0IGJyb3dzZXIgbXVzdCBhbGxvdyBhdCBtaW5pbXVtOlxyXG4gICAgICAgICAgLy8gLSAzMDAgY29va2llc1xyXG4gICAgICAgICAgLy8gLSAyMCBjb29raWVzIHBlciB1bmlxdWUgZG9tYWluXHJcbiAgICAgICAgICAvLyAtIDQwOTYgYnl0ZXMgcGVyIGNvb2tpZVxyXG4gICAgICAgICAgaWYgKGNvb2tpZUxlbmd0aCA+IDQwOTYpIHtcclxuICAgICAgICAgICAgJGxvZy53YXJuKFwiQ29va2llICdcIisgbmFtZSArXCInIHBvc3NpYmx5IG5vdCBzZXQgb3Igb3ZlcmZsb3dlZCBiZWNhdXNlIGl0IHdhcyB0b28gbGFyZ2UgKFwiK1xyXG4gICAgICAgICAgICAgIGNvb2tpZUxlbmd0aCArIFwiID4gNDA5NiBieXRlcykhXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHJhd0RvY3VtZW50LmNvb2tpZSAhPT0gbGFzdENvb2tpZVN0cmluZykge1xyXG4gICAgICAgIGxhc3RDb29raWVTdHJpbmcgPSByYXdEb2N1bWVudC5jb29raWU7XHJcbiAgICAgICAgY29va2llQXJyYXkgPSBsYXN0Q29va2llU3RyaW5nLnNwbGl0KFwiOyBcIik7XHJcbiAgICAgICAgbGFzdENvb2tpZXMgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb2tpZUFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb29raWUgPSBjb29raWVBcnJheVtpXTtcclxuICAgICAgICAgIGluZGV4ID0gY29va2llLmluZGV4T2YoJz0nKTtcclxuICAgICAgICAgIGlmIChpbmRleCA+IDApIHsgLy9pZ25vcmUgbmFtZWxlc3MgY29va2llc1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IHVuZXNjYXBlKGNvb2tpZS5zdWJzdHJpbmcoMCwgaW5kZXgpKTtcclxuICAgICAgICAgICAgLy8gdGhlIGZpcnN0IHZhbHVlIHRoYXQgaXMgc2VlbiBmb3IgYSBjb29raWUgaXMgdGhlIG1vc3RcclxuICAgICAgICAgICAgLy8gc3BlY2lmaWMgb25lLiAgdmFsdWVzIGZvciB0aGUgc2FtZSBjb29raWUgbmFtZSB0aGF0XHJcbiAgICAgICAgICAgIC8vIGZvbGxvdyBhcmUgZm9yIGxlc3Mgc3BlY2lmaWMgcGF0aHMuXHJcbiAgICAgICAgICAgIGlmIChsYXN0Q29va2llc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgbGFzdENvb2tpZXNbbmFtZV0gPSB1bmVzY2FwZShjb29raWUuc3Vic3RyaW5nKGluZGV4ICsgMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsYXN0Q29va2llcztcclxuICAgIH1cclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgbmcuJGJyb3dzZXIjZGVmZXJcclxuICAgKiBAbWV0aG9kT2YgbmcuJGJyb3dzZXJcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuIEEgZnVuY3Rpb24sIHdobydzIGV4ZWN1dGlvbiBzaG91bGQgYmUgZGVmZXJyZWQuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbZGVsYXk9MF0gb2YgbWlsbGlzZWNvbmRzIHRvIGRlZmVyIHRoZSBmdW5jdGlvbiBleGVjdXRpb24uXHJcbiAgICogQHJldHVybnMgeyp9IERlZmVySWQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHRhc2sgdmlhIGAkYnJvd3Nlci5kZWZlci5jYW5jZWwoKWAuXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBFeGVjdXRlcyBhIGZuIGFzeW5jaHJvbm91c2x5IHZpYSBgc2V0VGltZW91dChmbiwgZGVsYXkpYC5cclxuICAgKlxyXG4gICAqIFVubGlrZSB3aGVuIGNhbGxpbmcgYHNldFRpbWVvdXRgIGRpcmVjdGx5LCBpbiB0ZXN0IHRoaXMgZnVuY3Rpb24gaXMgbW9ja2VkIGFuZCBpbnN0ZWFkIG9mIHVzaW5nXHJcbiAgICogYHNldFRpbWVvdXRgIGluIHRlc3RzLCB0aGUgZm5zIGFyZSBxdWV1ZWQgaW4gYW4gYXJyYXksIHdoaWNoIGNhbiBiZSBwcm9ncmFtbWF0aWNhbGx5IGZsdXNoZWRcclxuICAgKiB2aWEgYCRicm93c2VyLmRlZmVyLmZsdXNoKClgLlxyXG4gICAqXHJcbiAgICovXHJcbiAgc2VsZi5kZWZlciA9IGZ1bmN0aW9uKGZuLCBkZWxheSkge1xyXG4gICAgdmFyIHRpbWVvdXRJZDtcclxuICAgIG91dHN0YW5kaW5nUmVxdWVzdENvdW50Kys7XHJcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICBkZWxldGUgcGVuZGluZ0RlZmVySWRzW3RpbWVvdXRJZF07XHJcbiAgICAgIGNvbXBsZXRlT3V0c3RhbmRpbmdSZXF1ZXN0KGZuKTtcclxuICAgIH0sIGRlbGF5IHx8IDApO1xyXG4gICAgcGVuZGluZ0RlZmVySWRzW3RpbWVvdXRJZF0gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRpbWVvdXRJZDtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgbmcuJGJyb3dzZXIjZGVmZXIuY2FuY2VsXHJcbiAgICogQG1ldGhvZE9mIG5nLiRicm93c2VyLmRlZmVyXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBDYW5jZWxzIGEgZGVmZXJyZWQgdGFzayBpZGVudGlmaWVkIHdpdGggYGRlZmVySWRgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsqfSBkZWZlcklkIFRva2VuIHJldHVybmVkIGJ5IHRoZSBgJGJyb3dzZXIuZGVmZXJgIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGFzayBoYXNuJ3QgZXhlY3V0ZWQgeWV0IGFuZCB3YXMgc3VjY2Vzc2Z1bGx5IGNhbmNlbGVkLlxyXG4gICAqL1xyXG4gIHNlbGYuZGVmZXIuY2FuY2VsID0gZnVuY3Rpb24oZGVmZXJJZCkge1xyXG4gICAgaWYgKHBlbmRpbmdEZWZlcklkc1tkZWZlcklkXSkge1xyXG4gICAgICBkZWxldGUgcGVuZGluZ0RlZmVySWRzW2RlZmVySWRdO1xyXG4gICAgICBjbGVhclRpbWVvdXQoZGVmZXJJZCk7XHJcbiAgICAgIGNvbXBsZXRlT3V0c3RhbmRpbmdSZXF1ZXN0KG5vb3ApO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9O1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gJEJyb3dzZXJQcm92aWRlcigpe1xyXG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsICckbG9nJywgJyRzbmlmZmVyJywgJyRkb2N1bWVudCcsXHJcbiAgICAgIGZ1bmN0aW9uKCAkd2luZG93LCAgICRsb2csICAgJHNuaWZmZXIsICAgJGRvY3VtZW50KXtcclxuICAgICAgICByZXR1cm4gbmV3IEJyb3dzZXIoJHdpbmRvdywgJGRvY3VtZW50LCAkbG9nLCAkc25pZmZlcik7XHJcbiAgICAgIH1dO1xyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy4kY2FjaGVGYWN0b3J5XHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBGYWN0b3J5IHRoYXQgY29uc3RydWN0cyBjYWNoZSBvYmplY3RzIGFuZCBnaXZlcyBhY2Nlc3MgdG8gdGhlbS5cclxuICogXHJcbiAqIDxwcmU+XHJcbiAqIFxyXG4gKiAgdmFyIGNhY2hlID0gJGNhY2hlRmFjdG9yeSgnY2FjaGVJZCcpO1xyXG4gKiAgZXhwZWN0KCRjYWNoZUZhY3RvcnkuZ2V0KCdjYWNoZUlkJykpLnRvQmUoY2FjaGUpO1xyXG4gKiAgZXhwZWN0KCRjYWNoZUZhY3RvcnkuZ2V0KCdub1N1Y2hDYWNoZUlkJykpLm5vdC50b0JlRGVmaW5lZCgpO1xyXG4gKlxyXG4gKiAgY2FjaGUucHV0KFwia2V5XCIsIFwidmFsdWVcIik7XHJcbiAqICBjYWNoZS5wdXQoXCJhbm90aGVyIGtleVwiLCBcImFub3RoZXIgdmFsdWVcIik7XHJcbiAqIFxyXG4gKiAgZXhwZWN0KGNhY2hlLmluZm8oKSkudG9FcXVhbCh7aWQ6ICdjYWNoZUlkJywgc2l6ZTogMn0pOyAvLyBTaW5jZSB3ZSd2ZSBzcGVjaWZpZWQgbm8gb3B0aW9ucyBvbiBjcmVhdGlvblxyXG4gKiBcclxuICogPC9wcmU+XHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZUlkIE5hbWUgb3IgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgY2FjaGUuXHJcbiAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0aW9ucyBPcHRpb25zIG9iamVjdCB0aGF0IHNwZWNpZmllcyB0aGUgY2FjaGUgYmVoYXZpb3IuIFByb3BlcnRpZXM6XHJcbiAqXHJcbiAqICAgLSBge251bWJlcj19YCBgY2FwYWNpdHlgIMOi4oKs4oCdIHR1cm5zIHRoZSBjYWNoZSBpbnRvIExSVSBjYWNoZS5cclxuICpcclxuICogQHJldHVybnMge29iamVjdH0gTmV3bHkgY3JlYXRlZCBjYWNoZSBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHNldCBvZiBtZXRob2RzOlxyXG4gKlxyXG4gKiAtIGB7b2JqZWN0fWAgYGluZm8oKWAgw6LigqzigJ0gUmV0dXJucyBpZCwgc2l6ZSwgYW5kIG9wdGlvbnMgb2YgY2FjaGUuXHJcbiAqIC0gYHt7Kn19YCBgcHV0KHtzdHJpbmd9IGtleSwgeyp9IHZhbHVlKWAgw6LigqzigJ0gUHV0cyBhIG5ldyBrZXktdmFsdWUgcGFpciBpbnRvIHRoZSBjYWNoZSBhbmQgcmV0dXJucyBpdC5cclxuICogLSBge3sqfX1gIGBnZXQoe3N0cmluZ30ga2V5KWAgw6LigqzigJ0gUmV0dXJucyBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgIG9yIHVuZGVmaW5lZCBmb3IgY2FjaGUgbWlzcy5cclxuICogLSBge3ZvaWR9YCBgcmVtb3ZlKHtzdHJpbmd9IGtleSlgIMOi4oKs4oCdIFJlbW92ZXMgYSBrZXktdmFsdWUgcGFpciBmcm9tIHRoZSBjYWNoZS5cclxuICogLSBge3ZvaWR9YCBgcmVtb3ZlQWxsKClgIMOi4oKs4oCdIFJlbW92ZXMgYWxsIGNhY2hlZCB2YWx1ZXMuXHJcbiAqIC0gYHt2b2lkfWAgYGRlc3Ryb3koKWAgw6LigqzigJ0gUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoaXMgY2FjaGUgZnJvbSAkY2FjaGVGYWN0b3J5LlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gJENhY2hlRmFjdG9yeVByb3ZpZGVyKCkge1xyXG5cclxuICB0aGlzLiRnZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBjYWNoZXMgPSB7fTtcclxuXHJcbiAgICBmdW5jdGlvbiBjYWNoZUZhY3RvcnkoY2FjaGVJZCwgb3B0aW9ucykge1xyXG4gICAgICBpZiAoY2FjaGVJZCBpbiBjYWNoZXMpIHtcclxuICAgICAgICB0aHJvdyBtaW5FcnIoJyRjYWNoZUZhY3RvcnknKSgnaWlkJywgXCJDYWNoZUlkICd7MH0nIGlzIGFscmVhZHkgdGFrZW4hXCIsIGNhY2hlSWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc2l6ZSA9IDAsXHJcbiAgICAgICAgICBzdGF0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucywge2lkOiBjYWNoZUlkfSksXHJcbiAgICAgICAgICBkYXRhID0ge30sXHJcbiAgICAgICAgICBjYXBhY2l0eSA9IChvcHRpb25zICYmIG9wdGlvbnMuY2FwYWNpdHkpIHx8IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICBscnVIYXNoID0ge30sXHJcbiAgICAgICAgICBmcmVzaEVuZCA9IG51bGwsXHJcbiAgICAgICAgICBzdGFsZUVuZCA9IG51bGw7XHJcblxyXG4gICAgICByZXR1cm4gY2FjaGVzW2NhY2hlSWRdID0ge1xyXG5cclxuICAgICAgICBwdXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgIHZhciBscnVFbnRyeSA9IGxydUhhc2hba2V5XSB8fCAobHJ1SGFzaFtrZXldID0ge2tleToga2V5fSk7XHJcblxyXG4gICAgICAgICAgcmVmcmVzaChscnVFbnRyeSk7XHJcblxyXG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkgcmV0dXJuO1xyXG4gICAgICAgICAgaWYgKCEoa2V5IGluIGRhdGEpKSBzaXplKys7XHJcbiAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICBpZiAoc2l6ZSA+IGNhcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKHN0YWxlRW5kLmtleSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgdmFyIGxydUVudHJ5ID0gbHJ1SGFzaFtrZXldO1xyXG5cclxuICAgICAgICAgIGlmICghbHJ1RW50cnkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICByZWZyZXNoKGxydUVudHJ5KTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgICAgdmFyIGxydUVudHJ5ID0gbHJ1SGFzaFtrZXldO1xyXG5cclxuICAgICAgICAgIGlmICghbHJ1RW50cnkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICBpZiAobHJ1RW50cnkgPT0gZnJlc2hFbmQpIGZyZXNoRW5kID0gbHJ1RW50cnkucDtcclxuICAgICAgICAgIGlmIChscnVFbnRyeSA9PSBzdGFsZUVuZCkgc3RhbGVFbmQgPSBscnVFbnRyeS5uO1xyXG4gICAgICAgICAgbGluayhscnVFbnRyeS5uLGxydUVudHJ5LnApO1xyXG5cclxuICAgICAgICAgIGRlbGV0ZSBscnVIYXNoW2tleV07XHJcbiAgICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xyXG4gICAgICAgICAgc2l6ZS0tO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICByZW1vdmVBbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgZGF0YSA9IHt9O1xyXG4gICAgICAgICAgc2l6ZSA9IDA7XHJcbiAgICAgICAgICBscnVIYXNoID0ge307XHJcbiAgICAgICAgICBmcmVzaEVuZCA9IHN0YWxlRW5kID0gbnVsbDtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgICAgIHN0YXRzID0gbnVsbDtcclxuICAgICAgICAgIGxydUhhc2ggPSBudWxsO1xyXG4gICAgICAgICAgZGVsZXRlIGNhY2hlc1tjYWNoZUlkXTtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgaW5mbzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBzdGF0cywge3NpemU6IHNpemV9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIG1ha2VzIHRoZSBgZW50cnlgIHRoZSBmcmVzaEVuZCBvZiB0aGUgTFJVIGxpbmtlZCBsaXN0XHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiByZWZyZXNoKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKGVudHJ5ICE9IGZyZXNoRW5kKSB7XHJcbiAgICAgICAgICBpZiAoIXN0YWxlRW5kKSB7XHJcbiAgICAgICAgICAgIHN0YWxlRW5kID0gZW50cnk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWxlRW5kID09IGVudHJ5KSB7XHJcbiAgICAgICAgICAgIHN0YWxlRW5kID0gZW50cnkubjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBsaW5rKGVudHJ5Lm4sIGVudHJ5LnApO1xyXG4gICAgICAgICAgbGluayhlbnRyeSwgZnJlc2hFbmQpO1xyXG4gICAgICAgICAgZnJlc2hFbmQgPSBlbnRyeTtcclxuICAgICAgICAgIGZyZXNoRW5kLm4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBiaWRpcmVjdGlvbmFsbHkgbGlua3MgdHdvIGVudHJpZXMgb2YgdGhlIExSVSBsaW5rZWQgbGlzdFxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gbGluayhuZXh0RW50cnksIHByZXZFbnRyeSkge1xyXG4gICAgICAgIGlmIChuZXh0RW50cnkgIT0gcHJldkVudHJ5KSB7XHJcbiAgICAgICAgICBpZiAobmV4dEVudHJ5KSBuZXh0RW50cnkucCA9IHByZXZFbnRyeTsgLy9wIHN0YW5kcyBmb3IgcHJldmlvdXMsICdwcmV2JyBkaWRuJ3QgbWluaWZ5XHJcbiAgICAgICAgICBpZiAocHJldkVudHJ5KSBwcmV2RW50cnkubiA9IG5leHRFbnRyeTsgLy9uIHN0YW5kcyBmb3IgbmV4dCwgJ25leHQnIGRpZG4ndCBtaW5pZnlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBtZXRob2RcclxuICAgKiBAbmFtZSBuZy4kY2FjaGVGYWN0b3J5I2luZm9cclxuICAgKiBAbWV0aG9kT2YgbmcuJGNhY2hlRmFjdG9yeVxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGFsbCB0aGUgb2YgdGhlIGNhY2hlcyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIGtleS12YWx1ZSBtYXAgb2YgYGNhY2hlSWRgIHRvIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgY2FjaGUjaW5mb2BcclxuICAgKi9cclxuICAgIGNhY2hlRmFjdG9yeS5pbmZvID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBpbmZvID0ge307XHJcbiAgICAgIGZvckVhY2goY2FjaGVzLCBmdW5jdGlvbihjYWNoZSwgY2FjaGVJZCkge1xyXG4gICAgICAgIGluZm9bY2FjaGVJZF0gPSBjYWNoZS5pbmZvKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gaW5mbztcclxuICAgIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICogQG5hbWUgbmcuJGNhY2hlRmFjdG9yeSNnZXRcclxuICAgKiBAbWV0aG9kT2YgbmcuJGNhY2hlRmFjdG9yeVxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogR2V0IGFjY2VzcyB0byBhIGNhY2hlIG9iamVjdCBieSB0aGUgYGNhY2hlSWRgIHVzZWQgd2hlbiBpdCB3YXMgY3JlYXRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZUlkIE5hbWUgb3IgaWQgb2YgYSBjYWNoZSB0byBhY2Nlc3MuXHJcbiAgICogQHJldHVybnMge29iamVjdH0gQ2FjaGUgb2JqZWN0IGlkZW50aWZpZWQgYnkgdGhlIGNhY2hlSWQgb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2ggY2FjaGUuXHJcbiAgICovXHJcbiAgICBjYWNoZUZhY3RvcnkuZ2V0ID0gZnVuY3Rpb24oY2FjaGVJZCkge1xyXG4gICAgICByZXR1cm4gY2FjaGVzW2NhY2hlSWRdO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgcmV0dXJuIGNhY2hlRmFjdG9yeTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy4kdGVtcGxhdGVDYWNoZVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGZpcnN0IHRpbWUgYSB0ZW1wbGF0ZSBpcyB1c2VkLCBpdCBpcyBsb2FkZWQgaW4gdGhlIHRlbXBsYXRlIGNhY2hlIGZvciBxdWljayByZXRyaWV2YWwuIFlvdSBjYW5cclxuICogbG9hZCB0ZW1wbGF0ZXMgZGlyZWN0bHkgaW50byB0aGUgY2FjaGUgaW4gYSBgc2NyaXB0YCB0YWcsIG9yIGJ5IGNvbnN1bWluZyB0aGUgYCR0ZW1wbGF0ZUNhY2hlYFxyXG4gKiBzZXJ2aWNlIGRpcmVjdGx5LlxyXG4gKiBcclxuICogQWRkaW5nIHZpYSB0aGUgYHNjcmlwdGAgdGFnOlxyXG4gKiA8cHJlPlxyXG4gKiA8aHRtbCBuZy1hcHA+XHJcbiAqIDxoZWFkPlxyXG4gKiA8c2NyaXB0IHR5cGU9XCJ0ZXh0L25nLXRlbXBsYXRlXCIgaWQ9XCJ0ZW1wbGF0ZUlkLmh0bWxcIj5cclxuICogICBUaGlzIGlzIHRoZSBjb250ZW50IG9mIHRoZSB0ZW1wbGF0ZVxyXG4gKiA8L3NjcmlwdD5cclxuICogPC9oZWFkPlxyXG4gKiAgIC4uLlxyXG4gKiA8L2h0bWw+XHJcbiAqIDwvcHJlPlxyXG4gKiBcclxuICogKipOb3RlOioqIHRoZSBgc2NyaXB0YCB0YWcgY29udGFpbmluZyB0aGUgdGVtcGxhdGUgZG9lcyBub3QgbmVlZCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgYGhlYWRgIG9mIHRoZSBkb2N1bWVudCwgYnV0IFxyXG4gKiBpdCBtdXN0IGJlIGJlbG93IHRoZSBgbmctYXBwYCBkZWZpbml0aW9uLlxyXG4gKiBcclxuICogQWRkaW5nIHZpYSB0aGUgJHRlbXBsYXRlQ2FjaGUgc2VydmljZTpcclxuICogXHJcbiAqIDxwcmU+XHJcbiAqIHZhciBteUFwcCA9IGFuZ3VsYXIubW9kdWxlKCdteUFwcCcsIFtdKTtcclxuICogbXlBcHAucnVuKGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAqICAgJHRlbXBsYXRlQ2FjaGUucHV0KCd0ZW1wbGF0ZUlkLmh0bWwnLCAnVGhpcyBpcyB0aGUgY29udGVudCBvZiB0aGUgdGVtcGxhdGUnKTtcclxuICogfSk7XHJcbiAqIDwvcHJlPlxyXG4gKiBcclxuICogVG8gcmV0cmlldmUgdGhlIHRlbXBsYXRlIGxhdGVyLCBzaW1wbHkgdXNlIGl0IGluIHlvdXIgSFRNTDpcclxuICogPHByZT5cclxuICogPGRpdiBuZy1pbmNsdWRlPVwiICd0ZW1wbGF0ZUlkLmh0bWwnIFwiPjwvZGl2PlxyXG4gKiA8L3ByZT5cclxuICogXHJcbiAqIG9yIGdldCBpdCB2aWEgSmF2YXNjcmlwdDpcclxuICogPHByZT5cclxuICogJHRlbXBsYXRlQ2FjaGUuZ2V0KCd0ZW1wbGF0ZUlkLmh0bWwnKVxyXG4gKiA8L3ByZT5cclxuICogXHJcbiAqIFNlZSB7QGxpbmsgbmcuJGNhY2hlRmFjdG9yeSAkY2FjaGVGYWN0b3J5fS5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uICRUZW1wbGF0ZUNhY2hlUHJvdmlkZXIoKSB7XHJcbiAgdGhpcy4kZ2V0ID0gWyckY2FjaGVGYWN0b3J5JywgZnVuY3Rpb24oJGNhY2hlRmFjdG9yeSkge1xyXG4gICAgcmV0dXJuICRjYWNoZUZhY3RvcnkoJ3RlbXBsYXRlcycpO1xyXG4gIH1dO1xyXG59XHJcblxyXG4vKiAhIFZBUklBQkxFL0ZVTkNUSU9OIE5BTUlORyBDT05WRU5USU9OUyBUSEFUIEFQUExZIFRPIFRISVMgRklMRSFcclxuICpcclxuICogRE9NLXJlbGF0ZWQgdmFyaWFibGVzOlxyXG4gKlxyXG4gKiAtIFwibm9kZVwiIC0gRE9NIE5vZGVcclxuICogLSBcImVsZW1lbnRcIiAtIERPTSBFbGVtZW50IG9yIE5vZGVcclxuICogLSBcIiRub2RlXCIgb3IgXCIkZWxlbWVudFwiIC0ganFMaXRlLXdyYXBwZWQgbm9kZSBvciBlbGVtZW50XHJcbiAqXHJcbiAqXHJcbiAqIENvbXBpbGVyIHJlbGF0ZWQgc3R1ZmY6XHJcbiAqXHJcbiAqIC0gXCJsaW5rRm5cIiAtIGxpbmtpbmcgZm4gb2YgYSBzaW5nbGUgZGlyZWN0aXZlXHJcbiAqIC0gXCJub2RlTGlua0ZuXCIgLSBmdW5jdGlvbiB0aGF0IGFnZ3JlZ2F0ZXMgYWxsIGxpbmtpbmcgZm5zIGZvciBhIHBhcnRpY3VsYXIgbm9kZVxyXG4gKiAtIFwiY2hpbGRMaW5rRm5cIiAtICBmdW5jdGlvbiB0aGF0IGFnZ3JlZ2F0ZXMgYWxsIGxpbmtpbmcgZm5zIGZvciBjaGlsZCBub2RlcyBvZiBhIHBhcnRpY3VsYXIgbm9kZVxyXG4gKiAtIFwiY29tcG9zaXRlTGlua0ZuXCIgLSBmdW5jdGlvbiB0aGF0IGFnZ3JlZ2F0ZXMgYWxsIGxpbmtpbmcgZm5zIGZvciBhIGNvbXBpbGF0aW9uIHJvb3QgKG5vZGVMaXN0KVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIG5nLiRjb21waWxlXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ29tcGlsZXMgYSBwaWVjZSBvZiBIVE1MIHN0cmluZyBvciBET00gaW50byBhIHRlbXBsYXRlIGFuZCBwcm9kdWNlcyBhIHRlbXBsYXRlIGZ1bmN0aW9uLCB3aGljaFxyXG4gKiBjYW4gdGhlbiBiZSB1c2VkIHRvIGxpbmsge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUgc2NvcGV9IGFuZCB0aGUgdGVtcGxhdGUgdG9nZXRoZXIuXHJcbiAqXHJcbiAqIFRoZSBjb21waWxhdGlvbiBpcyBhIHByb2Nlc3Mgb2Ygd2Fsa2luZyB0aGUgRE9NIHRyZWUgYW5kIHRyeWluZyB0byBtYXRjaCBET00gZWxlbWVudHMgdG9cclxuICoge0BsaW5rIG5nLiRjb21waWxlUHJvdmlkZXIjZGlyZWN0aXZlIGRpcmVjdGl2ZXN9LiBGb3IgZWFjaCBtYXRjaCBpdFxyXG4gKiBleGVjdXRlcyBjb3JyZXNwb25kaW5nIHRlbXBsYXRlIGZ1bmN0aW9uIGFuZCBjb2xsZWN0cyB0aGVcclxuICogaW5zdGFuY2UgZnVuY3Rpb25zIGludG8gYSBzaW5nbGUgdGVtcGxhdGUgZnVuY3Rpb24gd2hpY2ggaXMgdGhlbiByZXR1cm5lZC5cclxuICpcclxuICogVGhlIHRlbXBsYXRlIGZ1bmN0aW9uIGNhbiB0aGVuIGJlIHVzZWQgb25jZSB0byBwcm9kdWNlIHRoZSB2aWV3IG9yIGFzIGl0IGlzIHRoZSBjYXNlIHdpdGhcclxuICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1JlcGVhdCByZXBlYXRlcn0gbWFueS10aW1lcywgaW4gd2hpY2hcclxuICogY2FzZSBlYWNoIGNhbGwgcmVzdWx0cyBpbiBhIHZpZXcgdGhhdCBpcyBhIERPTSBjbG9uZSBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUuXHJcbiAqXHJcbiA8ZG9jOmV4YW1wbGUgbW9kdWxlPVwiY29tcGlsZVwiPlxyXG4gICA8ZG9jOnNvdXJjZT5cclxuICAgIDxzY3JpcHQ+XHJcbiAgICAgIC8vIGRlY2xhcmUgYSBuZXcgbW9kdWxlLCBhbmQgaW5qZWN0IHRoZSAkY29tcGlsZVByb3ZpZGVyXHJcbiAgICAgIGFuZ3VsYXIubW9kdWxlKCdjb21waWxlJywgW10sIGZ1bmN0aW9uKCRjb21waWxlUHJvdmlkZXIpIHtcclxuICAgICAgICAvLyBjb25maWd1cmUgbmV3ICdjb21waWxlJyBkaXJlY3RpdmUgYnkgcGFzc2luZyBhIGRpcmVjdGl2ZVxyXG4gICAgICAgIC8vIGZhY3RvcnkgZnVuY3Rpb24uIFRoZSBmYWN0b3J5IGZ1bmN0aW9uIGluamVjdHMgdGhlICckY29tcGlsZSdcclxuICAgICAgICAkY29tcGlsZVByb3ZpZGVyLmRpcmVjdGl2ZSgnY29tcGlsZScsIGZ1bmN0aW9uKCRjb21waWxlKSB7XHJcbiAgICAgICAgICAvLyBkaXJlY3RpdmUgZmFjdG9yeSBjcmVhdGVzIGEgbGluayBmdW5jdGlvblxyXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xyXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goXHJcbiAgICAgICAgICAgICAgZnVuY3Rpb24oc2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAvLyB3YXRjaCB0aGUgJ2NvbXBpbGUnIGV4cHJlc3Npb24gZm9yIGNoYW5nZXNcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS4kZXZhbChhdHRycy5jb21waWxlKTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSAnY29tcGlsZScgZXhwcmVzc2lvbiBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gaXQgaW50byB0aGUgY3VycmVudCBET01cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuaHRtbCh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZSB0aGUgbmV3IERPTSBhbmQgbGluayBpdCB0byB0aGUgY3VycmVudFxyXG4gICAgICAgICAgICAgICAgLy8gc2NvcGUuXHJcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBvbmx5IGNvbXBpbGUgLmNoaWxkTm9kZXMgc28gdGhhdFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgZ2V0IGludG8gaW5maW5pdGUgbG9vcCBjb21waWxpbmcgb3Vyc2VsdmVzXHJcbiAgICAgICAgICAgICAgICAkY29tcGlsZShlbGVtZW50LmNvbnRlbnRzKCkpKHNjb3BlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAkc2NvcGUubmFtZSA9ICdBbmd1bGFyJztcclxuICAgICAgICAkc2NvcGUuaHRtbCA9ICdIZWxsbyB7e25hbWV9fSc7XHJcbiAgICAgIH1cclxuICAgIDwvc2NyaXB0PlxyXG4gICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICA8aW5wdXQgbmctbW9kZWw9XCJuYW1lXCI+IDxicj5cclxuICAgICAgPHRleHRhcmVhIG5nLW1vZGVsPVwiaHRtbFwiPjwvdGV4dGFyZWE+IDxicj5cclxuICAgICAgPGRpdiBjb21waWxlPVwiaHRtbFwiPjwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgIDwvZG9jOnNvdXJjZT5cclxuICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICBpdCgnc2hvdWxkIGF1dG8gY29tcGlsZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgZXhwZWN0KGVsZW1lbnQoJ2Rpdltjb21waWxlXScpLnRleHQoKSkudG9CZSgnSGVsbG8gQW5ndWxhcicpO1xyXG4gICAgICAgaW5wdXQoJ2h0bWwnKS5lbnRlcigne3tuYW1lfX0hJyk7XHJcbiAgICAgICBleHBlY3QoZWxlbWVudCgnZGl2W2NvbXBpbGVdJykudGV4dCgpKS50b0JlKCdBbmd1bGFyIScpO1xyXG4gICAgIH0pO1xyXG4gICA8L2RvYzpzY2VuYXJpbz5cclxuIDwvZG9jOmV4YW1wbGU+XHJcblxyXG4gKlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xET01FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgb3IgSFRNTCBzdHJpbmcgdG8gY29tcGlsZSBpbnRvIGEgdGVtcGxhdGUgZnVuY3Rpb24uXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW5ndWxhci5TY29wZVssIGNsb25lQXR0YWNoRm5dfSB0cmFuc2NsdWRlIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBkaXJlY3RpdmVzLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4UHJpb3JpdHkgb25seSBhcHBseSBkaXJlY3RpdmVzIGxvd2VyIHRoZW4gZ2l2ZW4gcHJpb3JpdHkgKE9ubHkgZWZmZWN0cyB0aGVcclxuICogICAgICAgICAgICAgICAgIHJvb3QgZWxlbWVudChzKSwgbm90IHRoZWlyIGNoaWxkcmVuKVxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc2NvcGVbLCBjbG9uZUF0dGFjaEZuXSl9IGEgbGluayBmdW5jdGlvbiB3aGljaCBpcyB1c2VkIHRvIGJpbmQgdGVtcGxhdGVcclxuICogKGEgRE9NIGVsZW1lbnQvdHJlZSkgdG8gYSBzY29wZS4gV2hlcmU6XHJcbiAqXHJcbiAqICAqIGBzY29wZWAgLSBBIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIFNjb3BlfSB0byBiaW5kIHRvLlxyXG4gKiAgKiBgY2xvbmVBdHRhY2hGbmAgLSBJZiBgY2xvbmVBdHRhY2hGbmAgaXMgcHJvdmlkZWQsIHRoZW4gdGhlIGxpbmsgZnVuY3Rpb24gd2lsbCBjbG9uZSB0aGVcclxuICogICAgICAgICAgICAgICBgdGVtcGxhdGVgIGFuZCBjYWxsIHRoZSBgY2xvbmVBdHRhY2hGbmAgZnVuY3Rpb24gYWxsb3dpbmcgdGhlIGNhbGxlciB0byBhdHRhY2ggdGhlXHJcbiAqICAgICAgICAgICAgICAgY2xvbmVkIGVsZW1lbnRzIHRvIHRoZSBET00gZG9jdW1lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHBsYWNlLiBUaGUgYGNsb25lQXR0YWNoRm5gIGlzXHJcbiAqICAgICAgICAgICAgICAgY2FsbGVkIGFzOiA8YnI+IGBjbG9uZUF0dGFjaEZuKGNsb25lZEVsZW1lbnQsIHNjb3BlKWAgd2hlcmU6XHJcbiAqXHJcbiAqICAgICAgKiBgY2xvbmVkRWxlbWVudGAgLSBpcyBhIGNsb25lIG9mIHRoZSBvcmlnaW5hbCBgZWxlbWVudGAgcGFzc2VkIGludG8gdGhlIGNvbXBpbGVyLlxyXG4gKiAgICAgICogYHNjb3BlYCAtIGlzIHRoZSBjdXJyZW50IHNjb3BlIHdpdGggd2hpY2ggdGhlIGxpbmtpbmcgZnVuY3Rpb24gaXMgd29ya2luZyB3aXRoLlxyXG4gKlxyXG4gKiBDYWxsaW5nIHRoZSBsaW5raW5nIGZ1bmN0aW9uIHJldHVybnMgdGhlIGVsZW1lbnQgb2YgdGhlIHRlbXBsYXRlLiBJdCBpcyBlaXRoZXIgdGhlIG9yaWdpbmFsIGVsZW1lbnRcclxuICogcGFzc2VkIGluLCBvciB0aGUgY2xvbmUgb2YgdGhlIGVsZW1lbnQgaWYgdGhlIGBjbG9uZUF0dGFjaEZuYCBpcyBwcm92aWRlZC5cclxuICpcclxuICogQWZ0ZXIgbGlua2luZyB0aGUgdmlldyBpcyBub3QgdXBkYXRlZCB1bnRpbCBhZnRlciBhIGNhbGwgdG8gJGRpZ2VzdCB3aGljaCB0eXBpY2FsbHkgaXMgZG9uZSBieVxyXG4gKiBBbmd1bGFyIGF1dG9tYXRpY2FsbHkuXHJcbiAqXHJcbiAqIElmIHlvdSBuZWVkIGFjY2VzcyB0byB0aGUgYm91bmQgdmlldywgdGhlcmUgYXJlIHR3byB3YXlzIHRvIGRvIGl0OlxyXG4gKlxyXG4gKiAtIElmIHlvdSBhcmUgbm90IGFza2luZyB0aGUgbGlua2luZyBmdW5jdGlvbiB0byBjbG9uZSB0aGUgdGVtcGxhdGUsIGNyZWF0ZSB0aGUgRE9NIGVsZW1lbnQocylcclxuICogICBiZWZvcmUgeW91IHNlbmQgdGhlbSB0byB0aGUgY29tcGlsZXIgYW5kIGtlZXAgdGhpcyByZWZlcmVuY2UgYXJvdW5kLlxyXG4gKiAgIDxwcmU+XHJcbiAqICAgICB2YXIgZWxlbWVudCA9ICRjb21waWxlKCc8cD57e3RvdGFsfX08L3A+Jykoc2NvcGUpO1xyXG4gKiAgIDwvcHJlPlxyXG4gKlxyXG4gKiAtIGlmIG9uIHRoZSBvdGhlciBoYW5kLCB5b3UgbmVlZCB0aGUgZWxlbWVudCB0byBiZSBjbG9uZWQsIHRoZSB2aWV3IHJlZmVyZW5jZSBmcm9tIHRoZSBvcmlnaW5hbFxyXG4gKiAgIGV4YW1wbGUgd291bGQgbm90IHBvaW50IHRvIHRoZSBjbG9uZSwgYnV0IHJhdGhlciB0byB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB3YXMgY2xvbmVkLiBJblxyXG4gKiAgIHRoaXMgY2FzZSwgeW91IGNhbiBhY2Nlc3MgdGhlIGNsb25lIHZpYSB0aGUgY2xvbmVBdHRhY2hGbjpcclxuICogICA8cHJlPlxyXG4gKiAgICAgdmFyIHRlbXBsYXRlSFRNTCA9IGFuZ3VsYXIuZWxlbWVudCgnPHA+e3t0b3RhbH19PC9wPicpLFxyXG4gKiAgICAgICAgIHNjb3BlID0gLi4uLjtcclxuICpcclxuICogICAgIHZhciBjbG9uZWRFbGVtZW50ID0gJGNvbXBpbGUodGVtcGxhdGVIVE1MKShzY29wZSwgZnVuY3Rpb24oY2xvbmVkRWxlbWVudCwgc2NvcGUpIHtcclxuICogICAgICAgLy9hdHRhY2ggdGhlIGNsb25lIHRvIERPTSBkb2N1bWVudCBhdCB0aGUgcmlnaHQgcGxhY2VcclxuICogICAgIH0pO1xyXG4gKlxyXG4gKiAgICAgLy9ub3cgd2UgaGF2ZSByZWZlcmVuY2UgdG8gdGhlIGNsb25lZCBET00gdmlhIGBjbG9uZWBcclxuICogICA8L3ByZT5cclxuICpcclxuICpcclxuICogRm9yIGluZm9ybWF0aW9uIG9uIGhvdyB0aGUgY29tcGlsZXIgd29ya3MsIHNlZSB0aGVcclxuICoge0BsaW5rIGd1aWRlL2NvbXBpbGVyIEFuZ3VsYXIgSFRNTCBDb21waWxlcn0gc2VjdGlvbiBvZiB0aGUgRGV2ZWxvcGVyIEd1aWRlLlxyXG4gKi9cclxuXHJcbnZhciAkY29tcGlsZU1pbkVyciA9IG1pbkVycignJGNvbXBpbGUnKTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgc2VydmljZVxyXG4gKiBAbmFtZSBuZy4kY29tcGlsZVByb3ZpZGVyXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICovXHJcbiRDb21waWxlUHJvdmlkZXIuJGluamVjdCA9IFsnJHByb3ZpZGUnXTtcclxuZnVuY3Rpb24gJENvbXBpbGVQcm92aWRlcigkcHJvdmlkZSkge1xyXG4gIHZhciBoYXNEaXJlY3RpdmVzID0ge30sXHJcbiAgICAgIFN1ZmZpeCA9ICdEaXJlY3RpdmUnLFxyXG4gICAgICBDT01NRU5UX0RJUkVDVElWRV9SRUdFWFAgPSAvXlxccypkaXJlY3RpdmVcXDpcXHMqKFtcXGRcXHdcXC1fXSspXFxzKyguKikkLyxcclxuICAgICAgQ0xBU1NfRElSRUNUSVZFX1JFR0VYUCA9IC8oKFtcXGRcXHdcXC1fXSspKD86XFw6KFteO10rKSk/Oz8pLyxcclxuICAgICAgYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3QgPSAvXlxccyooaHR0cHM/fGZ0cHxtYWlsdG98ZmlsZSk6LyxcclxuICAgICAgaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0ID0gL15cXHMqKGh0dHBzP3xmdHB8ZmlsZSk6fGRhdGE6aW1hZ2VcXC8vO1xyXG5cclxuICAvLyBSZWY6IGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvd2ViYXBwYXBpcy5odG1sI2V2ZW50LWhhbmRsZXItaWRsLWF0dHJpYnV0ZXNcclxuICAvLyBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IGZ1dHVyZSBET00gZXZlbnQgYXR0cmlidXRlIG5hbWVzIHdpbGwgYmVnaW4gd2l0aFxyXG4gIC8vICdvbicgYW5kIGJlIGNvbXBvc2VkIG9mIG9ubHkgRW5nbGlzaCBsZXR0ZXJzLlxyXG4gIHZhciBFVkVOVF9IQU5ETEVSX0FUVFJfUkVHRVhQID0gL14ob25bYS16XSp8Zm9ybWFjdGlvbikkLztcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgbmcuJGNvbXBpbGVQcm92aWRlciNkaXJlY3RpdmVcclxuICAgKiBAbWV0aG9kT2YgbmcuJGNvbXBpbGVQcm92aWRlclxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogUmVnaXN0ZXIgYSBuZXcgZGlyZWN0aXZlIHdpdGggdGhlIGNvbXBpbGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZGlyZWN0aXZlIGluIGNhbWVsLWNhc2UuIChpZSA8Y29kZT5uZ0JpbmQ8L2NvZGU+IHdoaWNoIHdpbGwgbWF0Y2ggYXNcclxuICAgKiAgICAgICAgICAgICAgICA8Y29kZT5uZy1iaW5kPC9jb2RlPikuXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbnxBcnJheX0gZGlyZWN0aXZlRmFjdG9yeSBBbiBpbmplY3RhYmxlIGRpcmVjdGl2ZSBmYWN0b3J5IGZ1bmN0aW9uLiBTZWUge0BsaW5rIGd1aWRlL2RpcmVjdGl2ZX0gZm9yIG1vcmVcclxuICAgKiAgICAgICAgICAgICAgICBpbmZvLlxyXG4gICAqIEByZXR1cm5zIHtuZy4kY29tcGlsZVByb3ZpZGVyfSBTZWxmIGZvciBjaGFpbmluZy5cclxuICAgKi9cclxuICAgdGhpcy5kaXJlY3RpdmUgPSBmdW5jdGlvbiByZWdpc3RlckRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmVGYWN0b3J5KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcobmFtZSkpIHtcclxuICAgICAgYXNzZXJ0QXJnKGRpcmVjdGl2ZUZhY3RvcnksICdkaXJlY3RpdmVGYWN0b3J5Jyk7XHJcbiAgICAgIGlmICghaGFzRGlyZWN0aXZlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgIGhhc0RpcmVjdGl2ZXNbbmFtZV0gPSBbXTtcclxuICAgICAgICAkcHJvdmlkZS5mYWN0b3J5KG5hbWUgKyBTdWZmaXgsIFsnJGluamVjdG9yJywgJyRleGNlcHRpb25IYW5kbGVyJyxcclxuICAgICAgICAgIGZ1bmN0aW9uKCRpbmplY3RvciwgJGV4Y2VwdGlvbkhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yRWFjaChoYXNEaXJlY3RpdmVzW25hbWVdLCBmdW5jdGlvbihkaXJlY3RpdmVGYWN0b3J5KSB7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSAkaW5qZWN0b3IuaW52b2tlKGRpcmVjdGl2ZUZhY3RvcnkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyZWN0aXZlKSkge1xyXG4gICAgICAgICAgICAgICAgICBkaXJlY3RpdmUgPSB7IGNvbXBpbGU6IHZhbHVlRm4oZGlyZWN0aXZlKSB9O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghZGlyZWN0aXZlLmNvbXBpbGUgJiYgZGlyZWN0aXZlLmxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlLmNvbXBpbGUgPSB2YWx1ZUZuKGRpcmVjdGl2ZS5saW5rKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZS5wcmlvcml0eSA9IGRpcmVjdGl2ZS5wcmlvcml0eSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLm5hbWUgPSBkaXJlY3RpdmUubmFtZSB8fCBuYW1lO1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLnJlcXVpcmUgPSBkaXJlY3RpdmUucmVxdWlyZSB8fCAoZGlyZWN0aXZlLmNvbnRyb2xsZXIgJiYgZGlyZWN0aXZlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLnJlc3RyaWN0ID0gZGlyZWN0aXZlLnJlc3RyaWN0IHx8ICdBJztcclxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXMucHVzaChkaXJlY3RpdmUpO1xyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXJlY3RpdmVzO1xyXG4gICAgICAgICAgfV0pO1xyXG4gICAgICB9XHJcbiAgICAgIGhhc0RpcmVjdGl2ZXNbbmFtZV0ucHVzaChkaXJlY3RpdmVGYWN0b3J5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvckVhY2gobmFtZSwgcmV2ZXJzZVBhcmFtcyhyZWdpc3RlckRpcmVjdGl2ZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLiRjb21waWxlUHJvdmlkZXIjYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3RcclxuICAgKiBAbWV0aG9kT2YgbmcuJGNvbXBpbGVQcm92aWRlclxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogUmV0cmlldmVzIG9yIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBpcyB1c2VkIGZvciB3aGl0ZWxpc3Rpbmcgb2Ygc2FmZVxyXG4gICAqIHVybHMgZHVyaW5nIGFbaHJlZl0gc2FuaXRpemF0aW9uLlxyXG4gICAqXHJcbiAgICogVGhlIHNhbml0aXphdGlvbiBpcyBhIHNlY3VyaXR5IG1lYXN1cmUgYWltZWQgYXQgcHJldmVudCBYU1MgYXR0YWNrcyB2aWEgaHRtbCBsaW5rcy5cclxuICAgKlxyXG4gICAqIEFueSB1cmwgYWJvdXQgdG8gYmUgYXNzaWduZWQgdG8gYVtocmVmXSB2aWEgZGF0YS1iaW5kaW5nIGlzIGZpcnN0IG5vcm1hbGl6ZWQgYW5kIHR1cm5lZCBpbnRvXHJcbiAgICogYW4gYWJzb2x1dGUgdXJsLiBBZnRlcndhcmRzLCB0aGUgdXJsIGlzIG1hdGNoZWQgYWdhaW5zdCB0aGUgYGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0YFxyXG4gICAqIHJlZ3VsYXIgZXhwcmVzc2lvbi4gSWYgYSBtYXRjaCBpcyBmb3VuZCwgdGhlIG9yaWdpbmFsIHVybCBpcyB3cml0dGVuIGludG8gdGhlIGRvbS4gT3RoZXJ3aXNlLFxyXG4gICAqIHRoZSBhYnNvbHV0ZSB1cmwgaXMgcHJlZml4ZWQgd2l0aCBgJ3Vuc2FmZTonYCBzdHJpbmcgYW5kIG9ubHkgdGhlbiBpcyBpdCB3cml0dGVuIGludG8gdGhlIERPTS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVnRXhwPX0gcmVnZXhwIE5ldyByZWdleHAgdG8gd2hpdGVsaXN0IHVybHMgd2l0aC5cclxuICAgKiBAcmV0dXJucyB7UmVnRXhwfG5nLiRjb21waWxlUHJvdmlkZXJ9IEN1cnJlbnQgUmVnRXhwIGlmIGNhbGxlZCB3aXRob3V0IHZhbHVlIG9yIHNlbGYgZm9yXHJcbiAgICogICAgY2hhaW5pbmcgb3RoZXJ3aXNlLlxyXG4gICAqL1xyXG4gIHRoaXMuYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3QgPSBmdW5jdGlvbihyZWdleHApIHtcclxuICAgIGlmIChpc0RlZmluZWQocmVnZXhwKSkge1xyXG4gICAgICBhSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdCA9IHJlZ2V4cDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3Q7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLiRjb21waWxlUHJvdmlkZXIjaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0XHJcbiAgICogQG1ldGhvZE9mIG5nLiRjb21waWxlUHJvdmlkZXJcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFJldHJpZXZlcyBvciBvdmVycmlkZXMgdGhlIGRlZmF1bHQgcmVndWxhciBleHByZXNzaW9uIHRoYXQgaXMgdXNlZCBmb3Igd2hpdGVsaXN0aW5nIG9mIHNhZmVcclxuICAgKiB1cmxzIGR1cmluZyBpbWdbc3JjXSBzYW5pdGl6YXRpb24uXHJcbiAgICpcclxuICAgKiBUaGUgc2FuaXRpemF0aW9uIGlzIGEgc2VjdXJpdHkgbWVhc3VyZSBhaW1lZCBhdCBwcmV2ZW50IFhTUyBhdHRhY2tzIHZpYSBodG1sIGxpbmtzLlxyXG4gICAqXHJcbiAgICogQW55IHVybCBhYm91dCB0byBiZSBhc3NpZ25lZCB0byBpbWdbc3JjXSB2aWEgZGF0YS1iaW5kaW5nIGlzIGZpcnN0IG5vcm1hbGl6ZWQgYW5kIHR1cm5lZCBpbnRvIGFuXHJcbiAgICogYWJzb2x1dGUgdXJsLiBBZnRlcndhcmRzLCB0aGUgdXJsIGlzIG1hdGNoZWQgYWdhaW5zdCB0aGUgYGltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdGAgcmVndWxhclxyXG4gICAqIGV4cHJlc3Npb24uIElmIGEgbWF0Y2ggaXMgZm91bmQsIHRoZSBvcmlnaW5hbCB1cmwgaXMgd3JpdHRlbiBpbnRvIHRoZSBkb20uIE90aGVyd2lzZSwgdGhlXHJcbiAgICogYWJzb2x1dGUgdXJsIGlzIHByZWZpeGVkIHdpdGggYCd1bnNhZmU6J2Agc3RyaW5nIGFuZCBvbmx5IHRoZW4gaXMgaXQgd3JpdHRlbiBpbnRvIHRoZSBET00uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1JlZ0V4cD19IHJlZ2V4cCBOZXcgcmVnZXhwIHRvIHdoaXRlbGlzdCB1cmxzIHdpdGguXHJcbiAgICogQHJldHVybnMge1JlZ0V4cHxuZy4kY29tcGlsZVByb3ZpZGVyfSBDdXJyZW50IFJlZ0V4cCBpZiBjYWxsZWQgd2l0aG91dCB2YWx1ZSBvciBzZWxmIGZvclxyXG4gICAqICAgIGNoYWluaW5nIG90aGVyd2lzZS5cclxuICAgKi9cclxuICB0aGlzLmltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdCA9IGZ1bmN0aW9uKHJlZ2V4cCkge1xyXG4gICAgaWYgKGlzRGVmaW5lZChyZWdleHApKSB7XHJcbiAgICAgIGltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdCA9IHJlZ2V4cDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0O1xyXG4gIH07XHJcblxyXG5cclxuICB0aGlzLiRnZXQgPSBbXHJcbiAgICAgICAgICAgICckaW5qZWN0b3InLCAnJGludGVycG9sYXRlJywgJyRleGNlcHRpb25IYW5kbGVyJywgJyRodHRwJywgJyR0ZW1wbGF0ZUNhY2hlJywgJyRwYXJzZScsXHJcbiAgICAgICAgICAgICckY29udHJvbGxlcicsICckcm9vdFNjb3BlJywgJyRkb2N1bWVudCcsICckc2NlJywgJyQkdXJsVXRpbHMnLCAnJGFuaW1hdGUnLFxyXG4gICAgZnVuY3Rpb24oJGluamVjdG9yLCAgICRpbnRlcnBvbGF0ZSwgICAkZXhjZXB0aW9uSGFuZGxlciwgICAkaHR0cCwgICAkdGVtcGxhdGVDYWNoZSwgICAkcGFyc2UsXHJcbiAgICAgICAgICAgICAkY29udHJvbGxlciwgICAkcm9vdFNjb3BlLCAgICRkb2N1bWVudCwgICAkc2NlLCAgICQkdXJsVXRpbHMsICRhbmltYXRlKSB7XHJcblxyXG4gICAgdmFyIEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XHJcbiAgICAgIHRoaXMuJCRlbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgdGhpcy4kYXR0ciA9IGF0dHIgfHwge307XHJcbiAgICB9O1xyXG5cclxuICAgIEF0dHJpYnV0ZXMucHJvdG90eXBlID0ge1xyXG4gICAgICAkbm9ybWFsaXplOiBkaXJlY3RpdmVOb3JtYWxpemUsXHJcblxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlcyMkYWRkQ2xhc3NcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRjb21waWxlLmRpcmVjdGl2ZS5BdHRyaWJ1dGVzXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogQWRkcyB0aGUgQ1NTIGNsYXNzIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgY2xhc3NWYWwgcGFyYW1ldGVyIHRvIHRoZSBlbGVtZW50LiBJZiBhbmltYXRpb25zXHJcbiAgICAgICAqIGFyZSBlbmFibGVkIHRoZW4gYW4gYW5pbWF0aW9uIHdpbGwgYmUgdHJpZ2dlcmVkIGZvciB0aGUgY2xhc3MgYWRkaXRpb24uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1ZhbCBUaGUgY2xhc3NOYW1lIHZhbHVlIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgZWxlbWVudFxyXG4gICAgICAgKi9cclxuICAgICAgJGFkZENsYXNzIDogZnVuY3Rpb24oY2xhc3NWYWwpIHtcclxuICAgICAgICBpZihjbGFzc1ZhbCAmJiBjbGFzc1ZhbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAkYW5pbWF0ZS5hZGRDbGFzcyh0aGlzLiQkZWxlbWVudCwgY2xhc3NWYWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXMjJHJlbW92ZUNsYXNzXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlc1xyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFJlbW92ZXMgdGhlIENTUyBjbGFzcyB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGNsYXNzVmFsIHBhcmFtZXRlciBmcm9tIHRoZSBlbGVtZW50LiBJZiBhbmltYXRpb25zXHJcbiAgICAgICAqIGFyZSBlbmFibGVkIHRoZW4gYW4gYW5pbWF0aW9uIHdpbGwgYmUgdHJpZ2dlcmVkIGZvciB0aGUgY2xhc3MgcmVtb3ZhbC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVmFsIFRoZSBjbGFzc05hbWUgdmFsdWUgdGhhdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudFxyXG4gICAgICAgKi9cclxuICAgICAgJHJlbW92ZUNsYXNzIDogZnVuY3Rpb24oY2xhc3NWYWwpIHtcclxuICAgICAgICBpZihjbGFzc1ZhbCAmJiBjbGFzc1ZhbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAkYW5pbWF0ZS5yZW1vdmVDbGFzcyh0aGlzLiQkZWxlbWVudCwgY2xhc3NWYWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZXQgYSBub3JtYWxpemVkIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudCBpbiBhIHdheSBzdWNoIHRoYXQgYWxsIGRpcmVjdGl2ZXNcclxuICAgICAgICogY2FuIHNoYXJlIHRoZSBhdHRyaWJ1dGUuIFRoaXMgZnVuY3Rpb24gcHJvcGVybHkgaGFuZGxlcyBib29sZWFuIGF0dHJpYnV0ZXMuXHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgTm9ybWFsaXplZCBrZXkuIChpZSBuZ0F0dHJpYnV0ZSlcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd8Ym9vbGVhbn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC4gSWYgYG51bGxgIGF0dHJpYnV0ZSB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHdyaXRlQXR0ciBJZiBmYWxzZSwgZG9lcyBub3Qgd3JpdGUgdGhlIHZhbHVlIHRvIERPTSBlbGVtZW50IGF0dHJpYnV0ZS5cclxuICAgICAgICogICAgIERlZmF1bHRzIHRvIHRydWUuXHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXR0ck5hbWUgT3B0aW9uYWwgbm9uZSBub3JtYWxpemVkIG5hbWUuIERlZmF1bHRzIHRvIGtleS5cclxuICAgICAgICovXHJcbiAgICAgICRzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIHdyaXRlQXR0ciwgYXR0ck5hbWUpIHtcclxuICAgICAgICAvL3NwZWNpYWwgY2FzZSBmb3IgY2xhc3MgYXR0cmlidXRlIGFkZGl0aW9uICsgcmVtb3ZhbFxyXG4gICAgICAgIC8vc28gdGhhdCBjbGFzcyBjaGFuZ2VzIGNhbiB0YXAgaW50byB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgLy9ob29rcyBwcm92aWRlZCBieSB0aGUgJGFuaW1hdGUgc2VydmljZVxyXG4gICAgICAgIGlmKGtleSA9PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8ICcnO1xyXG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLiQkZWxlbWVudC5hdHRyKCdjbGFzcycpIHx8ICcnO1xyXG4gICAgICAgICAgdGhpcy4kcmVtb3ZlQ2xhc3ModG9rZW5EaWZmZXJlbmNlKGN1cnJlbnQsIHZhbHVlKS5qb2luKCcgJykpO1xyXG4gICAgICAgICAgdGhpcy4kYWRkQ2xhc3ModG9rZW5EaWZmZXJlbmNlKHZhbHVlLCBjdXJyZW50KS5qb2luKCcgJykpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgYm9vbGVhbktleSA9IGdldEJvb2xlYW5BdHRyTmFtZSh0aGlzLiQkZWxlbWVudFswXSwga2V5KSxcclxuICAgICAgICAgICAgICBub3JtYWxpemVkVmFsLFxyXG4gICAgICAgICAgICAgIG5vZGVOYW1lO1xyXG5cclxuICAgICAgICAgIGlmIChib29sZWFuS2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuJCRlbGVtZW50LnByb3Aoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYm9vbGVhbktleTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAvLyB0cmFuc2xhdGUgbm9ybWFsaXplZCBrZXkgdG8gYWN0dWFsIGtleVxyXG4gICAgICAgICAgaWYgKGF0dHJOYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGF0dHJba2V5XSA9IGF0dHJOYW1lO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXR0ck5hbWUgPSB0aGlzLiRhdHRyW2tleV07XHJcbiAgICAgICAgICAgIGlmICghYXR0ck5hbWUpIHtcclxuICAgICAgICAgICAgICB0aGlzLiRhdHRyW2tleV0gPSBhdHRyTmFtZSA9IHNuYWtlX2Nhc2Uoa2V5LCAnLScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbm9kZU5hbWUgPSBub2RlTmFtZV8odGhpcy4kJGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgIC8vIHNhbml0aXplIGFbaHJlZl0gYW5kIGltZ1tzcmNdIHZhbHVlc1xyXG4gICAgICAgICAgaWYgKChub2RlTmFtZSA9PT0gJ0EnICYmIGtleSA9PT0gJ2hyZWYnKSB8fFxyXG4gICAgICAgICAgICAgIChub2RlTmFtZSA9PT0gJ0lNRycgJiYga2V5ID09PSAnc3JjJykpIHtcclxuICAgICAgICAgICAgLy8gTk9URTogJCR1cmxVdGlscy5yZXNvbHZlKCkgZG9lc24ndCBzdXBwb3J0IElFIDwgOCBzbyB3ZSBkb24ndCBzYW5pdGl6ZSBmb3IgdGhhdCBjYXNlLlxyXG4gICAgICAgICAgICBpZiAoIW1zaWUgfHwgbXNpZSA+PSA4ICkge1xyXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRWYWwgPSAkJHVybFV0aWxzLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICAgIGlmIChub3JtYWxpemVkVmFsICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKChrZXkgPT09ICdocmVmJyAmJiAhbm9ybWFsaXplZFZhbC5tYXRjaChhSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGtleSA9PT0gJ3NyYycgJiYgIW5vcm1hbGl6ZWRWYWwubWF0Y2goaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0KSkpIHtcclxuICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gdmFsdWUgPSAndW5zYWZlOicgKyBub3JtYWxpemVkVmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICh3cml0ZUF0dHIgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy4kJGVsZW1lbnQucmVtb3ZlQXR0cihhdHRyTmFtZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy4kJGVsZW1lbnQuYXR0cihhdHRyTmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaXJlIG9ic2VydmVyc1xyXG4gICAgICAgIHZhciAkJG9ic2VydmVycyA9IHRoaXMuJCRvYnNlcnZlcnM7XHJcbiAgICAgICAgJCRvYnNlcnZlcnMgJiYgZm9yRWFjaCgkJG9ic2VydmVyc1trZXldLCBmdW5jdGlvbihmbikge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm4odmFsdWUpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdG9rZW5EaWZmZXJlbmNlKHN0cjEsIHN0cjIpIHtcclxuICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXSxcclxuICAgICAgICAgICAgICB0b2tlbnMxID0gc3RyMS5zcGxpdCgvXFxzKy8pLFxyXG4gICAgICAgICAgICAgIHRva2VuczIgPSBzdHIyLnNwbGl0KC9cXHMrLyk7XHJcblxyXG4gICAgICAgICAgb3V0ZXI6XHJcbiAgICAgICAgICBmb3IodmFyIGk9MDtpPHRva2VuczEubGVuZ3RoO2krKykge1xyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnMxW2ldO1xyXG4gICAgICAgICAgICBmb3IodmFyIGo9MDtqPHRva2VuczIubGVuZ3RoO2orKykge1xyXG4gICAgICAgICAgICAgIGlmKHRva2VuID09IHRva2VuczJbal0pIGNvbnRpbnVlIG91dGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRva2VuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSxcclxuXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogT2JzZXJ2ZSBhbiBpbnRlcnBvbGF0ZWQgYXR0cmlidXRlLlxyXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgd2lsbCBuZXZlciBiZSBjYWxsZWQsIGlmIGdpdmVuIGF0dHJpYnV0ZSBpcyBub3QgaW50ZXJwb2xhdGVkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IE5vcm1hbGl6ZWQga2V5LiAoaWUgbmdBdHRyaWJ1dGUpIC5cclxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigqKX0gZm4gRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgYXR0cmlidXRlIHZhbHVlIGNoYW5nZXMuXHJcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigqKX0gdGhlIGBmbmAgRnVuY3Rpb24gcGFzc2VkIGluLlxyXG4gICAgICAgKi9cclxuICAgICAgJG9ic2VydmU6IGZ1bmN0aW9uKGtleSwgZm4pIHtcclxuICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLFxyXG4gICAgICAgICAgICAkJG9ic2VydmVycyA9IChhdHRycy4kJG9ic2VydmVycyB8fCAoYXR0cnMuJCRvYnNlcnZlcnMgPSB7fSkpLFxyXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSAoJCRvYnNlcnZlcnNba2V5XSB8fCAoJCRvYnNlcnZlcnNba2V5XSA9IFtdKSk7XHJcblxyXG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGZuKTtcclxuICAgICAgICAkcm9vdFNjb3BlLiRldmFsQXN5bmMoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoIWxpc3RlbmVycy4kJGludGVyKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIG9uZSByZWdpc3RlcmVkIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uLCBzbyBsZXRzIGNhbGwgaXQgbWFudWFsbHlcclxuICAgICAgICAgICAgZm4oYXR0cnNba2V5XSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciB1cmxTYW5pdGl6YXRpb25Ob2RlID0gJGRvY3VtZW50WzBdLmNyZWF0ZUVsZW1lbnQoJ2EnKSxcclxuICAgICAgICBzdGFydFN5bWJvbCA9ICRpbnRlcnBvbGF0ZS5zdGFydFN5bWJvbCgpLFxyXG4gICAgICAgIGVuZFN5bWJvbCA9ICRpbnRlcnBvbGF0ZS5lbmRTeW1ib2woKSxcclxuICAgICAgICBkZW5vcm1hbGl6ZVRlbXBsYXRlID0gKHN0YXJ0U3ltYm9sID09ICd7eycgfHwgZW5kU3ltYm9sICA9PSAnfX0nKVxyXG4gICAgICAgICAgICA/IGlkZW50aXR5XHJcbiAgICAgICAgICAgIDogZnVuY3Rpb24gZGVub3JtYWxpemVUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHtcXHsvZywgc3RhcnRTeW1ib2wpLnJlcGxhY2UoL319L2csIGVuZFN5bWJvbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBOR19BVFRSX0JJTkRJTkcgPSAvXm5nQXR0cltBLVpdLztcclxuXHJcblxyXG4gICAgcmV0dXJuIGNvbXBpbGU7XHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBpbGUoJGNvbXBpbGVOb2RlcywgdHJhbnNjbHVkZUZuLCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlKSB7XHJcbiAgICAgIGlmICghKCRjb21waWxlTm9kZXMgaW5zdGFuY2VvZiBqcUxpdGUpKSB7XHJcbiAgICAgICAgLy8ganF1ZXJ5IGFsd2F5cyByZXdyYXBzLCB3aGVyZWFzIHdlIG5lZWQgdG8gcHJlc2VydmUgdGhlIG9yaWdpbmFsIHNlbGVjdG9yIHNvIHRoYXQgd2UgY2FuIG1vZGlmeSBpdC5cclxuICAgICAgICAkY29tcGlsZU5vZGVzID0ganFMaXRlKCRjb21waWxlTm9kZXMpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFdlIGNhbiBub3QgY29tcGlsZSB0b3AgbGV2ZWwgdGV4dCBlbGVtZW50cyBzaW5jZSB0ZXh0IG5vZGVzIGNhbiBiZSBtZXJnZWQgYW5kIHdlIHdpbGxcclxuICAgICAgLy8gbm90IGJlIGFibGUgdG8gYXR0YWNoIHNjb3BlIGRhdGEgdG8gdGhlbSwgc28gd2Ugd2lsbCB3cmFwIHRoZW0gaW4gPHNwYW4+XHJcbiAgICAgIGZvckVhY2goJGNvbXBpbGVOb2RlcywgZnVuY3Rpb24obm9kZSwgaW5kZXgpe1xyXG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgLyogdGV4dCBub2RlICovICYmIG5vZGUubm9kZVZhbHVlLm1hdGNoKC9cXFMrLykgLyogbm9uLWVtcHR5ICovICkge1xyXG4gICAgICAgICAgJGNvbXBpbGVOb2Rlc1tpbmRleF0gPSBub2RlID0ganFMaXRlKG5vZGUpLndyYXAoJzxzcGFuPjwvc3Bhbj4nKS5wYXJlbnQoKVswXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICB2YXIgY29tcG9zaXRlTGlua0ZuID0gY29tcGlsZU5vZGVzKCRjb21waWxlTm9kZXMsIHRyYW5zY2x1ZGVGbiwgJGNvbXBpbGVOb2RlcywgbWF4UHJpb3JpdHksIGlnbm9yZURpcmVjdGl2ZSk7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwdWJsaWNMaW5rRm4oc2NvcGUsIGNsb25lQ29ubmVjdEZuKXtcclxuICAgICAgICBhc3NlcnRBcmcoc2NvcGUsICdzY29wZScpO1xyXG4gICAgICAgIC8vIGltcG9ydGFudCEhOiB3ZSBtdXN0IGNhbGwgb3VyIGpxTGl0ZS5jbG9uZSgpIHNpbmNlIHRoZSBqUXVlcnkgb25lIGlzIHRyeWluZyB0byBiZSBzbWFydFxyXG4gICAgICAgIC8vIGFuZCBzb21ldGltZXMgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBET00uXHJcbiAgICAgICAgdmFyICRsaW5rTm9kZSA9IGNsb25lQ29ubmVjdEZuXHJcbiAgICAgICAgICA/IEpRTGl0ZVByb3RvdHlwZS5jbG9uZS5jYWxsKCRjb21waWxlTm9kZXMpIC8vIElNUE9SVEFOVCEhIVxyXG4gICAgICAgICAgOiAkY29tcGlsZU5vZGVzO1xyXG5cclxuICAgICAgICAvLyBBdHRhY2ggc2NvcGUgb25seSB0byBub24tdGV4dCBub2Rlcy5cclxuICAgICAgICBmb3IodmFyIGkgPSAwLCBpaSA9ICRsaW5rTm9kZS5sZW5ndGg7IGk8aWk7IGkrKykge1xyXG4gICAgICAgICAgdmFyIG5vZGUgPSAkbGlua05vZGVbaV07XHJcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxIC8qIGVsZW1lbnQgKi8gfHwgbm9kZS5ub2RlVHlwZSA9PSA5IC8qIGRvY3VtZW50ICovKSB7XHJcbiAgICAgICAgICAgICRsaW5rTm9kZS5lcShpKS5kYXRhKCckc2NvcGUnLCBzY29wZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNhZmVBZGRDbGFzcygkbGlua05vZGUsICduZy1zY29wZScpO1xyXG4gICAgICAgIGlmIChjbG9uZUNvbm5lY3RGbikgY2xvbmVDb25uZWN0Rm4oJGxpbmtOb2RlLCBzY29wZSk7XHJcbiAgICAgICAgaWYgKGNvbXBvc2l0ZUxpbmtGbikgY29tcG9zaXRlTGlua0ZuKHNjb3BlLCAkbGlua05vZGUsICRsaW5rTm9kZSk7XHJcbiAgICAgICAgcmV0dXJuICRsaW5rTm9kZTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzYWZlQWRkQ2xhc3MoJGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgICRlbGVtZW50LmFkZENsYXNzKGNsYXNzTmFtZSk7XHJcbiAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgIC8vIGlnbm9yZSwgc2luY2UgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgdHJ5aW5nIHRvIHNldCBjbGFzcyBvblxyXG4gICAgICAgIC8vIFNWRyBlbGVtZW50LCB3aGVyZSBjbGFzcyBuYW1lIGlzIHJlYWQtb25seS5cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGlsZSBmdW5jdGlvbiBtYXRjaGVzIGVhY2ggbm9kZSBpbiBub2RlTGlzdCBhZ2FpbnN0IHRoZSBkaXJlY3RpdmVzLiBPbmNlIGFsbCBkaXJlY3RpdmVzXHJcbiAgICAgKiBmb3IgYSBwYXJ0aWN1bGFyIG5vZGUgYXJlIGNvbGxlY3RlZCB0aGVpciBjb21waWxlIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQuIFRoZSBjb21waWxlXHJcbiAgICAgKiBmdW5jdGlvbnMgcmV0dXJuIHZhbHVlcyAtIHRoZSBsaW5raW5nIGZ1bmN0aW9ucyAtIGFyZSBjb21iaW5lZCBpbnRvIGEgY29tcG9zaXRlIGxpbmtpbmdcclxuICAgICAqIGZ1bmN0aW9uLCB3aGljaCBpcyB0aGUgYSBsaW5raW5nIGZ1bmN0aW9uIGZvciB0aGUgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge05vZGVMaXN0fSBub2RlTGlzdCBhbiBhcnJheSBvZiBub2RlcyBvciBOb2RlTGlzdCB0byBjb21waWxlXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGFuZ3VsYXIuU2NvcGVbLCBjbG9uZUF0dGFjaEZuXX0gdHJhbnNjbHVkZUZuIEEgbGlua2luZyBmdW5jdGlvbiwgd2hlcmUgdGhlXHJcbiAgICAgKiAgICAgICAgc2NvcGUgYXJndW1lbnQgaXMgYXV0by1nZW5lcmF0ZWQgdG8gdGhlIG5ldyBjaGlsZCBvZiB0aGUgdHJhbnNjbHVkZWQgcGFyZW50IHNjb3BlLlxyXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50PX0gJHJvb3RFbGVtZW50IElmIHRoZSBub2RlTGlzdCBpcyB0aGUgcm9vdCBvZiB0aGUgY29tcGlsYXRpb24gdHJlZSB0aGVuIHRoZVxyXG4gICAgICogICAgICAgIHJvb3RFbGVtZW50IG11c3QgYmUgc2V0IHRoZSBqcUxpdGUgY29sbGVjdGlvbiBvZiB0aGUgY29tcGlsZSByb290LiBUaGlzIGlzXHJcbiAgICAgKiAgICAgICAgbmVlZGVkIHNvIHRoYXQgdGhlIGpxTGl0ZSBjb2xsZWN0aW9uIGl0ZW1zIGNhbiBiZSByZXBsYWNlZCB3aXRoIHdpZGdldHMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG1heCBkaXJlY3RpdmUgcHJpb3JpdHlcclxuICAgICAqIEByZXR1cm5zIHs/ZnVuY3Rpb259IEEgY29tcG9zaXRlIGxpbmtpbmcgZnVuY3Rpb24gb2YgYWxsIG9mIHRoZSBtYXRjaGVkIGRpcmVjdGl2ZXMgb3IgbnVsbC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29tcGlsZU5vZGVzKG5vZGVMaXN0LCB0cmFuc2NsdWRlRm4sICRyb290RWxlbWVudCwgbWF4UHJpb3JpdHksIGlnbm9yZURpcmVjdGl2ZSkge1xyXG4gICAgICB2YXIgbGlua0ZucyA9IFtdLFxyXG4gICAgICAgICAgbm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4sIGRpcmVjdGl2ZXMsIGF0dHJzLCBsaW5rRm5Gb3VuZDtcclxuXHJcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGF0dHJzID0gbmV3IEF0dHJpYnV0ZXMoKTtcclxuXHJcbiAgICAgICAgLy8gd2UgbXVzdCBhbHdheXMgcmVmZXIgdG8gbm9kZUxpc3RbaV0gc2luY2UgdGhlIG5vZGVzIGNhbiBiZSByZXBsYWNlZCB1bmRlcm5lYXRoIHVzLlxyXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBjb2xsZWN0RGlyZWN0aXZlcyhub2RlTGlzdFtpXSwgW10sIGF0dHJzLCBpID09IDAgPyBtYXhQcmlvcml0eSA6IHVuZGVmaW5lZCwgaWdub3JlRGlyZWN0aXZlKTtcclxuXHJcbiAgICAgICAgbm9kZUxpbmtGbiA9IChkaXJlY3RpdmVzLmxlbmd0aClcclxuICAgICAgICAgICAgPyBhcHBseURpcmVjdGl2ZXNUb05vZGUoZGlyZWN0aXZlcywgbm9kZUxpc3RbaV0sIGF0dHJzLCB0cmFuc2NsdWRlRm4sICRyb290RWxlbWVudClcclxuICAgICAgICAgICAgOiBudWxsO1xyXG5cclxuICAgICAgICBjaGlsZExpbmtGbiA9IChub2RlTGlua0ZuICYmIG5vZGVMaW5rRm4udGVybWluYWwgfHwgIW5vZGVMaXN0W2ldLmNoaWxkTm9kZXMgfHwgIW5vZGVMaXN0W2ldLmNoaWxkTm9kZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgICAgOiBjb21waWxlTm9kZXMobm9kZUxpc3RbaV0uY2hpbGROb2RlcyxcclxuICAgICAgICAgICAgICAgICBub2RlTGlua0ZuID8gbm9kZUxpbmtGbi50cmFuc2NsdWRlIDogdHJhbnNjbHVkZUZuKTtcclxuXHJcbiAgICAgICAgbGlua0Zucy5wdXNoKG5vZGVMaW5rRm4pO1xyXG4gICAgICAgIGxpbmtGbnMucHVzaChjaGlsZExpbmtGbik7XHJcbiAgICAgICAgbGlua0ZuRm91bmQgPSAobGlua0ZuRm91bmQgfHwgbm9kZUxpbmtGbiB8fCBjaGlsZExpbmtGbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJldHVybiBhIGxpbmtpbmcgZnVuY3Rpb24gaWYgd2UgaGF2ZSBmb3VuZCBhbnl0aGluZywgbnVsbCBvdGhlcndpc2VcclxuICAgICAgcmV0dXJuIGxpbmtGbkZvdW5kID8gY29tcG9zaXRlTGlua0ZuIDogbnVsbDtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBvc2l0ZUxpbmtGbihzY29wZSwgbm9kZUxpc3QsICRyb290RWxlbWVudCwgYm91bmRUcmFuc2NsdWRlRm4pIHtcclxuICAgICAgICB2YXIgbm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4sIG5vZGUsIGNoaWxkU2NvcGUsIGNoaWxkVHJhbnNjbHVkZUZuLCBpLCBpaSwgbjtcclxuXHJcbiAgICAgICAgLy8gY29weSBub2RlTGlzdCBzbyB0aGF0IGxpbmtpbmcgZG9lc24ndCBicmVhayBkdWUgdG8gbGl2ZSBsaXN0IHVwZGF0ZXMuXHJcbiAgICAgICAgdmFyIHN0YWJsZU5vZGVMaXN0ID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBub2RlTGlzdC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgICBzdGFibGVOb2RlTGlzdC5wdXNoKG5vZGVMaXN0W2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcihpID0gMCwgbiA9IDAsIGlpID0gbGlua0Zucy5sZW5ndGg7IGkgPCBpaTsgbisrKSB7XHJcbiAgICAgICAgICBub2RlID0gc3RhYmxlTm9kZUxpc3Rbbl07XHJcbiAgICAgICAgICBub2RlTGlua0ZuID0gbGlua0Zuc1tpKytdO1xyXG4gICAgICAgICAgY2hpbGRMaW5rRm4gPSBsaW5rRm5zW2krK107XHJcblxyXG4gICAgICAgICAgaWYgKG5vZGVMaW5rRm4pIHtcclxuICAgICAgICAgICAgaWYgKG5vZGVMaW5rRm4uc2NvcGUpIHtcclxuICAgICAgICAgICAgICBjaGlsZFNjb3BlID0gc2NvcGUuJG5ldyhpc09iamVjdChub2RlTGlua0ZuLnNjb3BlKSk7XHJcbiAgICAgICAgICAgICAganFMaXRlKG5vZGUpLmRhdGEoJyRzY29wZScsIGNoaWxkU2NvcGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNoaWxkU2NvcGUgPSBzY29wZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGlsZFRyYW5zY2x1ZGVGbiA9IG5vZGVMaW5rRm4udHJhbnNjbHVkZTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJhbnNjbHVkZUZuIHx8ICghYm91bmRUcmFuc2NsdWRlRm4gJiYgdHJhbnNjbHVkZUZuKSkge1xyXG4gICAgICAgICAgICAgIG5vZGVMaW5rRm4oY2hpbGRMaW5rRm4sIGNoaWxkU2NvcGUsIG5vZGUsICRyb290RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKHRyYW5zY2x1ZGVGbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjbG9uZUZuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNjbHVkZVNjb3BlID0gc2NvcGUuJG5ldygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNjbHVkZVNjb3BlLiQkdHJhbnNjbHVkZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2NsdWRlRm4odHJhbnNjbHVkZVNjb3BlLCBjbG9uZUZuKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbignJGRlc3Ryb3knLCBiaW5kKHRyYW5zY2x1ZGVTY29wZSwgdHJhbnNjbHVkZVNjb3BlLiRkZXN0cm95KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgfSkoY2hpbGRUcmFuc2NsdWRlRm4gfHwgdHJhbnNjbHVkZUZuKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbm9kZUxpbmtGbihjaGlsZExpbmtGbiwgY2hpbGRTY29wZSwgbm9kZSwgdW5kZWZpbmVkLCBib3VuZFRyYW5zY2x1ZGVGbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRMaW5rRm4pIHtcclxuICAgICAgICAgICAgY2hpbGRMaW5rRm4oc2NvcGUsIG5vZGUuY2hpbGROb2RlcywgdW5kZWZpbmVkLCBib3VuZFRyYW5zY2x1ZGVGbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9va3MgZm9yIGRpcmVjdGl2ZXMgb24gdGhlIGdpdmVuIG5vZGUgYW5kIGFkZHMgdGhlbSB0byB0aGUgZGlyZWN0aXZlIGNvbGxlY3Rpb24gd2hpY2ggaXNcclxuICAgICAqIHNvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBOb2RlIHRvIHNlYXJjaC5cclxuICAgICAqIEBwYXJhbSBkaXJlY3RpdmVzIEFuIGFycmF5IHRvIHdoaWNoIHRoZSBkaXJlY3RpdmVzIGFyZSBhZGRlZCB0by4gVGhpcyBhcnJheSBpcyBzb3J0ZWQgYmVmb3JlXHJcbiAgICAgKiAgICAgICAgdGhlIGZ1bmN0aW9uIHJldHVybnMuXHJcbiAgICAgKiBAcGFyYW0gYXR0cnMgVGhlIHNoYXJlZCBhdHRycyBvYmplY3Qgd2hpY2ggaXMgdXNlZCB0byBwb3B1bGF0ZSB0aGUgbm9ybWFsaXplZCBhdHRyaWJ1dGVzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBtYXhQcmlvcml0eSBNYXggZGlyZWN0aXZlIHByaW9yaXR5LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb2xsZWN0RGlyZWN0aXZlcyhub2RlLCBkaXJlY3RpdmVzLCBhdHRycywgbWF4UHJpb3JpdHksIGlnbm9yZURpcmVjdGl2ZSkge1xyXG4gICAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlLFxyXG4gICAgICAgICAgYXR0cnNNYXAgPSBhdHRycy4kYXR0cixcclxuICAgICAgICAgIG1hdGNoLFxyXG4gICAgICAgICAgY2xhc3NOYW1lO1xyXG5cclxuICAgICAgc3dpdGNoKG5vZGVUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAxOiAvKiBFbGVtZW50ICovXHJcbiAgICAgICAgICAvLyB1c2UgdGhlIG5vZGUgbmFtZTogPGRpcmVjdGl2ZT5cclxuICAgICAgICAgIGFkZERpcmVjdGl2ZShkaXJlY3RpdmVzLFxyXG4gICAgICAgICAgICAgIGRpcmVjdGl2ZU5vcm1hbGl6ZShub2RlTmFtZV8obm9kZSkudG9Mb3dlckNhc2UoKSksICdFJywgbWF4UHJpb3JpdHksIGlnbm9yZURpcmVjdGl2ZSk7XHJcblxyXG4gICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICBmb3IgKHZhciBhdHRyLCBuYW1lLCBuTmFtZSwgbmdBdHRyTmFtZSwgdmFsdWUsIG5BdHRycyA9IG5vZGUuYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgIGogPSAwLCBqaiA9IG5BdHRycyAmJiBuQXR0cnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xyXG4gICAgICAgICAgICB2YXIgYXR0clN0YXJ0TmFtZTtcclxuICAgICAgICAgICAgdmFyIGF0dHJFbmROYW1lO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXg7XHJcblxyXG4gICAgICAgICAgICBhdHRyID0gbkF0dHJzW2pdO1xyXG4gICAgICAgICAgICBpZiAoIW1zaWUgfHwgbXNpZSA+PSA4IHx8IGF0dHIuc3BlY2lmaWVkKSB7XHJcbiAgICAgICAgICAgICAgbmFtZSA9IGF0dHIubmFtZTtcclxuICAgICAgICAgICAgICAvLyBzdXBwb3J0IG5nQXR0ciBhdHRyaWJ1dGUgYmluZGluZ1xyXG4gICAgICAgICAgICAgIG5nQXR0ck5hbWUgPSBkaXJlY3RpdmVOb3JtYWxpemUobmFtZSk7XHJcbiAgICAgICAgICAgICAgaWYgKE5HX0FUVFJfQklORElORy50ZXN0KG5nQXR0ck5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmdBdHRyTmFtZS5zdWJzdHIoNikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKChpbmRleCA9IG5nQXR0ck5hbWUubGFzdEluZGV4T2YoJ1N0YXJ0JykpICE9IC0xICYmIGluZGV4ID09IG5nQXR0ck5hbWUubGVuZ3RoIC0gNSkge1xyXG4gICAgICAgICAgICAgICAgYXR0clN0YXJ0TmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICBhdHRyRW5kTmFtZSA9IG5hbWUuc3Vic3RyKDAsIG5hbWUubGVuZ3RoIC0gNSkgKyAnZW5kJztcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLCBuYW1lLmxlbmd0aCAtIDYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBuTmFtZSA9IGRpcmVjdGl2ZU5vcm1hbGl6ZShuYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgICAgICAgIGF0dHJzTWFwW25OYW1lXSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgYXR0cnNbbk5hbWVdID0gdmFsdWUgPSB0cmltKChtc2llICYmIG5hbWUgPT0gJ2hyZWYnKVxyXG4gICAgICAgICAgICAgICAgPyBkZWNvZGVVUklDb21wb25lbnQobm9kZS5nZXRBdHRyaWJ1dGUobmFtZSwgMikpXHJcbiAgICAgICAgICAgICAgICA6IGF0dHIudmFsdWUpO1xyXG4gICAgICAgICAgICAgIGlmIChnZXRCb29sZWFuQXR0ck5hbWUobm9kZSwgbk5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyc1tuTmFtZV0gPSB0cnVlOyAvLyBwcmVzZW5jZSBtZWFucyB0cnVlXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGFkZEF0dHJJbnRlcnBvbGF0ZURpcmVjdGl2ZShub2RlLCBkaXJlY3RpdmVzLCB2YWx1ZSwgbk5hbWUpO1xyXG4gICAgICAgICAgICAgIGFkZERpcmVjdGl2ZShkaXJlY3RpdmVzLCBuTmFtZSwgJ0EnLCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlLCBhdHRyU3RhcnROYW1lLCBhdHRyRW5kTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyB1c2UgY2xhc3MgYXMgZGlyZWN0aXZlXHJcbiAgICAgICAgICBjbGFzc05hbWUgPSBub2RlLmNsYXNzTmFtZTtcclxuICAgICAgICAgIGlmIChpc1N0cmluZyhjbGFzc05hbWUpICYmIGNsYXNzTmFtZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gQ0xBU1NfRElSRUNUSVZFX1JFR0VYUC5leGVjKGNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgICBuTmFtZSA9IGRpcmVjdGl2ZU5vcm1hbGl6ZShtYXRjaFsyXSk7XHJcbiAgICAgICAgICAgICAgaWYgKGFkZERpcmVjdGl2ZShkaXJlY3RpdmVzLCBuTmFtZSwgJ0MnLCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlKSkge1xyXG4gICAgICAgICAgICAgICAgYXR0cnNbbk5hbWVdID0gdHJpbShtYXRjaFszXSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5zdWJzdHIobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6IC8qIFRleHQgTm9kZSAqL1xyXG4gICAgICAgICAgYWRkVGV4dEludGVycG9sYXRlRGlyZWN0aXZlKGRpcmVjdGl2ZXMsIG5vZGUubm9kZVZhbHVlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgODogLyogQ29tbWVudCAqL1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbWF0Y2ggPSBDT01NRU5UX0RJUkVDVElWRV9SRUdFWFAuZXhlYyhub2RlLm5vZGVWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgIG5OYW1lID0gZGlyZWN0aXZlTm9ybWFsaXplKG1hdGNoWzFdKTtcclxuICAgICAgICAgICAgICBpZiAoYWRkRGlyZWN0aXZlKGRpcmVjdGl2ZXMsIG5OYW1lLCAnTScsIG1heFByaW9yaXR5LCBpZ25vcmVEaXJlY3RpdmUpKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyc1tuTmFtZV0gPSB0cmltKG1hdGNoWzJdKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gdHVybnMgb3V0IHRoYXQgdW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzIElFOSB0aHJvd3MgZXJyb3JzIHdoZW4gb25lIGF0dGVtcHRzIHRvIHJlYWQgY29tbWVudCdzIG5vZGUgdmFsdWUuXHJcbiAgICAgICAgICAgIC8vIEp1c3QgaWdub3JlIGl0IGFuZCBjb250aW51ZS4gKENhbid0IHNlZW0gdG8gcmVwcm9kdWNlIGluIHRlc3QgY2FzZS4pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgZGlyZWN0aXZlcy5zb3J0KGJ5UHJpb3JpdHkpO1xyXG4gICAgICByZXR1cm4gZGlyZWN0aXZlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgbm9kZSB3aXRoIGFuIGRpcmVjdGl2ZS1zdGFydCBpdCBjb2xsZWN0cyBhbGwgb2YgdGhlIHNpYmxpbmdzIHVudGlsIGl0IGZpbmQgZGlyZWN0aXZlLWVuZC5cclxuICAgICAqIEBwYXJhbSBub2RlXHJcbiAgICAgKiBAcGFyYW0gYXR0clN0YXJ0XHJcbiAgICAgKiBAcGFyYW0gYXR0ckVuZFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdyb3VwU2Nhbihub2RlLCBhdHRyU3RhcnQsIGF0dHJFbmQpIHtcclxuICAgICAgdmFyIG5vZGVzID0gW107XHJcbiAgICAgIHZhciBkZXB0aCA9IDA7XHJcbiAgICAgIGlmIChhdHRyU3RhcnQgJiYgbm9kZS5oYXNBdHRyaWJ1dGUgJiYgbm9kZS5oYXNBdHRyaWJ1dGUoYXR0clN0YXJ0KSkge1xyXG4gICAgICAgIHZhciBzdGFydE5vZGUgPSBub2RlO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICB0aHJvdyAkY29tcGlsZU1pbkVycigndXRlcmRpcicsIFwiVW50ZXJtaW5hdGVkIGF0dHJpYnV0ZSwgZm91bmQgJ3swfScgYnV0IG5vIG1hdGNoaW5nICd7MX0nIGZvdW5kLlwiLCBhdHRyU3RhcnQsIGF0dHJFbmQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAvKiogRWxlbWVudCAqKi8pIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJTdGFydCkpIGRlcHRoKys7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyRW5kKSkgZGVwdGgtLTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcclxuICAgICAgICB9IHdoaWxlIChkZXB0aCA+IDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGpxTGl0ZShub2Rlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcGVyIGZvciBsaW5raW5nIGZ1bmN0aW9uIHdoaWNoIGNvbnZlcnRzIG5vcm1hbCBsaW5raW5nIGZ1bmN0aW9uIGludG8gYSBncm91cGVkXHJcbiAgICAgKiBsaW5raW5nIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIGxpbmtGblxyXG4gICAgICogQHBhcmFtIGF0dHJTdGFydFxyXG4gICAgICogQHBhcmFtIGF0dHJFbmRcclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ3JvdXBFbGVtZW50c0xpbmtGbldyYXBwZXIobGlua0ZuLCBhdHRyU3RhcnQsIGF0dHJFbmQpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlcnMpIHtcclxuICAgICAgICBlbGVtZW50ID0gZ3JvdXBTY2FuKGVsZW1lbnRbMF0sIGF0dHJTdGFydCwgYXR0ckVuZCk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmtGbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNvbnRyb2xsZXJzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT25jZSB0aGUgZGlyZWN0aXZlcyBoYXZlIGJlZW4gY29sbGVjdGVkLCB0aGVpciBjb21waWxlIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQuIFRoaXMgbWV0aG9kXHJcbiAgICAgKiBpcyByZXNwb25zaWJsZSBmb3IgaW5saW5pbmcgZGlyZWN0aXZlIHRlbXBsYXRlcyBhcyB3ZWxsIGFzIHRlcm1pbmF0aW5nIHRoZSBhcHBsaWNhdGlvblxyXG4gICAgICogb2YgdGhlIGRpcmVjdGl2ZXMgaWYgdGhlIHRlcm1pbmFsIGRpcmVjdGl2ZSBoYXMgYmVlbiByZWFjaGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRpcmVjdGl2ZXMgQXJyYXkgb2YgY29sbGVjdGVkIGRpcmVjdGl2ZXMgdG8gZXhlY3V0ZSB0aGVpciBjb21waWxlIGZ1bmN0aW9uLlxyXG4gICAgICogICAgICAgIHRoaXMgbmVlZHMgdG8gYmUgcHJlLXNvcnRlZCBieSBwcmlvcml0eSBvcmRlci5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gY29tcGlsZU5vZGUgVGhlIHJhdyBET00gbm9kZSB0byBhcHBseSB0aGUgY29tcGlsZSBmdW5jdGlvbnMgdG9cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUF0dHJzIFRoZSBzaGFyZWQgYXR0cmlidXRlIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGFuZ3VsYXIuU2NvcGVbLCBjbG9uZUF0dGFjaEZuXX0gdHJhbnNjbHVkZUZuIEEgbGlua2luZyBmdW5jdGlvbiwgd2hlcmUgdGhlXHJcbiAgICAgKiAgICAgICAgc2NvcGUgYXJndW1lbnQgaXMgYXV0by1nZW5lcmF0ZWQgdG8gdGhlIG5ldyBjaGlsZCBvZiB0aGUgdHJhbnNjbHVkZWQgcGFyZW50IHNjb3BlLlxyXG4gICAgICogQHBhcmFtIHtKUUxpdGV9IGpxQ29sbGVjdGlvbiBJZiB3ZSBhcmUgd29ya2luZyBvbiB0aGUgcm9vdCBvZiB0aGUgY29tcGlsZSB0cmVlIHRoZW4gdGhpc1xyXG4gICAgICogICAgICAgIGFyZ3VtZW50IGhhcyB0aGUgcm9vdCBqcUxpdGUgYXJyYXkgc28gdGhhdCB3ZSBjYW4gcmVwbGFjZSBub2RlcyBvbiBpdC5cclxuICAgICAqIEByZXR1cm5zIGxpbmtGblxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhcHBseURpcmVjdGl2ZXNUb05vZGUoZGlyZWN0aXZlcywgY29tcGlsZU5vZGUsIHRlbXBsYXRlQXR0cnMsIHRyYW5zY2x1ZGVGbiwganFDb2xsZWN0aW9uLCBvcmlnaW5hbFJlcGxhY2VEaXJlY3RpdmUpIHtcclxuICAgICAgdmFyIHRlcm1pbmFsUHJpb3JpdHkgPSAtTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICAgIHByZUxpbmtGbnMgPSBbXSxcclxuICAgICAgICAgIHBvc3RMaW5rRm5zID0gW10sXHJcbiAgICAgICAgICBuZXdTY29wZURpcmVjdGl2ZSA9IG51bGwsXHJcbiAgICAgICAgICBuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUgPSBudWxsLFxyXG4gICAgICAgICAgdGVtcGxhdGVEaXJlY3RpdmUgPSBudWxsLFxyXG4gICAgICAgICAgJGNvbXBpbGVOb2RlID0gdGVtcGxhdGVBdHRycy4kJGVsZW1lbnQgPSBqcUxpdGUoY29tcGlsZU5vZGUpLFxyXG4gICAgICAgICAgZGlyZWN0aXZlLFxyXG4gICAgICAgICAgZGlyZWN0aXZlTmFtZSxcclxuICAgICAgICAgICR0ZW1wbGF0ZSxcclxuICAgICAgICAgIHRyYW5zY2x1ZGVEaXJlY3RpdmUsXHJcbiAgICAgICAgICByZXBsYWNlRGlyZWN0aXZlID0gb3JpZ2luYWxSZXBsYWNlRGlyZWN0aXZlLFxyXG4gICAgICAgICAgY2hpbGRUcmFuc2NsdWRlRm4gPSB0cmFuc2NsdWRlRm4sXHJcbiAgICAgICAgICBjb250cm9sbGVyRGlyZWN0aXZlcyxcclxuICAgICAgICAgIGxpbmtGbixcclxuICAgICAgICAgIGRpcmVjdGl2ZVZhbHVlO1xyXG5cclxuICAgICAgLy8gZXhlY3V0ZXMgYWxsIGRpcmVjdGl2ZXMgb24gdGhlIGN1cnJlbnQgZWxlbWVudFxyXG4gICAgICBmb3IodmFyIGkgPSAwLCBpaSA9IGRpcmVjdGl2ZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgIGRpcmVjdGl2ZSA9IGRpcmVjdGl2ZXNbaV07XHJcbiAgICAgICAgdmFyIGF0dHJTdGFydCA9IGRpcmVjdGl2ZS4kJHN0YXJ0O1xyXG4gICAgICAgIHZhciBhdHRyRW5kID0gZGlyZWN0aXZlLiQkZW5kO1xyXG5cclxuICAgICAgICAvLyBjb2xsZWN0IG11bHRpYmxvY2sgc2VjdGlvbnNcclxuICAgICAgICBpZiAoYXR0clN0YXJ0KSB7XHJcbiAgICAgICAgICAkY29tcGlsZU5vZGUgPSBncm91cFNjYW4oY29tcGlsZU5vZGUsIGF0dHJTdGFydCwgYXR0ckVuZClcclxuICAgICAgICB9XHJcbiAgICAgICAgJHRlbXBsYXRlID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBpZiAodGVybWluYWxQcmlvcml0eSA+IGRpcmVjdGl2ZS5wcmlvcml0eSkge1xyXG4gICAgICAgICAgYnJlYWs7IC8vIHByZXZlbnQgZnVydGhlciBwcm9jZXNzaW5nIG9mIGRpcmVjdGl2ZXNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaXJlY3RpdmVWYWx1ZSA9IGRpcmVjdGl2ZS5zY29wZSkge1xyXG4gICAgICAgICAgYXNzZXJ0Tm9EdXBsaWNhdGUoJ2lzb2xhdGVkIHNjb3BlJywgbmV3SXNvbGF0ZVNjb3BlRGlyZWN0aXZlLCBkaXJlY3RpdmUsICRjb21waWxlTm9kZSk7XHJcbiAgICAgICAgICBpZiAoaXNPYmplY3QoZGlyZWN0aXZlVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHNhZmVBZGRDbGFzcygkY29tcGlsZU5vZGUsICduZy1pc29sYXRlLXNjb3BlJyk7XHJcbiAgICAgICAgICAgIG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNhZmVBZGRDbGFzcygkY29tcGlsZU5vZGUsICduZy1zY29wZScpO1xyXG4gICAgICAgICAgbmV3U2NvcGVEaXJlY3RpdmUgPSBuZXdTY29wZURpcmVjdGl2ZSB8fCBkaXJlY3RpdmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlLm5hbWU7XHJcblxyXG4gICAgICAgIGlmIChkaXJlY3RpdmVWYWx1ZSA9IGRpcmVjdGl2ZS5jb250cm9sbGVyKSB7XHJcbiAgICAgICAgICBjb250cm9sbGVyRGlyZWN0aXZlcyA9IGNvbnRyb2xsZXJEaXJlY3RpdmVzIHx8IHt9O1xyXG4gICAgICAgICAgYXNzZXJ0Tm9EdXBsaWNhdGUoXCInXCIgKyBkaXJlY3RpdmVOYW1lICsgXCInIGNvbnRyb2xsZXJcIixcclxuICAgICAgICAgICAgICBjb250cm9sbGVyRGlyZWN0aXZlc1tkaXJlY3RpdmVOYW1lXSwgZGlyZWN0aXZlLCAkY29tcGlsZU5vZGUpO1xyXG4gICAgICAgICAgY29udHJvbGxlckRpcmVjdGl2ZXNbZGlyZWN0aXZlTmFtZV0gPSBkaXJlY3RpdmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGlyZWN0aXZlVmFsdWUgPSBkaXJlY3RpdmUudHJhbnNjbHVkZSkge1xyXG4gICAgICAgICAgYXNzZXJ0Tm9EdXBsaWNhdGUoJ3RyYW5zY2x1c2lvbicsIHRyYW5zY2x1ZGVEaXJlY3RpdmUsIGRpcmVjdGl2ZSwgJGNvbXBpbGVOb2RlKTtcclxuICAgICAgICAgIHRyYW5zY2x1ZGVEaXJlY3RpdmUgPSBkaXJlY3RpdmU7XHJcbiAgICAgICAgICB0ZXJtaW5hbFByaW9yaXR5ID0gZGlyZWN0aXZlLnByaW9yaXR5O1xyXG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZVZhbHVlID09ICdlbGVtZW50Jykge1xyXG4gICAgICAgICAgICAkdGVtcGxhdGUgPSBncm91cFNjYW4oY29tcGlsZU5vZGUsIGF0dHJTdGFydCwgYXR0ckVuZClcclxuICAgICAgICAgICAgJGNvbXBpbGVOb2RlID0gdGVtcGxhdGVBdHRycy4kJGVsZW1lbnQgPVxyXG4gICAgICAgICAgICAgICAganFMaXRlKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJyAnICsgZGlyZWN0aXZlTmFtZSArICc6ICcgKyB0ZW1wbGF0ZUF0dHJzW2RpcmVjdGl2ZU5hbWVdICsgJyAnKSk7XHJcbiAgICAgICAgICAgIGNvbXBpbGVOb2RlID0gJGNvbXBpbGVOb2RlWzBdO1xyXG4gICAgICAgICAgICByZXBsYWNlV2l0aChqcUNvbGxlY3Rpb24sIGpxTGl0ZShzbGljZUFyZ3MoJHRlbXBsYXRlKSksIGNvbXBpbGVOb2RlKTtcclxuXHJcbiAgICAgICAgICAgIGNoaWxkVHJhbnNjbHVkZUZuID0gY29tcGlsZSgkdGVtcGxhdGUsIHRyYW5zY2x1ZGVGbiwgdGVybWluYWxQcmlvcml0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VEaXJlY3RpdmUgJiYgcmVwbGFjZURpcmVjdGl2ZS5uYW1lKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICR0ZW1wbGF0ZSA9IGpxTGl0ZShKUUxpdGVDbG9uZShjb21waWxlTm9kZSkpLmNvbnRlbnRzKCk7XHJcbiAgICAgICAgICAgICRjb21waWxlTm9kZS5odG1sKCcnKTsgLy8gY2xlYXIgY29udGVudHNcclxuICAgICAgICAgICAgY2hpbGRUcmFuc2NsdWRlRm4gPSBjb21waWxlKCR0ZW1wbGF0ZSwgdHJhbnNjbHVkZUZuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaXJlY3RpdmUudGVtcGxhdGUpIHtcclxuICAgICAgICAgIGFzc2VydE5vRHVwbGljYXRlKCd0ZW1wbGF0ZScsIHRlbXBsYXRlRGlyZWN0aXZlLCBkaXJlY3RpdmUsICRjb21waWxlTm9kZSk7XHJcbiAgICAgICAgICB0ZW1wbGF0ZURpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuXHJcbiAgICAgICAgICBkaXJlY3RpdmVWYWx1ZSA9IChpc0Z1bmN0aW9uKGRpcmVjdGl2ZS50ZW1wbGF0ZSkpXHJcbiAgICAgICAgICAgICAgPyBkaXJlY3RpdmUudGVtcGxhdGUoJGNvbXBpbGVOb2RlLCB0ZW1wbGF0ZUF0dHJzKVxyXG4gICAgICAgICAgICAgIDogZGlyZWN0aXZlLnRlbXBsYXRlO1xyXG5cclxuICAgICAgICAgIGRpcmVjdGl2ZVZhbHVlID0gZGVub3JtYWxpemVUZW1wbGF0ZShkaXJlY3RpdmVWYWx1ZSk7XHJcblxyXG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZS5yZXBsYWNlKSB7XHJcbiAgICAgICAgICAgIHJlcGxhY2VEaXJlY3RpdmUgPSBkaXJlY3RpdmU7XHJcbiAgICAgICAgICAgICR0ZW1wbGF0ZSA9IGpxTGl0ZSgnPGRpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpbShkaXJlY3RpdmVWYWx1ZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicpLmNvbnRlbnRzKCk7XHJcbiAgICAgICAgICAgIGNvbXBpbGVOb2RlID0gJHRlbXBsYXRlWzBdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCR0ZW1wbGF0ZS5sZW5ndGggIT0gMSB8fCBjb21waWxlTm9kZS5ub2RlVHlwZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCd0cGxydCcsIFwiVGVtcGxhdGUgZm9yIGRpcmVjdGl2ZSAnezB9JyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiB7MX1cIiwgZGlyZWN0aXZlTmFtZSwgJycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXBsYWNlV2l0aChqcUNvbGxlY3Rpb24sICRjb21waWxlTm9kZSwgY29tcGlsZU5vZGUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5ld1RlbXBsYXRlQXR0cnMgPSB7JGF0dHI6IHt9fTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbWJpbmUgZGlyZWN0aXZlcyBmcm9tIHRoZSBvcmlnaW5hbCBub2RlIGFuZCBmcm9tIHRoZSB0ZW1wbGF0ZTpcclxuICAgICAgICAgICAgLy8gLSB0YWtlIHRoZSBhcnJheSBvZiBkaXJlY3RpdmVzIGZvciB0aGlzIGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gLSBzcGxpdCBpdCBpbnRvIHR3byBwYXJ0cywgdGhvc2UgdGhhdCB3ZXJlIGFscmVhZHkgYXBwbGllZCBhbmQgdGhvc2UgdGhhdCB3ZXJlbid0XHJcbiAgICAgICAgICAgIC8vIC0gY29sbGVjdCBkaXJlY3RpdmVzIGZyb20gdGhlIHRlbXBsYXRlLCBhZGQgdGhlbSB0byB0aGUgc2Vjb25kIGdyb3VwIGFuZCBzb3J0IHRoZW1cclxuICAgICAgICAgICAgLy8gLSBhcHBlbmQgdGhlIHNlY29uZCBncm91cCB3aXRoIG5ldyBkaXJlY3RpdmVzIHRvIHRoZSBmaXJzdCBncm91cFxyXG4gICAgICAgICAgICBkaXJlY3RpdmVzID0gZGlyZWN0aXZlcy5jb25jYXQoXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0RGlyZWN0aXZlcyhcclxuICAgICAgICAgICAgICAgICAgICBjb21waWxlTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzLnNwbGljZShpICsgMSwgZGlyZWN0aXZlcy5sZW5ndGggLSAoaSArIDEpKSxcclxuICAgICAgICAgICAgICAgICAgICBuZXdUZW1wbGF0ZUF0dHJzXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIG1lcmdlVGVtcGxhdGVBdHRyaWJ1dGVzKHRlbXBsYXRlQXR0cnMsIG5ld1RlbXBsYXRlQXR0cnMpO1xyXG5cclxuICAgICAgICAgICAgaWkgPSBkaXJlY3RpdmVzLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICRjb21waWxlTm9kZS5odG1sKGRpcmVjdGl2ZVZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkaXJlY3RpdmUudGVtcGxhdGVVcmwpIHtcclxuICAgICAgICAgIGFzc2VydE5vRHVwbGljYXRlKCd0ZW1wbGF0ZScsIHRlbXBsYXRlRGlyZWN0aXZlLCBkaXJlY3RpdmUsICRjb21waWxlTm9kZSk7XHJcbiAgICAgICAgICB0ZW1wbGF0ZURpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuXHJcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlLnJlcGxhY2UpIHtcclxuICAgICAgICAgICAgcmVwbGFjZURpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5vZGVMaW5rRm4gPSBjb21waWxlVGVtcGxhdGVVcmwoZGlyZWN0aXZlcy5zcGxpY2UoaSwgZGlyZWN0aXZlcy5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgICBub2RlTGlua0ZuLCAkY29tcGlsZU5vZGUsIHRlbXBsYXRlQXR0cnMsIGpxQ29sbGVjdGlvbiwgY2hpbGRUcmFuc2NsdWRlRm4pO1xyXG4gICAgICAgICAgaWkgPSBkaXJlY3RpdmVzLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGl2ZS5jb21waWxlKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsaW5rRm4gPSBkaXJlY3RpdmUuY29tcGlsZSgkY29tcGlsZU5vZGUsIHRlbXBsYXRlQXR0cnMsIGNoaWxkVHJhbnNjbHVkZUZuKTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obGlua0ZuKSkge1xyXG4gICAgICAgICAgICAgIGFkZExpbmtGbnMobnVsbCwgbGlua0ZuLCBhdHRyU3RhcnQsIGF0dHJFbmQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmtGbikge1xyXG4gICAgICAgICAgICAgIGFkZExpbmtGbnMobGlua0ZuLnByZSwgbGlua0ZuLnBvc3QsIGF0dHJTdGFydCwgYXR0ckVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSwgc3RhcnRpbmdUYWcoJGNvbXBpbGVOb2RlKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGlyZWN0aXZlLnRlcm1pbmFsKSB7XHJcbiAgICAgICAgICBub2RlTGlua0ZuLnRlcm1pbmFsID0gdHJ1ZTtcclxuICAgICAgICAgIHRlcm1pbmFsUHJpb3JpdHkgPSBNYXRoLm1heCh0ZXJtaW5hbFByaW9yaXR5LCBkaXJlY3RpdmUucHJpb3JpdHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5vZGVMaW5rRm4uc2NvcGUgPSBuZXdTY29wZURpcmVjdGl2ZSAmJiBuZXdTY29wZURpcmVjdGl2ZS5zY29wZTtcclxuICAgICAgbm9kZUxpbmtGbi50cmFuc2NsdWRlID0gdHJhbnNjbHVkZURpcmVjdGl2ZSAmJiBjaGlsZFRyYW5zY2x1ZGVGbjtcclxuXHJcbiAgICAgIC8vIG1pZ2h0IGJlIG5vcm1hbCBvciBkZWxheWVkIG5vZGVMaW5rRm4gZGVwZW5kaW5nIG9uIGlmIHRlbXBsYXRlVXJsIGlzIHByZXNlbnRcclxuICAgICAgcmV0dXJuIG5vZGVMaW5rRm47XHJcblxyXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuICAgICAgZnVuY3Rpb24gYWRkTGlua0ZucyhwcmUsIHBvc3QsIGF0dHJTdGFydCwgYXR0ckVuZCkge1xyXG4gICAgICAgIGlmIChwcmUpIHtcclxuICAgICAgICAgIGlmIChhdHRyU3RhcnQpIHByZSA9IGdyb3VwRWxlbWVudHNMaW5rRm5XcmFwcGVyKHByZSwgYXR0clN0YXJ0LCBhdHRyRW5kKTtcclxuICAgICAgICAgIHByZS5yZXF1aXJlID0gZGlyZWN0aXZlLnJlcXVpcmU7XHJcbiAgICAgICAgICBwcmVMaW5rRm5zLnB1c2gocHJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvc3QpIHtcclxuICAgICAgICAgIGlmIChhdHRyU3RhcnQpIHBvc3QgPSBncm91cEVsZW1lbnRzTGlua0ZuV3JhcHBlcihwb3N0LCBhdHRyU3RhcnQsIGF0dHJFbmQpO1xyXG4gICAgICAgICAgcG9zdC5yZXF1aXJlID0gZGlyZWN0aXZlLnJlcXVpcmU7XHJcbiAgICAgICAgICBwb3N0TGlua0Zucy5wdXNoKHBvc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGdldENvbnRyb2xsZXJzKHJlcXVpcmUsICRlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlLCByZXRyaWV2YWxNZXRob2QgPSAnZGF0YScsIG9wdGlvbmFsID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHJlcXVpcmUpKSB7XHJcbiAgICAgICAgICB3aGlsZSgodmFsdWUgPSByZXF1aXJlLmNoYXJBdCgwKSkgPT0gJ14nIHx8IHZhbHVlID09ICc/Jykge1xyXG4gICAgICAgICAgICByZXF1aXJlID0gcmVxdWlyZS5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSAnXicpIHtcclxuICAgICAgICAgICAgICByZXRyaWV2YWxNZXRob2QgPSAnaW5oZXJpdGVkRGF0YSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9uYWwgPSBvcHRpb25hbCB8fCB2YWx1ZSA9PSAnPyc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YWx1ZSA9ICRlbGVtZW50W3JldHJpZXZhbE1ldGhvZF0oJyQnICsgcmVxdWlyZSArICdDb250cm9sbGVyJyk7XHJcbiAgICAgICAgICBpZiAoIXZhbHVlICYmICFvcHRpb25hbCkge1xyXG4gICAgICAgICAgICB0aHJvdyAkY29tcGlsZU1pbkVycignY3RyZXEnLCBcIkNvbnRyb2xsZXIgJ3swfScsIHJlcXVpcmVkIGJ5IGRpcmVjdGl2ZSAnezF9JywgY2FuJ3QgYmUgZm91bmQhXCIsIHJlcXVpcmUsIGRpcmVjdGl2ZU5hbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShyZXF1aXJlKSkge1xyXG4gICAgICAgICAgdmFsdWUgPSBbXTtcclxuICAgICAgICAgIGZvckVhY2gocmVxdWlyZSwgZnVuY3Rpb24ocmVxdWlyZSkge1xyXG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGdldENvbnRyb2xsZXJzKHJlcXVpcmUsICRlbGVtZW50KSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgZnVuY3Rpb24gbm9kZUxpbmtGbihjaGlsZExpbmtGbiwgc2NvcGUsIGxpbmtOb2RlLCAkcm9vdEVsZW1lbnQsIGJvdW5kVHJhbnNjbHVkZUZuKSB7XHJcbiAgICAgICAgdmFyIGF0dHJzLCAkZWxlbWVudCwgaSwgaWksIGxpbmtGbiwgY29udHJvbGxlcjtcclxuXHJcbiAgICAgICAgaWYgKGNvbXBpbGVOb2RlID09PSBsaW5rTm9kZSkge1xyXG4gICAgICAgICAgYXR0cnMgPSB0ZW1wbGF0ZUF0dHJzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhdHRycyA9IHNoYWxsb3dDb3B5KHRlbXBsYXRlQXR0cnMsIG5ldyBBdHRyaWJ1dGVzKGpxTGl0ZShsaW5rTm9kZSksIHRlbXBsYXRlQXR0cnMuJGF0dHIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJGVsZW1lbnQgPSBhdHRycy4kJGVsZW1lbnQ7XHJcblxyXG4gICAgICAgIGlmIChuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUpIHtcclxuICAgICAgICAgIHZhciBMT0NBTF9SRUdFWFAgPSAvXlxccyooW0A9Jl0pKFxcPz8pXFxzKihcXHcqKVxccyokLztcclxuXHJcbiAgICAgICAgICB2YXIgcGFyZW50U2NvcGUgPSBzY29wZS4kcGFyZW50IHx8IHNjb3BlO1xyXG5cclxuICAgICAgICAgIGZvckVhY2gobmV3SXNvbGF0ZVNjb3BlRGlyZWN0aXZlLnNjb3BlLCBmdW5jdGlvbihkZWZpbml0aW9uLCBzY29wZU5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoID0gZGVmaW5pdGlvbi5tYXRjaChMT0NBTF9SRUdFWFApIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBtYXRjaFszXSB8fCBzY29wZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25hbCA9IChtYXRjaFsyXSA9PSAnPycpLFxyXG4gICAgICAgICAgICAgICAgbW9kZSA9IG1hdGNoWzFdLCAvLyBALCA9LCBvciAmXHJcbiAgICAgICAgICAgICAgICBsYXN0VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRHZXQsIHBhcmVudFNldDtcclxuXHJcbiAgICAgICAgICAgIHNjb3BlLiQkaXNvbGF0ZUJpbmRpbmdzW3Njb3BlTmFtZV0gPSBtb2RlICsgYXR0ck5hbWU7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgY2FzZSAnQCc6IHtcclxuICAgICAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKGF0dHJOYW1lLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICBzY29wZVtzY29wZU5hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGF0dHJzLiQkb2JzZXJ2ZXJzW2F0dHJOYW1lXS4kJHNjb3BlID0gcGFyZW50U2NvcGU7XHJcbiAgICAgICAgICAgICAgICBpZiggYXR0cnNbYXR0ck5hbWVdICkge1xyXG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXR0cmlidXRlIGhhcyBiZWVuIHByb3ZpZGVkIHRoZW4gd2UgdHJpZ2dlciBhbiBpbnRlcnBvbGF0aW9uIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgdGhlcmUgZm9yIHVzZSBpbiB0aGUgbGluayBmblxyXG4gICAgICAgICAgICAgICAgICBzY29wZVtzY29wZU5hbWVdID0gJGludGVycG9sYXRlKGF0dHJzW2F0dHJOYW1lXSkocGFyZW50U2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBjYXNlICc9Jzoge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsICYmICFhdHRyc1thdHRyTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50R2V0ID0gJHBhcnNlKGF0dHJzW2F0dHJOYW1lXSk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRTZXQgPSBwYXJlbnRHZXQuYXNzaWduIHx8IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgY2hhbmdlLCBvciB3ZSB3aWxsIHRocm93IHRoaXMgZXhjZXB0aW9uIG9uIGV2ZXJ5ICRkaWdlc3RcclxuICAgICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gc2NvcGVbc2NvcGVOYW1lXSA9IHBhcmVudEdldChwYXJlbnRTY29wZSk7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCdub25hc3NpZ24nLCBcIkV4cHJlc3Npb24gJ3swfScgdXNlZCB3aXRoIGRpcmVjdGl2ZSAnezF9JyBpcyBub24tYXNzaWduYWJsZSFcIixcclxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2F0dHJOYW1lXSwgbmV3SXNvbGF0ZVNjb3BlRGlyZWN0aXZlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHNjb3BlW3Njb3BlTmFtZV0gPSBwYXJlbnRHZXQocGFyZW50U2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uIHBhcmVudFZhbHVlV2F0Y2goKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRWYWx1ZSA9IHBhcmVudEdldChwYXJlbnRTY29wZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAocGFyZW50VmFsdWUgIT09IHNjb3BlW3Njb3BlTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgb3V0IG9mIHN5bmMgYW5kIG5lZWQgdG8gY29weVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgY2hhbmdlZCBhbmQgaXQgaGFzIHByZWNlZGVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHNjb3BlW3Njb3BlTmFtZV0gPSBwYXJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBhcmVudCBjYW4gYmUgYXNzaWduZWQgdGhlbiBkbyBzb1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50U2V0KHBhcmVudFNjb3BlLCBwYXJlbnRWYWx1ZSA9IGxhc3RWYWx1ZSA9IHNjb3BlW3Njb3BlTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgY2FzZSAnJic6IHtcclxuICAgICAgICAgICAgICAgIHBhcmVudEdldCA9ICRwYXJzZShhdHRyc1thdHRyTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgc2NvcGVbc2NvcGVOYW1lXSA9IGZ1bmN0aW9uKGxvY2Fscykge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50R2V0KHBhcmVudFNjb3BlLCBsb2NhbHMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJGNvbXBpbGVNaW5FcnIoJ2lzY3AnLCBcIkludmFsaWQgaXNvbGF0ZSBzY29wZSBkZWZpbml0aW9uIGZvciBkaXJlY3RpdmUgJ3swfScuIERlZmluaXRpb246IHsuLi4gezF9OiAnezJ9JyAuLi59XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SXNvbGF0ZVNjb3BlRGlyZWN0aXZlLm5hbWUsIHNjb3BlTmFtZSwgZGVmaW5pdGlvbik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb250cm9sbGVyRGlyZWN0aXZlcykge1xyXG4gICAgICAgICAgZm9yRWFjaChjb250cm9sbGVyRGlyZWN0aXZlcywgZnVuY3Rpb24oZGlyZWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbHMgPSB7XHJcbiAgICAgICAgICAgICAgJHNjb3BlOiBzY29wZSxcclxuICAgICAgICAgICAgICAkZWxlbWVudDogJGVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgJGF0dHJzOiBhdHRycyxcclxuICAgICAgICAgICAgICAkdHJhbnNjbHVkZTogYm91bmRUcmFuc2NsdWRlRm5cclxuICAgICAgICAgICAgfSwgY29udHJvbGxlckluc3RhbmNlO1xyXG5cclxuICAgICAgICAgICAgY29udHJvbGxlciA9IGRpcmVjdGl2ZS5jb250cm9sbGVyO1xyXG4gICAgICAgICAgICBpZiAoY29udHJvbGxlciA9PSAnQCcpIHtcclxuICAgICAgICAgICAgICBjb250cm9sbGVyID0gYXR0cnNbZGlyZWN0aXZlLm5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb250cm9sbGVySW5zdGFuY2UgPSAkY29udHJvbGxlcihjb250cm9sbGVyLCBsb2NhbHMpO1xyXG4gICAgICAgICAgICAkZWxlbWVudC5kYXRhKFxyXG4gICAgICAgICAgICAgICAgJyQnICsgZGlyZWN0aXZlLm5hbWUgKyAnQ29udHJvbGxlcicsXHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVySW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlLmNvbnRyb2xsZXJBcykge1xyXG4gICAgICAgICAgICAgIGxvY2Fscy4kc2NvcGVbZGlyZWN0aXZlLmNvbnRyb2xsZXJBc10gPSBjb250cm9sbGVySW5zdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUFJFTElOS0lOR1xyXG4gICAgICAgIGZvcihpID0gMCwgaWkgPSBwcmVMaW5rRm5zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxpbmtGbiA9IHByZUxpbmtGbnNbaV07XHJcbiAgICAgICAgICAgIGxpbmtGbihzY29wZSwgJGVsZW1lbnQsIGF0dHJzLFxyXG4gICAgICAgICAgICAgICAgbGlua0ZuLnJlcXVpcmUgJiYgZ2V0Q29udHJvbGxlcnMobGlua0ZuLnJlcXVpcmUsICRlbGVtZW50KSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUsIHN0YXJ0aW5nVGFnKCRlbGVtZW50KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSRUNVUlNJT05cclxuICAgICAgICBjaGlsZExpbmtGbiAmJiBjaGlsZExpbmtGbihzY29wZSwgbGlua05vZGUuY2hpbGROb2RlcywgdW5kZWZpbmVkLCBib3VuZFRyYW5zY2x1ZGVGbik7XHJcblxyXG4gICAgICAgIC8vIFBPU1RMSU5LSU5HXHJcbiAgICAgICAgZm9yKGkgPSAwLCBpaSA9IHBvc3RMaW5rRm5zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxpbmtGbiA9IHBvc3RMaW5rRm5zW2ldO1xyXG4gICAgICAgICAgICBsaW5rRm4oc2NvcGUsICRlbGVtZW50LCBhdHRycyxcclxuICAgICAgICAgICAgICAgIGxpbmtGbi5yZXF1aXJlICYmIGdldENvbnRyb2xsZXJzKGxpbmtGbi5yZXF1aXJlLCAkZWxlbWVudCkpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlLCBzdGFydGluZ1RhZygkZWxlbWVudCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIGxvb2tzIHVwIHRoZSBkaXJlY3RpdmUgYW5kIGRlY29yYXRlcyBpdCB3aXRoIGV4Y2VwdGlvbiBoYW5kbGluZyBhbmQgcHJvcGVyIHBhcmFtZXRlcnMuIFdlXHJcbiAgICAgKiBjYWxsIHRoaXMgdGhlIGJvdW5kRGlyZWN0aXZlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGRpcmVjdGl2ZSB0byBsb29rIHVwLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIFRoZSBkaXJlY3RpdmUgbXVzdCBiZSBmb3VuZCBpbiBzcGVjaWZpYyBmb3JtYXQuXHJcbiAgICAgKiAgIFN0cmluZyBjb250YWluaW5nIGFueSBvZiB0aGVzZXMgY2hhcmFjdGVyczpcclxuICAgICAqXHJcbiAgICAgKiAgICogYEVgOiBlbGVtZW50IG5hbWVcclxuICAgICAqICAgKiBgQSc6IGF0dHJpYnV0ZVxyXG4gICAgICogICAqIGBDYDogY2xhc3NcclxuICAgICAqICAgKiBgTWA6IGNvbW1lbnRcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZGlyZWN0aXZlIHdhcyBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWRkRGlyZWN0aXZlKHREaXJlY3RpdmVzLCBuYW1lLCBsb2NhdGlvbiwgbWF4UHJpb3JpdHksIGlnbm9yZURpcmVjdGl2ZSwgc3RhcnRBdHRyTmFtZSwgZW5kQXR0ck5hbWUpIHtcclxuICAgICAgaWYgKG5hbWUgPT09IGlnbm9yZURpcmVjdGl2ZSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHZhciBtYXRjaCA9IG51bGw7XHJcbiAgICAgIGlmIChoYXNEaXJlY3RpdmVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgZm9yKHZhciBkaXJlY3RpdmUsIGRpcmVjdGl2ZXMgPSAkaW5qZWN0b3IuZ2V0KG5hbWUgKyBTdWZmaXgpLFxyXG4gICAgICAgICAgICBpID0gMCwgaWkgPSBkaXJlY3RpdmVzLmxlbmd0aDsgaTxpaTsgaSsrKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkaXJlY3RpdmUgPSBkaXJlY3RpdmVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIChtYXhQcmlvcml0eSA9PT0gdW5kZWZpbmVkIHx8IG1heFByaW9yaXR5ID4gZGlyZWN0aXZlLnByaW9yaXR5KSAmJlxyXG4gICAgICAgICAgICAgICAgIGRpcmVjdGl2ZS5yZXN0cmljdC5pbmRleE9mKGxvY2F0aW9uKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgIGlmIChzdGFydEF0dHJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUgPSBpbmhlcml0KGRpcmVjdGl2ZSwgeyQkc3RhcnQ6IHN0YXJ0QXR0ck5hbWUsICQkZW5kOiBlbmRBdHRyTmFtZX0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB0RGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgbWF0Y2ggPSBkaXJlY3RpdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2goZSkgeyAkZXhjZXB0aW9uSGFuZGxlcihlKTsgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0aGUgZWxlbWVudCBpcyByZXBsYWNlZCB3aXRoIEhUTUwgdGVtcGxhdGUgdGhlbiB0aGUgbmV3IGF0dHJpYnV0ZXNcclxuICAgICAqIG9uIHRoZSB0ZW1wbGF0ZSBuZWVkIHRvIGJlIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBhdHRyaWJ1dGVzIGluIHRoZSBET00uXHJcbiAgICAgKiBUaGUgZGVzaXJlZCBlZmZlY3QgaXMgdG8gaGF2ZSBib3RoIG9mIHRoZSBhdHRyaWJ1dGVzIHByZXNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRzdCBkZXN0aW5hdGlvbiBhdHRyaWJ1dGVzIChvcmlnaW5hbCBET00pXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3JjIHNvdXJjZSBhdHRyaWJ1dGVzIChmcm9tIHRoZSBkaXJlY3RpdmUgdGVtcGxhdGUpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1lcmdlVGVtcGxhdGVBdHRyaWJ1dGVzKGRzdCwgc3JjKSB7XHJcbiAgICAgIHZhciBzcmNBdHRyID0gc3JjLiRhdHRyLFxyXG4gICAgICAgICAgZHN0QXR0ciA9IGRzdC4kYXR0cixcclxuICAgICAgICAgICRlbGVtZW50ID0gZHN0LiQkZWxlbWVudDtcclxuXHJcbiAgICAgIC8vIHJlYXBwbHkgdGhlIG9sZCBhdHRyaWJ1dGVzIHRvIHRoZSBuZXcgZWxlbWVudFxyXG4gICAgICBmb3JFYWNoKGRzdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICAgIGlmIChrZXkuY2hhckF0KDApICE9ICckJykge1xyXG4gICAgICAgICAgaWYgKHNyY1trZXldKSB7XHJcbiAgICAgICAgICAgIHZhbHVlICs9IChrZXkgPT09ICdzdHlsZScgPyAnOycgOiAnICcpICsgc3JjW2tleV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkc3QuJHNldChrZXksIHZhbHVlLCB0cnVlLCBzcmNBdHRyW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBjb3B5IHRoZSBuZXcgYXR0cmlidXRlcyBvbiB0aGUgb2xkIGF0dHJzIG9iamVjdFxyXG4gICAgICBmb3JFYWNoKHNyYywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICAgIGlmIChrZXkgPT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgc2FmZUFkZENsYXNzKCRlbGVtZW50LCB2YWx1ZSk7XHJcbiAgICAgICAgICBkc3RbJ2NsYXNzJ10gPSAoZHN0WydjbGFzcyddID8gZHN0WydjbGFzcyddICsgJyAnIDogJycpICsgdmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgJGVsZW1lbnQuYXR0cignc3R5bGUnLCAkZWxlbWVudC5hdHRyKCdzdHlsZScpICsgJzsnICsgdmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5LmNoYXJBdCgwKSAhPSAnJCcgJiYgIWRzdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICBkc3Rba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgZHN0QXR0cltrZXldID0gc3JjQXR0cltrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBpbGVUZW1wbGF0ZVVybChkaXJlY3RpdmVzLCBiZWZvcmVUZW1wbGF0ZU5vZGVMaW5rRm4sICRjb21waWxlTm9kZSwgdEF0dHJzLFxyXG4gICAgICAgICRyb290RWxlbWVudCwgY2hpbGRUcmFuc2NsdWRlRm4pIHtcclxuICAgICAgdmFyIGxpbmtRdWV1ZSA9IFtdLFxyXG4gICAgICAgICAgYWZ0ZXJUZW1wbGF0ZU5vZGVMaW5rRm4sXHJcbiAgICAgICAgICBhZnRlclRlbXBsYXRlQ2hpbGRMaW5rRm4sXHJcbiAgICAgICAgICBiZWZvcmVUZW1wbGF0ZUNvbXBpbGVOb2RlID0gJGNvbXBpbGVOb2RlWzBdLFxyXG4gICAgICAgICAgb3JpZ0FzeW5jRGlyZWN0aXZlID0gZGlyZWN0aXZlcy5zaGlmdCgpLFxyXG4gICAgICAgICAgLy8gVGhlIGZhY3QgdGhhdCB3ZSBoYXZlIHRvIGNvcHkgYW5kIHBhdGNoIHRoZSBkaXJlY3RpdmUgc2VlbXMgd3JvbmchXHJcbiAgICAgICAgICBkZXJpdmVkU3luY0RpcmVjdGl2ZSA9IGV4dGVuZCh7fSwgb3JpZ0FzeW5jRGlyZWN0aXZlLCB7XHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IG51bGwsIHRlbXBsYXRlVXJsOiBudWxsLCB0cmFuc2NsdWRlOiBudWxsLCBzY29wZTogbnVsbCwgcmVwbGFjZTogbnVsbFxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgICB0ZW1wbGF0ZVVybCA9IChpc0Z1bmN0aW9uKG9yaWdBc3luY0RpcmVjdGl2ZS50ZW1wbGF0ZVVybCkpXHJcbiAgICAgICAgICAgICAgPyBvcmlnQXN5bmNEaXJlY3RpdmUudGVtcGxhdGVVcmwoJGNvbXBpbGVOb2RlLCB0QXR0cnMpXHJcbiAgICAgICAgICAgICAgOiBvcmlnQXN5bmNEaXJlY3RpdmUudGVtcGxhdGVVcmw7XHJcblxyXG4gICAgICAkY29tcGlsZU5vZGUuaHRtbCgnJyk7XHJcblxyXG4gICAgICAkaHR0cC5nZXQoJHNjZS5nZXRUcnVzdGVkUmVzb3VyY2VVcmwodGVtcGxhdGVVcmwpLCB7Y2FjaGU6ICR0ZW1wbGF0ZUNhY2hlfSkuXHJcbiAgICAgICAgc3VjY2VzcyhmdW5jdGlvbihjb250ZW50KSB7XHJcbiAgICAgICAgICB2YXIgY29tcGlsZU5vZGUsIHRlbXBUZW1wbGF0ZUF0dHJzLCAkdGVtcGxhdGU7XHJcblxyXG4gICAgICAgICAgY29udGVudCA9IGRlbm9ybWFsaXplVGVtcGxhdGUoY29udGVudCk7XHJcblxyXG4gICAgICAgICAgaWYgKG9yaWdBc3luY0RpcmVjdGl2ZS5yZXBsYWNlKSB7XHJcbiAgICAgICAgICAgICR0ZW1wbGF0ZSA9IGpxTGl0ZSgnPGRpdj4nICsgdHJpbShjb250ZW50KSArICc8L2Rpdj4nKS5jb250ZW50cygpO1xyXG4gICAgICAgICAgICBjb21waWxlTm9kZSA9ICR0ZW1wbGF0ZVswXTtcclxuXHJcbiAgICAgICAgICAgIGlmICgkdGVtcGxhdGUubGVuZ3RoICE9IDEgfHwgY29tcGlsZU5vZGUubm9kZVR5cGUgIT09IDEpIHtcclxuICAgICAgICAgICAgICB0aHJvdyAkY29tcGlsZU1pbkVycigndHBscnQnLCBcIlRlbXBsYXRlIGZvciBkaXJlY3RpdmUgJ3swfScgbXVzdCBoYXZlIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gezF9XCIsXHJcbiAgICAgICAgICAgICAgICAgIG9yaWdBc3luY0RpcmVjdGl2ZS5uYW1lLCB0ZW1wbGF0ZVVybCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRlbXBUZW1wbGF0ZUF0dHJzID0geyRhdHRyOiB7fX07XHJcbiAgICAgICAgICAgIHJlcGxhY2VXaXRoKCRyb290RWxlbWVudCwgJGNvbXBpbGVOb2RlLCBjb21waWxlTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbGxlY3REaXJlY3RpdmVzKGNvbXBpbGVOb2RlLCBkaXJlY3RpdmVzLCB0ZW1wVGVtcGxhdGVBdHRycyk7XHJcbiAgICAgICAgICAgIG1lcmdlVGVtcGxhdGVBdHRyaWJ1dGVzKHRBdHRycywgdGVtcFRlbXBsYXRlQXR0cnMpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29tcGlsZU5vZGUgPSBiZWZvcmVUZW1wbGF0ZUNvbXBpbGVOb2RlO1xyXG4gICAgICAgICAgICAkY29tcGlsZU5vZGUuaHRtbChjb250ZW50KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBkaXJlY3RpdmVzLnVuc2hpZnQoZGVyaXZlZFN5bmNEaXJlY3RpdmUpO1xyXG5cclxuICAgICAgICAgIGFmdGVyVGVtcGxhdGVOb2RlTGlua0ZuID0gYXBwbHlEaXJlY3RpdmVzVG9Ob2RlKGRpcmVjdGl2ZXMsIGNvbXBpbGVOb2RlLCB0QXR0cnMsIGNoaWxkVHJhbnNjbHVkZUZuLCAkY29tcGlsZU5vZGUsIG9yaWdBc3luY0RpcmVjdGl2ZSk7XHJcbiAgICAgICAgICBmb3JFYWNoKCRyb290RWxlbWVudCwgZnVuY3Rpb24obm9kZSwgaSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSA9PSBjb21waWxlTm9kZSkge1xyXG4gICAgICAgICAgICAgICRyb290RWxlbWVudFtpXSA9ICRjb21waWxlTm9kZVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBhZnRlclRlbXBsYXRlQ2hpbGRMaW5rRm4gPSBjb21waWxlTm9kZXMoJGNvbXBpbGVOb2RlWzBdLmNoaWxkTm9kZXMsIGNoaWxkVHJhbnNjbHVkZUZuKTtcclxuXHJcblxyXG4gICAgICAgICAgd2hpbGUobGlua1F1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSBsaW5rUXVldWUuc2hpZnQoKSxcclxuICAgICAgICAgICAgICAgIGJlZm9yZVRlbXBsYXRlTGlua05vZGUgPSBsaW5rUXVldWUuc2hpZnQoKSxcclxuICAgICAgICAgICAgICAgIGxpbmtSb290RWxlbWVudCA9IGxpbmtRdWV1ZS5zaGlmdCgpLFxyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlciA9IGxpbmtRdWV1ZS5zaGlmdCgpLFxyXG4gICAgICAgICAgICAgICAgbGlua05vZGUgPSAkY29tcGlsZU5vZGVbMF07XHJcblxyXG4gICAgICAgICAgICBpZiAoYmVmb3JlVGVtcGxhdGVMaW5rTm9kZSAhPT0gYmVmb3JlVGVtcGxhdGVDb21waWxlTm9kZSkge1xyXG4gICAgICAgICAgICAgIC8vIGl0IHdhcyBjbG9uZWQgdGhlcmVmb3JlIHdlIGhhdmUgdG8gY2xvbmUgYXMgd2VsbC5cclxuICAgICAgICAgICAgICBsaW5rTm9kZSA9IEpRTGl0ZUNsb25lKGNvbXBpbGVOb2RlKTtcclxuICAgICAgICAgICAgICByZXBsYWNlV2l0aChsaW5rUm9vdEVsZW1lbnQsIGpxTGl0ZShiZWZvcmVUZW1wbGF0ZUxpbmtOb2RlKSwgbGlua05vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhZnRlclRlbXBsYXRlTm9kZUxpbmtGbihcclxuICAgICAgICAgICAgICBiZWZvcmVUZW1wbGF0ZU5vZGVMaW5rRm4oYWZ0ZXJUZW1wbGF0ZUNoaWxkTGlua0ZuLCBzY29wZSwgbGlua05vZGUsICRyb290RWxlbWVudCwgY29udHJvbGxlciksXHJcbiAgICAgICAgICAgICAgc2NvcGUsIGxpbmtOb2RlLCAkcm9vdEVsZW1lbnQsIGNvbnRyb2xsZXJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxpbmtRdWV1ZSA9IG51bGw7XHJcbiAgICAgICAgfSkuXHJcbiAgICAgICAgZXJyb3IoZnVuY3Rpb24ocmVzcG9uc2UsIGNvZGUsIGhlYWRlcnMsIGNvbmZpZykge1xyXG4gICAgICAgICAgdGhyb3cgJGNvbXBpbGVNaW5FcnIoJ3RwbG9hZCcsICdGYWlsZWQgdG8gbG9hZCB0ZW1wbGF0ZTogezB9JywgY29uZmlnLnVybCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXllZE5vZGVMaW5rRm4oaWdub3JlQ2hpbGRMaW5rRm4sIHNjb3BlLCBub2RlLCByb290RWxlbWVudCwgY29udHJvbGxlcikge1xyXG4gICAgICAgIGlmIChsaW5rUXVldWUpIHtcclxuICAgICAgICAgIGxpbmtRdWV1ZS5wdXNoKHNjb3BlKTtcclxuICAgICAgICAgIGxpbmtRdWV1ZS5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgbGlua1F1ZXVlLnB1c2gocm9vdEVsZW1lbnQpO1xyXG4gICAgICAgICAgbGlua1F1ZXVlLnB1c2goY29udHJvbGxlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFmdGVyVGVtcGxhdGVOb2RlTGlua0ZuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBiZWZvcmVUZW1wbGF0ZU5vZGVMaW5rRm4oYWZ0ZXJUZW1wbGF0ZUNoaWxkTGlua0ZuLCBzY29wZSwgbm9kZSwgcm9vdEVsZW1lbnQsIGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgfSwgc2NvcGUsIG5vZGUsIHJvb3RFbGVtZW50LCBjb250cm9sbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29ydGluZyBmdW5jdGlvbiBmb3IgYm91bmQgZGlyZWN0aXZlcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYnlQcmlvcml0eShhLCBiKSB7XHJcbiAgICAgIHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gYXNzZXJ0Tm9EdXBsaWNhdGUod2hhdCwgcHJldmlvdXNEaXJlY3RpdmUsIGRpcmVjdGl2ZSwgZWxlbWVudCkge1xyXG4gICAgICBpZiAocHJldmlvdXNEaXJlY3RpdmUpIHtcclxuICAgICAgICB0aHJvdyAkY29tcGlsZU1pbkVycignbXVsdGlkaXInLCAnTXVsdGlwbGUgZGlyZWN0aXZlcyBbezB9LCB7MX1dIGFza2luZyBmb3IgezJ9IG9uOiB7M30nLFxyXG4gICAgICAgICAgICBwcmV2aW91c0RpcmVjdGl2ZS5uYW1lLCBkaXJlY3RpdmUubmFtZSwgd2hhdCwgc3RhcnRpbmdUYWcoZWxlbWVudCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFRleHRJbnRlcnBvbGF0ZURpcmVjdGl2ZShkaXJlY3RpdmVzLCB0ZXh0KSB7XHJcbiAgICAgIHZhciBpbnRlcnBvbGF0ZUZuID0gJGludGVycG9sYXRlKHRleHQsIHRydWUpO1xyXG4gICAgICBpZiAoaW50ZXJwb2xhdGVGbikge1xyXG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaCh7XHJcbiAgICAgICAgICBwcmlvcml0eTogMCxcclxuICAgICAgICAgIGNvbXBpbGU6IHZhbHVlRm4oZnVuY3Rpb24gdGV4dEludGVycG9sYXRlTGlua0ZuKHNjb3BlLCBub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudCgpLFxyXG4gICAgICAgICAgICAgICAgYmluZGluZ3MgPSBwYXJlbnQuZGF0YSgnJGJpbmRpbmcnKSB8fCBbXTtcclxuICAgICAgICAgICAgYmluZGluZ3MucHVzaChpbnRlcnBvbGF0ZUZuKTtcclxuICAgICAgICAgICAgc2FmZUFkZENsYXNzKHBhcmVudC5kYXRhKCckYmluZGluZycsIGJpbmRpbmdzKSwgJ25nLWJpbmRpbmcnKTtcclxuICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGludGVycG9sYXRlRm4sIGZ1bmN0aW9uIGludGVycG9sYXRlRm5XYXRjaEFjdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIG5vZGVbMF0ubm9kZVZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRUcnVzdGVkQ29udGV4dChub2RlLCBhdHRyTm9ybWFsaXplZE5hbWUpIHtcclxuICAgICAgLy8gbWFjdGlvblt4bGluazpocmVmXSBjYW4gc291cmNlIFNWRy4gIEl0J3Mgbm90IGxpbWl0ZWQgdG8gPG1hY3Rpb24+LlxyXG4gICAgICBpZiAoYXR0ck5vcm1hbGl6ZWROYW1lID09IFwieGxpbmtIcmVmXCIgfHxcclxuICAgICAgICAgIChub2RlTmFtZV8obm9kZSkgIT0gXCJJTUdcIiAmJiAoYXR0ck5vcm1hbGl6ZWROYW1lID09IFwic3JjXCIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJOb3JtYWxpemVkTmFtZSA9PSBcIm5nU3JjXCIpKSkge1xyXG4gICAgICAgIHJldHVybiAkc2NlLlJFU09VUkNFX1VSTDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRBdHRySW50ZXJwb2xhdGVEaXJlY3RpdmUobm9kZSwgZGlyZWN0aXZlcywgdmFsdWUsIG5hbWUpIHtcclxuICAgICAgdmFyIGludGVycG9sYXRlRm4gPSAkaW50ZXJwb2xhdGUodmFsdWUsIHRydWUpO1xyXG5cclxuICAgICAgLy8gbm8gaW50ZXJwb2xhdGlvbiBmb3VuZCAtPiBpZ25vcmVcclxuICAgICAgaWYgKCFpbnRlcnBvbGF0ZUZuKSByZXR1cm47XHJcblxyXG5cclxuICAgICAgaWYgKG5hbWUgPT09IFwibXVsdGlwbGVcIiAmJiBub2RlTmFtZV8obm9kZSkgPT09IFwiU0VMRUNUXCIpIHtcclxuICAgICAgICB0aHJvdyAkY29tcGlsZU1pbkVycihcInNlbG11bHRpXCIsIFwiQmluZGluZyB0byB0aGUgJ211bHRpcGxlJyBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZC4gRWxlbWVudDogezB9XCIsXHJcbiAgICAgICAgICAgIHN0YXJ0aW5nVGFnKG5vZGUpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGlyZWN0aXZlcy5wdXNoKHtcclxuICAgICAgICBwcmlvcml0eTogMTAwLFxyXG4gICAgICAgIGNvbXBpbGU6IHZhbHVlRm4oZnVuY3Rpb24gYXR0ckludGVycG9sYXRlTGlua0ZuKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcbiAgICAgICAgICB2YXIgJCRvYnNlcnZlcnMgPSAoYXR0ci4kJG9ic2VydmVycyB8fCAoYXR0ci4kJG9ic2VydmVycyA9IHt9KSk7XHJcblxyXG4gICAgICAgICAgaWYgKEVWRU5UX0hBTkRMRVJfQVRUUl9SRUdFWFAudGVzdChuYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyAkY29tcGlsZU1pbkVycignbm9kb21ldmVudHMnLFxyXG4gICAgICAgICAgICAgICAgXCJJbnRlcnBvbGF0aW9ucyBmb3IgSFRNTCBET00gZXZlbnQgYXR0cmlidXRlcyBhcmUgZGlzYWxsb3dlZC4gIFBsZWFzZSB1c2UgdGhlIG5nLSBcIiArXHJcbiAgICAgICAgICAgICAgICBcInZlcnNpb25zIChzdWNoIGFzIG5nLWNsaWNrIGluc3RlYWQgb2Ygb25jbGljaykgaW5zdGVhZC5cIik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBpbnRlcnBvbGF0ZSBhZ2FpbiwgaW4gY2FzZSB0aGUgYXR0cmlidXRlIHZhbHVlIGhhcyBiZWVuIHVwZGF0ZWRcclxuICAgICAgICAgIC8vIChlLmcuIGJ5IGFub3RoZXIgZGlyZWN0aXZlJ3MgY29tcGlsZSBmdW5jdGlvbilcclxuICAgICAgICAgIGludGVycG9sYXRlRm4gPSAkaW50ZXJwb2xhdGUoYXR0cltuYW1lXSwgdHJ1ZSwgZ2V0VHJ1c3RlZENvbnRleHQobm9kZSwgbmFtZSkpO1xyXG5cclxuICAgICAgICAgIC8vIGlmIGF0dHJpYnV0ZSB3YXMgdXBkYXRlZCBzbyB0aGF0IHRoZXJlIGlzIG5vIGludGVycG9sYXRpb24gZ29pbmcgb24gd2UgZG9uJ3Qgd2FudCB0b1xyXG4gICAgICAgICAgLy8gcmVnaXN0ZXIgYW55IG9ic2VydmVyc1xyXG4gICAgICAgICAgaWYgKCFpbnRlcnBvbGF0ZUZuKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgYXR0cltuYW1lXSA9IGludGVycG9sYXRlRm4oc2NvcGUpO1xyXG4gICAgICAgICAgKCQkb2JzZXJ2ZXJzW25hbWVdIHx8ICgkJG9ic2VydmVyc1tuYW1lXSA9IFtdKSkuJCRpbnRlciA9IHRydWU7XHJcbiAgICAgICAgICAoYXR0ci4kJG9ic2VydmVycyAmJiBhdHRyLiQkb2JzZXJ2ZXJzW25hbWVdLiQkc2NvcGUgfHwgc2NvcGUpLlxyXG4gICAgICAgICAgICAkd2F0Y2goaW50ZXJwb2xhdGVGbiwgZnVuY3Rpb24gaW50ZXJwb2xhdGVGbldhdGNoQWN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgYXR0ci4kc2V0KG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBhIHNwZWNpYWwganFMaXRlLnJlcGxhY2VXaXRoLCB3aGljaCBjYW4gcmVwbGFjZSBpdGVtcyB3aGljaFxyXG4gICAgICogaGF2ZSBubyBwYXJlbnRzLCBwcm92aWRlZCB0aGF0IHRoZSBjb250YWluaW5nIGpxTGl0ZSBjb2xsZWN0aW9uIGlzIHByb3ZpZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SnFMaXRlPX0gJHJvb3RFbGVtZW50IFRoZSByb290IG9mIHRoZSBjb21waWxlIHRyZWUuIFVzZWQgc28gdGhhdCB3ZSBjYW4gcmVwbGFjZSBub2Rlc1xyXG4gICAgICogICAgaW4gdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXHJcbiAgICAgKiBAcGFyYW0ge0pxTGl0ZX0gZWxlbWVudHNUb1JlbW92ZSBUaGUganFMaXRlIGVsZW1lbnQgd2hpY2ggd2UgYXJlIGdvaW5nIHRvIHJlcGxhY2UuIFdlIGtlZXAgdGhlIHNoZWxsLFxyXG4gICAgICogICAgYnV0IHJlcGxhY2UgaXRzIERPTSBub2RlIHJlZmVyZW5jZS5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbmV3Tm9kZSBUaGUgbmV3IERPTSBub2RlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlV2l0aCgkcm9vdEVsZW1lbnQsIGVsZW1lbnRzVG9SZW1vdmUsIG5ld05vZGUpIHtcclxuICAgICAgdmFyIGZpcnN0RWxlbWVudFRvUmVtb3ZlID0gZWxlbWVudHNUb1JlbW92ZVswXSxcclxuICAgICAgICAgIHJlbW92ZUNvdW50ID0gZWxlbWVudHNUb1JlbW92ZS5sZW5ndGgsXHJcbiAgICAgICAgICBwYXJlbnQgPSBmaXJzdEVsZW1lbnRUb1JlbW92ZS5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgaSwgaWk7XHJcblxyXG4gICAgICBpZiAoJHJvb3RFbGVtZW50KSB7XHJcbiAgICAgICAgZm9yKGkgPSAwLCBpaSA9ICRyb290RWxlbWVudC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoJHJvb3RFbGVtZW50W2ldID09IGZpcnN0RWxlbWVudFRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICRyb290RWxlbWVudFtpKytdID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGksIGoyID0gaiArIHJlbW92ZUNvdW50IC0gMSxcclxuICAgICAgICAgICAgICAgICAgICAgamogPSAkcm9vdEVsZW1lbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgIGogPCBqajsgaisrLCBqMisrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGoyIDwgamopIHtcclxuICAgICAgICAgICAgICAgICRyb290RWxlbWVudFtqXSA9ICRyb290RWxlbWVudFtqMl07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSAkcm9vdEVsZW1lbnRbal07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICRyb290RWxlbWVudC5sZW5ndGggLT0gcmVtb3ZlQ291bnQgLSAxO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKG5ld05vZGUsIGZpcnN0RWxlbWVudFRvUmVtb3ZlKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGZpcnN0RWxlbWVudFRvUmVtb3ZlKTtcclxuICAgICAgbmV3Tm9kZVtqcUxpdGUuZXhwYW5kb10gPSBmaXJzdEVsZW1lbnRUb1JlbW92ZVtqcUxpdGUuZXhwYW5kb107XHJcbiAgICAgIGZvciAodmFyIGsgPSAxLCBrayA9IGVsZW1lbnRzVG9SZW1vdmUubGVuZ3RoOyBrIDwga2s7IGsrKykge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNUb1JlbW92ZVtrXTtcclxuICAgICAgICBqcUxpdGUoZWxlbWVudCkucmVtb3ZlKCk7IC8vIG11c3QgZG8gdGhpcyB3YXkgdG8gY2xlYW4gdXAgZXhwYW5kb1xyXG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG4gICAgICAgIGRlbGV0ZSBlbGVtZW50c1RvUmVtb3ZlW2tdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbGVtZW50c1RvUmVtb3ZlWzBdID0gbmV3Tm9kZTtcclxuICAgICAgZWxlbWVudHNUb1JlbW92ZS5sZW5ndGggPSAxXHJcbiAgICB9XHJcbiAgfV07XHJcbn1cclxuXHJcbnZhciBQUkVGSVhfUkVHRVhQID0gL14oeFtcXDpcXC1fXXxkYXRhW1xcOlxcLV9dKS9pO1xyXG4vKipcclxuICogQ29udmVydHMgYWxsIGFjY2VwdGVkIGRpcmVjdGl2ZXMgZm9ybWF0IGludG8gcHJvcGVyIGRpcmVjdGl2ZSBuYW1lLlxyXG4gKiBBbGwgb2YgdGhlc2Ugd2lsbCBiZWNvbWUgJ215RGlyZWN0aXZlJzpcclxuICogICBteTpEaXJlY3RpdmVcclxuICogICBteS1kaXJlY3RpdmVcclxuICogICB4LW15LWRpcmVjdGl2ZVxyXG4gKiAgIGRhdGEtbXk6ZGlyZWN0aXZlXHJcbiAqXHJcbiAqIEFsc28gdGhlcmUgaXMgc3BlY2lhbCBjYXNlIGZvciBNb3ogcHJlZml4IHN0YXJ0aW5nIHdpdGggdXBwZXIgY2FzZSBsZXR0ZXIuXHJcbiAqIEBwYXJhbSBuYW1lIE5hbWUgdG8gbm9ybWFsaXplXHJcbiAqL1xyXG5mdW5jdGlvbiBkaXJlY3RpdmVOb3JtYWxpemUobmFtZSkge1xyXG4gIHJldHVybiBjYW1lbENhc2UobmFtZS5yZXBsYWNlKFBSRUZJWF9SRUdFWFAsICcnKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRjb21waWxlLmRpcmVjdGl2ZS5BdHRyaWJ1dGVzXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBBIHNoYXJlZCBvYmplY3QgYmV0d2VlbiBkaXJlY3RpdmUgY29tcGlsZSAvIGxpbmtpbmcgZnVuY3Rpb25zIHdoaWNoIGNvbnRhaW5zIG5vcm1hbGl6ZWQgRE9NIGVsZW1lbnRcclxuICogYXR0cmlidXRlcy4gVGhlIHRoZSB2YWx1ZXMgcmVmbGVjdCBjdXJyZW50IGJpbmRpbmcgc3RhdGUgYHt7IH19YC4gVGhlIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkXHJcbiAqIHNpbmNlIGFsbCBvZiB0aGVzZSBhcmUgdHJlYXRlZCBhcyBlcXVpdmFsZW50IGluIEFuZ3VsYXI6XHJcbiAqXHJcbiAqICAgICAgICAgIDxzcGFuIG5nOmJpbmQ9XCJhXCIgbmctYmluZD1cImFcIiBkYXRhLW5nLWJpbmQ9XCJhXCIgeC1uZy1iaW5kPVwiYVwiPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgcHJvcGVydHlcclxuICogQG5hbWUgbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXMjJGF0dHJcclxuICogQHByb3BlcnR5T2YgbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXNcclxuICogQHJldHVybnMge29iamVjdH0gQSBtYXAgb2YgRE9NIGVsZW1lbnQgYXR0cmlidXRlIG5hbWVzIHRvIHRoZSBub3JtYWxpemVkIG5hbWUuIFRoaXMgaXNcclxuICogICAgICAgICAgbmVlZGVkIHRvIGRvIHJldmVyc2UgbG9va3VwIGZyb20gbm9ybWFsaXplZCBuYW1lIGJhY2sgdG8gYWN0dWFsIG5hbWUuXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXMjJHNldFxyXG4gKiBAbWV0aG9kT2YgbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXNcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTZXQgRE9NIGVsZW1lbnQgYXR0cmlidXRlIHZhbHVlLlxyXG4gKlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOb3JtYWxpemVkIGVsZW1lbnQgYXR0cmlidXRlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIG1vZGlmeS4gVGhlIG5hbWUgaXNcclxuICogICAgICAgICAgcmV2ZXJzIHRyYW5zbGF0ZWQgdXNpbmcgdGhlIHtAbGluayBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlcyMkYXR0ciAkYXR0cn1cclxuICogICAgICAgICAgcHJvcGVydHkgdG8gdGhlIG9yaWdpbmFsIG5hbWUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0by4gVGhlIHZhbHVlIGNhbiBiZSBhbiBpbnRlcnBvbGF0ZWQgc3RyaW5nLlxyXG4gKi9cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIENsb3N1cmUgY29tcGlsZXIgdHlwZSBpbmZvcm1hdGlvblxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG5vZGVzZXRMaW5raW5nRm4oXHJcbiAgLyogYW5ndWxhci5TY29wZSAqLyBzY29wZSxcclxuICAvKiBOb2RlTGlzdCAqLyBub2RlTGlzdCxcclxuICAvKiBFbGVtZW50ICovIHJvb3RFbGVtZW50LFxyXG4gIC8qIGZ1bmN0aW9uKEZ1bmN0aW9uKSAqLyBib3VuZFRyYW5zY2x1ZGVGblxyXG4pe31cclxuXHJcbmZ1bmN0aW9uIGRpcmVjdGl2ZUxpbmtpbmdGbihcclxuICAvKiBub2Rlc2V0TGlua2luZ0ZuICovIG5vZGVzZXRMaW5raW5nRm4sXHJcbiAgLyogYW5ndWxhci5TY29wZSAqLyBzY29wZSxcclxuICAvKiBOb2RlICovIG5vZGUsXHJcbiAgLyogRWxlbWVudCAqLyByb290RWxlbWVudCxcclxuICAvKiBmdW5jdGlvbihGdW5jdGlvbikgKi8gYm91bmRUcmFuc2NsdWRlRm5cclxuKXt9XHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy4kY29udHJvbGxlclByb3ZpZGVyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUge0BsaW5rIG5nLiRjb250cm9sbGVyICRjb250cm9sbGVyIHNlcnZpY2V9IGlzIHVzZWQgYnkgQW5ndWxhciB0byBjcmVhdGUgbmV3XHJcbiAqIGNvbnRyb2xsZXJzLlxyXG4gKlxyXG4gKiBUaGlzIHByb3ZpZGVyIGFsbG93cyBjb250cm9sbGVyIHJlZ2lzdHJhdGlvbiB2aWEgdGhlXHJcbiAqIHtAbGluayBuZy4kY29udHJvbGxlclByb3ZpZGVyI3JlZ2lzdGVyIHJlZ2lzdGVyfSBtZXRob2QuXHJcbiAqL1xyXG5mdW5jdGlvbiAkQ29udHJvbGxlclByb3ZpZGVyKCkge1xyXG4gIHZhciBjb250cm9sbGVycyA9IHt9LFxyXG4gICAgICBDTlRSTF9SRUcgPSAvXihcXFMrKShcXHMrYXNcXHMrKFxcdyspKT8kLztcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLiRjb250cm9sbGVyUHJvdmlkZXIjcmVnaXN0ZXJcclxuICAgKiBAbWV0aG9kT2YgbmcuJGNvbnRyb2xsZXJQcm92aWRlclxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENvbnRyb2xsZXIgbmFtZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258QXJyYXl9IGNvbnN0cnVjdG9yIENvbnRyb2xsZXIgY29uc3RydWN0b3IgZm4gKG9wdGlvbmFsbHkgZGVjb3JhdGVkIHdpdGggRElcclxuICAgKiAgICBhbm5vdGF0aW9ucyBpbiB0aGUgYXJyYXkgbm90YXRpb24pLlxyXG4gICAqL1xyXG4gIHRoaXMucmVnaXN0ZXIgPSBmdW5jdGlvbihuYW1lLCBjb25zdHJ1Y3Rvcikge1xyXG4gICAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XHJcbiAgICAgIGV4dGVuZChjb250cm9sbGVycywgbmFtZSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRyb2xsZXJzW25hbWVdID0gY29uc3RydWN0b3I7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcblxyXG4gIHRoaXMuJGdldCA9IFsnJGluamVjdG9yJywgJyR3aW5kb3cnLCBmdW5jdGlvbigkaW5qZWN0b3IsICR3aW5kb3cpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgbmcuJGNvbnRyb2xsZXJcclxuICAgICAqIEByZXF1aXJlcyAkaW5qZWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gY29uc3RydWN0b3IgSWYgY2FsbGVkIHdpdGggYSBmdW5jdGlvbiB0aGVuIGl0J3MgY29uc2lkZXJlZCB0byBiZSB0aGVcclxuICAgICAqICAgIGNvbnRyb2xsZXIgY29uc3RydWN0b3IgZnVuY3Rpb24uIE90aGVyd2lzZSBpdCdzIGNvbnNpZGVyZWQgdG8gYmUgYSBzdHJpbmcgd2hpY2ggaXMgdXNlZFxyXG4gICAgICogICAgdG8gcmV0cmlldmUgdGhlIGNvbnRyb2xsZXIgY29uc3RydWN0b3IgdXNpbmcgdGhlIGZvbGxvd2luZyBzdGVwczpcclxuICAgICAqXHJcbiAgICAgKiAgICAqIGNoZWNrIGlmIGEgY29udHJvbGxlciB3aXRoIGdpdmVuIG5hbWUgaXMgcmVnaXN0ZXJlZCB2aWEgYCRjb250cm9sbGVyUHJvdmlkZXJgXHJcbiAgICAgKiAgICAqIGNoZWNrIGlmIGV2YWx1YXRpbmcgdGhlIHN0cmluZyBvbiB0aGUgY3VycmVudCBzY29wZSByZXR1cm5zIGEgY29uc3RydWN0b3JcclxuICAgICAqICAgICogY2hlY2sgYHdpbmRvd1tjb25zdHJ1Y3Rvcl1gIG9uIHRoZSBnbG9iYWwgYHdpbmRvd2Agb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvY2FscyBJbmplY3Rpb24gbG9jYWxzIGZvciBDb250cm9sbGVyLlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBJbnN0YW5jZSBvZiBnaXZlbiBjb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogYCRjb250cm9sbGVyYCBzZXJ2aWNlIGlzIHJlc3BvbnNpYmxlIGZvciBpbnN0YW50aWF0aW5nIGNvbnRyb2xsZXJzLlxyXG4gICAgICpcclxuICAgICAqIEl0J3MganVzdCBhIHNpbXBsZSBjYWxsIHRvIHtAbGluayBBVVRPLiRpbmplY3RvciAkaW5qZWN0b3J9LCBidXQgZXh0cmFjdGVkIGludG9cclxuICAgICAqIGEgc2VydmljZSwgc28gdGhhdCBvbmUgY2FuIG92ZXJyaWRlIHRoaXMgc2VydmljZSB3aXRoIHtAbGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xNjQ5Nzg4XHJcbiAgICAgKiBCQyB2ZXJzaW9ufS5cclxuICAgICAqL1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV4cHJlc3Npb24sIGxvY2Fscykge1xyXG4gICAgICB2YXIgaW5zdGFuY2UsIG1hdGNoLCBjb25zdHJ1Y3RvciwgaWRlbnRpZmllcjtcclxuXHJcbiAgICAgIGlmKGlzU3RyaW5nKGV4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgbWF0Y2ggPSBleHByZXNzaW9uLm1hdGNoKENOVFJMX1JFRyksXHJcbiAgICAgICAgY29uc3RydWN0b3IgPSBtYXRjaFsxXSxcclxuICAgICAgICBpZGVudGlmaWVyID0gbWF0Y2hbM107XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGNvbnRyb2xsZXJzLmhhc093blByb3BlcnR5KGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAgICA/IGNvbnRyb2xsZXJzW2NvbnN0cnVjdG9yXVxyXG4gICAgICAgICAgICA6IGdldHRlcihsb2NhbHMuJHNjb3BlLCBjb25zdHJ1Y3RvciwgdHJ1ZSkgfHwgZ2V0dGVyKCR3aW5kb3csIGNvbnN0cnVjdG9yLCB0cnVlKTtcclxuXHJcbiAgICAgICAgYXNzZXJ0QXJnRm4oZXhwcmVzc2lvbiwgY29uc3RydWN0b3IsIHRydWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpbnN0YW5jZSA9ICRpbmplY3Rvci5pbnN0YW50aWF0ZShleHByZXNzaW9uLCBsb2NhbHMpO1xyXG5cclxuICAgICAgaWYgKGlkZW50aWZpZXIpIHtcclxuICAgICAgICBpZiAoIShsb2NhbHMgJiYgdHlwZW9mIGxvY2Fscy4kc2NvcGUgPT0gJ29iamVjdCcpKSB7XHJcbiAgICAgICAgICB0aHJvdyBtaW5FcnIoJyRjb250cm9sbGVyJykoJ25vc2NwJywgXCJDYW5ub3QgZXhwb3J0IGNvbnRyb2xsZXIgJ3swfScgYXMgJ3sxfSchIE5vICRzY29wZSBvYmplY3QgcHJvdmlkZWQgdmlhIGBsb2NhbHNgLlwiLCBjb25zdHJ1Y3RvciB8fCBleHByZXNzaW9uLm5hbWUsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbG9jYWxzLiRzY29wZVtpZGVudGlmaWVyXSA9IGluc3RhbmNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9O1xyXG4gIH1dO1xyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy4kZG9jdW1lbnRcclxuICogQHJlcXVpcmVzICR3aW5kb3dcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEge0BsaW5rIGFuZ3VsYXIuZWxlbWVudCBqUXVlcnkgKGxpdGUpfS13cmFwcGVkIHJlZmVyZW5jZSB0byB0aGUgYnJvd3NlcidzIGB3aW5kb3cuZG9jdW1lbnRgXHJcbiAqIGVsZW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiAkRG9jdW1lbnRQcm92aWRlcigpe1xyXG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsIGZ1bmN0aW9uKHdpbmRvdyl7XHJcbiAgICByZXR1cm4ganFMaXRlKHdpbmRvdy5kb2N1bWVudCk7XHJcbiAgfV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgbmcuJGV4Y2VwdGlvbkhhbmRsZXJcclxuICogQHJlcXVpcmVzICRsb2dcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEFueSB1bmNhdWdodCBleGNlcHRpb24gaW4gYW5ndWxhciBleHByZXNzaW9ucyBpcyBkZWxlZ2F0ZWQgdG8gdGhpcyBzZXJ2aWNlLlxyXG4gKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgZGVsZWdhdGVzIHRvIGAkbG9nLmVycm9yYCB3aGljaCBsb2dzIGl0IGludG9cclxuICogdGhlIGJyb3dzZXIgY29uc29sZS5cclxuICpcclxuICogSW4gdW5pdCB0ZXN0cywgaWYgYGFuZ3VsYXItbW9ja3MuanNgIGlzIGxvYWRlZCwgdGhpcyBzZXJ2aWNlIGlzIG92ZXJyaWRkZW4gYnlcclxuICoge0BsaW5rIG5nTW9jay4kZXhjZXB0aW9uSGFuZGxlciBtb2NrICRleGNlcHRpb25IYW5kbGVyfSB3aGljaCBhaWRzIGluIHRlc3RpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RXJyb3J9IGV4Y2VwdGlvbiBFeGNlcHRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBlcnJvci5cclxuICogQHBhcmFtIHtzdHJpbmc9fSBjYXVzZSBvcHRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29udGV4dCBpbiB3aGljaFxyXG4gKiAgICAgICB0aGUgZXJyb3Igd2FzIHRocm93bi5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uICRFeGNlcHRpb25IYW5kbGVyUHJvdmlkZXIoKSB7XHJcbiAgdGhpcy4kZ2V0ID0gWyckbG9nJywgZnVuY3Rpb24oJGxvZykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV4Y2VwdGlvbiwgY2F1c2UpIHtcclxuICAgICAgJGxvZy5lcnJvci5hcHBseSgkbG9nLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9XTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBrZXkgdmFsdWUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJzIFJhdyBoZWFkZXJzIGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFBhcnNlZCBoZWFkZXJzIGFzIGtleSB2YWx1ZSBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XHJcbiAgdmFyIHBhcnNlZCA9IHt9LCBrZXksIHZhbCwgaTtcclxuXHJcbiAgaWYgKCFoZWFkZXJzKSByZXR1cm4gcGFyc2VkO1xyXG5cclxuICBmb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbihsaW5lKSB7XHJcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XHJcbiAgICBrZXkgPSBsb3dlcmNhc2UodHJpbShsaW5lLnN1YnN0cigwLCBpKSkpO1xyXG4gICAgdmFsID0gdHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xyXG5cclxuICAgIGlmIChrZXkpIHtcclxuICAgICAgaWYgKHBhcnNlZFtrZXldKSB7XHJcbiAgICAgICAgcGFyc2VkW2tleV0gKz0gJywgJyArIHZhbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJzZWRba2V5XSA9IHZhbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gcGFyc2VkO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBwYXJzZWQgaGVhZGVycy5cclxuICpcclxuICogSGVhZGVycyBhcmUgbGF6eSBwYXJzZWQgd2hlbiBmaXJzdCByZXF1ZXN0ZWQuXHJcbiAqIEBzZWUgcGFyc2VIZWFkZXJzXHJcbiAqXHJcbiAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpfSBoZWFkZXJzIEhlYWRlcnMgdG8gcHJvdmlkZSBhY2Nlc3MgdG8uXHJcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmc9KX0gUmV0dXJucyBhIGdldHRlciBmdW5jdGlvbiB3aGljaCBpZiBjYWxsZWQgd2l0aDpcclxuICpcclxuICogICAtIGlmIGNhbGxlZCB3aXRoIHNpbmdsZSBhbiBhcmd1bWVudCByZXR1cm5zIGEgc2luZ2xlIGhlYWRlciB2YWx1ZSBvciBudWxsXHJcbiAqICAgLSBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgaGVhZGVycy5cclxuICovXHJcbmZ1bmN0aW9uIGhlYWRlcnNHZXR0ZXIoaGVhZGVycykge1xyXG4gIHZhciBoZWFkZXJzT2JqID0gaXNPYmplY3QoaGVhZGVycykgPyBoZWFkZXJzIDogdW5kZWZpbmVkO1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xyXG4gICAgaWYgKCFoZWFkZXJzT2JqKSBoZWFkZXJzT2JqID0gIHBhcnNlSGVhZGVycyhoZWFkZXJzKTtcclxuXHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICByZXR1cm4gaGVhZGVyc09ialtsb3dlcmNhc2UobmFtZSldIHx8IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhlYWRlcnNPYmo7XHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDaGFpbiBhbGwgZ2l2ZW4gZnVuY3Rpb25zXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgYm90aCByZXF1ZXN0IGFuZCByZXNwb25zZSB0cmFuc2Zvcm1pbmdcclxuICpcclxuICogQHBhcmFtIHsqfSBkYXRhIERhdGEgdG8gdHJhbnNmb3JtLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZz0pfSBoZWFkZXJzIEh0dHAgaGVhZGVycyBnZXR0ZXIgZm4uXHJcbiAqIEBwYXJhbSB7KGZ1bmN0aW9ufEFycmF5LjxmdW5jdGlvbj4pfSBmbnMgRnVuY3Rpb24gb3IgYW4gYXJyYXkgb2YgZnVuY3Rpb25zLlxyXG4gKiBAcmV0dXJucyB7Kn0gVHJhbnNmb3JtZWQgZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XHJcbiAgaWYgKGlzRnVuY3Rpb24oZm5zKSlcclxuICAgIHJldHVybiBmbnMoZGF0YSwgaGVhZGVycyk7XHJcblxyXG4gIGZvckVhY2goZm5zLCBmdW5jdGlvbihmbikge1xyXG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGlzU3VjY2VzcyhzdGF0dXMpIHtcclxuICByZXR1cm4gMjAwIDw9IHN0YXR1cyAmJiBzdGF0dXMgPCAzMDA7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiAkSHR0cFByb3ZpZGVyKCkge1xyXG4gIHZhciBKU09OX1NUQVJUID0gL15cXHMqKFxcW3xcXHtbXlxce10pLyxcclxuICAgICAgSlNPTl9FTkQgPSAvW1xcfVxcXV1cXHMqJC8sXHJcbiAgICAgIFBST1RFQ1RJT05fUFJFRklYID0gL15cXClcXF1cXH0nLD9cXG4vLFxyXG4gICAgICBDT05URU5UX1RZUEVfQVBQTElDQVRJT05fSlNPTiA9IHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCd9O1xyXG5cclxuICB2YXIgZGVmYXVsdHMgPSB0aGlzLmRlZmF1bHRzID0ge1xyXG4gICAgLy8gdHJhbnNmb3JtIGluY29taW5nIHJlc3BvbnNlIGRhdGFcclxuICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICBpZiAoaXNTdHJpbmcoZGF0YSkpIHtcclxuICAgICAgICAvLyBzdHJpcCBqc29uIHZ1bG5lcmFiaWxpdHkgcHJvdGVjdGlvbiBwcmVmaXhcclxuICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKFBST1RFQ1RJT05fUFJFRklYLCAnJyk7XHJcbiAgICAgICAgaWYgKEpTT05fU1RBUlQudGVzdChkYXRhKSAmJiBKU09OX0VORC50ZXN0KGRhdGEpKVxyXG4gICAgICAgICAgZGF0YSA9IGZyb21Kc29uKGRhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfV0sXHJcblxyXG4gICAgLy8gdHJhbnNmb3JtIG91dGdvaW5nIHJlcXVlc3QgZGF0YVxyXG4gICAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uKGQpIHtcclxuICAgICAgcmV0dXJuIGlzT2JqZWN0KGQpICYmICFpc0ZpbGUoZCkgPyB0b0pzb24oZCkgOiBkO1xyXG4gICAgfV0sXHJcblxyXG4gICAgLy8gZGVmYXVsdCBoZWFkZXJzXHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgIGNvbW1vbjoge1xyXG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xyXG4gICAgICB9LFxyXG4gICAgICBwb3N0OiAgIENPTlRFTlRfVFlQRV9BUFBMSUNBVElPTl9KU09OLFxyXG4gICAgICBwdXQ6ICAgIENPTlRFTlRfVFlQRV9BUFBMSUNBVElPTl9KU09OLFxyXG4gICAgICBwYXRjaDogIENPTlRFTlRfVFlQRV9BUFBMSUNBVElPTl9KU09OXHJcbiAgICB9LFxyXG5cclxuICAgIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXHJcbiAgICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTidcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBcmUgb3JkZXIgYnkgcmVxdWVzdC4gSS5FLiB0aGV5IGFyZSBhcHBsaWVkIGluIHRoZSBzYW1lIG9yZGVyIGFzXHJcbiAgICogYXJyYXkgb24gcmVxdWVzdCwgYnV0IHJldmVycyBvcmRlciBvbiByZXNwb25zZS5cclxuICAgKi9cclxuICB2YXIgaW50ZXJjZXB0b3JGYWN0b3JpZXMgPSB0aGlzLmludGVyY2VwdG9ycyA9IFtdO1xyXG4gIC8qKlxyXG4gICAqIEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIHJlc3BvbnNlIGludGVyY2VwdG9ycyBvcmRlcmVkIGJ5IHRoZSBvcmRlciBpbiB3aGljaFxyXG4gICAqIHRoZXkgYXJlIGFwcGxpZWQgdG8gcmVzcG9uc2UuIChUaGlzIGlzIGluIHJldmVycyB0byBpbnRlcmNlcHRvckZhY3RvcmllcylcclxuICAgKi9cclxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckZhY3RvcmllcyA9IHRoaXMucmVzcG9uc2VJbnRlcmNlcHRvcnMgPSBbXTtcclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckaHR0cEJhY2tlbmQnLCAnJGJyb3dzZXInLCAnJGNhY2hlRmFjdG9yeScsICckcm9vdFNjb3BlJywgJyRxJywgJyRpbmplY3RvcicsICckJHVybFV0aWxzJyxcclxuICAgICAgZnVuY3Rpb24oJGh0dHBCYWNrZW5kLCAkYnJvd3NlciwgJGNhY2hlRmFjdG9yeSwgJHJvb3RTY29wZSwgJHEsICRpbmplY3RvciwgJCR1cmxVdGlscykge1xyXG5cclxuICAgIHZhciBkZWZhdWx0Q2FjaGUgPSAkY2FjaGVGYWN0b3J5KCckaHR0cCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJjZXB0b3JzIHN0b3JlZCBpbiByZXZlcnNlIG9yZGVyLiBJbm5lciBpbnRlcmNlcHRvcnMgYmVmb3JlIG91dGVyIGludGVyY2VwdG9ycy5cclxuICAgICAqIFRoZSByZXZlcnNhbCBpcyBuZWVkZWQgc28gdGhhdCB3ZSBjYW4gYnVpbGQgdXAgdGhlIGludGVyY2VwdGlvbiBjaGFpbiBhcm91bmQgdGhlXHJcbiAgICAgKiBzZXJ2ZXIgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgdmFyIHJldmVyc2VkSW50ZXJjZXB0b3JzID0gW107XHJcblxyXG4gICAgZm9yRWFjaChpbnRlcmNlcHRvckZhY3RvcmllcywgZnVuY3Rpb24oaW50ZXJjZXB0b3JGYWN0b3J5KSB7XHJcbiAgICAgIHJldmVyc2VkSW50ZXJjZXB0b3JzLnVuc2hpZnQoaXNTdHJpbmcoaW50ZXJjZXB0b3JGYWN0b3J5KVxyXG4gICAgICAgICAgPyAkaW5qZWN0b3IuZ2V0KGludGVyY2VwdG9yRmFjdG9yeSkgOiAkaW5qZWN0b3IuaW52b2tlKGludGVyY2VwdG9yRmFjdG9yeSkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yRWFjaChyZXNwb25zZUludGVyY2VwdG9yRmFjdG9yaWVzLCBmdW5jdGlvbihpbnRlcmNlcHRvckZhY3RvcnksIGluZGV4KSB7XHJcbiAgICAgIHZhciByZXNwb25zZUZuID0gaXNTdHJpbmcoaW50ZXJjZXB0b3JGYWN0b3J5KVxyXG4gICAgICAgICAgPyAkaW5qZWN0b3IuZ2V0KGludGVyY2VwdG9yRmFjdG9yeSlcclxuICAgICAgICAgIDogJGluamVjdG9yLmludm9rZShpbnRlcmNlcHRvckZhY3RvcnkpO1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFJlc3BvbnNlIGludGVyY2VwdG9ycyBnbyBiZWZvcmUgXCJhcm91bmRcIiBpbnRlcmNlcHRvcnMgKG5vIHJlYWwgcmVhc29uLCBqdXN0XHJcbiAgICAgICAqIGhhZCB0byBwaWNrIG9uZS4pIEJ1dCB0aGV5IGFyZSBhbHJlYWR5IHJldmVyc2VkLCBzbyB3ZSBjYW4ndCB1c2UgdW5zaGlmdCwgaGVuY2VcclxuICAgICAgICogdGhlIHNwbGljZS5cclxuICAgICAgICovXHJcbiAgICAgIHJldmVyc2VkSW50ZXJjZXB0b3JzLnNwbGljZShpbmRleCwgMCwge1xyXG4gICAgICAgIHJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlRm4oJHEud2hlbihyZXNwb25zZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzcG9uc2VFcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgIHJldHVybiByZXNwb25zZUZuKCRxLnJlamVjdChyZXNwb25zZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIG5nLiRodHRwXHJcbiAgICAgKiBAcmVxdWlyZXMgJGh0dHBCYWNrZW5kXHJcbiAgICAgKiBAcmVxdWlyZXMgJGJyb3dzZXJcclxuICAgICAqIEByZXF1aXJlcyAkY2FjaGVGYWN0b3J5XHJcbiAgICAgKiBAcmVxdWlyZXMgJHJvb3RTY29wZVxyXG4gICAgICogQHJlcXVpcmVzICRxXHJcbiAgICAgKiBAcmVxdWlyZXMgJGluamVjdG9yXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBUaGUgYCRodHRwYCBzZXJ2aWNlIGlzIGEgY29yZSBBbmd1bGFyIHNlcnZpY2UgdGhhdCBmYWNpbGl0YXRlcyBjb21tdW5pY2F0aW9uIHdpdGggdGhlIHJlbW90ZVxyXG4gICAgICogSFRUUCBzZXJ2ZXJzIHZpYSB0aGUgYnJvd3NlcidzIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi94bWxodHRwcmVxdWVzdFxyXG4gICAgICogWE1MSHR0cFJlcXVlc3R9IG9iamVjdCBvciB2aWEge0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSlNPTlAgSlNPTlB9LlxyXG4gICAgICpcclxuICAgICAqIEZvciB1bml0IHRlc3RpbmcgYXBwbGljYXRpb25zIHRoYXQgdXNlIGAkaHR0cGAgc2VydmljZSwgc2VlXHJcbiAgICAgKiB7QGxpbmsgbmdNb2NrLiRodHRwQmFja2VuZCAkaHR0cEJhY2tlbmQgbW9ja30uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGEgaGlnaGVyIGxldmVsIG9mIGFic3RyYWN0aW9uLCBwbGVhc2UgY2hlY2sgb3V0IHRoZSB7QGxpbmsgbmdSZXNvdXJjZS4kcmVzb3VyY2VcclxuICAgICAqICRyZXNvdXJjZX0gc2VydmljZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgJGh0dHAgQVBJIGlzIGJhc2VkIG9uIHRoZSB7QGxpbmsgbmcuJHEgZGVmZXJyZWQvcHJvbWlzZSBBUElzfSBleHBvc2VkIGJ5XHJcbiAgICAgKiB0aGUgJHEgc2VydmljZS4gV2hpbGUgZm9yIHNpbXBsZSB1c2FnZSBwYXR0ZXJucyB0aGlzIGRvZXNuJ3QgbWF0dGVyIG11Y2gsIGZvciBhZHZhbmNlZCB1c2FnZVxyXG4gICAgICogaXQgaXMgaW1wb3J0YW50IHRvIGZhbWlsaWFyaXplIHlvdXJzZWxmIHdpdGggdGhlc2UgQVBJcyBhbmQgdGhlIGd1YXJhbnRlZXMgdGhleSBwcm92aWRlLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiAjIEdlbmVyYWwgdXNhZ2VcclxuICAgICAqIFRoZSBgJGh0dHBgIHNlcnZpY2UgaXMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudCDDouKCrOKAnSBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IMOi4oKs4oCdXHJcbiAgICAgKiB0aGF0IGlzIHVzZWQgdG8gZ2VuZXJhdGUgYW4gSFRUUCByZXF1ZXN0IGFuZCByZXR1cm5zICBhIHtAbGluayBuZy4kcSBwcm9taXNlfVxyXG4gICAgICogd2l0aCB0d28gJGh0dHAgc3BlY2lmaWMgbWV0aG9kczogYHN1Y2Nlc3NgIGFuZCBgZXJyb3JgLlxyXG4gICAgICpcclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiAgICRodHRwKHttZXRob2Q6ICdHRVQnLCB1cmw6ICcvc29tZVVybCd9KS5cclxuICAgICAqICAgICBzdWNjZXNzKGZ1bmN0aW9uKGRhdGEsIHN0YXR1cywgaGVhZGVycywgY29uZmlnKSB7XHJcbiAgICAgKiAgICAgICAvLyB0aGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgKiAgICAgICAvLyB3aGVuIHRoZSByZXNwb25zZSBpcyBhdmFpbGFibGVcclxuICAgICAqICAgICB9KS5cclxuICAgICAqICAgICBlcnJvcihmdW5jdGlvbihkYXRhLCBzdGF0dXMsIGhlYWRlcnMsIGNvbmZpZykge1xyXG4gICAgICogICAgICAgLy8gY2FsbGVkIGFzeW5jaHJvbm91c2x5IGlmIGFuIGVycm9yIG9jY3Vyc1xyXG4gICAgICogICAgICAgLy8gb3Igc2VydmVyIHJldHVybnMgcmVzcG9uc2Ugd2l0aCBhbiBlcnJvciBzdGF0dXMuXHJcbiAgICAgKiAgICAgfSk7XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqXHJcbiAgICAgKiBTaW5jZSB0aGUgcmV0dXJuZWQgdmFsdWUgb2YgY2FsbGluZyB0aGUgJGh0dHAgZnVuY3Rpb24gaXMgYSBgcHJvbWlzZWAsIHlvdSBjYW4gYWxzbyB1c2VcclxuICAgICAqIHRoZSBgdGhlbmAgbWV0aG9kIHRvIHJlZ2lzdGVyIGNhbGxiYWNrcywgYW5kIHRoZXNlIGNhbGxiYWNrcyB3aWxsIHJlY2VpdmUgYSBzaW5nbGUgYXJndW1lbnQgw6LigqzigJxcclxuICAgICAqIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlc3BvbnNlLiBTZWUgdGhlIEFQSSBzaWduYXR1cmUgYW5kIHR5cGUgaW5mbyBiZWxvdyBmb3IgbW9yZVxyXG4gICAgICogZGV0YWlscy5cclxuICAgICAqXHJcbiAgICAgKiBBIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGJldHdlZW4gMjAwIGFuZCAyOTkgaXMgY29uc2lkZXJlZCBhIHN1Y2Nlc3Mgc3RhdHVzIGFuZFxyXG4gICAgICogd2lsbCByZXN1bHQgaW4gdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgYmVpbmcgY2FsbGVkLiBOb3RlIHRoYXQgaWYgdGhlIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QsXHJcbiAgICAgKiBYTUxIdHRwUmVxdWVzdCB3aWxsIHRyYW5zcGFyZW50bHkgZm9sbG93IGl0LCBtZWFuaW5nIHRoYXQgdGhlIGVycm9yIGNhbGxiYWNrIHdpbGwgbm90IGJlXHJcbiAgICAgKiBjYWxsZWQgZm9yIHN1Y2ggcmVzcG9uc2VzLlxyXG4gICAgICpcclxuICAgICAqICMgU2hvcnRjdXQgbWV0aG9kc1xyXG4gICAgICpcclxuICAgICAqIFNpbmNlIGFsbCBpbnZvY2F0aW9ucyBvZiB0aGUgJGh0dHAgc2VydmljZSByZXF1aXJlIHBhc3NpbmcgaW4gYW4gSFRUUCBtZXRob2QgYW5kIFVSTCwgYW5kXHJcbiAgICAgKiBQT1NUL1BVVCByZXF1ZXN0cyByZXF1aXJlIHJlcXVlc3QgZGF0YSB0byBiZSBwcm92aWRlZCBhcyB3ZWxsLCBzaG9ydGN1dCBtZXRob2RzXHJcbiAgICAgKiB3ZXJlIGNyZWF0ZWQ6XHJcbiAgICAgKlxyXG4gICAgICogPHByZT5cclxuICAgICAqICAgJGh0dHAuZ2V0KCcvc29tZVVybCcpLnN1Y2Nlc3Moc3VjY2Vzc0NhbGxiYWNrKTtcclxuICAgICAqICAgJGh0dHAucG9zdCgnL3NvbWVVcmwnLCBkYXRhKS5zdWNjZXNzKHN1Y2Nlc3NDYWxsYmFjayk7XHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqXHJcbiAgICAgKiBDb21wbGV0ZSBsaXN0IG9mIHNob3J0Y3V0IG1ldGhvZHM6XHJcbiAgICAgKlxyXG4gICAgICogLSB7QGxpbmsgbmcuJGh0dHAjZ2V0ICRodHRwLmdldH1cclxuICAgICAqIC0ge0BsaW5rIG5nLiRodHRwI2hlYWQgJGh0dHAuaGVhZH1cclxuICAgICAqIC0ge0BsaW5rIG5nLiRodHRwI3Bvc3QgJGh0dHAucG9zdH1cclxuICAgICAqIC0ge0BsaW5rIG5nLiRodHRwI3B1dCAkaHR0cC5wdXR9XHJcbiAgICAgKiAtIHtAbGluayBuZy4kaHR0cCNkZWxldGUgJGh0dHAuZGVsZXRlfVxyXG4gICAgICogLSB7QGxpbmsgbmcuJGh0dHAjanNvbnAgJGh0dHAuanNvbnB9XHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICMgU2V0dGluZyBIVFRQIEhlYWRlcnNcclxuICAgICAqXHJcbiAgICAgKiBUaGUgJGh0dHAgc2VydmljZSB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkIGNlcnRhaW4gSFRUUCBoZWFkZXJzIHRvIGFsbCByZXF1ZXN0cy4gVGhlc2UgZGVmYXVsdHNcclxuICAgICAqIGNhbiBiZSBmdWxseSBjb25maWd1cmVkIGJ5IGFjY2Vzc2luZyB0aGUgYCRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVyc2AgY29uZmlndXJhdGlvblxyXG4gICAgICogb2JqZWN0LCB3aGljaCBjdXJyZW50bHkgY29udGFpbnMgdGhpcyBkZWZhdWx0IGNvbmZpZ3VyYXRpb246XHJcbiAgICAgKlxyXG4gICAgICogLSBgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vbmAgKGhlYWRlcnMgdGhhdCBhcmUgY29tbW9uIGZvciBhbGwgcmVxdWVzdHMpOlxyXG4gICAgICogICAtIGBBY2NlcHQ6IGFwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICogLyAqYFxyXG4gICAgICogLSBgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLnBvc3RgOiAoaGVhZGVyIGRlZmF1bHRzIGZvciBQT1NUIHJlcXVlc3RzKVxyXG4gICAgICogICAtIGBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25gXHJcbiAgICAgKiAtIGAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLmhlYWRlcnMucHV0YCAoaGVhZGVyIGRlZmF1bHRzIGZvciBQVVQgcmVxdWVzdHMpXHJcbiAgICAgKiAgIC0gYENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvbmBcclxuICAgICAqXHJcbiAgICAgKiBUbyBhZGQgb3Igb3ZlcndyaXRlIHRoZXNlIGRlZmF1bHRzLCBzaW1wbHkgYWRkIG9yIHJlbW92ZSBhIHByb3BlcnR5IGZyb20gdGhlc2UgY29uZmlndXJhdGlvblxyXG4gICAgICogb2JqZWN0cy4gVG8gYWRkIGhlYWRlcnMgZm9yIGFuIEhUVFAgbWV0aG9kIG90aGVyIHRoYW4gUE9TVCBvciBQVVQsIHNpbXBseSBhZGQgYSBuZXcgb2JqZWN0XHJcbiAgICAgKiB3aXRoIHRoZSBsb3dlcmNhc2VkIEhUVFAgbWV0aG9kIG5hbWUgYXMgdGhlIGtleSwgZS5nLlxyXG4gICAgICogYCRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVycy5nZXRbJ015LUhlYWRlciddPSd2YWx1ZSdgLlxyXG4gICAgICpcclxuICAgICAqIEFkZGl0aW9uYWxseSwgdGhlIGRlZmF1bHRzIGNhbiBiZSBzZXQgYXQgcnVudGltZSB2aWEgdGhlIGAkaHR0cC5kZWZhdWx0c2Agb2JqZWN0IGluIHRoZSBzYW1lXHJcbiAgICAgKiBmYXNoaW9uLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiAjIFRyYW5zZm9ybWluZyBSZXF1ZXN0cyBhbmQgUmVzcG9uc2VzXHJcbiAgICAgKlxyXG4gICAgICogQm90aCByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzIGNhbiBiZSB0cmFuc2Zvcm1lZCB1c2luZyB0cmFuc2Zvcm0gZnVuY3Rpb25zLiBCeSBkZWZhdWx0LCBBbmd1bGFyXHJcbiAgICAgKiBhcHBsaWVzIHRoZXNlIHRyYW5zZm9ybWF0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiBSZXF1ZXN0IHRyYW5zZm9ybWF0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiAtIElmIHRoZSBgZGF0YWAgcHJvcGVydHkgb2YgdGhlIHJlcXVlc3QgY29uZmlndXJhdGlvbiBvYmplY3QgY29udGFpbnMgYW4gb2JqZWN0LCBzZXJpYWxpemUgaXQgaW50b1xyXG4gICAgICogICBKU09OIGZvcm1hdC5cclxuICAgICAqXHJcbiAgICAgKiBSZXNwb25zZSB0cmFuc2Zvcm1hdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogIC0gSWYgWFNSRiBwcmVmaXggaXMgZGV0ZWN0ZWQsIHN0cmlwIGl0IChzZWUgU2VjdXJpdHkgQ29uc2lkZXJhdGlvbnMgc2VjdGlvbiBiZWxvdykuXHJcbiAgICAgKiAgLSBJZiBKU09OIHJlc3BvbnNlIGlzIGRldGVjdGVkLCBkZXNlcmlhbGl6ZSBpdCB1c2luZyBhIEpTT04gcGFyc2VyLlxyXG4gICAgICpcclxuICAgICAqIFRvIGdsb2JhbGx5IGF1Z21lbnQgb3Igb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdHJhbnNmb3JtcywgbW9kaWZ5IHRoZSBgJGh0dHBQcm92aWRlci5kZWZhdWx0cy50cmFuc2Zvcm1SZXF1ZXN0YCBhbmRcclxuICAgICAqIGAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLnRyYW5zZm9ybVJlc3BvbnNlYCBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBieSBkZWZhdWx0IGFuXHJcbiAgICAgKiBhcnJheSBvZiB0cmFuc2Zvcm0gZnVuY3Rpb25zLCB3aGljaCBhbGxvd3MgeW91IHRvIGBwdXNoYCBvciBgdW5zaGlmdGAgYSBuZXcgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gaW50byB0aGVcclxuICAgICAqIHRyYW5zZm9ybWF0aW9uIGNoYWluLiBZb3UgY2FuIGFsc28gZGVjaWRlIHRvIGNvbXBsZXRlbHkgb3ZlcnJpZGUgYW55IGRlZmF1bHQgdHJhbnNmb3JtYXRpb25zIGJ5IGFzc2lnbmluZyB5b3VyXHJcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gdGhlc2UgcHJvcGVydGllcyBkaXJlY3RseSB3aXRob3V0IHRoZSBhcnJheSB3cmFwcGVyLlxyXG4gICAgICpcclxuICAgICAqIFNpbWlsYXJseSwgdG8gbG9jYWxseSBvdmVycmlkZSB0aGUgcmVxdWVzdC9yZXNwb25zZSB0cmFuc2Zvcm1zLCBhdWdtZW50IHRoZSBgdHJhbnNmb3JtUmVxdWVzdGAgYW5kL29yXHJcbiAgICAgKiBgdHJhbnNmb3JtUmVzcG9uc2VgIHByb3BlcnRpZXMgb2YgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHBhc3NlZCBpbnRvIGAkaHR0cGAuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICMgQ2FjaGluZ1xyXG4gICAgICpcclxuICAgICAqIFRvIGVuYWJsZSBjYWNoaW5nLCBzZXQgdGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydHkgYGNhY2hlYCB0byBgdHJ1ZWAuIFdoZW4gdGhlIGNhY2hlIGlzXHJcbiAgICAgKiBlbmFibGVkLCBgJGh0dHBgIHN0b3JlcyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIGluIGxvY2FsIGNhY2hlLiBOZXh0IHRpbWUgdGhlXHJcbiAgICAgKiByZXNwb25zZSBpcyBzZXJ2ZWQgZnJvbSB0aGUgY2FjaGUgd2l0aG91dCBzZW5kaW5nIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBldmVuIGlmIHRoZSByZXNwb25zZSBpcyBzZXJ2ZWQgZnJvbSBjYWNoZSwgZGVsaXZlcnkgb2YgdGhlIGRhdGEgaXMgYXN5bmNocm9ub3VzIGluXHJcbiAgICAgKiB0aGUgc2FtZSB3YXkgdGhhdCByZWFsIHJlcXVlc3RzIGFyZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgR0VUIHJlcXVlc3RzIGZvciB0aGUgc2FtZSBVUkwgdGhhdCBzaG91bGQgYmUgY2FjaGVkIHVzaW5nIHRoZSBzYW1lXHJcbiAgICAgKiBjYWNoZSwgYnV0IHRoZSBjYWNoZSBpcyBub3QgcG9wdWxhdGVkIHlldCwgb25seSBvbmUgcmVxdWVzdCB0byB0aGUgc2VydmVyIHdpbGwgYmUgbWFkZSBhbmRcclxuICAgICAqIHRoZSByZW1haW5pbmcgcmVxdWVzdHMgd2lsbCBiZSBmdWxmaWxsZWQgdXNpbmcgdGhlIHJlc3BvbnNlIGZyb20gdGhlIGZpcnN0IHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQSBjdXN0b20gZGVmYXVsdCBjYWNoZSBidWlsdCB3aXRoICRjYWNoZUZhY3RvcnkgY2FuIGJlIHByb3ZpZGVkIGluICRodHRwLmRlZmF1bHRzLmNhY2hlLlxyXG4gICAgICogVG8gc2tpcCBpdCwgc2V0IGNvbmZpZ3VyYXRpb24gcHJvcGVydHkgYGNhY2hlYCB0byBgZmFsc2VgLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiAjIEludGVyY2VwdG9yc1xyXG4gICAgICpcclxuICAgICAqIEJlZm9yZSB5b3Ugc3RhcnQgY3JlYXRpbmcgaW50ZXJjZXB0b3JzLCBiZSBzdXJlIHRvIHVuZGVyc3RhbmQgdGhlXHJcbiAgICAgKiB7QGxpbmsgbmcuJHEgJHEgYW5kIGRlZmVycmVkL3Byb21pc2UgQVBJc30uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIHB1cnBvc2VzIG9mIGdsb2JhbCBlcnJvciBoYW5kbGluZywgYXV0aGVudGljYXRpb24sIG9yIGFueSBraW5kIG9mIHN5bmNocm9ub3VzIG9yXHJcbiAgICAgKiBhc3luY2hyb25vdXMgcHJlLXByb2Nlc3Npbmcgb2YgcmVxdWVzdCBvciBwb3N0cHJvY2Vzc2luZyBvZiByZXNwb25zZXMsIGl0IGlzIGRlc2lyYWJsZSB0byBiZVxyXG4gICAgICogYWJsZSB0byBpbnRlcmNlcHQgcmVxdWVzdHMgYmVmb3JlIHRoZXkgYXJlIGhhbmRlZCB0byB0aGUgc2VydmVyIGFuZFxyXG4gICAgICogcmVzcG9uc2VzIGJlZm9yZSB0aGV5IGFyZSBoYW5kZWQgb3ZlciB0byB0aGUgYXBwbGljYXRpb24gY29kZSB0aGF0XHJcbiAgICAgKiBpbml0aWF0ZWQgdGhlc2UgcmVxdWVzdHMuIFRoZSBpbnRlcmNlcHRvcnMgbGV2ZXJhZ2UgdGhlIHtAbGluayBuZy4kcVxyXG4gICAgICogcHJvbWlzZSBBUElzfSB0byBmdWxmaWxsIHRoaXMgbmVlZCBmb3IgYm90aCBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzIHByZS1wcm9jZXNzaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBpbnRlcmNlcHRvcnMgYXJlIHNlcnZpY2UgZmFjdG9yaWVzIHRoYXQgYXJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgYCRodHRwUHJvdmlkZXJgIGJ5XHJcbiAgICAgKiBhZGRpbmcgdGhlbSB0byB0aGUgYCRodHRwUHJvdmlkZXIuaW50ZXJjZXB0b3JzYCBhcnJheS4gVGhlIGZhY3RvcnkgaXMgY2FsbGVkIGFuZFxyXG4gICAgICogaW5qZWN0ZWQgd2l0aCBkZXBlbmRlbmNpZXMgKGlmIHNwZWNpZmllZCkgYW5kIHJldHVybnMgdGhlIGludGVyY2VwdG9yLlxyXG4gICAgICpcclxuICAgICAqIFRoZXJlIGFyZSB0d28ga2luZHMgb2YgaW50ZXJjZXB0b3JzIChhbmQgdHdvIGtpbmRzIG9mIHJlamVjdGlvbiBpbnRlcmNlcHRvcnMpOlxyXG4gICAgICpcclxuICAgICAqICAgKiBgcmVxdWVzdGA6IGludGVyY2VwdG9ycyBnZXQgY2FsbGVkIHdpdGggaHR0cCBgY29uZmlnYCBvYmplY3QuIFRoZSBmdW5jdGlvbiBpcyBmcmVlIHRvIG1vZGlmeVxyXG4gICAgICogICAgIHRoZSBgY29uZmlnYCBvciBjcmVhdGUgYSBuZXcgb25lLiBUaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIHRoZSBgY29uZmlnYCBkaXJlY3RseSBvciBhcyBhXHJcbiAgICAgKiAgICAgcHJvbWlzZS5cclxuICAgICAqICAgKiBgcmVxdWVzdEVycm9yYDogaW50ZXJjZXB0b3IgZ2V0cyBjYWxsZWQgd2hlbiBhIHByZXZpb3VzIGludGVyY2VwdG9yIHRocmV3IGFuIGVycm9yIG9yIHJlc29sdmVkXHJcbiAgICAgKiAgICAgIHdpdGggYSByZWplY3Rpb24uXHJcbiAgICAgKiAgICogYHJlc3BvbnNlYDogaW50ZXJjZXB0b3JzIGdldCBjYWxsZWQgd2l0aCBodHRwIGByZXNwb25zZWAgb2JqZWN0LiBUaGUgZnVuY3Rpb24gaXMgZnJlZSB0byBtb2RpZnlcclxuICAgICAqICAgICB0aGUgYHJlc3BvbnNlYCBvciBjcmVhdGUgYSBuZXcgb25lLiBUaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIHRoZSBgcmVzcG9uc2VgIGRpcmVjdGx5IG9yIGFzIGFcclxuICAgICAqICAgICBwcm9taXNlLlxyXG4gICAgICogICAqIGByZXNwb25zZUVycm9yYDogaW50ZXJjZXB0b3IgZ2V0cyBjYWxsZWQgd2hlbiBhIHByZXZpb3VzIGludGVyY2VwdG9yIHRocmV3IGFuIGVycm9yIG9yIHJlc29sdmVkXHJcbiAgICAgKiAgICAgIHdpdGggYSByZWplY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiAgIC8vIHJlZ2lzdGVyIHRoZSBpbnRlcmNlcHRvciBhcyBhIHNlcnZpY2VcclxuICAgICAqICAgJHByb3ZpZGUuZmFjdG9yeSgnbXlIdHRwSW50ZXJjZXB0b3InLCBmdW5jdGlvbigkcSwgZGVwZW5kZW5jeTEsIGRlcGVuZGVuY3kyKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIHtcclxuICAgICAqICAgICAgIC8vIG9wdGlvbmFsIG1ldGhvZFxyXG4gICAgICogICAgICAgJ3JlcXVlc3QnOiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAqICAgICAgICAgLy8gZG8gc29tZXRoaW5nIG9uIHN1Y2Nlc3NcclxuICAgICAqICAgICAgICAgcmV0dXJuIGNvbmZpZyB8fCAkcS53aGVuKGNvbmZpZyk7XHJcbiAgICAgKiAgICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgIC8vIG9wdGlvbmFsIG1ldGhvZFxyXG4gICAgICogICAgICAncmVxdWVzdEVycm9yJzogZnVuY3Rpb24ocmVqZWN0aW9uKSB7XHJcbiAgICAgKiAgICAgICAgIC8vIGRvIHNvbWV0aGluZyBvbiBlcnJvclxyXG4gICAgICogICAgICAgICBpZiAoY2FuUmVjb3ZlcihyZWplY3Rpb24pKSB7XHJcbiAgICAgKiAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlT3JOZXdQcm9taXNlXHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqICAgICAgICAgcmV0dXJuICRxLnJlamVjdChyZWplY3Rpb24pO1xyXG4gICAgICogICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICAgICAgIC8vIG9wdGlvbmFsIG1ldGhvZFxyXG4gICAgICogICAgICAgJ3Jlc3BvbnNlJzogZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAqICAgICAgICAgLy8gZG8gc29tZXRoaW5nIG9uIHN1Y2Nlc3NcclxuICAgICAqICAgICAgICAgcmV0dXJuIHJlc3BvbnNlIHx8ICRxLndoZW4ocmVzcG9uc2UpO1xyXG4gICAgICogICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAvLyBvcHRpb25hbCBtZXRob2RcclxuICAgICAqICAgICAgJ3Jlc3BvbnNlRXJyb3InOiBmdW5jdGlvbihyZWplY3Rpb24pIHtcclxuICAgICAqICAgICAgICAgLy8gZG8gc29tZXRoaW5nIG9uIGVycm9yXHJcbiAgICAgKiAgICAgICAgIGlmIChjYW5SZWNvdmVyKHJlamVjdGlvbikpIHtcclxuICAgICAqICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VPck5ld1Byb21pc2VcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgICAgICByZXR1cm4gJHEucmVqZWN0KHJlamVjdGlvbik7XHJcbiAgICAgKiAgICAgICB9O1xyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogICAkaHR0cFByb3ZpZGVyLmludGVyY2VwdG9ycy5wdXNoKCdteUh0dHBJbnRlcmNlcHRvcicpO1xyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIHJlZ2lzdGVyIHRoZSBpbnRlcmNlcHRvciB2aWEgYW4gYW5vbnltb3VzIGZhY3RvcnlcclxuICAgICAqICAgJGh0dHBQcm92aWRlci5pbnRlcmNlcHRvcnMucHVzaChmdW5jdGlvbigkcSwgZGVwZW5kZW5jeTEsIGRlcGVuZGVuY3kyKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIHtcclxuICAgICAqICAgICAgJ3JlcXVlc3QnOiBmdW5jdGlvbihjb25maWcpIHtcclxuICAgICAqICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmVcclxuICAgICAqICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAncmVzcG9uc2UnOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICogICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICB9KTtcclxuICAgICAqIDwvcHJlPlxyXG4gICAgICpcclxuICAgICAqICMgUmVzcG9uc2UgaW50ZXJjZXB0b3JzIChERVBSRUNBVEVEKVxyXG4gICAgICpcclxuICAgICAqIEJlZm9yZSB5b3Ugc3RhcnQgY3JlYXRpbmcgaW50ZXJjZXB0b3JzLCBiZSBzdXJlIHRvIHVuZGVyc3RhbmQgdGhlXHJcbiAgICAgKiB7QGxpbmsgbmcuJHEgJHEgYW5kIGRlZmVycmVkL3Byb21pc2UgQVBJc30uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIHB1cnBvc2VzIG9mIGdsb2JhbCBlcnJvciBoYW5kbGluZywgYXV0aGVudGljYXRpb24gb3IgYW55IGtpbmQgb2Ygc3luY2hyb25vdXMgb3JcclxuICAgICAqIGFzeW5jaHJvbm91cyBwcmVwcm9jZXNzaW5nIG9mIHJlY2VpdmVkIHJlc3BvbnNlcywgaXQgaXMgZGVzaXJhYmxlIHRvIGJlIGFibGUgdG8gaW50ZXJjZXB0XHJcbiAgICAgKiByZXNwb25zZXMgZm9yIGh0dHAgcmVxdWVzdHMgYmVmb3JlIHRoZXkgYXJlIGhhbmRlZCBvdmVyIHRvIHRoZSBhcHBsaWNhdGlvbiBjb2RlIHRoYXRcclxuICAgICAqIGluaXRpYXRlZCB0aGVzZSByZXF1ZXN0cy4gVGhlIHJlc3BvbnNlIGludGVyY2VwdG9ycyBsZXZlcmFnZSB0aGUge0BsaW5rIG5nLiRxXHJcbiAgICAgKiBwcm9taXNlIGFwaXN9IHRvIGZ1bGZpbCB0aGlzIG5lZWQgZm9yIGJvdGggc3luY2hyb25vdXMgYW5kIGFzeW5jaHJvbm91cyBwcmVwcm9jZXNzaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBpbnRlcmNlcHRvcnMgYXJlIHNlcnZpY2UgZmFjdG9yaWVzIHRoYXQgYXJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgJGh0dHBQcm92aWRlciBieVxyXG4gICAgICogYWRkaW5nIHRoZW0gdG8gdGhlIGAkaHR0cFByb3ZpZGVyLnJlc3BvbnNlSW50ZXJjZXB0b3JzYCBhcnJheS4gVGhlIGZhY3RvcnkgaXMgY2FsbGVkIGFuZFxyXG4gICAgICogaW5qZWN0ZWQgd2l0aCBkZXBlbmRlbmNpZXMgKGlmIHNwZWNpZmllZCkgYW5kIHJldHVybnMgdGhlIGludGVyY2VwdG9yICDDouKCrOKAnSBhIGZ1bmN0aW9uIHRoYXRcclxuICAgICAqIHRha2VzIGEge0BsaW5rIG5nLiRxIHByb21pc2V9IGFuZCByZXR1cm5zIHRoZSBvcmlnaW5hbCBvciBhIG5ldyBwcm9taXNlLlxyXG4gICAgICpcclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiAgIC8vIHJlZ2lzdGVyIHRoZSBpbnRlcmNlcHRvciBhcyBhIHNlcnZpY2VcclxuICAgICAqICAgJHByb3ZpZGUuZmFjdG9yeSgnbXlIdHRwSW50ZXJjZXB0b3InLCBmdW5jdGlvbigkcSwgZGVwZW5kZW5jeTEsIGRlcGVuZGVuY3kyKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb21pc2UpIHtcclxuICAgICAqICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAqICAgICAgICAgLy8gZG8gc29tZXRoaW5nIG9uIHN1Y2Nlc3NcclxuICAgICAqICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICogICAgICAgfSwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAqICAgICAgICAgLy8gZG8gc29tZXRoaW5nIG9uIGVycm9yXHJcbiAgICAgKiAgICAgICAgIGlmIChjYW5SZWNvdmVyKHJlc3BvbnNlKSkge1xyXG4gICAgICogICAgICAgICAgIHJldHVybiByZXNwb25zZU9yTmV3UHJvbWlzZVxyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgICAgIHJldHVybiAkcS5yZWplY3QocmVzcG9uc2UpO1xyXG4gICAgICogICAgICAgfSk7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9KTtcclxuICAgICAqXHJcbiAgICAgKiAgICRodHRwUHJvdmlkZXIucmVzcG9uc2VJbnRlcmNlcHRvcnMucHVzaCgnbXlIdHRwSW50ZXJjZXB0b3InKTtcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogICAvLyByZWdpc3RlciB0aGUgaW50ZXJjZXB0b3IgdmlhIGFuIGFub255bW91cyBmYWN0b3J5XHJcbiAgICAgKiAgICRodHRwUHJvdmlkZXIucmVzcG9uc2VJbnRlcmNlcHRvcnMucHVzaChmdW5jdGlvbigkcSwgZGVwZW5kZW5jeTEsIGRlcGVuZGVuY3kyKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb21pc2UpIHtcclxuICAgICAqICAgICAgIC8vIHNhbWUgYXMgYWJvdmVcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH0pO1xyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICMgU2VjdXJpdHkgQ29uc2lkZXJhdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBXaGVuIGRlc2lnbmluZyB3ZWIgYXBwbGljYXRpb25zLCBjb25zaWRlciBzZWN1cml0eSB0aHJlYXRzIGZyb206XHJcbiAgICAgKlxyXG4gICAgICogLSB7QGxpbmsgaHR0cDovL2hhYWNrZWQuY29tL2FyY2hpdmUvMjAwOC8xMS8yMC9hbmF0b215LW9mLWEtc3VidGxlLWpzb24tdnVsbmVyYWJpbGl0eS5hc3B4XHJcbiAgICAgKiAgIEpTT04gdnVsbmVyYWJpbGl0eX1cclxuICAgICAqIC0ge0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3Jvc3Mtc2l0ZV9yZXF1ZXN0X2ZvcmdlcnkgWFNSRn1cclxuICAgICAqXHJcbiAgICAgKiBCb3RoIHNlcnZlciBhbmQgdGhlIGNsaWVudCBtdXN0IGNvb3BlcmF0ZSBpbiBvcmRlciB0byBlbGltaW5hdGUgdGhlc2UgdGhyZWF0cy4gQW5ndWxhciBjb21lc1xyXG4gICAgICogcHJlLWNvbmZpZ3VyZWQgd2l0aCBzdHJhdGVnaWVzIHRoYXQgYWRkcmVzcyB0aGVzZSBpc3N1ZXMsIGJ1dCBmb3IgdGhpcyB0byB3b3JrIGJhY2tlbmQgc2VydmVyXHJcbiAgICAgKiBjb29wZXJhdGlvbiBpcyByZXF1aXJlZC5cclxuICAgICAqXHJcbiAgICAgKiAjIyBKU09OIFZ1bG5lcmFiaWxpdHkgUHJvdGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIEEge0BsaW5rIGh0dHA6Ly9oYWFja2VkLmNvbS9hcmNoaXZlLzIwMDgvMTEvMjAvYW5hdG9teS1vZi1hLXN1YnRsZS1qc29uLXZ1bG5lcmFiaWxpdHkuYXNweFxyXG4gICAgICogSlNPTiB2dWxuZXJhYmlsaXR5fSBhbGxvd3MgdGhpcmQgcGFydHkgd2Vic2l0ZSB0byB0dXJuIHlvdXIgSlNPTiByZXNvdXJjZSBVUkwgaW50b1xyXG4gICAgICoge0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSlNPTlAgSlNPTlB9IHJlcXVlc3QgdW5kZXIgc29tZSBjb25kaXRpb25zLiBUb1xyXG4gICAgICogY291bnRlciB0aGlzIHlvdXIgc2VydmVyIGNhbiBwcmVmaXggYWxsIEpTT04gcmVxdWVzdHMgd2l0aCBmb2xsb3dpbmcgc3RyaW5nIGBcIildfScsXFxuXCJgLlxyXG4gICAgICogQW5ndWxhciB3aWxsIGF1dG9tYXRpY2FsbHkgc3RyaXAgdGhlIHByZWZpeCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBhcyBKU09OLlxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlIGlmIHlvdXIgc2VydmVyIG5lZWRzIHRvIHJldHVybjpcclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiBbJ29uZScsJ3R3byddXHJcbiAgICAgKiA8L3ByZT5cclxuICAgICAqXHJcbiAgICAgKiB3aGljaCBpcyB2dWxuZXJhYmxlIHRvIGF0dGFjaywgeW91ciBzZXJ2ZXIgY2FuIHJldHVybjpcclxuICAgICAqIDxwcmU+XHJcbiAgICAgKiApXX0nLFxyXG4gICAgICogWydvbmUnLCd0d28nXVxyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKlxyXG4gICAgICogQW5ndWxhciB3aWxsIHN0cmlwIHRoZSBwcmVmaXgsIGJlZm9yZSBwcm9jZXNzaW5nIHRoZSBKU09OLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiAjIyBDcm9zcyBTaXRlIFJlcXVlc3QgRm9yZ2VyeSAoWFNSRikgUHJvdGVjdGlvblxyXG4gICAgICpcclxuICAgICAqIHtAbGluayBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nyb3NzLXNpdGVfcmVxdWVzdF9mb3JnZXJ5IFhTUkZ9IGlzIGEgdGVjaG5pcXVlIGJ5IHdoaWNoXHJcbiAgICAgKiBhbiB1bmF1dGhvcml6ZWQgc2l0ZSBjYW4gZ2FpbiB5b3VyIHVzZXIncyBwcml2YXRlIGRhdGEuIEFuZ3VsYXIgcHJvdmlkZXMgYSBtZWNoYW5pc21cclxuICAgICAqIHRvIGNvdW50ZXIgWFNSRi4gV2hlbiBwZXJmb3JtaW5nIFhIUiByZXF1ZXN0cywgdGhlICRodHRwIHNlcnZpY2UgcmVhZHMgYSB0b2tlbiBmcm9tIGEgY29va2llXHJcbiAgICAgKiAoYnkgZGVmYXVsdCwgYFhTUkYtVE9LRU5gKSBhbmQgc2V0cyBpdCBhcyBhbiBIVFRQIGhlYWRlciAoYFgtWFNSRi1UT0tFTmApLiBTaW5jZSBvbmx5XHJcbiAgICAgKiBKYXZhU2NyaXB0IHRoYXQgcnVucyBvbiB5b3VyIGRvbWFpbiBjb3VsZCByZWFkIHRoZSBjb29raWUsIHlvdXIgc2VydmVyIGNhbiBiZSBhc3N1cmVkIHRoYXRcclxuICAgICAqIHRoZSBYSFIgY2FtZSBmcm9tIEphdmFTY3JpcHQgcnVubmluZyBvbiB5b3VyIGRvbWFpbi4gVGhlIGhlYWRlciB3aWxsIG5vdCBiZSBzZXQgZm9yXHJcbiAgICAgKiBjcm9zcy1kb21haW4gcmVxdWVzdHMuXHJcbiAgICAgKlxyXG4gICAgICogVG8gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhpcywgeW91ciBzZXJ2ZXIgbmVlZHMgdG8gc2V0IGEgdG9rZW4gaW4gYSBKYXZhU2NyaXB0IHJlYWRhYmxlIHNlc3Npb25cclxuICAgICAqIGNvb2tpZSBjYWxsZWQgYFhTUkYtVE9LRU5gIG9uIHRoZSBmaXJzdCBIVFRQIEdFVCByZXF1ZXN0LiBPbiBzdWJzZXF1ZW50IFhIUiByZXF1ZXN0cyB0aGVcclxuICAgICAqIHNlcnZlciBjYW4gdmVyaWZ5IHRoYXQgdGhlIGNvb2tpZSBtYXRjaGVzIGBYLVhTUkYtVE9LRU5gIEhUVFAgaGVhZGVyLCBhbmQgdGhlcmVmb3JlIGJlIHN1cmVcclxuICAgICAqIHRoYXQgb25seSBKYXZhU2NyaXB0IHJ1bm5pbmcgb24geW91ciBkb21haW4gY291bGQgaGF2ZSBzZW50IHRoZSByZXF1ZXN0LiBUaGUgdG9rZW4gbXVzdCBiZVxyXG4gICAgICogdW5pcXVlIGZvciBlYWNoIHVzZXIgYW5kIG11c3QgYmUgdmVyaWZpYWJsZSBieSB0aGUgc2VydmVyICh0byBwcmV2ZW50IHRoZSBKYXZhU2NyaXB0IGZyb20gbWFraW5nXHJcbiAgICAgKiB1cCBpdHMgb3duIHRva2VucykuIFdlIHJlY29tbWVuZCB0aGF0IHRoZSB0b2tlbiBpcyBhIGRpZ2VzdCBvZiB5b3VyIHNpdGUncyBhdXRoZW50aWNhdGlvblxyXG4gICAgICogY29va2llIHdpdGggYSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2FsdF8oY3J5cHRvZ3JhcGh5KSBzYWx0fSBmb3IgYWRkZWQgc2VjdXJpdHkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGhlYWRlcnMgY2FuIGJlIHNwZWNpZmllZCB1c2luZyB0aGUgeHNyZkhlYWRlck5hbWUgYW5kIHhzcmZDb29raWVOYW1lXHJcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGVpdGhlciAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLCBvciB0aGUgcGVyLXJlcXVlc3QgY29uZmlnIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBPYmplY3QgZGVzY3JpYmluZyB0aGUgcmVxdWVzdCB0byBiZSBtYWRlIGFuZCBob3cgaXQgc2hvdWxkIGJlXHJcbiAgICAgKiAgICBwcm9jZXNzZWQuIFRoZSBvYmplY3QgaGFzIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICpcclxuICAgICAqICAgIC0gKiptZXRob2QqKiDDouKCrOKAnCBge3N0cmluZ31gIMOi4oKs4oCcIEhUVFAgbWV0aG9kIChlLmcuICdHRVQnLCAnUE9TVCcsIGV0YylcclxuICAgICAqICAgIC0gKip1cmwqKiDDouKCrOKAnCBge3N0cmluZ31gIMOi4oKs4oCcIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCBvZiB0aGUgcmVzb3VyY2UgdGhhdCBpcyBiZWluZyByZXF1ZXN0ZWQuXHJcbiAgICAgKiAgICAtICoqcGFyYW1zKiogw6LigqzigJwgYHtPYmplY3QuPHN0cmluZ3xPYmplY3Q+fWAgw6LigqzigJwgTWFwIG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB3aGljaCB3aWxsIGJlIHR1cm5lZCB0b1xyXG4gICAgICogICAgICBgP2tleTE9dmFsdWUxJmtleTI9dmFsdWUyYCBhZnRlciB0aGUgdXJsLiBJZiB0aGUgdmFsdWUgaXMgbm90IGEgc3RyaW5nLCBpdCB3aWxsIGJlIEpTT05pZmllZC5cclxuICAgICAqICAgIC0gKipkYXRhKiogw6LigqzigJwgYHtzdHJpbmd8T2JqZWN0fWAgw6LigqzigJwgRGF0YSB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0IG1lc3NhZ2UgZGF0YS5cclxuICAgICAqICAgIC0gKipoZWFkZXJzKiogw6LigqzigJwgYHtPYmplY3R9YCDDouKCrOKAnCBNYXAgb2Ygc3RyaW5ncyBvciBmdW5jdGlvbnMgd2hpY2ggcmV0dXJuIHN0cmluZ3MgcmVwcmVzZW50aW5nXHJcbiAgICAgKiAgICAgIEhUVFAgaGVhZGVycyB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIuIElmIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiBpcyBudWxsLCB0aGUgaGVhZGVyIHdpbGxcclxuICAgICAqICAgICAgbm90IGJlIHNlbnQuXHJcbiAgICAgKiAgICAtICoqeHNyZkhlYWRlck5hbWUqKiDDouKCrOKAnCBge3N0cmluZ31gIMOi4oKs4oCcIE5hbWUgb2YgSFRUUCBoZWFkZXIgdG8gcG9wdWxhdGUgd2l0aCB0aGUgWFNSRiB0b2tlbi5cclxuICAgICAqICAgIC0gKip4c3JmQ29va2llTmFtZSoqIMOi4oKs4oCcIGB7c3RyaW5nfWAgw6LigqzigJwgTmFtZSBvZiBjb29raWUgY29udGFpbmluZyB0aGUgWFNSRiB0b2tlbi5cclxuICAgICAqICAgIC0gKip0cmFuc2Zvcm1SZXF1ZXN0Kiogw6LigqzigJwgYHtmdW5jdGlvbihkYXRhLCBoZWFkZXJzR2V0dGVyKXxBcnJheS48ZnVuY3Rpb24oZGF0YSwgaGVhZGVyc0dldHRlcik+fWAgw6LigqzigJxcclxuICAgICAqICAgICAgdHJhbnNmb3JtIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHN1Y2ggZnVuY3Rpb25zLiBUaGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHRha2VzIHRoZSBodHRwXHJcbiAgICAgKiAgICAgIHJlcXVlc3QgYm9keSBhbmQgaGVhZGVycyBhbmQgcmV0dXJucyBpdHMgdHJhbnNmb3JtZWQgKHR5cGljYWxseSBzZXJpYWxpemVkKSB2ZXJzaW9uLlxyXG4gICAgICogICAgLSAqKnRyYW5zZm9ybVJlc3BvbnNlKiogw6LigqzigJwgYHtmdW5jdGlvbihkYXRhLCBoZWFkZXJzR2V0dGVyKXxBcnJheS48ZnVuY3Rpb24oZGF0YSwgaGVhZGVyc0dldHRlcik+fWAgw6LigqzigJxcclxuICAgICAqICAgICAgdHJhbnNmb3JtIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHN1Y2ggZnVuY3Rpb25zLiBUaGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHRha2VzIHRoZSBodHRwXHJcbiAgICAgKiAgICAgIHJlc3BvbnNlIGJvZHkgYW5kIGhlYWRlcnMgYW5kIHJldHVybnMgaXRzIHRyYW5zZm9ybWVkICh0eXBpY2FsbHkgZGVzZXJpYWxpemVkKSB2ZXJzaW9uLlxyXG4gICAgICogICAgLSAqKmNhY2hlKiogw6LigqzigJwgYHtib29sZWFufENhY2hlfWAgw6LigqzigJwgSWYgdHJ1ZSwgYSBkZWZhdWx0ICRodHRwIGNhY2hlIHdpbGwgYmUgdXNlZCB0byBjYWNoZSB0aGVcclxuICAgICAqICAgICAgR0VUIHJlcXVlc3QsIG90aGVyd2lzZSBpZiBhIGNhY2hlIGluc3RhbmNlIGJ1aWx0IHdpdGhcclxuICAgICAqICAgICAge0BsaW5rIG5nLiRjYWNoZUZhY3RvcnkgJGNhY2hlRmFjdG9yeX0sIHRoaXMgY2FjaGUgd2lsbCBiZSB1c2VkIGZvclxyXG4gICAgICogICAgICBjYWNoaW5nLlxyXG4gICAgICogICAgLSAqKnRpbWVvdXQqKiDDouKCrOKAnCBge251bWJlcnxQcm9taXNlfWAgw6LigqzigJwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMsIG9yIHtAbGluayBuZy4kcSBwcm9taXNlfVxyXG4gICAgICogICAgICB0aGF0IHNob3VsZCBhYm9ydCB0aGUgcmVxdWVzdCB3aGVuIHJlc29sdmVkLlxyXG4gICAgICogICAgLSAqKndpdGhDcmVkZW50aWFscyoqIC0gYHtib29sZWFufWAgLSB3aGV0aGVyIHRvIHRvIHNldCB0aGUgYHdpdGhDcmVkZW50aWFsc2AgZmxhZyBvbiB0aGVcclxuICAgICAqICAgICAgWEhSIG9iamVjdC4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9odHRwX2FjY2Vzc19jb250cm9sI3NlY3Rpb25fNVxyXG4gICAgICogICAgICByZXF1ZXN0cyB3aXRoIGNyZWRlbnRpYWxzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqICAgIC0gKipyZXNwb25zZVR5cGUqKiAtIGB7c3RyaW5nfWAgLSBzZWUge0BsaW5rXHJcbiAgICAgKiAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0I3Jlc3BvbnNlVHlwZSByZXF1ZXN0VHlwZX0uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0h0dHBQcm9taXNlfSBSZXR1cm5zIGEge0BsaW5rIG5nLiRxIHByb21pc2V9IG9iamVjdCB3aXRoIHRoZVxyXG4gICAgICogICBzdGFuZGFyZCBgdGhlbmAgbWV0aG9kIGFuZCB0d28gaHR0cCBzcGVjaWZpYyBtZXRob2RzOiBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAuIFRoZSBgdGhlbmBcclxuICAgICAqICAgbWV0aG9kIHRha2VzIHR3byBhcmd1bWVudHMgYSBzdWNjZXNzIGFuZCBhbiBlcnJvciBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFcclxuICAgICAqICAgcmVzcG9uc2Ugb2JqZWN0LiBUaGUgYHN1Y2Nlc3NgIGFuZCBgZXJyb3JgIG1ldGhvZHMgdGFrZSBhIHNpbmdsZSBhcmd1bWVudCAtIGEgZnVuY3Rpb24gdGhhdFxyXG4gICAgICogICB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IHN1Y2NlZWRzIG9yIGZhaWxzIHJlc3BlY3RpdmVseS4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50b1xyXG4gICAgICogICB0aGVzZSBmdW5jdGlvbnMgYXJlIGRlc3RydWN0dXJlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVzcG9uc2Ugb2JqZWN0IHBhc3NlZCBpbnRvIHRoZVxyXG4gICAgICogICBgdGhlbmAgbWV0aG9kLiBUaGUgcmVzcG9uc2Ugb2JqZWN0IGhhcyB0aGVzZSBwcm9wZXJ0aWVzOlxyXG4gICAgICpcclxuICAgICAqICAgLSAqKmRhdGEqKiDDouKCrOKAnCBge3N0cmluZ3xPYmplY3R9YCDDouKCrOKAnCBUaGUgcmVzcG9uc2UgYm9keSB0cmFuc2Zvcm1lZCB3aXRoIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb25zLlxyXG4gICAgICogICAtICoqc3RhdHVzKiogw6LigqzigJwgYHtudW1iZXJ9YCDDouKCrOKAnCBIVFRQIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZS5cclxuICAgICAqICAgLSAqKmhlYWRlcnMqKiDDouKCrOKAnCBge2Z1bmN0aW9uKFtoZWFkZXJOYW1lXSl9YCDDouKCrOKAnCBIZWFkZXIgZ2V0dGVyIGZ1bmN0aW9uLlxyXG4gICAgICogICAtICoqY29uZmlnKiogw6LigqzigJwgYHtPYmplY3R9YCDDouKCrOKAnCBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgdGhhdCB3YXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5LjxPYmplY3Q+fSBwZW5kaW5nUmVxdWVzdHMgQXJyYXkgb2YgY29uZmlnIG9iamVjdHMgZm9yIGN1cnJlbnRseSBwZW5kaW5nXHJcbiAgICAgKiAgIHJlcXVlc3RzLiBUaGlzIGlzIHByaW1hcmlseSBtZWFudCB0byBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgIDxleGFtcGxlPlxyXG4gICAgICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJGZXRjaEN0cmxcIj5cclxuICAgICAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cIm1ldGhvZFwiPlxyXG4gICAgICAgICAgICAgIDxvcHRpb24+R0VUPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgPG9wdGlvbj5KU09OUDwvb3B0aW9uPlxyXG4gICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJ1cmxcIiBzaXplPVwiODBcIi8+XHJcbiAgICAgICAgICAgIDxidXR0b24gbmctY2xpY2s9XCJmZXRjaCgpXCI+ZmV0Y2g8L2J1dHRvbj48YnI+XHJcbiAgICAgICAgICAgIDxidXR0b24gbmctY2xpY2s9XCJ1cGRhdGVNb2RlbCgnR0VUJywgJ2h0dHAtaGVsbG8uaHRtbCcpXCI+U2FtcGxlIEdFVDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uIG5nLWNsaWNrPVwidXBkYXRlTW9kZWwoJ0pTT05QJywgJ2h0dHA6Ly9hbmd1bGFyanMub3JnL2dyZWV0LnBocD9jYWxsYmFjaz1KU09OX0NBTExCQUNLJm5hbWU9U3VwZXIlMjBIZXJvJylcIj5TYW1wbGUgSlNPTlA8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cInVwZGF0ZU1vZGVsKCdKU09OUCcsICdodHRwOi8vYW5ndWxhcmpzLm9yZy9kb2VzbnRleGlzdCZjYWxsYmFjaz1KU09OX0NBTExCQUNLJylcIj5JbnZhbGlkIEpTT05QPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxwcmU+aHR0cCBzdGF0dXMgY29kZToge3tzdGF0dXN9fTwvcHJlPlxyXG4gICAgICAgICAgICA8cHJlPmh0dHAgcmVzcG9uc2UgZGF0YToge3tkYXRhfX08L3ByZT5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZmlsZT5cclxuICAgICAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XHJcbiAgICAgICAgICBmdW5jdGlvbiBGZXRjaEN0cmwoJHNjb3BlLCAkaHR0cCwgJHRlbXBsYXRlQ2FjaGUpIHtcclxuICAgICAgICAgICAgJHNjb3BlLm1ldGhvZCA9ICdHRVQnO1xyXG4gICAgICAgICAgICAkc2NvcGUudXJsID0gJ2h0dHAtaGVsbG8uaHRtbCc7XHJcblxyXG4gICAgICAgICAgICAkc2NvcGUuZmV0Y2ggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAkc2NvcGUuY29kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLnJlc3BvbnNlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgJGh0dHAoe21ldGhvZDogJHNjb3BlLm1ldGhvZCwgdXJsOiAkc2NvcGUudXJsLCBjYWNoZTogJHRlbXBsYXRlQ2FjaGV9KS5cclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSwgc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5zdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIH0pLlxyXG4gICAgICAgICAgICAgICAgZXJyb3IoZnVuY3Rpb24oZGF0YSwgc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhID0gZGF0YSB8fCBcIlJlcXVlc3QgZmFpbGVkXCI7XHJcbiAgICAgICAgICAgICAgICAgICRzY29wZS5zdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAkc2NvcGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbihtZXRob2QsIHVybCkge1xyXG4gICAgICAgICAgICAgICRzY29wZS5tZXRob2QgPSBtZXRob2Q7XHJcbiAgICAgICAgICAgICAgJHNjb3BlLnVybCA9IHVybDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgIH1cclxuICAgICAgICA8L2ZpbGU+XHJcbiAgICAgICAgPGZpbGUgbmFtZT1cImh0dHAtaGVsbG8uaHRtbFwiPlxyXG4gICAgICAgICAgSGVsbG8sICRodHRwIVxyXG4gICAgICAgIDwvZmlsZT5cclxuICAgICAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cclxuICAgICAgICAgIGl0KCdzaG91bGQgbWFrZSBhbiB4aHIgR0VUIHJlcXVlc3QnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZWxlbWVudCgnOmJ1dHRvbjpjb250YWlucyhcIlNhbXBsZSBHRVRcIiknKS5jbGljaygpO1xyXG4gICAgICAgICAgICBlbGVtZW50KCc6YnV0dG9uOmNvbnRhaW5zKFwiZmV0Y2hcIiknKS5jbGljaygpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnc3RhdHVzJykpLnRvQmUoJzIwMCcpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnZGF0YScpKS50b01hdGNoKC9IZWxsbywgXFwkaHR0cCEvKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGl0KCdzaG91bGQgbWFrZSBhIEpTT05QIHJlcXVlc3QgdG8gYW5ndWxhcmpzLm9yZycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBlbGVtZW50KCc6YnV0dG9uOmNvbnRhaW5zKFwiU2FtcGxlIEpTT05QXCIpJykuY2xpY2soKTtcclxuICAgICAgICAgICAgZWxlbWVudCgnOmJ1dHRvbjpjb250YWlucyhcImZldGNoXCIpJykuY2xpY2soKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3N0YXR1cycpKS50b0JlKCcyMDAnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2RhdGEnKSkudG9NYXRjaCgvU3VwZXIgSGVybyEvKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGl0KCdzaG91bGQgbWFrZSBKU09OUCByZXF1ZXN0IHRvIGludmFsaWQgVVJMIGFuZCBpbnZva2UgdGhlIGVycm9yIGhhbmRsZXInLFxyXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBlbGVtZW50KCc6YnV0dG9uOmNvbnRhaW5zKFwiSW52YWxpZCBKU09OUFwiKScpLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQoJzpidXR0b246Y29udGFpbnMoXCJmZXRjaFwiKScpLmNsaWNrKCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdzdGF0dXMnKSkudG9CZSgnMCcpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnZGF0YScpKS50b0JlKCdSZXF1ZXN0IGZhaWxlZCcpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgPC9maWxlPlxyXG4gICAgICA8L2V4YW1wbGU+XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uICRodHRwKHJlcXVlc3RDb25maWcpIHtcclxuICAgICAgdmFyIGNvbmZpZyA9IHtcclxuICAgICAgICB0cmFuc2Zvcm1SZXF1ZXN0OiBkZWZhdWx0cy50cmFuc2Zvcm1SZXF1ZXN0LFxyXG4gICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlOiBkZWZhdWx0cy50cmFuc2Zvcm1SZXNwb25zZVxyXG4gICAgICB9O1xyXG4gICAgICB2YXIgaGVhZGVycyA9IG1lcmdlSGVhZGVycyhyZXF1ZXN0Q29uZmlnKTtcclxuXHJcbiAgICAgIGV4dGVuZChjb25maWcsIHJlcXVlc3RDb25maWcpO1xyXG4gICAgICBjb25maWcuaGVhZGVycyA9IGhlYWRlcnM7XHJcbiAgICAgIGNvbmZpZy5tZXRob2QgPSB1cHBlcmNhc2UoY29uZmlnLm1ldGhvZCk7XHJcblxyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gJCR1cmxVdGlscy5pc1NhbWVPcmlnaW4oY29uZmlnLnVybClcclxuICAgICAgICAgID8gJGJyb3dzZXIuY29va2llcygpW2NvbmZpZy54c3JmQ29va2llTmFtZSB8fCBkZWZhdWx0cy54c3JmQ29va2llTmFtZV1cclxuICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XHJcbiAgICAgICAgaGVhZGVyc1soY29uZmlnLnhzcmZIZWFkZXJOYW1lIHx8IGRlZmF1bHRzLnhzcmZIZWFkZXJOYW1lKV0gPSB4c3JmVmFsdWU7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICB2YXIgc2VydmVyUmVxdWVzdCA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIGhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcclxuICAgICAgICB2YXIgcmVxRGF0YSA9IHRyYW5zZm9ybURhdGEoY29uZmlnLmRhdGEsIGhlYWRlcnNHZXR0ZXIoaGVhZGVycyksIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0KTtcclxuXHJcbiAgICAgICAgLy8gc3RyaXAgY29udGVudC10eXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGNvbmZpZy5kYXRhKSkge1xyXG4gICAgICAgICAgZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbih2YWx1ZSwgaGVhZGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChsb3dlcmNhc2UoaGVhZGVyKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzW2hlYWRlcl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpICYmICFpc1VuZGVmaW5lZChkZWZhdWx0cy53aXRoQ3JlZGVudGlhbHMpKSB7XHJcbiAgICAgICAgICBjb25maWcud2l0aENyZWRlbnRpYWxzID0gZGVmYXVsdHMud2l0aENyZWRlbnRpYWxzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0XHJcbiAgICAgICAgcmV0dXJuIHNlbmRSZXEoY29uZmlnLCByZXFEYXRhLCBoZWFkZXJzKS50aGVuKHRyYW5zZm9ybVJlc3BvbnNlLCB0cmFuc2Zvcm1SZXNwb25zZSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIgY2hhaW4gPSBbc2VydmVyUmVxdWVzdCwgdW5kZWZpbmVkXTtcclxuICAgICAgdmFyIHByb21pc2UgPSAkcS53aGVuKGNvbmZpZyk7XHJcblxyXG4gICAgICAvLyBhcHBseSBpbnRlcmNlcHRvcnNcclxuICAgICAgZm9yRWFjaChyZXZlcnNlZEludGVyY2VwdG9ycywgZnVuY3Rpb24oaW50ZXJjZXB0b3IpIHtcclxuICAgICAgICBpZiAoaW50ZXJjZXB0b3IucmVxdWVzdCB8fCBpbnRlcmNlcHRvci5yZXF1ZXN0RXJyb3IpIHtcclxuICAgICAgICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IucmVxdWVzdCwgaW50ZXJjZXB0b3IucmVxdWVzdEVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGludGVyY2VwdG9yLnJlc3BvbnNlIHx8IGludGVyY2VwdG9yLnJlc3BvbnNlRXJyb3IpIHtcclxuICAgICAgICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IucmVzcG9uc2UsIGludGVyY2VwdG9yLnJlc3BvbnNlRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB3aGlsZShjaGFpbi5sZW5ndGgpIHtcclxuICAgICAgICB2YXIgdGhlbkZuID0gY2hhaW4uc2hpZnQoKTtcclxuICAgICAgICB2YXIgcmVqZWN0Rm4gPSBjaGFpbi5zaGlmdCgpO1xyXG5cclxuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHRoZW5GbiwgcmVqZWN0Rm4pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwcm9taXNlLnN1Y2Nlc3MgPSBmdW5jdGlvbihmbikge1xyXG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgZm4ocmVzcG9uc2UuZGF0YSwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5oZWFkZXJzLCBjb25maWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcHJvbWlzZS5lcnJvciA9IGZ1bmN0aW9uKGZuKSB7XHJcbiAgICAgICAgcHJvbWlzZS50aGVuKG51bGwsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICBmbihyZXNwb25zZS5kYXRhLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmhlYWRlcnMsIGNvbmZpZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gcHJvbWlzZTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgLy8gbWFrZSBhIGNvcHkgc2luY2UgdGhlIHJlc3BvbnNlIG11c3QgYmUgY2FjaGVhYmxlXHJcbiAgICAgICAgdmFyIHJlc3AgPSBleHRlbmQoe30sIHJlc3BvbnNlLCB7XHJcbiAgICAgICAgICBkYXRhOiB0cmFuc2Zvcm1EYXRhKHJlc3BvbnNlLmRhdGEsIHJlc3BvbnNlLmhlYWRlcnMsIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSlcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKGlzU3VjY2VzcyhyZXNwb25zZS5zdGF0dXMpKVxyXG4gICAgICAgICAgPyByZXNwXHJcbiAgICAgICAgICA6ICRxLnJlamVjdChyZXNwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gbWVyZ2VIZWFkZXJzKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBkZWZIZWFkZXJzID0gZGVmYXVsdHMuaGVhZGVycyxcclxuICAgICAgICAgICAgcmVxSGVhZGVycyA9IGV4dGVuZCh7fSwgY29uZmlnLmhlYWRlcnMpLFxyXG4gICAgICAgICAgICBkZWZIZWFkZXJOYW1lLCBsb3dlcmNhc2VEZWZIZWFkZXJOYW1lLCByZXFIZWFkZXJOYW1lO1xyXG5cclxuICAgICAgICBkZWZIZWFkZXJzID0gZXh0ZW5kKHt9LCBkZWZIZWFkZXJzLmNvbW1vbiwgZGVmSGVhZGVyc1tsb3dlcmNhc2UoY29uZmlnLm1ldGhvZCldKTtcclxuXHJcbiAgICAgICAgLy8gZXhlY3V0ZSBpZiBoZWFkZXIgdmFsdWUgaXMgZnVuY3Rpb25cclxuICAgICAgICBleGVjSGVhZGVycyhkZWZIZWFkZXJzKTtcclxuICAgICAgICBleGVjSGVhZGVycyhyZXFIZWFkZXJzKTtcclxuXHJcbiAgICAgICAgLy8gdXNpbmcgZm9yLWluIGluc3RlYWQgb2YgZm9yRWFjaCB0byBhdm9pZCB1bmVjZXNzYXJ5IGl0ZXJhdGlvbiBhZnRlciBoZWFkZXIgaGFzIGJlZW4gZm91bmRcclxuICAgICAgICBkZWZhdWx0SGVhZGVyc0l0ZXJhdGlvbjpcclxuICAgICAgICBmb3IgKGRlZkhlYWRlck5hbWUgaW4gZGVmSGVhZGVycykge1xyXG4gICAgICAgICAgbG93ZXJjYXNlRGVmSGVhZGVyTmFtZSA9IGxvd2VyY2FzZShkZWZIZWFkZXJOYW1lKTtcclxuXHJcbiAgICAgICAgICBmb3IgKHJlcUhlYWRlck5hbWUgaW4gcmVxSGVhZGVycykge1xyXG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlKHJlcUhlYWRlck5hbWUpID09PSBsb3dlcmNhc2VEZWZIZWFkZXJOYW1lKSB7XHJcbiAgICAgICAgICAgICAgY29udGludWUgZGVmYXVsdEhlYWRlcnNJdGVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXFIZWFkZXJzW2RlZkhlYWRlck5hbWVdID0gZGVmSGVhZGVyc1tkZWZIZWFkZXJOYW1lXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXFIZWFkZXJzO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBleGVjSGVhZGVycyhoZWFkZXJzKSB7XHJcbiAgICAgICAgICB2YXIgaGVhZGVyQ29udGVudDtcclxuXHJcbiAgICAgICAgICBmb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uKGhlYWRlckZuLCBoZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGVhZGVyRm4pKSB7XHJcbiAgICAgICAgICAgICAgaGVhZGVyQ29udGVudCA9IGhlYWRlckZuKCk7XHJcbiAgICAgICAgICAgICAgaWYgKGhlYWRlckNvbnRlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1toZWFkZXJdID0gaGVhZGVyQ29udGVudDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICRodHRwLnBlbmRpbmdSZXF1ZXN0cyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJGh0dHAjZ2V0XHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGh0dHBcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCB0byBwZXJmb3JtIGBHRVRgIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkwgc3BlY2lmeWluZyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7SHR0cFByb21pc2V9IEZ1dHVyZSBvYmplY3RcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJGh0dHAjZGVsZXRlXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGh0dHBcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCB0byBwZXJmb3JtIGBERUxFVEVgIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkwgc3BlY2lmeWluZyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIHJlcXVlc3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7SHR0cFByb21pc2V9IEZ1dHVyZSBvYmplY3RcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJGh0dHAjaGVhZFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRodHRwXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGN1dCBtZXRob2QgdG8gcGVyZm9ybSBgSEVBRGAgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFJlbGF0aXZlIG9yIGFic29sdXRlIFVSTCBzcGVjaWZ5aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgcmVxdWVzdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3RcclxuICAgICAqIEByZXR1cm5zIHtIdHRwUHJvbWlzZX0gRnV0dXJlIG9iamVjdFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kaHR0cCNqc29ucFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRodHRwXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGN1dCBtZXRob2QgdG8gcGVyZm9ybSBgSlNPTlBgIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkwgc3BlY2lmeWluZyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIHJlcXVlc3QuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIFNob3VsZCBjb250YWluIGBKU09OX0NBTExCQUNLYCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdFxyXG4gICAgICogQHJldHVybnMge0h0dHBQcm9taXNlfSBGdXR1cmUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVNob3J0TWV0aG9kcygnZ2V0JywgJ2RlbGV0ZScsICdoZWFkJywgJ2pzb25wJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kaHR0cCNwb3N0XHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGh0dHBcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCB0byBwZXJmb3JtIGBQT1NUYCByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgUmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMIHNwZWNpZnlpbmcgdGhlIGRlc3RpbmF0aW9uIG9mIHRoZSByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgUmVxdWVzdCBjb250ZW50XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdFxyXG4gICAgICogQHJldHVybnMge0h0dHBQcm9taXNlfSBGdXR1cmUgb2JqZWN0XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRodHRwI3B1dFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRodHRwXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGN1dCBtZXRob2QgdG8gcGVyZm9ybSBgUFVUYCByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgUmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMIHNwZWNpZnlpbmcgdGhlIGRlc3RpbmF0aW9uIG9mIHRoZSByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgUmVxdWVzdCBjb250ZW50XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdFxyXG4gICAgICogQHJldHVybnMge0h0dHBQcm9taXNlfSBGdXR1cmUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVNob3J0TWV0aG9kc1dpdGhEYXRhKCdwb3N0JywgJ3B1dCcpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbmdkb2MgcHJvcGVydHlcclxuICAgICAgICAgKiBAbmFtZSBuZy4kaHR0cCNkZWZhdWx0c1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eU9mIG5nLiRodHRwXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICAgKiBSdW50aW1lIGVxdWl2YWxlbnQgb2YgdGhlIGAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzYCBwcm9wZXJ0eS4gQWxsb3dzIGNvbmZpZ3VyYXRpb24gb2ZcclxuICAgICAgICAgKiBkZWZhdWx0IGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscyBhcyB3ZWxsIGFzIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHRyYW5zZm9ybWF0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFNlZSBcIlNldHRpbmcgSFRUUCBIZWFkZXJzXCIgYW5kIFwiVHJhbnNmb3JtaW5nIFJlcXVlc3RzIGFuZCBSZXNwb25zZXNcIiBzZWN0aW9ucyBhYm92ZS5cclxuICAgICAgICAgKi9cclxuICAgICRodHRwLmRlZmF1bHRzID0gZGVmYXVsdHM7XHJcblxyXG5cclxuICAgIHJldHVybiAkaHR0cDtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlU2hvcnRNZXRob2RzKG5hbWVzKSB7XHJcbiAgICAgIGZvckVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgJGh0dHBbbmFtZV0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xyXG4gICAgICAgICAgcmV0dXJuICRodHRwKGV4dGVuZChjb25maWcgfHwge30sIHtcclxuICAgICAgICAgICAgbWV0aG9kOiBuYW1lLFxyXG4gICAgICAgICAgICB1cmw6IHVybFxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTaG9ydE1ldGhvZHNXaXRoRGF0YShuYW1lKSB7XHJcbiAgICAgIGZvckVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgJGh0dHBbbmFtZV0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xyXG4gICAgICAgICAgcmV0dXJuICRodHRwKGV4dGVuZChjb25maWcgfHwge30sIHtcclxuICAgICAgICAgICAgbWV0aG9kOiBuYW1lLFxyXG4gICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIHRoZSByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqICEhISBBQ0NFU1NFUyBDTE9TVVJFIFZBUlM6XHJcbiAgICAgKiAkaHR0cEJhY2tlbmQsIGRlZmF1bHRzLCAkbG9nLCAkcm9vdFNjb3BlLCBkZWZhdWx0Q2FjaGUsICRodHRwLnBlbmRpbmdSZXF1ZXN0c1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZW5kUmVxKGNvbmZpZywgcmVxRGF0YSwgcmVxSGVhZGVycykge1xyXG4gICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxyXG4gICAgICAgICAgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UsXHJcbiAgICAgICAgICBjYWNoZSxcclxuICAgICAgICAgIGNhY2hlZFJlc3AsXHJcbiAgICAgICAgICB1cmwgPSBidWlsZFVybChjb25maWcudXJsLCBjb25maWcucGFyYW1zKTtcclxuXHJcbiAgICAgICRodHRwLnBlbmRpbmdSZXF1ZXN0cy5wdXNoKGNvbmZpZyk7XHJcbiAgICAgIHByb21pc2UudGhlbihyZW1vdmVQZW5kaW5nUmVxLCByZW1vdmVQZW5kaW5nUmVxKTtcclxuXHJcblxyXG4gICAgICBpZiAoKGNvbmZpZy5jYWNoZSB8fCBkZWZhdWx0cy5jYWNoZSkgJiYgY29uZmlnLmNhY2hlICE9PSBmYWxzZSAmJiBjb25maWcubWV0aG9kID09ICdHRVQnKSB7XHJcbiAgICAgICAgY2FjaGUgPSBpc09iamVjdChjb25maWcuY2FjaGUpID8gY29uZmlnLmNhY2hlXHJcbiAgICAgICAgICAgICAgOiBpc09iamVjdChkZWZhdWx0cy5jYWNoZSkgPyBkZWZhdWx0cy5jYWNoZVxyXG4gICAgICAgICAgICAgIDogZGVmYXVsdENhY2hlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2FjaGUpIHtcclxuICAgICAgICBjYWNoZWRSZXNwID0gY2FjaGUuZ2V0KHVybCk7XHJcbiAgICAgICAgaWYgKGlzRGVmaW5lZChjYWNoZWRSZXNwKSkge1xyXG4gICAgICAgICAgaWYgKGNhY2hlZFJlc3AudGhlbikge1xyXG4gICAgICAgICAgICAvLyBjYWNoZWQgcmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIHNlbnQsIGJ1dCB0aGVyZSBpcyBubyByZXNwb25zZSB5ZXRcclxuICAgICAgICAgICAgY2FjaGVkUmVzcC50aGVuKHJlbW92ZVBlbmRpbmdSZXEsIHJlbW92ZVBlbmRpbmdSZXEpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzcDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNlcnZpbmcgZnJvbSBjYWNoZVxyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShjYWNoZWRSZXNwKSkge1xyXG4gICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKGNhY2hlZFJlc3BbMV0sIGNhY2hlZFJlc3BbMF0sIGNvcHkoY2FjaGVkUmVzcFsyXSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKGNhY2hlZFJlc3AsIDIwMCwge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIHB1dCB0aGUgcHJvbWlzZSBmb3IgdGhlIG5vbi10cmFuc2Zvcm1lZCByZXNwb25zZSBpbnRvIGNhY2hlIGFzIGEgcGxhY2Vob2xkZXJcclxuICAgICAgICAgIGNhY2hlLnB1dCh1cmwsIHByb21pc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gaWYgd2Ugd29uJ3QgaGF2ZSB0aGUgcmVzcG9uc2UgaW4gY2FjaGUsIHNlbmQgdGhlIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmRcclxuICAgICAgaWYgKGlzVW5kZWZpbmVkKGNhY2hlZFJlc3ApKSB7XHJcbiAgICAgICAgJGh0dHBCYWNrZW5kKGNvbmZpZy5tZXRob2QsIHVybCwgcmVxRGF0YSwgZG9uZSwgcmVxSGVhZGVycywgY29uZmlnLnRpbWVvdXQsXHJcbiAgICAgICAgICAgIGNvbmZpZy53aXRoQ3JlZGVudGlhbHMsIGNvbmZpZy5yZXNwb25zZVR5cGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcHJvbWlzZTtcclxuXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQ2FsbGJhY2sgcmVnaXN0ZXJlZCB0byAkaHR0cEJhY2tlbmQoKTpcclxuICAgICAgICogIC0gY2FjaGVzIHRoZSByZXNwb25zZSBpZiBkZXNpcmVkXHJcbiAgICAgICAqICAtIHJlc29sdmVzIHRoZSByYXcgJGh0dHAgcHJvbWlzZVxyXG4gICAgICAgKiAgLSBjYWxscyAkYXBwbHlcclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIGRvbmUoc3RhdHVzLCByZXNwb25zZSwgaGVhZGVyc1N0cmluZykge1xyXG4gICAgICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgICAgaWYgKGlzU3VjY2VzcyhzdGF0dXMpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlLnB1dCh1cmwsIFtzdGF0dXMsIHJlc3BvbnNlLCBwYXJzZUhlYWRlcnMoaGVhZGVyc1N0cmluZyldKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBwcm9taXNlIGZyb20gdGhlIGNhY2hlXHJcbiAgICAgICAgICAgIGNhY2hlLnJlbW92ZSh1cmwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzb2x2ZVByb21pc2UocmVzcG9uc2UsIHN0YXR1cywgaGVhZGVyc1N0cmluZyk7XHJcbiAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpICRyb290U2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUmVzb2x2ZXMgdGhlIHJhdyAkaHR0cCBwcm9taXNlLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UocmVzcG9uc2UsIHN0YXR1cywgaGVhZGVycykge1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBpbnRlcm5hbCBzdGF0dXNlcyB0byAwXHJcbiAgICAgICAgc3RhdHVzID0gTWF0aC5tYXgoc3RhdHVzLCAwKTtcclxuXHJcbiAgICAgICAgKGlzU3VjY2VzcyhzdGF0dXMpID8gZGVmZXJyZWQucmVzb2x2ZSA6IGRlZmVycmVkLnJlamVjdCkoe1xyXG4gICAgICAgICAgZGF0YTogcmVzcG9uc2UsXHJcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcclxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNHZXR0ZXIoaGVhZGVycyksXHJcbiAgICAgICAgICBjb25maWc6IGNvbmZpZ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgZnVuY3Rpb24gcmVtb3ZlUGVuZGluZ1JlcSgpIHtcclxuICAgICAgICB2YXIgaWR4ID0gaW5kZXhPZigkaHR0cC5wZW5kaW5nUmVxdWVzdHMsIGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpICRodHRwLnBlbmRpbmdSZXF1ZXN0cy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZFVybCh1cmwsIHBhcmFtcykge1xyXG4gICAgICAgICAgaWYgKCFwYXJhbXMpIHJldHVybiB1cmw7XHJcbiAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcclxuICAgICAgICAgIGZvckVhY2hTb3J0ZWQocGFyYW1zLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFt2YWx1ZV07XHJcblxyXG4gICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHYpKSB7XHJcbiAgICAgICAgICAgICAgICB2ID0gdG9Kc29uKHYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZVVyaVF1ZXJ5KGtleSkgKyAnPScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVXJpUXVlcnkodikpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIHVybCArICgodXJsLmluZGV4T2YoJz8nKSA9PSAtMSkgPyAnPycgOiAnJicpICsgcGFydHMuam9pbignJicpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gIH1dO1xyXG59XHJcblxyXG52YXIgWEhSID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0IHx8IGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQLjYuMFwiKTsgfSBjYXRjaCAoZTEpIHt9XHJcbiAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFAuMy4wXCIpOyB9IGNhdGNoIChlMikge31cclxuICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKTsgfSBjYXRjaCAoZTMpIHt9XHJcbiAgdGhyb3cgbWluRXJyKCckaHR0cEJhY2tlbmQnKSgnbm94aHInLCBcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LlwiKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy4kaHR0cEJhY2tlbmRcclxuICogQHJlcXVpcmVzICRicm93c2VyXHJcbiAqIEByZXF1aXJlcyAkd2luZG93XHJcbiAqIEByZXF1aXJlcyAkZG9jdW1lbnRcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEhUVFAgYmFja2VuZCB1c2VkIGJ5IHRoZSB7QGxpbmsgbmcuJGh0dHAgc2VydmljZX0gdGhhdCBkZWxlZ2F0ZXMgdG9cclxuICogWE1MSHR0cFJlcXVlc3Qgb2JqZWN0IG9yIEpTT05QIGFuZCBkZWFscyB3aXRoIGJyb3dzZXIgaW5jb21wYXRpYmlsaXRpZXMuXHJcbiAqXHJcbiAqIFlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byB1c2UgdGhpcyBzZXJ2aWNlIGRpcmVjdGx5LCBpbnN0ZWFkIHVzZSB0aGUgaGlnaGVyLWxldmVsIGFic3RyYWN0aW9uczpcclxuICoge0BsaW5rIG5nLiRodHRwICRodHRwfSBvciB7QGxpbmsgbmdSZXNvdXJjZS4kcmVzb3VyY2UgJHJlc291cmNlfS5cclxuICpcclxuICogRHVyaW5nIHRlc3RpbmcgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBzd2FwcGVkIHdpdGgge0BsaW5rIG5nTW9jay4kaHR0cEJhY2tlbmQgbW9ja1xyXG4gKiAkaHR0cEJhY2tlbmR9IHdoaWNoIGNhbiBiZSB0cmFpbmVkIHdpdGggcmVzcG9uc2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gJEh0dHBCYWNrZW5kUHJvdmlkZXIoKSB7XHJcbiAgdGhpcy4kZ2V0ID0gWyckYnJvd3NlcicsICckd2luZG93JywgJyRkb2N1bWVudCcsIGZ1bmN0aW9uKCRicm93c2VyLCAkd2luZG93LCAkZG9jdW1lbnQpIHtcclxuICAgIHJldHVybiBjcmVhdGVIdHRwQmFja2VuZCgkYnJvd3NlciwgWEhSLCAkYnJvd3Nlci5kZWZlciwgJHdpbmRvdy5hbmd1bGFyLmNhbGxiYWNrcyxcclxuICAgICAgICAkZG9jdW1lbnRbMF0sICR3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wucmVwbGFjZSgnOicsICcnKSk7XHJcbiAgfV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh0dHBCYWNrZW5kKCRicm93c2VyLCBYSFIsICRicm93c2VyRGVmZXIsIGNhbGxiYWNrcywgcmF3RG9jdW1lbnQsIGxvY2F0aW9uUHJvdG9jb2wpIHtcclxuICAvLyBUT0RPKHZvanRhKTogZml4IHRoZSBzaWduYXR1cmVcclxuICByZXR1cm4gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBvc3QsIGNhbGxiYWNrLCBoZWFkZXJzLCB0aW1lb3V0LCB3aXRoQ3JlZGVudGlhbHMsIHJlc3BvbnNlVHlwZSkge1xyXG4gICAgdmFyIHN0YXR1cztcclxuICAgICRicm93c2VyLiQkaW5jT3V0c3RhbmRpbmdSZXF1ZXN0Q291bnQoKTtcclxuICAgIHVybCA9IHVybCB8fCAkYnJvd3Nlci51cmwoKTtcclxuXHJcbiAgICBpZiAobG93ZXJjYXNlKG1ldGhvZCkgPT0gJ2pzb25wJykge1xyXG4gICAgICB2YXIgY2FsbGJhY2tJZCA9ICdfJyArIChjYWxsYmFja3MuY291bnRlcisrKS50b1N0cmluZygzNik7XHJcbiAgICAgIGNhbGxiYWNrc1tjYWxsYmFja0lkXSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICBjYWxsYmFja3NbY2FsbGJhY2tJZF0uZGF0YSA9IGRhdGE7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB2YXIganNvbnBEb25lID0ganNvbnBSZXEodXJsLnJlcGxhY2UoJ0pTT05fQ0FMTEJBQ0snLCAnYW5ndWxhci5jYWxsYmFja3MuJyArIGNhbGxiYWNrSWQpLFxyXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrc1tjYWxsYmFja0lkXS5kYXRhKSB7XHJcbiAgICAgICAgICBjb21wbGV0ZVJlcXVlc3QoY2FsbGJhY2ssIDIwMCwgY2FsbGJhY2tzW2NhbGxiYWNrSWRdLmRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb21wbGV0ZVJlcXVlc3QoY2FsbGJhY2ssIHN0YXR1cyB8fCAtMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSBjYWxsYmFja3NbY2FsbGJhY2tJZF07XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHhociA9IG5ldyBYSFIoKTtcclxuICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xyXG4gICAgICBmb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICBpZiAodmFsdWUpIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEluIElFNiBhbmQgNywgdGhpcyBtaWdodCBiZSBjYWxsZWQgc3luY2hyb25vdXNseSB3aGVuIHhoci5zZW5kIGJlbG93IGlzIGNhbGxlZCBhbmQgdGhlXHJcbiAgICAgIC8vIHJlc3BvbnNlIGlzIGluIHRoZSBjYWNoZS4gdGhlIHByb21pc2UgYXBpIHdpbGwgZW5zdXJlIHRoYXQgdG8gdGhlIGFwcCBjb2RlIHRoZSBhcGkgaXNcclxuICAgICAgLy8gYWx3YXlzIGFzeW5jXHJcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xyXG4gICAgICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcclxuXHJcbiAgICAgICAgICAvLyBUT0RPKHZvanRhKTogcmVtb3ZlIG9uY2UgRmlyZWZveCAyMSBnZXRzIHJlbGVhc2VkLlxyXG4gICAgICAgICAgLy8gYmVnaW46IHdvcmthcm91bmQgdG8gb3ZlcmNvbWUgRmlyZWZveCBDT1JTIGh0dHAgcmVzcG9uc2UgaGVhZGVycyBidWdcclxuICAgICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTYwODczNVxyXG4gICAgICAgICAgLy8gRmlyZWZveCBhbHJlYWR5IHBhdGNoZWQgaW4gbmlnaHRseS4gU2hvdWxkIGxhbmQgaW4gRmlyZWZveCAyMS5cclxuXHJcbiAgICAgICAgICAvLyBDT1JTIFwic2ltcGxlIHJlc3BvbnNlIGhlYWRlcnNcIiBodHRwOi8vd3d3LnczLm9yZy9UUi9jb3JzL1xyXG4gICAgICAgICAgdmFyIHZhbHVlLFxyXG4gICAgICAgICAgICAgIHNpbXBsZUhlYWRlcnMgPSBbXCJDYWNoZS1Db250cm9sXCIsIFwiQ29udGVudC1MYW5ndWFnZVwiLCBcIkNvbnRlbnQtVHlwZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFeHBpcmVzXCIsIFwiTGFzdC1Nb2RpZmllZFwiLCBcIlByYWdtYVwiXTtcclxuICAgICAgICAgIGlmICghcmVzcG9uc2VIZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IFwiXCI7XHJcbiAgICAgICAgICAgIGZvckVhY2goc2ltcGxlSGVhZGVycywgZnVuY3Rpb24gKGhlYWRlcikge1xyXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xyXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMgKz0gaGVhZGVyICsgXCI6IFwiICsgdmFsdWUgKyBcIlxcblwiO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBlbmQgb2YgdGhlIHdvcmthcm91bmQuXHJcblxyXG4gICAgICAgICAgLy8gcmVzcG9uc2VUZXh0IGlzIHRoZSBvbGQtc2Nob29sIHdheSBvZiByZXRyaWV2aW5nIHJlc3BvbnNlIChzdXBwb3J0ZWQgYnkgSUU4ICYgOSlcclxuICAgICAgICAgIC8vIHJlc3BvbnNlIGFuZCByZXNwb25zZVR5cGUgcHJvcGVydGllcyB3ZXJlIGludHJvZHVjZWQgaW4gWEhSIExldmVsMiBzcGVjIChzdXBwb3J0ZWQgYnkgSUUxMClcclxuICAgICAgICAgIGNvbXBsZXRlUmVxdWVzdChjYWxsYmFjayxcclxuICAgICAgICAgICAgICBzdGF0dXMgfHwgeGhyLnN0YXR1cyxcclxuICAgICAgICAgICAgICAoeGhyLnJlc3BvbnNlVHlwZSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQpLFxyXG4gICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKHdpdGhDcmVkZW50aWFscykge1xyXG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVzcG9uc2VUeXBlKSB7XHJcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGhyLnNlbmQocG9zdCB8fCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRpbWVvdXQgPiAwKSB7XHJcbiAgICAgIHZhciB0aW1lb3V0SWQgPSAkYnJvd3NlckRlZmVyKHRpbWVvdXRSZXF1ZXN0LCB0aW1lb3V0KTtcclxuICAgIH0gZWxzZSBpZiAodGltZW91dCAmJiB0aW1lb3V0LnRoZW4pIHtcclxuICAgICAgdGltZW91dC50aGVuKHRpbWVvdXRSZXF1ZXN0KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdGltZW91dFJlcXVlc3QoKSB7XHJcbiAgICAgIHN0YXR1cyA9IC0xO1xyXG4gICAgICBqc29ucERvbmUgJiYganNvbnBEb25lKCk7XHJcbiAgICAgIHhociAmJiB4aHIuYWJvcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoY2FsbGJhY2ssIHN0YXR1cywgcmVzcG9uc2UsIGhlYWRlcnNTdHJpbmcpIHtcclxuICAgICAgLy8gVVJMX01BVENIIGlzIGRlZmluZWQgaW4gc3JjL3NlcnZpY2UvbG9jYXRpb24uanNcclxuICAgICAgdmFyIHByb3RvY29sID0gKHVybC5tYXRjaChTRVJWRVJfTUFUQ0gpIHx8IFsnJywgbG9jYXRpb25Qcm90b2NvbF0pWzFdO1xyXG5cclxuICAgICAgLy8gY2FuY2VsIHRpbWVvdXQgYW5kIHN1YnNlcXVlbnQgdGltZW91dCBwcm9taXNlIHJlc29sdXRpb25cclxuICAgICAgdGltZW91dElkICYmICRicm93c2VyRGVmZXIuY2FuY2VsKHRpbWVvdXRJZCk7XHJcbiAgICAgIGpzb25wRG9uZSA9IHhociA9IG51bGw7XHJcblxyXG4gICAgICAvLyBmaXggc3RhdHVzIGNvZGUgZm9yIGZpbGUgcHJvdG9jb2wgKGl0J3MgYWx3YXlzIDApXHJcbiAgICAgIHN0YXR1cyA9IChwcm90b2NvbCA9PSAnZmlsZScpID8gKHJlc3BvbnNlID8gMjAwIDogNDA0KSA6IHN0YXR1cztcclxuXHJcbiAgICAgIC8vIG5vcm1hbGl6ZSBJRSBidWcgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTApXHJcbiAgICAgIHN0YXR1cyA9IHN0YXR1cyA9PSAxMjIzID8gMjA0IDogc3RhdHVzO1xyXG5cclxuICAgICAgY2FsbGJhY2soc3RhdHVzLCByZXNwb25zZSwgaGVhZGVyc1N0cmluZyk7XHJcbiAgICAgICRicm93c2VyLiQkY29tcGxldGVPdXRzdGFuZGluZ1JlcXVlc3Qobm9vcCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24ganNvbnBSZXEodXJsLCBkb25lKSB7XHJcbiAgICAvLyB3ZSBjYW4ndCB1c2UgalF1ZXJ5L2pxTGl0ZSBoZXJlIGJlY2F1c2UgalF1ZXJ5IGRvZXMgY3Jhenkgc2hpdCB3aXRoIHNjcmlwdCBlbGVtZW50cywgZS5nLjpcclxuICAgIC8vIC0gZmV0Y2hlcyBsb2NhbCBzY3JpcHRzIHZpYSBYSFIgYW5kIGV2YWxzIHRoZW1cclxuICAgIC8vIC0gYWRkcyBhbmQgaW1tZWRpYXRlbHkgcmVtb3ZlcyBzY3JpcHQgZWxlbWVudHMgZnJvbSB0aGUgZG9jdW1lbnRcclxuICAgIHZhciBzY3JpcHQgPSByYXdEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcclxuICAgICAgICBkb25lV3JhcHBlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmF3RG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JpcHQpO1xyXG4gICAgICAgICAgaWYgKGRvbmUpIGRvbmUoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICBzY3JpcHQuc3JjID0gdXJsO1xyXG5cclxuICAgIGlmIChtc2llKSB7XHJcbiAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoL2xvYWRlZHxjb21wbGV0ZS8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIGRvbmVXcmFwcGVyKCk7XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uZXJyb3IgPSBkb25lV3JhcHBlcjtcclxuICAgIH1cclxuXHJcbiAgICByYXdEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiAgICByZXR1cm4gZG9uZVdyYXBwZXI7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgJGludGVycG9sYXRlTWluRXJyID0gbWluRXJyKCckaW50ZXJwb2xhdGUnKTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRpbnRlcnBvbGF0ZVByb3ZpZGVyXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogVXNlZCBmb3IgY29uZmlndXJpbmcgdGhlIGludGVycG9sYXRpb24gbWFya3VwLiBEZWZhdWx0cyB0byBge3tgIGFuZCBgfX1gLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGUgbW9kdWxlPVwiY3VzdG9tSW50ZXJwb2xhdGlvbkFwcFwiPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICA8c2NyaXB0PlxyXG4gICAgICAgIHZhciBjdXN0b21JbnRlcnBvbGF0aW9uQXBwID0gYW5ndWxhci5tb2R1bGUoJ2N1c3RvbUludGVycG9sYXRpb25BcHAnLCBbXSk7XHJcblxyXG4gICAgICAgIGN1c3RvbUludGVycG9sYXRpb25BcHAuY29uZmlnKGZ1bmN0aW9uKCRpbnRlcnBvbGF0ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAkaW50ZXJwb2xhdGVQcm92aWRlci5zdGFydFN5bWJvbCgnLy8nKTtcclxuICAgICAgICAgICRpbnRlcnBvbGF0ZVByb3ZpZGVyLmVuZFN5bWJvbCgnLy8nKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIGN1c3RvbUludGVycG9sYXRpb25BcHAuY29udHJvbGxlcignRGVtb0NvbnRyb2xsZXInLCBmdW5jdGlvbiBEZW1vQ29udHJvbGxlcigpIHtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbCA9IFwiVGhpcyBiaW5kaW5ncyBpcyBicm91Z2h0IHlvdSB5b3UgYnkgLy8gaW50ZXJwb2xhdGlvbiBzeW1ib2xzLlwiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICA8L3NjcmlwdD5cclxuICAgICAgPGRpdiBuZy1hcHA9XCJBcHBcIiBuZy1jb250cm9sbGVyPVwiRGVtb0NvbnRyb2xsZXIgYXMgZGVtb1wiPlxyXG4gICAgICAgICAgLy9kZW1vLmxhYmVsLy9cclxuICAgICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGludGVycG9sYXRlIGJpbmRpbmcgd2l0aCBjdXN0b20gc3ltYm9scycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnZGVtby5sYWJlbCcpKS50b0JlKCdUaGlzIGJpbmRpbmdzIGlzIGJyb3VnaHQgeW91IHlvdSBieSAvLyBpbnRlcnBvbGF0aW9uIHN5bWJvbHMuJyk7XHJcbiAgICAgICB9KTtcclxuIDwvZG9jOnNjZW5hcmlvPlxyXG4gICA8L2RvYzpleGFtcGxlPlxyXG4gKi9cclxuZnVuY3Rpb24gJEludGVycG9sYXRlUHJvdmlkZXIoKSB7XHJcbiAgdmFyIHN0YXJ0U3ltYm9sID0gJ3t7JztcclxuICB2YXIgZW5kU3ltYm9sID0gJ319JztcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAqIEBuYW1lIG5nLiRpbnRlcnBvbGF0ZVByb3ZpZGVyI3N0YXJ0U3ltYm9sXHJcbiAgICogQG1ldGhvZE9mIG5nLiRpbnRlcnBvbGF0ZVByb3ZpZGVyXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogU3ltYm9sIHRvIGRlbm90ZSBzdGFydCBvZiBleHByZXNzaW9uIGluIHRoZSBpbnRlcnBvbGF0ZWQgc3RyaW5nLiBEZWZhdWx0cyB0byBge3tgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSB2YWx1ZSBuZXcgdmFsdWUgdG8gc2V0IHRoZSBzdGFydGluZyBzeW1ib2wgdG8uXHJcbiAgICogQHJldHVybnMge3N0cmluZ3xzZWxmfSBSZXR1cm5zIHRoZSBzeW1ib2wgd2hlbiB1c2VkIGFzIGdldHRlciBhbmQgc2VsZiBpZiB1c2VkIGFzIHNldHRlci5cclxuICAgKi9cclxuICB0aGlzLnN0YXJ0U3ltYm9sID0gZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgIHN0YXJ0U3ltYm9sID0gdmFsdWU7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHN0YXJ0U3ltYm9sO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBtZXRob2RcclxuICAgKiBAbmFtZSBuZy4kaW50ZXJwb2xhdGVQcm92aWRlciNlbmRTeW1ib2xcclxuICAgKiBAbWV0aG9kT2YgbmcuJGludGVycG9sYXRlUHJvdmlkZXJcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBTeW1ib2wgdG8gZGVub3RlIHRoZSBlbmQgb2YgZXhwcmVzc2lvbiBpbiB0aGUgaW50ZXJwb2xhdGVkIHN0cmluZy4gRGVmYXVsdHMgdG8gYH19YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gdmFsdWUgbmV3IHZhbHVlIHRvIHNldCB0aGUgZW5kaW5nIHN5bWJvbCB0by5cclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfHNlbGZ9IFJldHVybnMgdGhlIHN5bWJvbCB3aGVuIHVzZWQgYXMgZ2V0dGVyIGFuZCBzZWxmIGlmIHVzZWQgYXMgc2V0dGVyLlxyXG4gICAqL1xyXG4gIHRoaXMuZW5kU3ltYm9sID0gZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgIGVuZFN5bWJvbCA9IHZhbHVlO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBlbmRTeW1ib2w7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcblxyXG4gIHRoaXMuJGdldCA9IFsnJHBhcnNlJywgJyRleGNlcHRpb25IYW5kbGVyJywgJyRzY2UnLCBmdW5jdGlvbigkcGFyc2UsICRleGNlcHRpb25IYW5kbGVyLCAkc2NlKSB7XHJcbiAgICB2YXIgc3RhcnRTeW1ib2xMZW5ndGggPSBzdGFydFN5bWJvbC5sZW5ndGgsXHJcbiAgICAgICAgZW5kU3ltYm9sTGVuZ3RoID0gZW5kU3ltYm9sLmxlbmd0aDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgbmcuJGludGVycG9sYXRlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqXHJcbiAgICAgKiBAcmVxdWlyZXMgJHBhcnNlXHJcbiAgICAgKiBAcmVxdWlyZXMgJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqIENvbXBpbGVzIGEgc3RyaW5nIHdpdGggbWFya3VwIGludG8gYW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvbi4gVGhpcyBzZXJ2aWNlIGlzIHVzZWQgYnkgdGhlXHJcbiAgICAgKiBIVE1MIHtAbGluayBuZy4kY29tcGlsZSAkY29tcGlsZX0gc2VydmljZSBmb3IgZGF0YSBiaW5kaW5nLiBTZWVcclxuICAgICAqIHtAbGluayBuZy4kaW50ZXJwb2xhdGVQcm92aWRlciAkaW50ZXJwb2xhdGVQcm92aWRlcn0gZm9yIGNvbmZpZ3VyaW5nIHRoZVxyXG4gICAgICogaW50ZXJwb2xhdGlvbiBtYXJrdXAuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAgIDxwcmU+XHJcbiAgICAgICAgIHZhciAkaW50ZXJwb2xhdGUgPSAuLi47IC8vIGluamVjdGVkXHJcbiAgICAgICAgIHZhciBleHAgPSAkaW50ZXJwb2xhdGUoJ0hlbGxvIHt7bmFtZX19IScpO1xyXG4gICAgICAgICBleHBlY3QoZXhwKHtuYW1lOidBbmd1bGFyJ30pLnRvRXF1YWwoJ0hlbGxvIEFuZ3VsYXIhJyk7XHJcbiAgICAgICA8L3ByZT5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgd2l0aCBtYXJrdXAgdG8gaW50ZXJwb2xhdGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtdXN0SGF2ZUV4cHJlc3Npb24gaWYgc2V0IHRvIHRydWUgdGhlbiB0aGUgaW50ZXJwb2xhdGlvbiBzdHJpbmcgbXVzdCBoYXZlXHJcbiAgICAgKiAgICBlbWJlZGRlZCBleHByZXNzaW9uIGluIG9yZGVyIHRvIHJldHVybiBhbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uLiBTdHJpbmdzIHdpdGggbm9cclxuICAgICAqICAgIGVtYmVkZGVkIGV4cHJlc3Npb24gd2lsbCByZXR1cm4gbnVsbCBmb3IgdGhlIGludGVycG9sYXRpb24gZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHRydXN0ZWRDb250ZXh0IHdoZW4gcHJvdmlkZWQsIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBwYXNzZXMgdGhlIGludGVycG9sYXRlZFxyXG4gICAgICogICAgcmVzdWx0IHRocm91Z2gge0BsaW5rIG5nLiRzY2UjZ2V0VHJ1c3RlZCAkc2NlLmdldFRydXN0ZWQoaW50ZXJwb2xhdGVkUmVzdWx0LFxyXG4gICAgICogICAgdHJ1c3RlZENvbnRleHQpfSBiZWZvcmUgcmV0dXJuaW5nIGl0LiAgUmVmZXIgdG8gdGhlIHtAbGluayBuZy4kc2NlICRzY2V9IHNlcnZpY2UgdGhhdFxyXG4gICAgICogICAgcHJvdmlkZXMgU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmcgZm9yIGRldGFpbHMuXHJcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oY29udGV4dCl9IGFuIGludGVycG9sYXRpb24gZnVuY3Rpb24gd2hpY2ggaXMgdXNlZCB0byBjb21wdXRlIHRoZSBpbnRlcnBvbGF0ZWRcclxuICAgICAqICAgIHN0cmluZy4gVGhlIGZ1bmN0aW9uIGhhcyB0aGVzZSBwYXJhbWV0ZXJzOlxyXG4gICAgICpcclxuICAgICAqICAgICogYGNvbnRleHRgOiBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3MgYXJlIGV2YWx1YXRlZFxyXG4gICAgICogICAgICBhZ2FpbnN0LlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gJGludGVycG9sYXRlKHRleHQsIG11c3RIYXZlRXhwcmVzc2lvbiwgdHJ1c3RlZENvbnRleHQpIHtcclxuICAgICAgdmFyIHN0YXJ0SW5kZXgsXHJcbiAgICAgICAgICBlbmRJbmRleCxcclxuICAgICAgICAgIGluZGV4ID0gMCxcclxuICAgICAgICAgIHBhcnRzID0gW10sXHJcbiAgICAgICAgICBsZW5ndGggPSB0ZXh0Lmxlbmd0aCxcclxuICAgICAgICAgIGhhc0ludGVycG9sYXRpb24gPSBmYWxzZSxcclxuICAgICAgICAgIGZuLFxyXG4gICAgICAgICAgZXhwLFxyXG4gICAgICAgICAgY29uY2F0ID0gW107XHJcblxyXG4gICAgICB3aGlsZShpbmRleCA8IGxlbmd0aCkge1xyXG4gICAgICAgIGlmICggKChzdGFydEluZGV4ID0gdGV4dC5pbmRleE9mKHN0YXJ0U3ltYm9sLCBpbmRleCkpICE9IC0xKSAmJlxyXG4gICAgICAgICAgICAgKChlbmRJbmRleCA9IHRleHQuaW5kZXhPZihlbmRTeW1ib2wsIHN0YXJ0SW5kZXggKyBzdGFydFN5bWJvbExlbmd0aCkpICE9IC0xKSApIHtcclxuICAgICAgICAgIChpbmRleCAhPSBzdGFydEluZGV4KSAmJiBwYXJ0cy5wdXNoKHRleHQuc3Vic3RyaW5nKGluZGV4LCBzdGFydEluZGV4KSk7XHJcbiAgICAgICAgICBwYXJ0cy5wdXNoKGZuID0gJHBhcnNlKGV4cCA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0SW5kZXggKyBzdGFydFN5bWJvbExlbmd0aCwgZW5kSW5kZXgpKSk7XHJcbiAgICAgICAgICBmbi5leHAgPSBleHA7XHJcbiAgICAgICAgICBpbmRleCA9IGVuZEluZGV4ICsgZW5kU3ltYm9sTGVuZ3RoO1xyXG4gICAgICAgICAgaGFzSW50ZXJwb2xhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIHdlIGRpZCBub3QgZmluZCBhbnl0aGluZywgc28gd2UgaGF2ZSB0byBhZGQgdGhlIHJlbWFpbmRlciB0byB0aGUgcGFydHMgYXJyYXlcclxuICAgICAgICAgIChpbmRleCAhPSBsZW5ndGgpICYmIHBhcnRzLnB1c2godGV4dC5zdWJzdHJpbmcoaW5kZXgpKTtcclxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEobGVuZ3RoID0gcGFydHMubGVuZ3RoKSkge1xyXG4gICAgICAgIC8vIHdlIGFkZGVkLCBub3RoaW5nLCBtdXN0IGhhdmUgYmVlbiBhbiBlbXB0eSBzdHJpbmcuXHJcbiAgICAgICAgcGFydHMucHVzaCgnJyk7XHJcbiAgICAgICAgbGVuZ3RoID0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29uY2F0ZW5hdGluZyBleHByZXNzaW9ucyBtYWtlcyBpdCBoYXJkIHRvIHJlYXNvbiBhYm91dCB3aGV0aGVyIHNvbWUgY29tYmluYXRpb24gb2YgY29uY2F0ZW5hdGVkXHJcbiAgICAgIC8vIHZhbHVlcyBhcmUgdW5zYWZlIHRvIHVzZSBhbmQgY291bGQgZWFzaWx5IGxlYWQgdG8gWFNTLiAgQnkgcmVxdWlyaW5nIHRoYXQgYSBzaW5nbGVcclxuICAgICAgLy8gZXhwcmVzc2lvbiBiZSB1c2VkIGZvciBpZnJhbWVbc3JjXSwgb2JqZWN0W3NyY10sIGV0Yy4sIHdlIGVuc3VyZSB0aGF0IHRoZSB2YWx1ZSB0aGF0J3MgdXNlZFxyXG4gICAgICAvLyBpcyBhc3NpZ25lZCBvciBjb25zdHJ1Y3RlZCBieSBzb21lIEpTIGNvZGUgc29tZXdoZXJlIHRoYXQgaXMgbW9yZSB0ZXN0YWJsZSBvciBtYWtlIGl0XHJcbiAgICAgIC8vIG9idmlvdXMgdGhhdCB5b3UgYm91bmQgdGhlIHZhbHVlIHRvIHNvbWUgdXNlciBjb250cm9sbGVkIHZhbHVlLiAgVGhpcyBoZWxwcyByZWR1Y2UgdGhlIGxvYWRcclxuICAgICAgLy8gd2hlbiBhdWRpdGluZyBmb3IgWFNTIGlzc3Vlcy5cclxuICAgICAgaWYgKHRydXN0ZWRDb250ZXh0ICYmIHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIHRocm93ICRpbnRlcnBvbGF0ZU1pbkVycignbm9jb25jYXQnLFxyXG4gICAgICAgICAgICAgIFwiRXJyb3Igd2hpbGUgaW50ZXJwb2xhdGluZzogezB9XFxuU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmcgZGlzYWxsb3dzIFwiICtcclxuICAgICAgICAgICAgICBcImludGVycG9sYXRpb25zIHRoYXQgY29uY2F0ZW5hdGUgbXVsdGlwbGUgZXhwcmVzc2lvbnMgd2hlbiBhIHRydXN0ZWQgdmFsdWUgaXMgXCIgK1xyXG4gICAgICAgICAgICAgIFwicmVxdWlyZWQuICBTZWUgaHR0cDovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmcuJHNjZVwiLCB0ZXh0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFtdXN0SGF2ZUV4cHJlc3Npb24gIHx8IGhhc0ludGVycG9sYXRpb24pIHtcclxuICAgICAgICBjb25jYXQubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIGZuID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgaWkgPSBsZW5ndGgsIHBhcnQ7IGk8aWk7IGkrKykge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBhcnQgPSBwYXJ0c1tpXSkgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcGFydCA9IHBhcnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJ1c3RlZENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgcGFydCA9ICRzY2UuZ2V0VHJ1c3RlZCh0cnVzdGVkQ29udGV4dCwgcGFydCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBwYXJ0ID0gJHNjZS52YWx1ZU9mKHBhcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT0gbnVsbCB8fCBwYXJ0ID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICBwYXJ0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJ0ICE9ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgIHBhcnQgPSB0b0pzb24ocGFydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGNvbmNhdFtpXSA9IHBhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdC5qb2luKCcnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNhdGNoKGVycikge1xyXG4gICAgICAgICAgICB2YXIgbmV3RXJyID0gJGludGVycG9sYXRlTWluRXJyKCdpbnRlcnInLCBcIkNhbid0IGludGVycG9sYXRlOiB7MH1cXG57MX1cIiwgdGV4dCwgZXJyLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihuZXdFcnIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm4uZXhwID0gdGV4dDtcclxuICAgICAgICBmbi5wYXJ0cyA9IHBhcnRzO1xyXG4gICAgICAgIHJldHVybiBmbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRpbnRlcnBvbGF0ZSNzdGFydFN5bWJvbFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRpbnRlcnBvbGF0ZVxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTeW1ib2wgdG8gZGVub3RlIHRoZSBzdGFydCBvZiBleHByZXNzaW9uIGluIHRoZSBpbnRlcnBvbGF0ZWQgc3RyaW5nLiBEZWZhdWx0cyB0byBge3tgLlxyXG4gICAgICpcclxuICAgICAqIFVzZSB7QGxpbmsgbmcuJGludGVycG9sYXRlUHJvdmlkZXIjc3RhcnRTeW1ib2wgJGludGVycG9sYXRlUHJvdmlkZXIjc3RhcnRTeW1ib2x9IHRvIGNoYW5nZVxyXG4gICAgICogdGhlIHN5bWJvbC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdGFydCBzeW1ib2wuXHJcbiAgICAgKi9cclxuICAgICRpbnRlcnBvbGF0ZS5zdGFydFN5bWJvbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gc3RhcnRTeW1ib2w7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJGludGVycG9sYXRlI2VuZFN5bWJvbFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRpbnRlcnBvbGF0ZVxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTeW1ib2wgdG8gZGVub3RlIHRoZSBlbmQgb2YgZXhwcmVzc2lvbiBpbiB0aGUgaW50ZXJwb2xhdGVkIHN0cmluZy4gRGVmYXVsdHMgdG8gYH19YC5cclxuICAgICAqXHJcbiAgICAgKiBVc2Uge0BsaW5rIG5nLiRpbnRlcnBvbGF0ZVByb3ZpZGVyI2VuZFN5bWJvbCAkaW50ZXJwb2xhdGVQcm92aWRlciNlbmRTeW1ib2x9IHRvIGNoYW5nZVxyXG4gICAgICogdGhlIHN5bWJvbC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdGFydCBzeW1ib2wuXHJcbiAgICAgKi9cclxuICAgICRpbnRlcnBvbGF0ZS5lbmRTeW1ib2wgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGVuZFN5bWJvbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJGludGVycG9sYXRlO1xyXG4gIH1dO1xyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy4kbG9jYWxlXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAkbG9jYWxlIHNlcnZpY2UgcHJvdmlkZXMgbG9jYWxpemF0aW9uIHJ1bGVzIGZvciB2YXJpb3VzIEFuZ3VsYXIgY29tcG9uZW50cy4gQXMgb2YgcmlnaHQgbm93IHRoZVxyXG4gKiBvbmx5IHB1YmxpYyBhcGkgaXM6XHJcbiAqXHJcbiAqICogYGlkYCDDouKCrOKAnCBge3N0cmluZ31gIMOi4oKs4oCcIGxvY2FsZSBpZCBmb3JtYXR0ZWQgYXMgYGxhbmd1YWdlSWQtY291bnRyeUlkYCAoZS5nLiBgZW4tdXNgKVxyXG4gKi9cclxuZnVuY3Rpb24gJExvY2FsZVByb3ZpZGVyKCl7XHJcbiAgdGhpcy4kZ2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogJ2VuLXVzJyxcclxuXHJcbiAgICAgIE5VTUJFUl9GT1JNQVRTOiB7XHJcbiAgICAgICAgREVDSU1BTF9TRVA6ICcuJyxcclxuICAgICAgICBHUk9VUF9TRVA6ICcsJyxcclxuICAgICAgICBQQVRURVJOUzogW1xyXG4gICAgICAgICAgeyAvLyBEZWNpbWFsIFBhdHRlcm5cclxuICAgICAgICAgICAgbWluSW50OiAxLFxyXG4gICAgICAgICAgICBtaW5GcmFjOiAwLFxyXG4gICAgICAgICAgICBtYXhGcmFjOiAzLFxyXG4gICAgICAgICAgICBwb3NQcmU6ICcnLFxyXG4gICAgICAgICAgICBwb3NTdWY6ICcnLFxyXG4gICAgICAgICAgICBuZWdQcmU6ICctJyxcclxuICAgICAgICAgICAgbmVnU3VmOiAnJyxcclxuICAgICAgICAgICAgZ1NpemU6IDMsXHJcbiAgICAgICAgICAgIGxnU2l6ZTogM1xyXG4gICAgICAgICAgfSx7IC8vQ3VycmVuY3kgUGF0dGVyblxyXG4gICAgICAgICAgICBtaW5JbnQ6IDEsXHJcbiAgICAgICAgICAgIG1pbkZyYWM6IDIsXHJcbiAgICAgICAgICAgIG1heEZyYWM6IDIsXHJcbiAgICAgICAgICAgIHBvc1ByZTogJ1xcdTAwQTQnLFxyXG4gICAgICAgICAgICBwb3NTdWY6ICcnLFxyXG4gICAgICAgICAgICBuZWdQcmU6ICcoXFx1MDBBNCcsXHJcbiAgICAgICAgICAgIG5lZ1N1ZjogJyknLFxyXG4gICAgICAgICAgICBnU2l6ZTogMyxcclxuICAgICAgICAgICAgbGdTaXplOiAzXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBDVVJSRU5DWV9TWU06ICckJ1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgREFURVRJTUVfRk9STUFUUzoge1xyXG4gICAgICAgIE1PTlRIOiAnSmFudWFyeSxGZWJydWFyeSxNYXJjaCxBcHJpbCxNYXksSnVuZSxKdWx5LEF1Z3VzdCxTZXB0ZW1iZXIsT2N0b2JlcixOb3ZlbWJlcixEZWNlbWJlcidcclxuICAgICAgICAgICAgICAgIC5zcGxpdCgnLCcpLFxyXG4gICAgICAgIFNIT1JUTU9OVEg6ICAnSmFuLEZlYixNYXIsQXByLE1heSxKdW4sSnVsLEF1ZyxTZXAsT2N0LE5vdixEZWMnLnNwbGl0KCcsJyksXHJcbiAgICAgICAgREFZOiAnU3VuZGF5LE1vbmRheSxUdWVzZGF5LFdlZG5lc2RheSxUaHVyc2RheSxGcmlkYXksU2F0dXJkYXknLnNwbGl0KCcsJyksXHJcbiAgICAgICAgU0hPUlREQVk6ICdTdW4sTW9uLFR1ZSxXZWQsVGh1LEZyaSxTYXQnLnNwbGl0KCcsJyksXHJcbiAgICAgICAgQU1QTVM6IFsnQU0nLCdQTSddLFxyXG4gICAgICAgIG1lZGl1bTogJ01NTSBkLCB5IGg6bW06c3MgYScsXHJcbiAgICAgICAgc2hvcnQ6ICdNL2QveXkgaDptbSBhJyxcclxuICAgICAgICBmdWxsRGF0ZTogJ0VFRUUsIE1NTU0gZCwgeScsXHJcbiAgICAgICAgbG9uZ0RhdGU6ICdNTU1NIGQsIHknLFxyXG4gICAgICAgIG1lZGl1bURhdGU6ICdNTU0gZCwgeScsXHJcbiAgICAgICAgc2hvcnREYXRlOiAnTS9kL3l5JyxcclxuICAgICAgICBtZWRpdW1UaW1lOiAnaDptbTpzcyBhJyxcclxuICAgICAgICBzaG9ydFRpbWU6ICdoOm1tIGEnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBwbHVyYWxDYXQ6IGZ1bmN0aW9uKG51bSkge1xyXG4gICAgICAgIGlmIChudW0gPT09IDEpIHtcclxuICAgICAgICAgIHJldHVybiAnb25lJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfTtcclxufVxyXG5cclxudmFyIFNFUlZFUl9NQVRDSCA9IC9eKFteOl0rKTpcXC9cXC8oXFx3Kzp7MCwxfVxcdypAKT8oXFx7P1tcXHdcXC4tXSpcXH0/KSg6KFswLTldKykpPyhcXC9bXlxcPyNdKik/KFxcPyhbXiNdKikpPygjKC4qKSk/JC8sXHJcbiAgICBQQVRIX01BVENIID0gL14oW15cXD8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/JC8sXHJcbiAgICBERUZBVUxUX1BPUlRTID0geydodHRwJzogODAsICdodHRwcyc6IDQ0MywgJ2Z0cCc6IDIxfTtcclxudmFyICRsb2NhdGlvbk1pbkVyciA9IG1pbkVycignJGxvY2F0aW9uJyk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEVuY29kZSBwYXRoIHVzaW5nIGVuY29kZVVyaVNlZ21lbnQsIGlnbm9yaW5nIGZvcndhcmQgc2xhc2hlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIGVuY29kZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XHJcbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpLFxyXG4gICAgICBpID0gc2VnbWVudHMubGVuZ3RoO1xyXG5cclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICBzZWdtZW50c1tpXSA9IGVuY29kZVVyaVNlZ21lbnQoc2VnbWVudHNbaV0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNlZ21lbnRzLmpvaW4oJy8nKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWF0Y2hVcmwodXJsLCBvYmopIHtcclxuICB2YXIgbWF0Y2ggPSBTRVJWRVJfTUFUQ0guZXhlYyh1cmwpO1xyXG5cclxuICBvYmouJCRwcm90b2NvbCA9IG1hdGNoWzFdO1xyXG4gIG9iai4kJGhvc3QgPSBtYXRjaFszXTtcclxuICBvYmouJCRwb3J0ID0gaW50KG1hdGNoWzVdKSB8fCBERUZBVUxUX1BPUlRTW21hdGNoWzFdXSB8fCBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXRjaEFwcFVybCh1cmwsIG9iaikge1xyXG4gIHZhciBtYXRjaCA9IFBBVEhfTUFUQ0guZXhlYyh1cmwpO1xyXG5cclxuICBvYmouJCRwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzFdKTtcclxuICBvYmouJCRzZWFyY2ggPSBwYXJzZUtleVZhbHVlKG1hdGNoWzNdKTtcclxuICBvYmouJCRoYXNoID0gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzVdIHx8ICcnKTtcclxuXHJcbiAgLy8gbWFrZSBzdXJlIHBhdGggc3RhcnRzIHdpdGggJy8nO1xyXG4gIGlmIChvYmouJCRwYXRoICYmIG9iai4kJHBhdGguY2hhckF0KDApICE9ICcvJykgb2JqLiQkcGF0aCA9ICcvJyArIG9iai4kJHBhdGg7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBjb21wb3NlUHJvdG9jb2xIb3N0UG9ydChwcm90b2NvbCwgaG9zdCwgcG9ydCkge1xyXG4gIHJldHVybiBwcm90b2NvbCArICc6Ly8nICsgaG9zdCArIChwb3J0ID09IERFRkFVTFRfUE9SVFNbcHJvdG9jb2xdID8gJycgOiAnOicgKyBwb3J0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBiZWdpblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2hvbGVcclxuICogQHBhcmFtIHtzdHJpbmd9IG90aGVyd2lzZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSByZXR1cm5zIHRleHQgZnJvbSB3aG9sZSBhZnRlciBiZWdpbiBvciBvdGhlcndpc2UgaWYgaXQgZG9lcyBub3QgYmVnaW4gd2l0aCBleHBlY3RlZCBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBiZWdpbnNXaXRoKGJlZ2luLCB3aG9sZSwgb3RoZXJ3aXNlKSB7XHJcbiAgcmV0dXJuIHdob2xlLmluZGV4T2YoYmVnaW4pID09IDAgPyB3aG9sZS5zdWJzdHIoYmVnaW4ubGVuZ3RoKSA6IG90aGVyd2lzZTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHN0cmlwSGFzaCh1cmwpIHtcclxuICB2YXIgaW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xyXG4gIHJldHVybiBpbmRleCA9PSAtMSA/IHVybCA6IHVybC5zdWJzdHIoMCwgaW5kZXgpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gc3RyaXBGaWxlKHVybCkge1xyXG4gIHJldHVybiB1cmwuc3Vic3RyKDAsIHN0cmlwSGFzaCh1cmwpLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcclxufVxyXG5cclxuLyogcmV0dXJuIHRoZSBzZXJ2ZXIgb25seSAoc2NoZW1lOi8vaG9zdDpwb3J0KSAqL1xyXG5mdW5jdGlvbiBzZXJ2ZXJCYXNlKHVybCkge1xyXG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5pbmRleE9mKCcvJywgdXJsLmluZGV4T2YoJy8vJykgKyAyKSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogTG9jYXRpb25IdG1sNVVybCByZXByZXNlbnRzIGFuIHVybFxyXG4gKiBUaGlzIG9iamVjdCBpcyBleHBvc2VkIGFzICRsb2NhdGlvbiBzZXJ2aWNlIHdoZW4gSFRNTDUgbW9kZSBpcyBlbmFibGVkIGFuZCBzdXBwb3J0ZWRcclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBCYXNlIGFwcGxpY2F0aW9uIGJhc2UgVVJMXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlUHJlZml4IHVybCBwYXRoIHByZWZpeFxyXG4gKi9cclxuZnVuY3Rpb24gTG9jYXRpb25IdG1sNVVybChhcHBCYXNlLCBiYXNlUHJlZml4KSB7XHJcbiAgdGhpcy4kJGh0bWw1ID0gdHJ1ZTtcclxuICBiYXNlUHJlZml4ID0gYmFzZVByZWZpeCB8fCAnJztcclxuICB2YXIgYXBwQmFzZU5vRmlsZSA9IHN0cmlwRmlsZShhcHBCYXNlKTtcclxuICAvKipcclxuICAgKiBQYXJzZSBnaXZlbiBodG1sNSAocmVndWxhcikgdXJsIHN0cmluZyBpbnRvIHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3QWJzb2x1dGVVcmwgSFRNTDUgdXJsXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICB0aGlzLiQkcGFyc2UgPSBmdW5jdGlvbih1cmwpIHtcclxuICAgIHZhciBwYXJzZWQgPSB7fVxyXG4gICAgbWF0Y2hVcmwodXJsLCBwYXJzZWQpO1xyXG4gICAgdmFyIHBhdGhVcmwgPSBiZWdpbnNXaXRoKGFwcEJhc2VOb0ZpbGUsIHVybCk7XHJcbiAgICBpZiAoIWlzU3RyaW5nKHBhdGhVcmwpKSB7XHJcbiAgICAgIHRocm93ICRsb2NhdGlvbk1pbkVycignaXB0aHByZngnLCAnSW52YWxpZCB1cmwgXCJ7MH1cIiwgbWlzc2luZyBwYXRoIHByZWZpeCBcInsxfVwiLicsIHVybCwgYXBwQmFzZU5vRmlsZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaEFwcFVybChwYXRoVXJsLCBwYXJzZWQpO1xyXG4gICAgZXh0ZW5kKHRoaXMsIHBhcnNlZCk7XHJcbiAgICBpZiAoIXRoaXMuJCRwYXRoKSB7XHJcbiAgICAgIHRoaXMuJCRwYXRoID0gJy8nO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuJCRjb21wb3NlKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcG9zZSB1cmwgYW5kIHVwZGF0ZSBgYWJzVXJsYCBwcm9wZXJ0eVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgdGhpcy4kJGNvbXBvc2UgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzZWFyY2ggPSB0b0tleVZhbHVlKHRoaXMuJCRzZWFyY2gpLFxyXG4gICAgICAgIGhhc2ggPSB0aGlzLiQkaGFzaCA/ICcjJyArIGVuY29kZVVyaVNlZ21lbnQodGhpcy4kJGhhc2gpIDogJyc7XHJcblxyXG4gICAgdGhpcy4kJHVybCA9IGVuY29kZVBhdGgodGhpcy4kJHBhdGgpICsgKHNlYXJjaCA/ICc/JyArIHNlYXJjaCA6ICcnKSArIGhhc2g7XHJcbiAgICB0aGlzLiQkYWJzVXJsID0gYXBwQmFzZU5vRmlsZSArIHRoaXMuJCR1cmwuc3Vic3RyKDEpOyAvLyBmaXJzdCBjaGFyIGlzIGFsd2F5cyAnLydcclxuICB9O1xyXG5cclxuICB0aGlzLiQkcmV3cml0ZSA9IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgdmFyIGFwcFVybCwgcHJldkFwcFVybDtcclxuXHJcbiAgICBpZiAoIChhcHBVcmwgPSBiZWdpbnNXaXRoKGFwcEJhc2UsIHVybCkpICE9PSB1bmRlZmluZWQgKSB7XHJcbiAgICAgIHByZXZBcHBVcmwgPSBhcHBVcmw7XHJcbiAgICAgIGlmICggKGFwcFVybCA9IGJlZ2luc1dpdGgoYmFzZVByZWZpeCwgYXBwVXJsKSkgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICByZXR1cm4gYXBwQmFzZU5vRmlsZSArIChiZWdpbnNXaXRoKCcvJywgYXBwVXJsKSB8fCBhcHBVcmwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBhcHBCYXNlICsgcHJldkFwcFVybDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICggKGFwcFVybCA9IGJlZ2luc1dpdGgoYXBwQmFzZU5vRmlsZSwgdXJsKSkgIT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgcmV0dXJuIGFwcEJhc2VOb0ZpbGUgKyBhcHBVcmw7XHJcbiAgICB9IGVsc2UgaWYgKGFwcEJhc2VOb0ZpbGUgPT0gdXJsICsgJy8nKSB7XHJcbiAgICAgIHJldHVybiBhcHBCYXNlTm9GaWxlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2NhdGlvbkhhc2hiYW5nVXJsIHJlcHJlc2VudHMgdXJsXHJcbiAqIFRoaXMgb2JqZWN0IGlzIGV4cG9zZWQgYXMgJGxvY2F0aW9uIHNlcnZpY2Ugd2hlbiBkZXZlbG9wZXIgZG9lc24ndCBvcHQgaW50byBodG1sNSBtb2RlLlxyXG4gKiBJdCBhbHNvIHNlcnZlcyBhcyB0aGUgYmFzZSBjbGFzcyBmb3IgaHRtbDUgbW9kZSBmYWxsYmFjayBvbiBsZWdhY3kgYnJvd3NlcnMuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwQmFzZSBhcHBsaWNhdGlvbiBiYXNlIFVSTFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaFByZWZpeCBoYXNoYmFuZyBwcmVmaXhcclxuICovXHJcbmZ1bmN0aW9uIExvY2F0aW9uSGFzaGJhbmdVcmwoYXBwQmFzZSwgaGFzaFByZWZpeCkge1xyXG4gIHZhciBhcHBCYXNlTm9GaWxlID0gc3RyaXBGaWxlKGFwcEJhc2UpO1xyXG5cclxuICBtYXRjaFVybChhcHBCYXNlLCB0aGlzKTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIGdpdmVuIGhhc2hiYW5nIHVybCBpbnRvIHByb3BlcnRpZXNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIEhhc2hiYW5nIHVybFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgdGhpcy4kJHBhcnNlID0gZnVuY3Rpb24odXJsKSB7XHJcbiAgICB2YXIgd2l0aG91dEJhc2VVcmwgPSBiZWdpbnNXaXRoKGFwcEJhc2UsIHVybCkgfHwgYmVnaW5zV2l0aChhcHBCYXNlTm9GaWxlLCB1cmwpO1xyXG4gICAgdmFyIHdpdGhvdXRIYXNoVXJsID0gd2l0aG91dEJhc2VVcmwuY2hhckF0KDApID09ICcjJ1xyXG4gICAgICAgID8gYmVnaW5zV2l0aChoYXNoUHJlZml4LCB3aXRob3V0QmFzZVVybClcclxuICAgICAgICA6ICh0aGlzLiQkaHRtbDUpXHJcbiAgICAgICAgICA/IHdpdGhvdXRCYXNlVXJsXHJcbiAgICAgICAgICA6ICcnO1xyXG5cclxuICAgIGlmICghaXNTdHJpbmcod2l0aG91dEhhc2hVcmwpKSB7XHJcbiAgICAgIHRocm93ICRsb2NhdGlvbk1pbkVycignaWhzaHByZngnLCAnSW52YWxpZCB1cmwgXCJ7MH1cIiwgbWlzc2luZyBoYXNoIHByZWZpeCBcInsxfVwiLicsIHVybCwgaGFzaFByZWZpeCk7XHJcbiAgICB9XHJcbiAgICBtYXRjaEFwcFVybCh3aXRob3V0SGFzaFVybCwgdGhpcyk7XHJcbiAgICB0aGlzLiQkY29tcG9zZSgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBvc2UgaGFzaGJhbmcgdXJsIGFuZCB1cGRhdGUgYGFic1VybGAgcHJvcGVydHlcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHRoaXMuJCRjb21wb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VhcmNoID0gdG9LZXlWYWx1ZSh0aGlzLiQkc2VhcmNoKSxcclxuICAgICAgICBoYXNoID0gdGhpcy4kJGhhc2ggPyAnIycgKyBlbmNvZGVVcmlTZWdtZW50KHRoaXMuJCRoYXNoKSA6ICcnO1xyXG5cclxuICAgIHRoaXMuJCR1cmwgPSBlbmNvZGVQYXRoKHRoaXMuJCRwYXRoKSArIChzZWFyY2ggPyAnPycgKyBzZWFyY2ggOiAnJykgKyBoYXNoO1xyXG4gICAgdGhpcy4kJGFic1VybCA9IGFwcEJhc2UgKyAodGhpcy4kJHVybCA/IGhhc2hQcmVmaXggKyB0aGlzLiQkdXJsIDogJycpO1xyXG4gIH07XHJcblxyXG4gIHRoaXMuJCRyZXdyaXRlID0gZnVuY3Rpb24odXJsKSB7XHJcbiAgICBpZihzdHJpcEhhc2goYXBwQmFzZSkgPT0gc3RyaXBIYXNoKHVybCkpIHtcclxuICAgICAgcmV0dXJuIHVybDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogTG9jYXRpb25IYXNoYmFuZ1VybCByZXByZXNlbnRzIHVybFxyXG4gKiBUaGlzIG9iamVjdCBpcyBleHBvc2VkIGFzICRsb2NhdGlvbiBzZXJ2aWNlIHdoZW4gaHRtbDUgaGlzdG9yeSBhcGkgaXMgZW5hYmxlZCBidXQgdGhlIGJyb3dzZXJcclxuICogZG9lcyBub3Qgc3VwcG9ydCBpdC5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBCYXNlIGFwcGxpY2F0aW9uIGJhc2UgVVJMXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoUHJlZml4IGhhc2hiYW5nIHByZWZpeFxyXG4gKi9cclxuZnVuY3Rpb24gTG9jYXRpb25IYXNoYmFuZ0luSHRtbDVVcmwoYXBwQmFzZSwgaGFzaFByZWZpeCkge1xyXG4gIHRoaXMuJCRodG1sNSA9IHRydWU7XHJcbiAgTG9jYXRpb25IYXNoYmFuZ1VybC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICB2YXIgYXBwQmFzZU5vRmlsZSA9IHN0cmlwRmlsZShhcHBCYXNlKTtcclxuXHJcbiAgdGhpcy4kJHJld3JpdGUgPSBmdW5jdGlvbih1cmwpIHtcclxuICAgIHZhciBhcHBVcmw7XHJcblxyXG4gICAgaWYgKCBhcHBCYXNlID09IHN0cmlwSGFzaCh1cmwpICkge1xyXG4gICAgICByZXR1cm4gdXJsO1xyXG4gICAgfSBlbHNlIGlmICggKGFwcFVybCA9IGJlZ2luc1dpdGgoYXBwQmFzZU5vRmlsZSwgdXJsKSkgKSB7XHJcbiAgICAgIHJldHVybiBhcHBCYXNlICsgaGFzaFByZWZpeCArIGFwcFVybDtcclxuICAgIH0gZWxzZSBpZiAoIGFwcEJhc2VOb0ZpbGUgPT09IHVybCArICcvJykge1xyXG4gICAgICByZXR1cm4gYXBwQmFzZU5vRmlsZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG5Mb2NhdGlvbkhhc2hiYW5nSW5IdG1sNVVybC5wcm90b3R5cGUgPVxyXG4gIExvY2F0aW9uSGFzaGJhbmdVcmwucHJvdG90eXBlID1cclxuICBMb2NhdGlvbkh0bWw1VXJsLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQXJlIHdlIGluIGh0bWw1IG1vZGU/XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICAkJGh0bWw1OiBmYWxzZSxcclxuXHJcbiAgLyoqXHJcbiAgICogSGFzIGFueSBjaGFuZ2UgYmVlbiByZXBsYWNpbmcgP1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgJCRyZXBsYWNlOiBmYWxzZSxcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAqIEBuYW1lIG5nLiRsb2NhdGlvbiNhYnNVcmxcclxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBUaGlzIG1ldGhvZCBpcyBnZXR0ZXIgb25seS5cclxuICAgKlxyXG4gICAqIFJldHVybiBmdWxsIHVybCByZXByZXNlbnRhdGlvbiB3aXRoIGFsbCBzZWdtZW50cyBlbmNvZGVkIGFjY29yZGluZyB0byBydWxlcyBzcGVjaWZpZWQgaW5cclxuICAgKiB7QGxpbmsgaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzk4Ni50eHQgUkZDIDM5ODZ9LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBmdWxsIHVybFxyXG4gICAqL1xyXG4gIGFic1VybDogbG9jYXRpb25HZXR0ZXIoJyQkYWJzVXJsJyksXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBtZXRob2RcclxuICAgKiBAbmFtZSBuZy4kbG9jYXRpb24jdXJsXHJcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogVGhpcyBtZXRob2QgaXMgZ2V0dGVyIC8gc2V0dGVyLlxyXG4gICAqXHJcbiAgICogUmV0dXJuIHVybCAoZS5nLiBgL3BhdGg/YT1iI2hhc2hgKSB3aGVuIGNhbGxlZCB3aXRob3V0IGFueSBwYXJhbWV0ZXIuXHJcbiAgICpcclxuICAgKiBDaGFuZ2UgcGF0aCwgc2VhcmNoIGFuZCBoYXNoLCB3aGVuIGNhbGxlZCB3aXRoIHBhcmFtZXRlciBhbmQgcmV0dXJuIGAkbG9jYXRpb25gLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSB1cmwgTmV3IHVybCB3aXRob3V0IGJhc2UgcHJlZml4IChlLmcuIGAvcGF0aD9hPWIjaGFzaGApXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSByZXBsYWNlIFRoZSBwYXRoIHRoYXQgd2lsbCBiZSBjaGFuZ2VkXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSB1cmxcclxuICAgKi9cclxuICB1cmw6IGZ1bmN0aW9uKHVybCwgcmVwbGFjZSkge1xyXG4gICAgaWYgKGlzVW5kZWZpbmVkKHVybCkpXHJcbiAgICAgIHJldHVybiB0aGlzLiQkdXJsO1xyXG5cclxuICAgIHZhciBtYXRjaCA9IFBBVEhfTUFUQ0guZXhlYyh1cmwpO1xyXG4gICAgaWYgKG1hdGNoWzFdKSB0aGlzLnBhdGgoZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzFdKSk7XHJcbiAgICBpZiAobWF0Y2hbMl0gfHwgbWF0Y2hbMV0pIHRoaXMuc2VhcmNoKG1hdGNoWzNdIHx8ICcnKTtcclxuICAgIHRoaXMuaGFzaChtYXRjaFs1XSB8fCAnJywgcmVwbGFjZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAqIEBuYW1lIG5nLiRsb2NhdGlvbiNwcm90b2NvbFxyXG4gICAqIEBtZXRob2RPZiBuZy4kbG9jYXRpb25cclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFRoaXMgbWV0aG9kIGlzIGdldHRlciBvbmx5LlxyXG4gICAqXHJcbiAgICogUmV0dXJuIHByb3RvY29sIG9mIGN1cnJlbnQgdXJsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBwcm90b2NvbCBvZiBjdXJyZW50IHVybFxyXG4gICAqL1xyXG4gIHByb3RvY29sOiBsb2NhdGlvbkdldHRlcignJCRwcm90b2NvbCcpLFxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI2hvc3RcclxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBUaGlzIG1ldGhvZCBpcyBnZXR0ZXIgb25seS5cclxuICAgKlxyXG4gICAqIFJldHVybiBob3N0IG9mIGN1cnJlbnQgdXJsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBob3N0IG9mIGN1cnJlbnQgdXJsLlxyXG4gICAqL1xyXG4gIGhvc3Q6IGxvY2F0aW9uR2V0dGVyKCckJGhvc3QnKSxcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAqIEBuYW1lIG5nLiRsb2NhdGlvbiNwb3J0XHJcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogVGhpcyBtZXRob2QgaXMgZ2V0dGVyIG9ubHkuXHJcbiAgICpcclxuICAgKiBSZXR1cm4gcG9ydCBvZiBjdXJyZW50IHVybC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gcG9ydFxyXG4gICAqL1xyXG4gIHBvcnQ6IGxvY2F0aW9uR2V0dGVyKCckJHBvcnQnKSxcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAqIEBuYW1lIG5nLiRsb2NhdGlvbiNwYXRoXHJcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogVGhpcyBtZXRob2QgaXMgZ2V0dGVyIC8gc2V0dGVyLlxyXG4gICAqXHJcbiAgICogUmV0dXJuIHBhdGggb2YgY3VycmVudCB1cmwgd2hlbiBjYWxsZWQgd2l0aG91dCBhbnkgcGFyYW1ldGVyLlxyXG4gICAqXHJcbiAgICogQ2hhbmdlIHBhdGggd2hlbiBjYWxsZWQgd2l0aCBwYXJhbWV0ZXIgYW5kIHJldHVybiBgJGxvY2F0aW9uYC5cclxuICAgKlxyXG4gICAqIE5vdGU6IFBhdGggc2hvdWxkIGFsd2F5cyBiZWdpbiB3aXRoIGZvcndhcmQgc2xhc2ggKC8pLCB0aGlzIG1ldGhvZCB3aWxsIGFkZCB0aGUgZm9yd2FyZCBzbGFzaFxyXG4gICAqIGlmIGl0IGlzIG1pc3NpbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHBhdGggTmV3IHBhdGhcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHBhdGhcclxuICAgKi9cclxuICBwYXRoOiBsb2NhdGlvbkdldHRlclNldHRlcignJCRwYXRoJywgZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xyXG4gIH0pLFxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI3NlYXJjaFxyXG4gICAqIEBtZXRob2RPZiBuZy4kbG9jYXRpb25cclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFRoaXMgbWV0aG9kIGlzIGdldHRlciAvIHNldHRlci5cclxuICAgKlxyXG4gICAqIFJldHVybiBzZWFyY2ggcGFydCAoYXMgb2JqZWN0KSBvZiBjdXJyZW50IHVybCB3aGVuIGNhbGxlZCB3aXRob3V0IGFueSBwYXJhbWV0ZXIuXHJcbiAgICpcclxuICAgKiBDaGFuZ2Ugc2VhcmNoIHBhcnQgd2hlbiBjYWxsZWQgd2l0aCBwYXJhbWV0ZXIgYW5kIHJldHVybiBgJGxvY2F0aW9uYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdC48c3RyaW5nPnxPYmplY3QuPEFycmF5LjxzdHJpbmc+Pn0gc2VhcmNoIE5ldyBzZWFyY2ggcGFyYW1zIC0gc3RyaW5nIG9yIGhhc2ggb2JqZWN0LiBIYXNoIG9iamVjdFxyXG4gICAqICAgIG1heSBjb250YWluIGFuIGFycmF5IG9mIHZhbHVlcywgd2hpY2ggd2lsbCBiZSBkZWNvZGVkIGFzIGR1cGxpY2F0ZXMgaW4gdGhlIHVybC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHBhcmFtVmFsdWUgSWYgYHNlYXJjaGAgaXMgYSBzdHJpbmcsIHRoZW4gYHBhcmFtVmFsdWVgIHdpbGwgb3ZlcnJpZGUgb25seSBhXHJcbiAgICogICAgc2luZ2xlIHNlYXJjaCBwYXJhbWV0ZXIuIElmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIHRoZSBwYXJhbWV0ZXIgd2lsbCBiZSBkZWxldGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBzZWFyY2hcclxuICAgKi9cclxuICBzZWFyY2g6IGZ1bmN0aW9uKHNlYXJjaCwgcGFyYW1WYWx1ZSkge1xyXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIGNhc2UgMDpcclxuICAgICAgICByZXR1cm4gdGhpcy4kJHNlYXJjaDtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGlmIChpc1N0cmluZyhzZWFyY2gpKSB7XHJcbiAgICAgICAgICB0aGlzLiQkc2VhcmNoID0gcGFyc2VLZXlWYWx1ZShzZWFyY2gpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qoc2VhcmNoKSkge1xyXG4gICAgICAgICAgdGhpcy4kJHNlYXJjaCA9IHNlYXJjaDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgJGxvY2F0aW9uTWluRXJyKCdpc3JjaGFyZycsICdUaGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGAkbG9jYXRpb24jc2VhcmNoKClgIGNhbGwgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBvYmplY3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGlmIChwYXJhbVZhbHVlID09IHVuZGVmaW5lZCB8fCBwYXJhbVZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLiQkc2VhcmNoW3NlYXJjaF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuJCRzZWFyY2hbc2VhcmNoXSA9IHBhcmFtVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuJCRjb21wb3NlKCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI2hhc2hcclxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBUaGlzIG1ldGhvZCBpcyBnZXR0ZXIgLyBzZXR0ZXIuXHJcbiAgICpcclxuICAgKiBSZXR1cm4gaGFzaCBmcmFnbWVudCB3aGVuIGNhbGxlZCB3aXRob3V0IGFueSBwYXJhbWV0ZXIuXHJcbiAgICpcclxuICAgKiBDaGFuZ2UgaGFzaCBmcmFnbWVudCB3aGVuIGNhbGxlZCB3aXRoIHBhcmFtZXRlciBhbmQgcmV0dXJuIGAkbG9jYXRpb25gLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBoYXNoIE5ldyBoYXNoIGZyYWdtZW50XHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBoYXNoXHJcbiAgICovXHJcbiAgaGFzaDogbG9jYXRpb25HZXR0ZXJTZXR0ZXIoJyQkaGFzaCcsIGlkZW50aXR5KSxcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAqIEBuYW1lIG5nLiRsb2NhdGlvbiNyZXBsYWNlXHJcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogSWYgY2FsbGVkLCBhbGwgY2hhbmdlcyB0byAkbG9jYXRpb24gZHVyaW5nIGN1cnJlbnQgYCRkaWdlc3RgIHdpbGwgYmUgcmVwbGFjaW5nIGN1cnJlbnQgaGlzdG9yeVxyXG4gICAqIHJlY29yZCwgaW5zdGVhZCBvZiBhZGRpbmcgbmV3IG9uZS5cclxuICAgKi9cclxuICByZXBsYWNlOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuJCRyZXBsYWNlID0gdHJ1ZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGxvY2F0aW9uR2V0dGVyKHByb3BlcnR5KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBsb2NhdGlvbkdldHRlclNldHRlcihwcm9wZXJ0eSwgcHJlcHJvY2Vzcykge1xyXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcclxuICAgICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xyXG5cclxuICAgIHRoaXNbcHJvcGVydHldID0gcHJlcHJvY2Vzcyh2YWx1ZSk7XHJcbiAgICB0aGlzLiQkY29tcG9zZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy4kbG9jYXRpb25cclxuICpcclxuICogQHJlcXVpcmVzICRicm93c2VyXHJcbiAqIEByZXF1aXJlcyAkc25pZmZlclxyXG4gKiBAcmVxdWlyZXMgJHJvb3RFbGVtZW50XHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgJGxvY2F0aW9uIHNlcnZpY2UgcGFyc2VzIHRoZSBVUkwgaW4gdGhlIGJyb3dzZXIgYWRkcmVzcyBiYXIgKGJhc2VkIG9uIHRoZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vd2luZG93LmxvY2F0aW9uIHdpbmRvdy5sb2NhdGlvbn0pIGFuZCBtYWtlcyB0aGUgVVJMXHJcbiAqIGF2YWlsYWJsZSB0byB5b3VyIGFwcGxpY2F0aW9uLiBDaGFuZ2VzIHRvIHRoZSBVUkwgaW4gdGhlIGFkZHJlc3MgYmFyIGFyZSByZWZsZWN0ZWQgaW50b1xyXG4gKiAkbG9jYXRpb24gc2VydmljZSBhbmQgY2hhbmdlcyB0byAkbG9jYXRpb24gYXJlIHJlZmxlY3RlZCBpbnRvIHRoZSBicm93c2VyIGFkZHJlc3MgYmFyLlxyXG4gKlxyXG4gKiAqKlRoZSAkbG9jYXRpb24gc2VydmljZToqKlxyXG4gKlxyXG4gKiAtIEV4cG9zZXMgdGhlIGN1cnJlbnQgVVJMIGluIHRoZSBicm93c2VyIGFkZHJlc3MgYmFyLCBzbyB5b3UgY2FuXHJcbiAqICAgLSBXYXRjaCBhbmQgb2JzZXJ2ZSB0aGUgVVJMLlxyXG4gKiAgIC0gQ2hhbmdlIHRoZSBVUkwuXHJcbiAqIC0gU3luY2hyb25pemVzIHRoZSBVUkwgd2l0aCB0aGUgYnJvd3NlciB3aGVuIHRoZSB1c2VyXHJcbiAqICAgLSBDaGFuZ2VzIHRoZSBhZGRyZXNzIGJhci5cclxuICogICAtIENsaWNrcyB0aGUgYmFjayBvciBmb3J3YXJkIGJ1dHRvbiAob3IgY2xpY2tzIGEgSGlzdG9yeSBsaW5rKS5cclxuICogICAtIENsaWNrcyBvbiBhIGxpbmsuXHJcbiAqIC0gUmVwcmVzZW50cyB0aGUgVVJMIG9iamVjdCBhcyBhIHNldCBvZiBtZXRob2RzIChwcm90b2NvbCwgaG9zdCwgcG9ydCwgcGF0aCwgc2VhcmNoLCBoYXNoKS5cclxuICpcclxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIHtAbGluayBndWlkZS9kZXZfZ3VpZGUuc2VydmljZXMuJGxvY2F0aW9uIERldmVsb3BlciBHdWlkZTogQW5ndWxhclxyXG4gKiBTZXJ2aWNlczogVXNpbmcgJGxvY2F0aW9ufVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRsb2NhdGlvblByb3ZpZGVyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBVc2UgdGhlIGAkbG9jYXRpb25Qcm92aWRlcmAgdG8gY29uZmlndXJlIGhvdyB0aGUgYXBwbGljYXRpb24gZGVlcCBsaW5raW5nIHBhdGhzIGFyZSBzdG9yZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiAkTG9jYXRpb25Qcm92aWRlcigpe1xyXG4gIHZhciBoYXNoUHJlZml4ID0gJycsXHJcbiAgICAgIGh0bWw1TW9kZSA9IGZhbHNlO1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgcHJvcGVydHlcclxuICAgKiBAbmFtZSBuZy4kbG9jYXRpb25Qcm92aWRlciNoYXNoUHJlZml4XHJcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblByb3ZpZGVyXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBwcmVmaXggUHJlZml4IGZvciBoYXNoIHBhcnQgKGNvbnRhaW5pbmcgcGF0aCBhbmQgc2VhcmNoKVxyXG4gICAqIEByZXR1cm5zIHsqfSBjdXJyZW50IHZhbHVlIGlmIHVzZWQgYXMgZ2V0dGVyIG9yIGl0c2VsZiAoY2hhaW5pbmcpIGlmIHVzZWQgYXMgc2V0dGVyXHJcbiAgICovXHJcbiAgdGhpcy5oYXNoUHJlZml4ID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICBpZiAoaXNEZWZpbmVkKHByZWZpeCkpIHtcclxuICAgICAgaGFzaFByZWZpeCA9IHByZWZpeDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gaGFzaFByZWZpeDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgcHJvcGVydHlcclxuICAgKiBAbmFtZSBuZy4kbG9jYXRpb25Qcm92aWRlciNodG1sNU1vZGVcclxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uUHJvdmlkZXJcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG1vZGUgVXNlIEhUTUw1IHN0cmF0ZWd5IGlmIGF2YWlsYWJsZS5cclxuICAgKiBAcmV0dXJucyB7Kn0gY3VycmVudCB2YWx1ZSBpZiB1c2VkIGFzIGdldHRlciBvciBpdHNlbGYgKGNoYWluaW5nKSBpZiB1c2VkIGFzIHNldHRlclxyXG4gICAqL1xyXG4gIHRoaXMuaHRtbDVNb2RlID0gZnVuY3Rpb24obW9kZSkge1xyXG4gICAgaWYgKGlzRGVmaW5lZChtb2RlKSkge1xyXG4gICAgICBodG1sNU1vZGUgPSBtb2RlO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBodG1sNU1vZGU7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckcm9vdFNjb3BlJywgJyRicm93c2VyJywgJyRzbmlmZmVyJywgJyRyb290RWxlbWVudCcsXHJcbiAgICAgIGZ1bmN0aW9uKCAkcm9vdFNjb3BlLCAgICRicm93c2VyLCAgICRzbmlmZmVyLCAgICRyb290RWxlbWVudCkge1xyXG4gICAgdmFyICRsb2NhdGlvbixcclxuICAgICAgICBMb2NhdGlvbk1vZGUsXHJcbiAgICAgICAgYmFzZUhyZWYgPSAkYnJvd3Nlci5iYXNlSHJlZigpLCAvLyBpZiBiYXNlW2hyZWZdIGlzIHVuZGVmaW5lZCwgaXQgZGVmYXVsdHMgdG8gJydcclxuICAgICAgICBpbml0aWFsVXJsID0gJGJyb3dzZXIudXJsKCksXHJcbiAgICAgICAgYXBwQmFzZTtcclxuXHJcbiAgICBpZiAoaHRtbDVNb2RlKSB7XHJcbiAgICAgIGFwcEJhc2UgPSBzZXJ2ZXJCYXNlKGluaXRpYWxVcmwpICsgKGJhc2VIcmVmIHx8ICcvJyk7XHJcbiAgICAgIExvY2F0aW9uTW9kZSA9ICRzbmlmZmVyLmhpc3RvcnkgPyBMb2NhdGlvbkh0bWw1VXJsIDogTG9jYXRpb25IYXNoYmFuZ0luSHRtbDVVcmw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhcHBCYXNlID0gc3RyaXBIYXNoKGluaXRpYWxVcmwpO1xyXG4gICAgICBMb2NhdGlvbk1vZGUgPSBMb2NhdGlvbkhhc2hiYW5nVXJsO1xyXG4gICAgfVxyXG4gICAgJGxvY2F0aW9uID0gbmV3IExvY2F0aW9uTW9kZShhcHBCYXNlLCAnIycgKyBoYXNoUHJlZml4KTtcclxuICAgICRsb2NhdGlvbi4kJHBhcnNlKCRsb2NhdGlvbi4kJHJld3JpdGUoaW5pdGlhbFVybCkpO1xyXG5cclxuICAgICRyb290RWxlbWVudC5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAvLyBUT0RPKHZvanRhKTogcmV3cml0ZSBsaW5rIHdoZW4gb3BlbmluZyBpbiBuZXcgdGFiL3dpbmRvdyAoaW4gbGVnYWN5IGJyb3dzZXIpXHJcbiAgICAgIC8vIGN1cnJlbnRseSB3ZSBvcGVuIG5pY2UgdXJsIGxpbmsgYW5kIHJlZGlyZWN0IHRoZW5cclxuXHJcbiAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQud2hpY2ggPT0gMikgcmV0dXJuO1xyXG5cclxuICAgICAgdmFyIGVsbSA9IGpxTGl0ZShldmVudC50YXJnZXQpO1xyXG5cclxuICAgICAgLy8gdHJhdmVyc2UgdGhlIERPTSB1cCB0byBmaW5kIGZpcnN0IEEgdGFnXHJcbiAgICAgIHdoaWxlIChsb3dlcmNhc2UoZWxtWzBdLm5vZGVOYW1lKSAhPT0gJ2EnKSB7XHJcbiAgICAgICAgLy8gaWdub3JlIHJld3JpdGluZyBpZiBubyBBIHRhZyAocmVhY2hlZCByb290IGVsZW1lbnQsIG9yIG5vIHBhcmVudCAtIHJlbW92ZWQgZnJvbSBkb2N1bWVudClcclxuICAgICAgICBpZiAoZWxtWzBdID09PSAkcm9vdEVsZW1lbnRbMF0gfHwgIShlbG0gPSBlbG0ucGFyZW50KCkpWzBdKSByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBhYnNIcmVmID0gZWxtLnByb3AoJ2hyZWYnKTtcclxuICAgICAgdmFyIHJld3JpdHRlblVybCA9ICRsb2NhdGlvbi4kJHJld3JpdGUoYWJzSHJlZik7XHJcblxyXG4gICAgICBpZiAoYWJzSHJlZiAmJiAhZWxtLmF0dHIoJ3RhcmdldCcpICYmIHJld3JpdHRlblVybCAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGlmIChyZXdyaXR0ZW5VcmwgIT0gJGJyb3dzZXIudXJsKCkpIHtcclxuICAgICAgICAgIC8vIHVwZGF0ZSBsb2NhdGlvbiBtYW51YWxseVxyXG4gICAgICAgICAgJGxvY2F0aW9uLiQkcGFyc2UocmV3cml0dGVuVXJsKTtcclxuICAgICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgICAvLyBoYWNrIHRvIHdvcmsgYXJvdW5kIEZGNiBidWcgNjg0MjA4IHdoZW4gc2NlbmFyaW8gcnVubmVyIGNsaWNrcyBvbiBsaW5rc1xyXG4gICAgICAgICAgd2luZG93LmFuZ3VsYXJbJ2ZmLTY4NDIwOC1wcmV2ZW50RGVmYXVsdCddID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvLyByZXdyaXRlIGhhc2hiYW5nIHVybCA8PiBodG1sNSB1cmxcclxuICAgIGlmICgkbG9jYXRpb24uYWJzVXJsKCkgIT0gaW5pdGlhbFVybCkge1xyXG4gICAgICAkYnJvd3Nlci51cmwoJGxvY2F0aW9uLmFic1VybCgpLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGUgJGxvY2F0aW9uIHdoZW4gJGJyb3dzZXIgdXJsIGNoYW5nZXNcclxuICAgICRicm93c2VyLm9uVXJsQ2hhbmdlKGZ1bmN0aW9uKG5ld1VybCkge1xyXG4gICAgICBpZiAoJGxvY2F0aW9uLmFic1VybCgpICE9IG5ld1VybCkge1xyXG4gICAgICAgIGlmICgkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRsb2NhdGlvbkNoYW5nZVN0YXJ0JywgbmV3VXJsLCAkbG9jYXRpb24uYWJzVXJsKCkpLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICRicm93c2VyLnVybCgkbG9jYXRpb24uYWJzVXJsKCkpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkcm9vdFNjb3BlLiRldmFsQXN5bmMoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgb2xkVXJsID0gJGxvY2F0aW9uLmFic1VybCgpO1xyXG5cclxuICAgICAgICAgICRsb2NhdGlvbi4kJHBhcnNlKG5ld1VybCk7XHJcbiAgICAgICAgICBhZnRlckxvY2F0aW9uQ2hhbmdlKG9sZFVybCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpICRyb290U2NvcGUuJGRpZ2VzdCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyB1cGRhdGUgYnJvd3NlclxyXG4gICAgdmFyIGNoYW5nZUNvdW50ZXIgPSAwO1xyXG4gICAgJHJvb3RTY29wZS4kd2F0Y2goZnVuY3Rpb24gJGxvY2F0aW9uV2F0Y2goKSB7XHJcbiAgICAgIHZhciBvbGRVcmwgPSAkYnJvd3Nlci51cmwoKTtcclxuICAgICAgdmFyIGN1cnJlbnRSZXBsYWNlID0gJGxvY2F0aW9uLiQkcmVwbGFjZTtcclxuXHJcbiAgICAgIGlmICghY2hhbmdlQ291bnRlciB8fCBvbGRVcmwgIT0gJGxvY2F0aW9uLmFic1VybCgpKSB7XHJcbiAgICAgICAgY2hhbmdlQ291bnRlcisrO1xyXG4gICAgICAgICRyb290U2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRsb2NhdGlvbkNoYW5nZVN0YXJ0JywgJGxvY2F0aW9uLmFic1VybCgpLCBvbGRVcmwpLlxyXG4gICAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgJGxvY2F0aW9uLiQkcGFyc2Uob2xkVXJsKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICRicm93c2VyLnVybCgkbG9jYXRpb24uYWJzVXJsKCksIGN1cnJlbnRSZXBsYWNlKTtcclxuICAgICAgICAgICAgYWZ0ZXJMb2NhdGlvbkNoYW5nZShvbGRVcmwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgICRsb2NhdGlvbi4kJHJlcGxhY2UgPSBmYWxzZTtcclxuXHJcbiAgICAgIHJldHVybiBjaGFuZ2VDb3VudGVyO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuICRsb2NhdGlvbjtcclxuXHJcbiAgICBmdW5jdGlvbiBhZnRlckxvY2F0aW9uQ2hhbmdlKG9sZFVybCkge1xyXG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MnLCAkbG9jYXRpb24uYWJzVXJsKCksIG9sZFVybCk7XHJcbiAgICB9XHJcbn1dO1xyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy4kbG9nXHJcbiAqIEByZXF1aXJlcyAkd2luZG93XHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTaW1wbGUgc2VydmljZSBmb3IgbG9nZ2luZy4gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3cml0ZXMgdGhlIG1lc3NhZ2VcclxuICogaW50byB0aGUgYnJvd3NlcidzIGNvbnNvbGUgKGlmIHByZXNlbnQpLlxyXG4gKlxyXG4gKiBUaGUgbWFpbiBwdXJwb3NlIG9mIHRoaXMgc2VydmljZSBpcyB0byBzaW1wbGlmeSBkZWJ1Z2dpbmcgYW5kIHRyb3VibGVzaG9vdGluZy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgPGV4YW1wbGU+XHJcbiAgICAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxyXG4gICAgICAgZnVuY3Rpb24gTG9nQ3RybCgkc2NvcGUsICRsb2cpIHtcclxuICAgICAgICAgJHNjb3BlLiRsb2cgPSAkbG9nO1xyXG4gICAgICAgICAkc2NvcGUubWVzc2FnZSA9ICdIZWxsbyBXb3JsZCEnO1xyXG4gICAgICAgfVxyXG4gICAgIDwvZmlsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiTG9nQ3RybFwiPlxyXG4gICAgICAgICA8cD5SZWxvYWQgdGhpcyBwYWdlIHdpdGggb3BlbiBjb25zb2xlLCBlbnRlciB0ZXh0IGFuZCBoaXQgdGhlIGxvZyBidXR0b24uLi48L3A+XHJcbiAgICAgICAgIE1lc3NhZ2U6XHJcbiAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwibWVzc2FnZVwiLz5cclxuICAgICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cIiRsb2cubG9nKG1lc3NhZ2UpXCI+bG9nPC9idXR0b24+XHJcbiAgICAgICAgIDxidXR0b24gbmctY2xpY2s9XCIkbG9nLndhcm4obWVzc2FnZSlcIj53YXJuPC9idXR0b24+XHJcbiAgICAgICAgIDxidXR0b24gbmctY2xpY2s9XCIkbG9nLmluZm8obWVzc2FnZSlcIj5pbmZvPC9idXR0b24+XHJcbiAgICAgICAgIDxidXR0b24gbmctY2xpY2s9XCIkbG9nLmVycm9yKG1lc3NhZ2UpXCI+ZXJyb3I8L2J1dHRvbj5cclxuICAgICAgIDwvZGl2PlxyXG4gICAgIDwvZmlsZT5cclxuICAgPC9leGFtcGxlPlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRsb2dQcm92aWRlclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVXNlIHRoZSBgJGxvZ1Byb3ZpZGVyYCB0byBjb25maWd1cmUgaG93IHRoZSBhcHBsaWNhdGlvbiBsb2dzIG1lc3NhZ2VzXHJcbiAqL1xyXG5mdW5jdGlvbiAkTG9nUHJvdmlkZXIoKXtcclxuICB2YXIgZGVidWcgPSB0cnVlLFxyXG4gICAgICBzZWxmID0gdGhpcztcclxuICBcclxuICAvKipcclxuICAgKiBAbmdkb2MgcHJvcGVydHlcclxuICAgKiBAbmFtZSBuZy4kbG9nUHJvdmlkZXIjZGVidWdFbmFibGVkXHJcbiAgICogQG1ldGhvZE9mIG5nLiRsb2dQcm92aWRlclxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gZmxhZyBlbmFibGUgb3IgZGlzYWJsZSBkZWJ1ZyBsZXZlbCBtZXNzYWdlc1xyXG4gICAqIEByZXR1cm5zIHsqfSBjdXJyZW50IHZhbHVlIGlmIHVzZWQgYXMgZ2V0dGVyIG9yIGl0c2VsZiAoY2hhaW5pbmcpIGlmIHVzZWQgYXMgc2V0dGVyXHJcbiAgICovXHJcbiAgdGhpcy5kZWJ1Z0VuYWJsZWQgPSBmdW5jdGlvbihmbGFnKSB7XHJcblx0ICBpZiAoaXNEZWZpbmVkKGZsYWcpKSB7XHJcblx0XHQgIGRlYnVnID0gZmxhZztcclxuXHRcdCAgcmV0dXJuIHRoaXM7XHJcblx0ICB9IGVsc2Uge1xyXG5cdFx0ICByZXR1cm4gZGVidWc7XHJcblx0ICB9XHJcbiAgfTtcclxuICBcclxuICB0aGlzLiRnZXQgPSBbJyR3aW5kb3cnLCBmdW5jdGlvbigkd2luZG93KXtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAqIEBuYW1lIG5nLiRsb2cjbG9nXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kbG9nXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBXcml0ZSBhIGxvZyBtZXNzYWdlXHJcbiAgICAgICAqL1xyXG4gICAgICBsb2c6IGNvbnNvbGVMb2coJ2xvZycpLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAgICogQG5hbWUgbmcuJGxvZyNpbmZvXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kbG9nXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBXcml0ZSBhbiBpbmZvcm1hdGlvbiBtZXNzYWdlXHJcbiAgICAgICAqL1xyXG4gICAgICBpbmZvOiBjb25zb2xlTG9nKCdpbmZvJyksXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgKiBAbmFtZSBuZy4kbG9nI3dhcm5cclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRsb2dcclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFdyaXRlIGEgd2FybmluZyBtZXNzYWdlXHJcbiAgICAgICAqL1xyXG4gICAgICB3YXJuOiBjb25zb2xlTG9nKCd3YXJuJyksXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICAgKiBAbmFtZSBuZy4kbG9nI2Vycm9yXHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kbG9nXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBXcml0ZSBhbiBlcnJvciBtZXNzYWdlXHJcbiAgICAgICAqL1xyXG4gICAgICBlcnJvcjogY29uc29sZUxvZygnZXJyb3InKSxcclxuICAgICAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgICAqIEBuYW1lIG5nLiRsb2cjZGVidWdcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRsb2dcclxuICAgICAgICogXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBXcml0ZSBhIGRlYnVnIG1lc3NhZ2VcclxuICAgICAgICovXHJcbiAgICAgIGRlYnVnOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgXHR2YXIgZm4gPSBjb25zb2xlTG9nKCdkZWJ1ZycpO1xyXG4gICAgXHRcclxuICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgXHRcdGlmIChkZWJ1Zykge1xyXG4gICAgXHRcdFx0Zm4uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdH1cclxuICAgICAgfSgpKVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBmb3JtYXRFcnJvcihhcmcpIHtcclxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgaWYgKGFyZy5zdGFjaykge1xyXG4gICAgICAgICAgYXJnID0gKGFyZy5tZXNzYWdlICYmIGFyZy5zdGFjay5pbmRleE9mKGFyZy5tZXNzYWdlKSA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgPyAnRXJyb3I6ICcgKyBhcmcubWVzc2FnZSArICdcXG4nICsgYXJnLnN0YWNrXHJcbiAgICAgICAgICAgICAgOiBhcmcuc3RhY2s7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhcmcuc291cmNlVVJMKSB7XHJcbiAgICAgICAgICBhcmcgPSBhcmcubWVzc2FnZSArICdcXG4nICsgYXJnLnNvdXJjZVVSTCArICc6JyArIGFyZy5saW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJnO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnNvbGVMb2codHlwZSkge1xyXG4gICAgICB2YXIgY29uc29sZSA9ICR3aW5kb3cuY29uc29sZSB8fCB7fSxcclxuICAgICAgICAgIGxvZ0ZuID0gY29uc29sZVt0eXBlXSB8fCBjb25zb2xlLmxvZyB8fCBub29wO1xyXG5cclxuICAgICAgaWYgKGxvZ0ZuLmFwcGx5KSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgIGZvckVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihhcmcpIHtcclxuICAgICAgICAgICAgYXJncy5wdXNoKGZvcm1hdEVycm9yKGFyZykpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZXR1cm4gbG9nRm4uYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gd2UgYXJlIElFIHdoaWNoIGVpdGhlciBkb2Vzbid0IGhhdmUgd2luZG93LmNvbnNvbGUgPT4gdGhpcyBpcyBub29wIGFuZCB3ZSBkbyBub3RoaW5nLFxyXG4gICAgICAvLyBvciB3ZSBhcmUgSUUgd2hlcmUgY29uc29sZS5sb2cgZG9lc24ndCBoYXZlIGFwcGx5IHNvIHdlIGxvZyBhdCBsZWFzdCBmaXJzdCAyIGFyZ3NcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyZzEsIGFyZzIpIHtcclxuICAgICAgICBsb2dGbihhcmcxLCBhcmcyKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1dO1xyXG59XHJcblxyXG52YXIgJHBhcnNlTWluRXJyID0gbWluRXJyKCckcGFyc2UnKTtcclxuXHJcbi8vIFNhbmRib3hpbmcgQW5ndWxhciBFeHByZXNzaW9uc1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQW5ndWxhciBleHByZXNzaW9ucyBhcmUgZ2VuZXJhbGx5IGNvbnNpZGVyZWQgc2FmZSBiZWNhdXNlIHRoZXNlIGV4cHJlc3Npb25zIG9ubHkgaGF2ZSBkaXJlY3QgYWNjZXNzIHRvICRzY29wZSBhbmRcclxuLy8gbG9jYWxzLiBIb3dldmVyLCBvbmUgY2FuIG9idGFpbiB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBKUyBjb2RlIGJ5IG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byBuYXRpdmUgSlNcclxuLy8gZnVuY3Rpb25zIHN1Y2ggYXMgdGhlIEZ1bmN0aW9uIGNvbnN0cnVjdG9yLlxyXG4vL1xyXG4vLyBBcyBhbiBleGFtcGxlLCBjb25zaWRlciB0aGUgZm9sbG93aW5nIEFuZ3VsYXIgZXhwcmVzc2lvbjpcclxuLy9cclxuLy8gICB7fS50b1N0cmluZy5jb25zdHJ1Y3RvcihhbGVydChcImV2aWwgSlMgY29kZVwiKSlcclxuLy9cclxuLy8gV2Ugd2FudCB0byBwcmV2ZW50IHRoaXMgdHlwZSBvZiBhY2Nlc3MuIEZvciB0aGUgc2FrZSBvZiBwZXJmb3JtYW5jZSwgZHVyaW5nIHRoZSBsZXhpbmcgcGhhc2Ugd2UgZGlzYWxsb3cgYW55IFwiZG90dGVkXCJcclxuLy8gYWNjZXNzIHRvIGFueSBtZW1iZXIgbmFtZWQgXCJjb25zdHJ1Y3RvclwiLlxyXG4vL1xyXG4vLyBGb3IgcmVmbGVjdGl2ZSBjYWxscyAoYVtiXSkgd2UgY2hlY2sgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIGxvb2t1cCBpcyBub3QgdGhlIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIHdoaWxlIGV2YWx1YXRpbmdcclxuLy8gdGhlIGV4cHJlc3Npb24sIHdoaWNoIGlzIGEgc3Ryb25nZXIgYnV0IG1vcmUgZXhwZW5zaXZlIHRlc3QuIFNpbmNlIHJlZmxlY3RpdmUgY2FsbHMgYXJlIGV4cGVuc2l2ZSBhbnl3YXksIHRoaXMgaXMgbm90XHJcbi8vIHN1Y2ggYSBiaWcgZGVhbCBjb21wYXJlZCB0byBzdGF0aWMgZGVyZWZlcmVuY2luZy5cclxuLy9cclxuLy8gVGhpcyBzYW5kYm94aW5nIHRlY2huaXF1ZSBpcyBub3QgcGVyZmVjdCBhbmQgZG9lc24ndCBhaW0gdG8gYmUuIFRoZSBnb2FsIGlzIHRvIHByZXZlbnQgZXhwbG9pdHMgYWdhaW5zdCB0aGVcclxuLy8gZXhwcmVzc2lvbiBsYW5ndWFnZSwgYnV0IG5vdCB0byBwcmV2ZW50IGV4cGxvaXRzIHRoYXQgd2VyZSBlbmFibGVkIGJ5IGV4cG9zaW5nIHNlbnNpdGl2ZSBKYXZhU2NyaXB0IG9yIGJyb3dzZXIgYXBpc1xyXG4vLyBvbiBTY29wZS4gRXhwb3Npbmcgc3VjaCBvYmplY3RzIG9uIGEgU2NvcGUgaXMgbmV2ZXIgYSBnb29kIHByYWN0aWNlIGFuZCB0aGVyZWZvcmUgd2UgYXJlIG5vdCBldmVuIHRyeWluZyB0byBwcm90ZWN0XHJcbi8vIGFnYWluc3QgaW50ZXJhY3Rpb24gd2l0aCBhbiBvYmplY3QgZXhwbGljaXRseSBleHBvc2VkIGluIHRoaXMgd2F5LlxyXG4vL1xyXG4vLyBBIGRldmVsb3BlciBjb3VsZCBmb2lsIHRoZSBuYW1lIGNoZWNrIGJ5IGFsaWFzaW5nIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3RvciB1bmRlciBhIGRpZmZlcmVudCBuYW1lIG9uIHRoZSBzY29wZS5cclxuLy9cclxuLy8gSW4gZ2VuZXJhbCwgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGFjY2VzcyBhIFdpbmRvdyBvYmplY3QgZnJvbSBhbiBhbmd1bGFyIGV4cHJlc3Npb24gdW5sZXNzIGEgd2luZG93IG9yIHNvbWUgRE9NXHJcbi8vIG9iamVjdCB0aGF0IGhhcyBhIHJlZmVyZW5jZSB0byB3aW5kb3cgaXMgcHVibGlzaGVkIG9udG8gYSBTY29wZS5cclxuXHJcbmZ1bmN0aW9uIGVuc3VyZVNhZmVNZW1iZXJOYW1lKG5hbWUsIGZ1bGxFeHByZXNzaW9uKSB7XHJcbiAgaWYgKG5hbWUgPT09IFwiY29uc3RydWN0b3JcIikge1xyXG4gICAgdGhyb3cgJHBhcnNlTWluRXJyKCdpc2VjZmxkJyxcclxuICAgICAgICAnUmVmZXJlbmNpbmcgXCJjb25zdHJ1Y3RvclwiIGZpZWxkIGluIEFuZ3VsYXIgZXhwcmVzc2lvbnMgaXMgZGlzYWxsb3dlZCEgRXhwcmVzc2lvbjogezB9JywgZnVsbEV4cHJlc3Npb24pO1xyXG4gIH1cclxuICByZXR1cm4gbmFtZTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGVuc3VyZVNhZmVPYmplY3Qob2JqLCBmdWxsRXhwcmVzc2lvbikge1xyXG4gIC8vIG5pZnR5IGNoZWNrIGlmIG9iaiBpcyBGdW5jdGlvbiB0aGF0IGlzIGZhc3QgYW5kIHdvcmtzIGFjcm9zcyBpZnJhbWVzIGFuZCBvdGhlciBjb250ZXh0c1xyXG4gIGlmIChvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09PSBvYmopIHtcclxuICAgIHRocm93ICRwYXJzZU1pbkVycignaXNlY2ZuJyxcclxuICAgICAgICAnUmVmZXJlbmNpbmcgRnVuY3Rpb24gaW4gQW5ndWxhciBleHByZXNzaW9ucyBpcyBkaXNhbGxvd2VkISBFeHByZXNzaW9uOiB7MH0nLCBmdWxsRXhwcmVzc2lvbik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBvYmo7XHJcbiAgfVxyXG59XHJcblxyXG5cclxudmFyIE9QRVJBVE9SUyA9IHtcclxuICAgICdudWxsJzpmdW5jdGlvbigpe3JldHVybiBudWxsO30sXHJcbiAgICAndHJ1ZSc6ZnVuY3Rpb24oKXtyZXR1cm4gdHJ1ZTt9LFxyXG4gICAgJ2ZhbHNlJzpmdW5jdGlvbigpe3JldHVybiBmYWxzZTt9LFxyXG4gICAgdW5kZWZpbmVkOm5vb3AsXHJcbiAgICAnKyc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe1xyXG4gICAgICBhPWEoc2VsZiwgbG9jYWxzKTsgYj1iKHNlbGYsIGxvY2Fscyk7XHJcbiAgICAgIGlmIChpc0RlZmluZWQoYSkpIHtcclxuICAgICAgICBpZiAoaXNEZWZpbmVkKGIpKSB7XHJcbiAgICAgICAgICByZXR1cm4gYSArIGI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpc0RlZmluZWQoYik/Yjp1bmRlZmluZWQ7fSxcclxuICAgICctJzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7YT1hKHNlbGYsIGxvY2Fscyk7IGI9YihzZWxmLCBsb2NhbHMpOyByZXR1cm4gKGlzRGVmaW5lZChhKT9hOjApLShpc0RlZmluZWQoYik/YjowKTt9LFxyXG4gICAgJyonOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpKmIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJy8nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpL2Ioc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJyUnOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpJWIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJ14nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpXmIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJz0nOm5vb3AsXHJcbiAgICAnPT09JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsIGIpe3JldHVybiBhKHNlbGYsIGxvY2Fscyk9PT1iKHNlbGYsIGxvY2Fscyk7fSxcclxuICAgICchPT0nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSwgYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKSE9PWIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJz09JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKT09YihzZWxmLCBsb2NhbHMpO30sXHJcbiAgICAnIT0nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpIT1iKHNlbGYsIGxvY2Fscyk7fSxcclxuICAgICc8JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKTxiKHNlbGYsIGxvY2Fscyk7fSxcclxuICAgICc+JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKT5iKHNlbGYsIGxvY2Fscyk7fSxcclxuICAgICc8PSc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2Fscyk8PWIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJz49JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKT49YihzZWxmLCBsb2NhbHMpO30sXHJcbiAgICAnJiYnOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpJiZiKHNlbGYsIGxvY2Fscyk7fSxcclxuICAgICd8fCc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2Fscyl8fGIoc2VsZiwgbG9jYWxzKTt9LFxyXG4gICAgJyYnOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpJmIoc2VsZiwgbG9jYWxzKTt9LFxyXG4vLyAgICAnfCc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhfGI7fSxcclxuICAgICd8JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGIoc2VsZiwgbG9jYWxzKShzZWxmLCBsb2NhbHMsIGEoc2VsZiwgbG9jYWxzKSk7fSxcclxuICAgICchJzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEpe3JldHVybiAhYShzZWxmLCBsb2NhbHMpO31cclxufTtcclxudmFyIEVTQ0FQRSA9IHtcIm5cIjpcIlxcblwiLCBcImZcIjpcIlxcZlwiLCBcInJcIjpcIlxcclwiLCBcInRcIjpcIlxcdFwiLCBcInZcIjpcIlxcdlwiLCBcIidcIjpcIidcIiwgJ1wiJzonXCInfTtcclxuXHJcbmZ1bmN0aW9uIGxleCh0ZXh0LCBjc3Ape1xyXG4gIHZhciB0b2tlbnMgPSBbXSxcclxuICAgICAgdG9rZW4sXHJcbiAgICAgIGluZGV4ID0gMCxcclxuICAgICAganNvbiA9IFtdLFxyXG4gICAgICBjaCxcclxuICAgICAgbGFzdENoID0gJzonOyAvLyBjYW4gc3RhcnQgcmVnZXhwXHJcblxyXG4gIHdoaWxlIChpbmRleCA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICBjaCA9IHRleHQuY2hhckF0KGluZGV4KTtcclxuICAgIGlmIChpcygnXCJcXCcnKSkge1xyXG4gICAgICByZWFkU3RyaW5nKGNoKTtcclxuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoY2gpIHx8IGlzKCcuJykgJiYgaXNOdW1iZXIocGVlaygpKSkge1xyXG4gICAgICByZWFkTnVtYmVyKCk7XHJcbiAgICB9IGVsc2UgaWYgKGlzSWRlbnQoY2gpKSB7XHJcbiAgICAgIHJlYWRJZGVudCgpO1xyXG4gICAgICAvLyBpZGVudGlmaWVycyBjYW4gb25seSBiZSBpZiB0aGUgcHJlY2VkaW5nIGNoYXIgd2FzIGEgeyBvciAsXHJcbiAgICAgIGlmICh3YXMoJ3ssJykgJiYganNvblswXT09J3snICYmXHJcbiAgICAgICAgICh0b2tlbj10b2tlbnNbdG9rZW5zLmxlbmd0aC0xXSkpIHtcclxuICAgICAgICB0b2tlbi5qc29uID0gdG9rZW4udGV4dC5pbmRleE9mKCcuJykgPT0gLTE7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaXMoJygpe31bXS4sOzo/JykpIHtcclxuICAgICAgdG9rZW5zLnB1c2goe1xyXG4gICAgICAgIGluZGV4OmluZGV4LFxyXG4gICAgICAgIHRleHQ6Y2gsXHJcbiAgICAgICAganNvbjood2FzKCc6WywnKSAmJiBpcygne1snKSkgfHwgaXMoJ31dOiwnKVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGlzKCd7WycpKSBqc29uLnVuc2hpZnQoY2gpO1xyXG4gICAgICBpZiAoaXMoJ31dJykpIGpzb24uc2hpZnQoKTtcclxuICAgICAgaW5kZXgrKztcclxuICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGNoKSkge1xyXG4gICAgICBpbmRleCsrO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBjaDIgPSBjaCArIHBlZWsoKSxcclxuICAgICAgICAgIGNoMyA9IGNoMiArIHBlZWsoMiksXHJcbiAgICAgICAgICBmbiA9IE9QRVJBVE9SU1tjaF0sXHJcbiAgICAgICAgICBmbjIgPSBPUEVSQVRPUlNbY2gyXSxcclxuICAgICAgICAgIGZuMyA9IE9QRVJBVE9SU1tjaDNdO1xyXG4gICAgICBpZiAoZm4zKSB7XHJcbiAgICAgICAgdG9rZW5zLnB1c2goe2luZGV4OmluZGV4LCB0ZXh0OmNoMywgZm46Zm4zfSk7XHJcbiAgICAgICAgaW5kZXggKz0gMztcclxuICAgICAgfSBlbHNlIGlmIChmbjIpIHtcclxuICAgICAgICB0b2tlbnMucHVzaCh7aW5kZXg6aW5kZXgsIHRleHQ6Y2gyLCBmbjpmbjJ9KTtcclxuICAgICAgICBpbmRleCArPSAyO1xyXG4gICAgICB9IGVsc2UgaWYgKGZuKSB7XHJcbiAgICAgICAgdG9rZW5zLnB1c2goe2luZGV4OmluZGV4LCB0ZXh0OmNoLCBmbjpmbiwganNvbjogd2FzKCdbLDonKSAmJiBpcygnKy0nKX0pO1xyXG4gICAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcihcIlVuZXhwZWN0ZWQgbmV4dCBjaGFyYWN0ZXIgXCIsIGluZGV4LCBpbmRleCsxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGFzdENoID0gY2g7XHJcbiAgfVxyXG4gIHJldHVybiB0b2tlbnM7XHJcblxyXG4gIGZ1bmN0aW9uIGlzKGNoYXJzKSB7XHJcbiAgICByZXR1cm4gY2hhcnMuaW5kZXhPZihjaCkgIT0gLTE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB3YXMoY2hhcnMpIHtcclxuICAgIHJldHVybiBjaGFycy5pbmRleE9mKGxhc3RDaCkgIT0gLTE7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwZWVrKGkpIHtcclxuICAgIHZhciBudW0gPSBpIHx8IDE7XHJcbiAgICByZXR1cm4gaW5kZXggKyBudW0gPCB0ZXh0Lmxlbmd0aCA/IHRleHQuY2hhckF0KGluZGV4ICsgbnVtKSA6IGZhbHNlO1xyXG4gIH1cclxuICBmdW5jdGlvbiBpc051bWJlcihjaCkge1xyXG4gICAgcmV0dXJuICcwJyA8PSBjaCAmJiBjaCA8PSAnOSc7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjaCkge1xyXG4gICAgcmV0dXJuIGNoID09ICcgJyB8fCBjaCA9PSAnXFxyJyB8fCBjaCA9PSAnXFx0JyB8fFxyXG4gICAgICAgICAgIGNoID09ICdcXG4nIHx8IGNoID09ICdcXHYnIHx8IGNoID09ICdcXHUwMEEwJzsgLy8gSUUgdHJlYXRzIG5vbi1icmVha2luZyBzcGFjZSBhcyBcXHUwMEEwXHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGlzSWRlbnQoY2gpIHtcclxuICAgIHJldHVybiAnYScgPD0gY2ggJiYgY2ggPD0gJ3onIHx8XHJcbiAgICAgICAgICAgJ0EnIDw9IGNoICYmIGNoIDw9ICdaJyB8fFxyXG4gICAgICAgICAgICdfJyA9PSBjaCB8fCBjaCA9PSAnJCc7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGlzRXhwT3BlcmF0b3IoY2gpIHtcclxuICAgIHJldHVybiBjaCA9PSAnLScgfHwgY2ggPT0gJysnIHx8IGlzTnVtYmVyKGNoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRocm93RXJyb3IoZXJyb3IsIHN0YXJ0LCBlbmQpIHtcclxuICAgIGVuZCA9IGVuZCB8fCBpbmRleDtcclxuICAgIHZhciBjb2xTdHIgPSAoaXNEZWZpbmVkKHN0YXJ0KSA/XHJcbiAgICAgICAgXCJzIFwiICsgc3RhcnQgKyAgXCItXCIgKyBpbmRleCArIFwiIFtcIiArIHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpICsgXCJdXCJcclxuICAgICAgICA6IFwiIFwiICsgZW5kKTtcclxuICAgIHRocm93ICRwYXJzZU1pbkVycignbGV4ZXJyJywgXCJMZXhlciBFcnJvcjogezB9IGF0IGNvbHVtbnsxfSBpbiBleHByZXNzaW9uIFt7Mn1dLlwiLFxyXG4gICAgICAgIGVycm9yLCBjb2xTdHIsIHRleHQpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVhZE51bWJlcigpIHtcclxuICAgIHZhciBudW1iZXIgPSBcIlwiO1xyXG4gICAgdmFyIHN0YXJ0ID0gaW5kZXg7XHJcbiAgICB3aGlsZSAoaW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgICB2YXIgY2ggPSBsb3dlcmNhc2UodGV4dC5jaGFyQXQoaW5kZXgpKTtcclxuICAgICAgaWYgKGNoID09ICcuJyB8fCBpc051bWJlcihjaCkpIHtcclxuICAgICAgICBudW1iZXIgKz0gY2g7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHBlZWtDaCA9IHBlZWsoKTtcclxuICAgICAgICBpZiAoY2ggPT0gJ2UnICYmIGlzRXhwT3BlcmF0b3IocGVla0NoKSkge1xyXG4gICAgICAgICAgbnVtYmVyICs9IGNoO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNFeHBPcGVyYXRvcihjaCkgJiZcclxuICAgICAgICAgICAgcGVla0NoICYmIGlzTnVtYmVyKHBlZWtDaCkgJiZcclxuICAgICAgICAgICAgbnVtYmVyLmNoYXJBdChudW1iZXIubGVuZ3RoIC0gMSkgPT0gJ2UnKSB7XHJcbiAgICAgICAgICBudW1iZXIgKz0gY2g7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0V4cE9wZXJhdG9yKGNoKSAmJlxyXG4gICAgICAgICAgICAoIXBlZWtDaCB8fCAhaXNOdW1iZXIocGVla0NoKSkgJiZcclxuICAgICAgICAgICAgbnVtYmVyLmNoYXJBdChudW1iZXIubGVuZ3RoIC0gMSkgPT0gJ2UnKSB7XHJcbiAgICAgICAgICB0aHJvd0Vycm9yKCdJbnZhbGlkIGV4cG9uZW50Jyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpbmRleCsrO1xyXG4gICAgfVxyXG4gICAgbnVtYmVyID0gMSAqIG51bWJlcjtcclxuICAgIHRva2Vucy5wdXNoKHtpbmRleDpzdGFydCwgdGV4dDpudW1iZXIsIGpzb246dHJ1ZSxcclxuICAgICAgZm46ZnVuY3Rpb24oKSB7cmV0dXJuIG51bWJlcjt9fSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlYWRJZGVudCgpIHtcclxuICAgIHZhciBpZGVudCA9IFwiXCIsXHJcbiAgICAgICAgc3RhcnQgPSBpbmRleCxcclxuICAgICAgICBsYXN0RG90LCBwZWVrSW5kZXgsIG1ldGhvZE5hbWUsIGNoO1xyXG5cclxuICAgIHdoaWxlIChpbmRleCA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICAgIGNoID0gdGV4dC5jaGFyQXQoaW5kZXgpO1xyXG4gICAgICBpZiAoY2ggPT0gJy4nIHx8IGlzSWRlbnQoY2gpIHx8IGlzTnVtYmVyKGNoKSkge1xyXG4gICAgICAgIGlmIChjaCA9PSAnLicpIGxhc3REb3QgPSBpbmRleDtcclxuICAgICAgICBpZGVudCArPSBjaDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpbmRleCsrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vY2hlY2sgaWYgdGhpcyBpcyBub3QgYSBtZXRob2QgaW52b2NhdGlvbiBhbmQgaWYgaXQgaXMgYmFjayBvdXQgdG8gbGFzdCBkb3RcclxuICAgIGlmIChsYXN0RG90KSB7XHJcbiAgICAgIHBlZWtJbmRleCA9IGluZGV4O1xyXG4gICAgICB3aGlsZShwZWVrSW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgIGNoID0gdGV4dC5jaGFyQXQocGVla0luZGV4KTtcclxuICAgICAgICBpZiAoY2ggPT0gJygnKSB7XHJcbiAgICAgICAgICBtZXRob2ROYW1lID0gaWRlbnQuc3Vic3RyKGxhc3REb3QgLSBzdGFydCArIDEpO1xyXG4gICAgICAgICAgaWRlbnQgPSBpZGVudC5zdWJzdHIoMCwgbGFzdERvdCAtIHN0YXJ0KTtcclxuICAgICAgICAgIGluZGV4ID0gcGVla0luZGV4O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGlzV2hpdGVzcGFjZShjaCkpIHtcclxuICAgICAgICAgIHBlZWtJbmRleCsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgdmFyIHRva2VuID0ge1xyXG4gICAgICBpbmRleDpzdGFydCxcclxuICAgICAgdGV4dDppZGVudFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoT1BFUkFUT1JTLmhhc093blByb3BlcnR5KGlkZW50KSkge1xyXG4gICAgICB0b2tlbi5mbiA9IHRva2VuLmpzb24gPSBPUEVSQVRPUlNbaWRlbnRdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGdldHRlciA9IGdldHRlckZuKGlkZW50LCBjc3AsIHRleHQpO1xyXG4gICAgICB0b2tlbi5mbiA9IGV4dGVuZChmdW5jdGlvbihzZWxmLCBsb2NhbHMpIHtcclxuICAgICAgICByZXR1cm4gKGdldHRlcihzZWxmLCBsb2NhbHMpKTtcclxuICAgICAgfSwge1xyXG4gICAgICAgIGFzc2lnbjogZnVuY3Rpb24oc2VsZiwgdmFsdWUpIHtcclxuICAgICAgICAgIHJldHVybiBzZXR0ZXIoc2VsZiwgaWRlbnQsIHZhbHVlLCB0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuXHJcbiAgICBpZiAobWV0aG9kTmFtZSkge1xyXG4gICAgICB0b2tlbnMucHVzaCh7XHJcbiAgICAgICAgaW5kZXg6bGFzdERvdCxcclxuICAgICAgICB0ZXh0OiAnLicsXHJcbiAgICAgICAganNvbjogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICAgIHRva2Vucy5wdXNoKHtcclxuICAgICAgICBpbmRleDogbGFzdERvdCArIDEsXHJcbiAgICAgICAgdGV4dDogbWV0aG9kTmFtZSxcclxuICAgICAgICBqc29uOiBmYWxzZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWRTdHJpbmcocXVvdGUpIHtcclxuICAgIHZhciBzdGFydCA9IGluZGV4O1xyXG4gICAgaW5kZXgrKztcclxuICAgIHZhciBzdHJpbmcgPSBcIlwiO1xyXG4gICAgdmFyIHJhd1N0cmluZyA9IHF1b3RlO1xyXG4gICAgdmFyIGVzY2FwZSA9IGZhbHNlO1xyXG4gICAgd2hpbGUgKGluZGV4IDwgdGV4dC5sZW5ndGgpIHtcclxuICAgICAgdmFyIGNoID0gdGV4dC5jaGFyQXQoaW5kZXgpO1xyXG4gICAgICByYXdTdHJpbmcgKz0gY2g7XHJcbiAgICAgIGlmIChlc2NhcGUpIHtcclxuICAgICAgICBpZiAoY2ggPT0gJ3UnKSB7XHJcbiAgICAgICAgICB2YXIgaGV4ID0gdGV4dC5zdWJzdHJpbmcoaW5kZXggKyAxLCBpbmRleCArIDUpO1xyXG4gICAgICAgICAgaWYgKCFoZXgubWF0Y2goL1tcXGRhLWZdezR9L2kpKVxyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKCBcIkludmFsaWQgdW5pY29kZSBlc2NhcGUgW1xcXFx1XCIgKyBoZXggKyBcIl1cIik7XHJcbiAgICAgICAgICBpbmRleCArPSA0O1xyXG4gICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgcmVwID0gRVNDQVBFW2NoXTtcclxuICAgICAgICAgIGlmIChyZXApIHtcclxuICAgICAgICAgICAgc3RyaW5nICs9IHJlcDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXNjYXBlID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gJ1xcXFwnKSB7XHJcbiAgICAgICAgZXNjYXBlID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIGlmIChjaCA9PSBxdW90ZSkge1xyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgdG9rZW5zLnB1c2goe1xyXG4gICAgICAgICAgaW5kZXg6c3RhcnQsXHJcbiAgICAgICAgICB0ZXh0OnJhd1N0cmluZyxcclxuICAgICAgICAgIHN0cmluZzpzdHJpbmcsXHJcbiAgICAgICAgICBqc29uOnRydWUsXHJcbiAgICAgICAgICBmbjpmdW5jdGlvbigpIHsgcmV0dXJuIHN0cmluZzsgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdHJpbmcgKz0gY2g7XHJcbiAgICAgIH1cclxuICAgICAgaW5kZXgrKztcclxuICAgIH1cclxuICAgIHRocm93RXJyb3IoXCJVbnRlcm1pbmF0ZWQgcXVvdGVcIiwgc3RhcnQpO1xyXG4gIH1cclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmZ1bmN0aW9uIHBhcnNlcih0ZXh0LCBqc29uLCAkZmlsdGVyLCBjc3Ape1xyXG4gIHZhciBaRVJPID0gdmFsdWVGbigwKSxcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIHRva2VucyA9IGxleCh0ZXh0LCBjc3ApLFxyXG4gICAgICBhc3NpZ25tZW50ID0gX2Fzc2lnbm1lbnQsXHJcbiAgICAgIGZ1bmN0aW9uQ2FsbCA9IF9mdW5jdGlvbkNhbGwsXHJcbiAgICAgIGZpZWxkQWNjZXNzID0gX2ZpZWxkQWNjZXNzLFxyXG4gICAgICBvYmplY3RJbmRleCA9IF9vYmplY3RJbmRleCxcclxuICAgICAgZmlsdGVyQ2hhaW4gPSBfZmlsdGVyQ2hhaW47XHJcblxyXG4gIGlmKGpzb24pe1xyXG4gICAgLy8gVGhlIGV4dHJhIGxldmVsIG9mIGFsaWFzaW5nIGlzIGhlcmUsIGp1c3QgaW4gY2FzZSB0aGUgbGV4ZXIgbWlzc2VzIHNvbWV0aGluZywgc28gdGhhdFxyXG4gICAgLy8gd2UgcHJldmVudCBhbnkgYWNjaWRlbnRhbCBleGVjdXRpb24gaW4gSlNPTi5cclxuICAgIGFzc2lnbm1lbnQgPSBsb2dpY2FsT1I7XHJcbiAgICBmdW5jdGlvbkNhbGwgPVxyXG4gICAgICBmaWVsZEFjY2VzcyA9XHJcbiAgICAgIG9iamVjdEluZGV4ID1cclxuICAgICAgZmlsdGVyQ2hhaW4gPVxyXG4gICAgICAgIGZ1bmN0aW9uKCkgeyB0aHJvd0Vycm9yKFwiaXMgbm90IHZhbGlkIGpzb25cIiwge3RleHQ6dGV4dCwgaW5kZXg6MH0pOyB9O1xyXG4gICAgdmFsdWUgPSBwcmltYXJ5KCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhbHVlID0gc3RhdGVtZW50cygpO1xyXG4gIH1cclxuICBpZiAodG9rZW5zLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgdGhyb3dFcnJvcihcImlzIGFuIHVuZXhwZWN0ZWQgdG9rZW5cIiwgdG9rZW5zWzBdKTtcclxuICB9XHJcbiAgdmFsdWUubGl0ZXJhbCA9ICEhdmFsdWUubGl0ZXJhbDtcclxuICB2YWx1ZS5jb25zdGFudCA9ICEhdmFsdWUuY29uc3RhbnQ7XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gIGZ1bmN0aW9uIHRocm93RXJyb3IobXNnLCB0b2tlbikge1xyXG4gICAgdGhyb3cgJHBhcnNlTWluRXJyKCdzeW50YXgnLFxyXG4gICAgICAgIFwiU3ludGF4IEVycm9yOiBUb2tlbiAnezB9JyB7MX0gYXQgY29sdW1uIHsyfSBvZiB0aGUgZXhwcmVzc2lvbiBbezN9XSBzdGFydGluZyBhdCBbezR9XS5cIixcclxuICAgICAgICB0b2tlbi50ZXh0LCBtc2csICh0b2tlbi5pbmRleCArIDEpLCB0ZXh0LCB0ZXh0LnN1YnN0cmluZyh0b2tlbi5pbmRleCkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGVla1Rva2VuKCkge1xyXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDApXHJcbiAgICAgIHRocm93ICRwYXJzZU1pbkVycigndWVvZScsIFwiVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbjogezB9XCIsIHRleHQpO1xyXG4gICAgcmV0dXJuIHRva2Vuc1swXTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBlZWsoZTEsIGUyLCBlMywgZTQpIHtcclxuICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbMF07XHJcbiAgICAgIHZhciB0ID0gdG9rZW4udGV4dDtcclxuICAgICAgaWYgKHQ9PWUxIHx8IHQ9PWUyIHx8IHQ9PWUzIHx8IHQ9PWU0IHx8XHJcbiAgICAgICAgICAoIWUxICYmICFlMiAmJiAhZTMgJiYgIWU0KSkge1xyXG4gICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXhwZWN0KGUxLCBlMiwgZTMsIGU0KXtcclxuICAgIHZhciB0b2tlbiA9IHBlZWsoZTEsIGUyLCBlMywgZTQpO1xyXG4gICAgaWYgKHRva2VuKSB7XHJcbiAgICAgIGlmIChqc29uICYmICF0b2tlbi5qc29uKSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcihcImlzIG5vdCB2YWxpZCBqc29uXCIsIHRva2VuKTtcclxuICAgICAgfVxyXG4gICAgICB0b2tlbnMuc2hpZnQoKTtcclxuICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29uc3VtZShlMSl7XHJcbiAgICBpZiAoIWV4cGVjdChlMSkpIHtcclxuICAgICAgdGhyb3dFcnJvcihcImlzIHVuZXhwZWN0ZWQsIGV4cGVjdGluZyBbXCIgKyBlMSArIFwiXVwiLCBwZWVrKCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdW5hcnlGbihmbiwgcmlnaHQpIHtcclxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24oc2VsZiwgbG9jYWxzKSB7XHJcbiAgICAgIHJldHVybiBmbihzZWxmLCBsb2NhbHMsIHJpZ2h0KTtcclxuICAgIH0sIHtcclxuICAgICAgY29uc3RhbnQ6cmlnaHQuY29uc3RhbnRcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdGVybmFyeUZuKGxlZnQsIG1pZGRsZSwgcmlnaHQpe1xyXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbihzZWxmLCBsb2NhbHMpe1xyXG4gICAgICByZXR1cm4gbGVmdChzZWxmLCBsb2NhbHMpID8gbWlkZGxlKHNlbGYsIGxvY2FscykgOiByaWdodChzZWxmLCBsb2NhbHMpO1xyXG4gICAgfSwge1xyXG4gICAgICBjb25zdGFudDogbGVmdC5jb25zdGFudCAmJiBtaWRkbGUuY29uc3RhbnQgJiYgcmlnaHQuY29uc3RhbnRcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYmluYXJ5Rm4obGVmdCwgZm4sIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uKHNlbGYsIGxvY2Fscykge1xyXG4gICAgICByZXR1cm4gZm4oc2VsZiwgbG9jYWxzLCBsZWZ0LCByaWdodCk7XHJcbiAgICB9LCB7XHJcbiAgICAgIGNvbnN0YW50OmxlZnQuY29uc3RhbnQgJiYgcmlnaHQuY29uc3RhbnRcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3RhdGVtZW50cygpIHtcclxuICAgIHZhciBzdGF0ZW1lbnRzID0gW107XHJcbiAgICB3aGlsZSh0cnVlKSB7XHJcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiAhcGVlaygnfScsICcpJywgJzsnLCAnXScpKVxyXG4gICAgICAgIHN0YXRlbWVudHMucHVzaChmaWx0ZXJDaGFpbigpKTtcclxuICAgICAgaWYgKCFleHBlY3QoJzsnKSkge1xyXG4gICAgICAgIC8vIG9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgdGhlcmUgaXMgb25seSBvbmUgc3RhdGVtZW50LlxyXG4gICAgICAgIC8vIFRPRE8oc2l6ZSk6IG1heWJlIHdlIHNob3VsZCBub3Qgc3VwcG9ydCBtdWx0aXBsZSBzdGF0ZW1lbnRzP1xyXG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLmxlbmd0aCA9PSAxXHJcbiAgICAgICAgICA/IHN0YXRlbWVudHNbMF1cclxuICAgICAgICAgIDogZnVuY3Rpb24oc2VsZiwgbG9jYWxzKXtcclxuICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHN0YXRlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKHN0YXRlbWVudClcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhdGVtZW50KHNlbGYsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2ZpbHRlckNoYWluKCkge1xyXG4gICAgdmFyIGxlZnQgPSBleHByZXNzaW9uKCk7XHJcbiAgICB2YXIgdG9rZW47XHJcbiAgICB3aGlsZSh0cnVlKSB7XHJcbiAgICAgIGlmICgodG9rZW4gPSBleHBlY3QoJ3wnKSkpIHtcclxuICAgICAgICBsZWZ0ID0gYmluYXJ5Rm4obGVmdCwgdG9rZW4uZm4sIGZpbHRlcigpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbGVmdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmlsdGVyKCkge1xyXG4gICAgdmFyIHRva2VuID0gZXhwZWN0KCk7XHJcbiAgICB2YXIgZm4gPSAkZmlsdGVyKHRva2VuLnRleHQpO1xyXG4gICAgdmFyIGFyZ3NGbiA9IFtdO1xyXG4gICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICBpZiAoKHRva2VuID0gZXhwZWN0KCc6JykpKSB7XHJcbiAgICAgICAgYXJnc0ZuLnB1c2goZXhwcmVzc2lvbigpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgZm5JbnZva2UgPSBmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGlucHV0KXtcclxuICAgICAgICAgIHZhciBhcmdzID0gW2lucHV0XTtcclxuICAgICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3NGbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJnc0ZuW2ldKHNlbGYsIGxvY2FscykpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGZuSW52b2tlO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV4cHJlc3Npb24oKSB7XHJcbiAgICByZXR1cm4gYXNzaWdubWVudCgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2Fzc2lnbm1lbnQoKSB7XHJcbiAgICB2YXIgbGVmdCA9IHRlcm5hcnkoKTtcclxuICAgIHZhciByaWdodDtcclxuICAgIHZhciB0b2tlbjtcclxuICAgIGlmICgodG9rZW4gPSBleHBlY3QoJz0nKSkpIHtcclxuICAgICAgaWYgKCFsZWZ0LmFzc2lnbikge1xyXG4gICAgICAgIHRocm93RXJyb3IoXCJpbXBsaWVzIGFzc2lnbm1lbnQgYnV0IFtcIiArXHJcbiAgICAgICAgICB0ZXh0LnN1YnN0cmluZygwLCB0b2tlbi5pbmRleCkgKyBcIl0gY2FuIG5vdCBiZSBhc3NpZ25lZCB0b1wiLCB0b2tlbik7XHJcbiAgICAgIH1cclxuICAgICAgcmlnaHQgPSB0ZXJuYXJ5KCk7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgbG9jYWxzKXtcclxuICAgICAgICByZXR1cm4gbGVmdC5hc3NpZ24oc2NvcGUsIHJpZ2h0KHNjb3BlLCBsb2NhbHMpLCBsb2NhbHMpO1xyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0ZXJuYXJ5KCkge1xyXG4gICAgdmFyIGxlZnQgPSBsb2dpY2FsT1IoKTtcclxuICAgIHZhciBtaWRkbGU7XHJcbiAgICB2YXIgdG9rZW47XHJcbiAgICBpZigodG9rZW4gPSBleHBlY3QoJz8nKSkpe1xyXG4gICAgICBtaWRkbGUgPSB0ZXJuYXJ5KCk7XHJcbiAgICAgIGlmKCh0b2tlbiA9IGV4cGVjdCgnOicpKSl7XHJcbiAgICAgICAgcmV0dXJuIHRlcm5hcnlGbihsZWZ0LCBtaWRkbGUsIHRlcm5hcnkoKSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3dFcnJvcignZXhwZWN0ZWQgOicsIHRva2VuKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbG9naWNhbE9SKCkge1xyXG4gICAgdmFyIGxlZnQgPSBsb2dpY2FsQU5EKCk7XHJcbiAgICB2YXIgdG9rZW47XHJcbiAgICB3aGlsZSh0cnVlKSB7XHJcbiAgICAgIGlmICgodG9rZW4gPSBleHBlY3QoJ3x8JykpKSB7XHJcbiAgICAgICAgbGVmdCA9IGJpbmFyeUZuKGxlZnQsIHRva2VuLmZuLCBsb2dpY2FsQU5EKCkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2dpY2FsQU5EKCkge1xyXG4gICAgdmFyIGxlZnQgPSBlcXVhbGl0eSgpO1xyXG4gICAgdmFyIHRva2VuO1xyXG4gICAgaWYgKCh0b2tlbiA9IGV4cGVjdCgnJiYnKSkpIHtcclxuICAgICAgbGVmdCA9IGJpbmFyeUZuKGxlZnQsIHRva2VuLmZuLCBsb2dpY2FsQU5EKCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlcXVhbGl0eSgpIHtcclxuICAgIHZhciBsZWZ0ID0gcmVsYXRpb25hbCgpO1xyXG4gICAgdmFyIHRva2VuO1xyXG4gICAgaWYgKCh0b2tlbiA9IGV4cGVjdCgnPT0nLCchPScsJz09PScsJyE9PScpKSkge1xyXG4gICAgICBsZWZ0ID0gYmluYXJ5Rm4obGVmdCwgdG9rZW4uZm4sIGVxdWFsaXR5KCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWxhdGlvbmFsKCkge1xyXG4gICAgdmFyIGxlZnQgPSBhZGRpdGl2ZSgpO1xyXG4gICAgdmFyIHRva2VuO1xyXG4gICAgaWYgKCh0b2tlbiA9IGV4cGVjdCgnPCcsICc+JywgJzw9JywgJz49JykpKSB7XHJcbiAgICAgIGxlZnQgPSBiaW5hcnlGbihsZWZ0LCB0b2tlbi5mbiwgcmVsYXRpb25hbCgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWZ0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRkaXRpdmUoKSB7XHJcbiAgICB2YXIgbGVmdCA9IG11bHRpcGxpY2F0aXZlKCk7XHJcbiAgICB2YXIgdG9rZW47XHJcbiAgICB3aGlsZSAoKHRva2VuID0gZXhwZWN0KCcrJywnLScpKSkge1xyXG4gICAgICBsZWZ0ID0gYmluYXJ5Rm4obGVmdCwgdG9rZW4uZm4sIG11bHRpcGxpY2F0aXZlKCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtdWx0aXBsaWNhdGl2ZSgpIHtcclxuICAgIHZhciBsZWZ0ID0gdW5hcnkoKTtcclxuICAgIHZhciB0b2tlbjtcclxuICAgIHdoaWxlICgodG9rZW4gPSBleHBlY3QoJyonLCcvJywnJScpKSkge1xyXG4gICAgICBsZWZ0ID0gYmluYXJ5Rm4obGVmdCwgdG9rZW4uZm4sIHVuYXJ5KCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1bmFyeSgpIHtcclxuICAgIHZhciB0b2tlbjtcclxuICAgIGlmIChleHBlY3QoJysnKSkge1xyXG4gICAgICByZXR1cm4gcHJpbWFyeSgpO1xyXG4gICAgfSBlbHNlIGlmICgodG9rZW4gPSBleHBlY3QoJy0nKSkpIHtcclxuICAgICAgcmV0dXJuIGJpbmFyeUZuKFpFUk8sIHRva2VuLmZuLCB1bmFyeSgpKTtcclxuICAgIH0gZWxzZSBpZiAoKHRva2VuID0gZXhwZWN0KCchJykpKSB7XHJcbiAgICAgIHJldHVybiB1bmFyeUZuKHRva2VuLmZuLCB1bmFyeSgpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBwcmltYXJ5KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gcHJpbWFyeSgpIHtcclxuICAgIHZhciBwcmltYXJ5O1xyXG4gICAgaWYgKGV4cGVjdCgnKCcpKSB7XHJcbiAgICAgIHByaW1hcnkgPSBmaWx0ZXJDaGFpbigpO1xyXG4gICAgICBjb25zdW1lKCcpJyk7XHJcbiAgICB9IGVsc2UgaWYgKGV4cGVjdCgnWycpKSB7XHJcbiAgICAgIHByaW1hcnkgPSBhcnJheURlY2xhcmF0aW9uKCk7XHJcbiAgICB9IGVsc2UgaWYgKGV4cGVjdCgneycpKSB7XHJcbiAgICAgIHByaW1hcnkgPSBvYmplY3QoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciB0b2tlbiA9IGV4cGVjdCgpO1xyXG4gICAgICBwcmltYXJ5ID0gdG9rZW4uZm47XHJcbiAgICAgIGlmICghcHJpbWFyeSkge1xyXG4gICAgICAgIHRocm93RXJyb3IoXCJub3QgYSBwcmltYXJ5IGV4cHJlc3Npb25cIiwgdG9rZW4pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0b2tlbi5qc29uKSB7XHJcbiAgICAgICAgcHJpbWFyeS5jb25zdGFudCA9IHByaW1hcnkubGl0ZXJhbCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmV4dCwgY29udGV4dDtcclxuICAgIHdoaWxlICgobmV4dCA9IGV4cGVjdCgnKCcsICdbJywgJy4nKSkpIHtcclxuICAgICAgaWYgKG5leHQudGV4dCA9PT0gJygnKSB7XHJcbiAgICAgICAgcHJpbWFyeSA9IGZ1bmN0aW9uQ2FsbChwcmltYXJ5LCBjb250ZXh0KTtcclxuICAgICAgICBjb250ZXh0ID0gbnVsbDtcclxuICAgICAgfSBlbHNlIGlmIChuZXh0LnRleHQgPT09ICdbJykge1xyXG4gICAgICAgIGNvbnRleHQgPSBwcmltYXJ5O1xyXG4gICAgICAgIHByaW1hcnkgPSBvYmplY3RJbmRleChwcmltYXJ5KTtcclxuICAgICAgfSBlbHNlIGlmIChuZXh0LnRleHQgPT09ICcuJykge1xyXG4gICAgICAgIGNvbnRleHQgPSBwcmltYXJ5O1xyXG4gICAgICAgIHByaW1hcnkgPSBmaWVsZEFjY2VzcyhwcmltYXJ5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvd0Vycm9yKFwiSU1QT1NTSUJMRVwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1hcnk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfZmllbGRBY2Nlc3Mob2JqZWN0KSB7XHJcbiAgICB2YXIgZmllbGQgPSBleHBlY3QoKS50ZXh0O1xyXG4gICAgdmFyIGdldHRlciA9IGdldHRlckZuKGZpZWxkLCBjc3AsIHRleHQpO1xyXG4gICAgcmV0dXJuIGV4dGVuZChcclxuICAgICAgICBmdW5jdGlvbihzY29wZSwgbG9jYWxzLCBzZWxmKSB7XHJcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHNlbGYgfHwgb2JqZWN0KHNjb3BlLCBsb2NhbHMpLCBsb2NhbHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgYXNzaWduOmZ1bmN0aW9uKHNjb3BlLCB2YWx1ZSwgbG9jYWxzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXR0ZXIob2JqZWN0KHNjb3BlLCBsb2NhbHMpLCBmaWVsZCwgdmFsdWUsIHRleHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfb2JqZWN0SW5kZXgob2JqKSB7XHJcbiAgICB2YXIgaW5kZXhGbiA9IGV4cHJlc3Npb24oKTtcclxuICAgIGNvbnN1bWUoJ10nKTtcclxuICAgIHJldHVybiBleHRlbmQoXHJcbiAgICAgIGZ1bmN0aW9uKHNlbGYsIGxvY2Fscyl7XHJcbiAgICAgICAgdmFyIG8gPSBvYmooc2VsZiwgbG9jYWxzKSxcclxuICAgICAgICAgICAgaSA9IGluZGV4Rm4oc2VsZiwgbG9jYWxzKSxcclxuICAgICAgICAgICAgdiwgcDtcclxuXHJcbiAgICAgICAgaWYgKCFvKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIHYgPSBlbnN1cmVTYWZlT2JqZWN0KG9baV0sIHRleHQpO1xyXG4gICAgICAgIGlmICh2ICYmIHYudGhlbikge1xyXG4gICAgICAgICAgcCA9IHY7XHJcbiAgICAgICAgICBpZiAoISgnJCR2JyBpbiB2KSkge1xyXG4gICAgICAgICAgICBwLiQkdiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uKHZhbCkgeyBwLiQkdiA9IHZhbDsgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2ID0gdi4kJHY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgICB9LCB7XHJcbiAgICAgICAgYXNzaWduOmZ1bmN0aW9uKHNlbGYsIHZhbHVlLCBsb2NhbHMpe1xyXG4gICAgICAgICAgdmFyIGtleSA9IGluZGV4Rm4oc2VsZiwgbG9jYWxzKTtcclxuICAgICAgICAgIC8vIHByZXZlbnQgb3ZlcndyaXRpbmcgb2YgRnVuY3Rpb24uY29uc3RydWN0b3Igd2hpY2ggd291bGQgYnJlYWsgZW5zdXJlU2FmZU9iamVjdCBjaGVja1xyXG4gICAgICAgICAgcmV0dXJuIGVuc3VyZVNhZmVPYmplY3Qob2JqKHNlbGYsIGxvY2FscyksIHRleHQpW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gX2Z1bmN0aW9uQ2FsbChmbiwgY29udGV4dEdldHRlcikge1xyXG4gICAgdmFyIGFyZ3NGbiA9IFtdO1xyXG4gICAgaWYgKHBlZWtUb2tlbigpLnRleHQgIT0gJyknKSB7XHJcbiAgICAgIGRvIHtcclxuICAgICAgICBhcmdzRm4ucHVzaChleHByZXNzaW9uKCkpO1xyXG4gICAgICB9IHdoaWxlIChleHBlY3QoJywnKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdW1lKCcpJyk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGxvY2Fscyl7XHJcbiAgICAgIHZhciBhcmdzID0gW10sXHJcbiAgICAgICAgICBjb250ZXh0ID0gY29udGV4dEdldHRlciA/IGNvbnRleHRHZXR0ZXIoc2NvcGUsIGxvY2FscykgOiBzY29wZTtcclxuXHJcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3NGbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFyZ3MucHVzaChhcmdzRm5baV0oc2NvcGUsIGxvY2FscykpO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBmblB0ciA9IGZuKHNjb3BlLCBsb2NhbHMsIGNvbnRleHQpIHx8IG5vb3A7XHJcbiAgICAgIC8vIElFIHN0dXBpZGl0eSFcclxuICAgICAgdmFyIHYgPSBmblB0ci5hcHBseVxyXG4gICAgICAgICAgPyBmblB0ci5hcHBseShjb250ZXh0LCBhcmdzKVxyXG4gICAgICAgICAgOiBmblB0cihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciBwcm9taXNlXHJcbiAgICAgIGlmICh2ICYmIHYudGhlbikge1xyXG4gICAgICAgIHZhciBwID0gdjtcclxuICAgICAgICBpZiAoISgnJCR2JyBpbiB2KSkge1xyXG4gICAgICAgICAgcC4kJHYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24odmFsKSB7IHAuJCR2ID0gdmFsOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdiA9IHYuJCR2O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdjtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBUaGlzIGlzIHVzZWQgd2l0aCBqc29uIGFycmF5IGRlY2xhcmF0aW9uXHJcbiAgZnVuY3Rpb24gYXJyYXlEZWNsYXJhdGlvbiAoKSB7XHJcbiAgICB2YXIgZWxlbWVudEZucyA9IFtdO1xyXG4gICAgdmFyIGFsbENvbnN0YW50ID0gdHJ1ZTtcclxuICAgIGlmIChwZWVrVG9rZW4oKS50ZXh0ICE9ICddJykge1xyXG4gICAgICBkbyB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRGbiA9IGV4cHJlc3Npb24oKTtcclxuICAgICAgICBlbGVtZW50Rm5zLnB1c2goZWxlbWVudEZuKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnRGbi5jb25zdGFudCkge1xyXG4gICAgICAgICAgYWxsQ29uc3RhbnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gd2hpbGUgKGV4cGVjdCgnLCcpKTtcclxuICAgIH1cclxuICAgIGNvbnN1bWUoJ10nKTtcclxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24oc2VsZiwgbG9jYWxzKXtcclxuICAgICAgdmFyIGFycmF5ID0gW107XHJcbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnRGbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBhcnJheS5wdXNoKGVsZW1lbnRGbnNbaV0oc2VsZiwgbG9jYWxzKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfSwge1xyXG4gICAgICBsaXRlcmFsOnRydWUsXHJcbiAgICAgIGNvbnN0YW50OmFsbENvbnN0YW50XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9iamVjdCAoKSB7XHJcbiAgICB2YXIga2V5VmFsdWVzID0gW107XHJcbiAgICB2YXIgYWxsQ29uc3RhbnQgPSB0cnVlO1xyXG4gICAgaWYgKHBlZWtUb2tlbigpLnRleHQgIT0gJ30nKSB7XHJcbiAgICAgIGRvIHtcclxuICAgICAgICB2YXIgdG9rZW4gPSBleHBlY3QoKSxcclxuICAgICAgICBrZXkgPSB0b2tlbi5zdHJpbmcgfHwgdG9rZW4udGV4dDtcclxuICAgICAgICBjb25zdW1lKFwiOlwiKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBleHByZXNzaW9uKCk7XHJcbiAgICAgICAga2V5VmFsdWVzLnB1c2goe2tleTprZXksIHZhbHVlOnZhbHVlfSk7XHJcbiAgICAgICAgaWYgKCF2YWx1ZS5jb25zdGFudCkge1xyXG4gICAgICAgICAgYWxsQ29uc3RhbnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gd2hpbGUgKGV4cGVjdCgnLCcpKTtcclxuICAgIH1cclxuICAgIGNvbnN1bWUoJ30nKTtcclxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24oc2VsZiwgbG9jYWxzKXtcclxuICAgICAgdmFyIG9iamVjdCA9IHt9O1xyXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIga2V5VmFsdWUgPSBrZXlWYWx1ZXNbaV07XHJcbiAgICAgICAgb2JqZWN0W2tleVZhbHVlLmtleV0gPSBrZXlWYWx1ZS52YWx1ZShzZWxmLCBsb2NhbHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9LCB7XHJcbiAgICAgIGxpdGVyYWw6dHJ1ZSxcclxuICAgICAgY29uc3RhbnQ6YWxsQ29uc3RhbnRcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gUGFyc2VyIGhlbHBlciBmdW5jdGlvbnNcclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbmZ1bmN0aW9uIHNldHRlcihvYmosIHBhdGgsIHNldFZhbHVlLCBmdWxsRXhwKSB7XHJcbiAgdmFyIGVsZW1lbnQgPSBwYXRoLnNwbGl0KCcuJyksIGtleTtcclxuICBmb3IgKHZhciBpID0gMDsgZWxlbWVudC5sZW5ndGggPiAxOyBpKyspIHtcclxuICAgIGtleSA9IGVuc3VyZVNhZmVNZW1iZXJOYW1lKGVsZW1lbnQuc2hpZnQoKSwgZnVsbEV4cCk7XHJcbiAgICB2YXIgcHJvcGVydHlPYmogPSBvYmpba2V5XTtcclxuICAgIGlmICghcHJvcGVydHlPYmopIHtcclxuICAgICAgcHJvcGVydHlPYmogPSB7fTtcclxuICAgICAgb2JqW2tleV0gPSBwcm9wZXJ0eU9iajtcclxuICAgIH1cclxuICAgIG9iaiA9IHByb3BlcnR5T2JqO1xyXG4gICAgaWYgKG9iai50aGVuKSB7XHJcbiAgICAgIGlmICghKFwiJCR2XCIgaW4gb2JqKSkge1xyXG4gICAgICAgIChmdW5jdGlvbihwcm9taXNlKSB7XHJcbiAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTsgfVxyXG4gICAgICAgICkob2JqKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob2JqLiQkdiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgb2JqLiQkdiA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIG9iaiA9IG9iai4kJHY7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGtleSA9IGVuc3VyZVNhZmVNZW1iZXJOYW1lKGVsZW1lbnQuc2hpZnQoKSwgZnVsbEV4cCk7XHJcbiAgb2JqW2tleV0gPSBzZXRWYWx1ZTtcclxuICByZXR1cm4gc2V0VmFsdWU7XHJcbn1cclxuXHJcbnZhciBnZXR0ZXJGbkNhY2hlID0ge307XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFwiQmxhY2sgSG9sZVwiIHZhcmlhbnQgZnJvbTpcclxuICogLSBodHRwOi8vanNwZXJmLmNvbS9hbmd1bGFyanMtcGFyc2UtZ2V0dGVyLzRcclxuICogLSBodHRwOi8vanNwZXJmLmNvbS9wYXRoLWV2YWx1YXRpb24tc2ltcGxpZmllZC83XHJcbiAqL1xyXG5mdW5jdGlvbiBjc3BTYWZlR2V0dGVyRm4oa2V5MCwga2V5MSwga2V5Miwga2V5Mywga2V5NCwgZnVsbEV4cCkge1xyXG4gIGVuc3VyZVNhZmVNZW1iZXJOYW1lKGtleTAsIGZ1bGxFeHApO1xyXG4gIGVuc3VyZVNhZmVNZW1iZXJOYW1lKGtleTEsIGZ1bGxFeHApO1xyXG4gIGVuc3VyZVNhZmVNZW1iZXJOYW1lKGtleTIsIGZ1bGxFeHApO1xyXG4gIGVuc3VyZVNhZmVNZW1iZXJOYW1lKGtleTMsIGZ1bGxFeHApO1xyXG4gIGVuc3VyZVNhZmVNZW1iZXJOYW1lKGtleTQsIGZ1bGxFeHApO1xyXG4gIHJldHVybiBmdW5jdGlvbihzY29wZSwgbG9jYWxzKSB7XHJcbiAgICB2YXIgcGF0aFZhbCA9IChsb2NhbHMgJiYgbG9jYWxzLmhhc093blByb3BlcnR5KGtleTApKSA/IGxvY2FscyA6IHNjb3BlLFxyXG4gICAgICAgIHByb21pc2U7XHJcblxyXG4gICAgaWYgKHBhdGhWYWwgPT09IG51bGwgfHwgcGF0aFZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gcGF0aFZhbDtcclxuXHJcbiAgICBwYXRoVmFsID0gcGF0aFZhbFtrZXkwXTtcclxuICAgIGlmIChwYXRoVmFsICYmIHBhdGhWYWwudGhlbikge1xyXG4gICAgICBpZiAoIShcIiQkdlwiIGluIHBhdGhWYWwpKSB7XHJcbiAgICAgICAgcHJvbWlzZSA9IHBhdGhWYWw7XHJcbiAgICAgICAgcHJvbWlzZS4kJHYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbCkgeyBwcm9taXNlLiQkdiA9IHZhbDsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcGF0aFZhbCA9IHBhdGhWYWwuJCR2O1xyXG4gICAgfVxyXG4gICAgaWYgKCFrZXkxIHx8IHBhdGhWYWwgPT09IG51bGwgfHwgcGF0aFZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gcGF0aFZhbDtcclxuXHJcbiAgICBwYXRoVmFsID0gcGF0aFZhbFtrZXkxXTtcclxuICAgIGlmIChwYXRoVmFsICYmIHBhdGhWYWwudGhlbikge1xyXG4gICAgICBpZiAoIShcIiQkdlwiIGluIHBhdGhWYWwpKSB7XHJcbiAgICAgICAgcHJvbWlzZSA9IHBhdGhWYWw7XHJcbiAgICAgICAgcHJvbWlzZS4kJHYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbCkgeyBwcm9taXNlLiQkdiA9IHZhbDsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcGF0aFZhbCA9IHBhdGhWYWwuJCR2O1xyXG4gICAgfVxyXG4gICAgaWYgKCFrZXkyIHx8IHBhdGhWYWwgPT09IG51bGwgfHwgcGF0aFZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gcGF0aFZhbDtcclxuXHJcbiAgICBwYXRoVmFsID0gcGF0aFZhbFtrZXkyXTtcclxuICAgIGlmIChwYXRoVmFsICYmIHBhdGhWYWwudGhlbikge1xyXG4gICAgICBpZiAoIShcIiQkdlwiIGluIHBhdGhWYWwpKSB7XHJcbiAgICAgICAgcHJvbWlzZSA9IHBhdGhWYWw7XHJcbiAgICAgICAgcHJvbWlzZS4kJHYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbCkgeyBwcm9taXNlLiQkdiA9IHZhbDsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcGF0aFZhbCA9IHBhdGhWYWwuJCR2O1xyXG4gICAgfVxyXG4gICAgaWYgKCFrZXkzIHx8IHBhdGhWYWwgPT09IG51bGwgfHwgcGF0aFZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gcGF0aFZhbDtcclxuXHJcbiAgICBwYXRoVmFsID0gcGF0aFZhbFtrZXkzXTtcclxuICAgIGlmIChwYXRoVmFsICYmIHBhdGhWYWwudGhlbikge1xyXG4gICAgICBpZiAoIShcIiQkdlwiIGluIHBhdGhWYWwpKSB7XHJcbiAgICAgICAgcHJvbWlzZSA9IHBhdGhWYWw7XHJcbiAgICAgICAgcHJvbWlzZS4kJHYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbCkgeyBwcm9taXNlLiQkdiA9IHZhbDsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcGF0aFZhbCA9IHBhdGhWYWwuJCR2O1xyXG4gICAgfVxyXG4gICAgaWYgKCFrZXk0IHx8IHBhdGhWYWwgPT09IG51bGwgfHwgcGF0aFZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gcGF0aFZhbDtcclxuXHJcbiAgICBwYXRoVmFsID0gcGF0aFZhbFtrZXk0XTtcclxuICAgIGlmIChwYXRoVmFsICYmIHBhdGhWYWwudGhlbikge1xyXG4gICAgICBpZiAoIShcIiQkdlwiIGluIHBhdGhWYWwpKSB7XHJcbiAgICAgICAgcHJvbWlzZSA9IHBhdGhWYWw7XHJcbiAgICAgICAgcHJvbWlzZS4kJHYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbCkgeyBwcm9taXNlLiQkdiA9IHZhbDsgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcGF0aFZhbCA9IHBhdGhWYWwuJCR2O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhdGhWYWw7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0dGVyRm4ocGF0aCwgY3NwLCBmdWxsRXhwKSB7XHJcbiAgaWYgKGdldHRlckZuQ2FjaGUuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcclxuICAgIHJldHVybiBnZXR0ZXJGbkNhY2hlW3BhdGhdO1xyXG4gIH1cclxuXHJcbiAgdmFyIHBhdGhLZXlzID0gcGF0aC5zcGxpdCgnLicpLFxyXG4gICAgICBwYXRoS2V5c0xlbmd0aCA9IHBhdGhLZXlzLmxlbmd0aCxcclxuICAgICAgZm47XHJcblxyXG4gIGlmIChjc3ApIHtcclxuICAgIGZuID0gKHBhdGhLZXlzTGVuZ3RoIDwgNilcclxuICAgICAgICA/IGNzcFNhZmVHZXR0ZXJGbihwYXRoS2V5c1swXSwgcGF0aEtleXNbMV0sIHBhdGhLZXlzWzJdLCBwYXRoS2V5c1szXSwgcGF0aEtleXNbNF0sIGZ1bGxFeHApXHJcbiAgICAgICAgOiBmdW5jdGlvbihzY29wZSwgbG9jYWxzKSB7XHJcbiAgICAgICAgICB2YXIgaSA9IDAsIHZhbDtcclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgdmFsID0gY3NwU2FmZUdldHRlckZuKFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhLZXlzW2krK10sIHBhdGhLZXlzW2krK10sIHBhdGhLZXlzW2krK10sIHBhdGhLZXlzW2krK10sIHBhdGhLZXlzW2krK10sIGZ1bGxFeHBcclxuICAgICAgICAgICAgICAgICAgKShzY29wZSwgbG9jYWxzKTtcclxuXHJcbiAgICAgICAgICAgIGxvY2FscyA9IHVuZGVmaW5lZDsgLy8gY2xlYXIgYWZ0ZXIgZmlyc3QgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgIHNjb3BlID0gdmFsO1xyXG4gICAgICAgICAgfSB3aGlsZSAoaSA8IHBhdGhLZXlzTGVuZ3RoKTtcclxuICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgY29kZSA9ICd2YXIgbCwgZm4sIHA7XFxuJztcclxuICAgIGZvckVhY2gocGF0aEtleXMsIGZ1bmN0aW9uKGtleSwgaW5kZXgpIHtcclxuICAgICAgZW5zdXJlU2FmZU1lbWJlck5hbWUoa2V5LCBmdWxsRXhwKTtcclxuICAgICAgY29kZSArPSAnaWYocyA9PT0gbnVsbCB8fCBzID09PSB1bmRlZmluZWQpIHJldHVybiBzO1xcbicgK1xyXG4gICAgICAgICAgICAgICdsPXM7XFxuJyArXHJcbiAgICAgICAgICAgICAgJ3M9JysgKGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaW1wbHkgZGVyZWZlcmVuY2UgJ3MnIG9uIGFueSAuZG90IG5vdGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICA/ICdzJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGlmIHdlIGFyZSBmaXJzdCB0aGVuIHdlIGNoZWNrIGxvY2FscyBmaXJzdCwgYW5kIGlmIHNvIHJlYWQgaXQgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICAgIDogJygoayYmay5oYXNPd25Qcm9wZXJ0eShcIicgKyBrZXkgKyAnXCIpKT9rOnMpJykgKyAnW1wiJyArIGtleSArICdcIl0nICsgJztcXG4nICtcclxuICAgICAgICAgICAgICAnaWYgKHMgJiYgcy50aGVuKSB7XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnIGlmICghKFwiJCR2XCIgaW4gcykpIHtcXG4nICtcclxuICAgICAgICAgICAgICAgICAgJyBwPXM7XFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICcgcC4kJHYgPSB1bmRlZmluZWQ7XFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICcgcC50aGVuKGZ1bmN0aW9uKHYpIHtwLiQkdj12O30pO1xcbicgK1xyXG4gICAgICAgICAgICAgICAgICAnfVxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyBzPXMuJCR2XFxuJyArXHJcbiAgICAgICAgICAgICAgJ31cXG4nO1xyXG4gICAgfSk7XHJcbiAgICBjb2RlICs9ICdyZXR1cm4gczsnO1xyXG4gICAgZm4gPSBGdW5jdGlvbigncycsICdrJywgY29kZSk7IC8vIHM9c2NvcGUsIGs9bG9jYWxzXHJcbiAgICBmbi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29kZTsgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiBnZXR0ZXJGbkNhY2hlW3BhdGhdID0gZm47XHJcbn1cclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAqIEBuYW1lIG5nLiRwYXJzZVxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIENvbnZlcnRzIEFuZ3VsYXIge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0gaW50byBhIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiAgIHZhciBnZXR0ZXIgPSAkcGFyc2UoJ3VzZXIubmFtZScpO1xyXG4gKiAgIHZhciBzZXR0ZXIgPSBnZXR0ZXIuYXNzaWduO1xyXG4gKiAgIHZhciBjb250ZXh0ID0ge3VzZXI6e25hbWU6J2FuZ3VsYXInfX07XHJcbiAqICAgdmFyIGxvY2FscyA9IHt1c2VyOntuYW1lOidsb2NhbCd9fTtcclxuICpcclxuICogICBleHBlY3QoZ2V0dGVyKGNvbnRleHQpKS50b0VxdWFsKCdhbmd1bGFyJyk7XHJcbiAqICAgc2V0dGVyKGNvbnRleHQsICduZXdWYWx1ZScpO1xyXG4gKiAgIGV4cGVjdChjb250ZXh0LnVzZXIubmFtZSkudG9FcXVhbCgnbmV3VmFsdWUnKTtcclxuICogICBleHBlY3QoZ2V0dGVyKGNvbnRleHQsIGxvY2FscykpLnRvRXF1YWwoJ2xvY2FsJyk7XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBTdHJpbmcgZXhwcmVzc2lvbiB0byBjb21waWxlLlxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oY29udGV4dCwgbG9jYWxzKX0gYSBmdW5jdGlvbiB3aGljaCByZXByZXNlbnRzIHRoZSBjb21waWxlZCBleHByZXNzaW9uOlxyXG4gKlxyXG4gKiAgICAqIGBjb250ZXh0YCDDouKCrOKAnCBge29iamVjdH1gIMOi4oKs4oCcIGFuIG9iamVjdCBhZ2FpbnN0IHdoaWNoIGFueSBleHByZXNzaW9ucyBlbWJlZGRlZCBpbiB0aGUgc3RyaW5nc1xyXG4gKiAgICAgIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCAodHlwaWNhbGx5IGEgc2NvcGUgb2JqZWN0KS5cclxuICogICAgKiBgbG9jYWxzYCDDouKCrOKAnCBge29iamVjdD19YCDDouKCrOKAnCBsb2NhbCB2YXJpYWJsZXMgY29udGV4dCBvYmplY3QsIHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyB2YWx1ZXMgaW5cclxuICogICAgICBgY29udGV4dGAuXHJcbiAqXHJcbiAqICAgIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBhbHNvIGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAqICAgICAgKiBgbGl0ZXJhbGAgw6LigqzigJwgYHtib29sZWFufWAgw6LigqzigJwgd2hldGhlciB0aGUgZXhwcmVzc2lvbidzIHRvcC1sZXZlbCBub2RlIGlzIGEgSmF2YVNjcmlwdFxyXG4gKiAgICAgICAgbGl0ZXJhbC5cclxuICogICAgICAqIGBjb25zdGFudGAgw6LigqzigJwgYHtib29sZWFufWAgw6LigqzigJwgd2hldGhlciB0aGUgZXhwcmVzc2lvbiBpcyBtYWRlIGVudGlyZWx5IG9mIEphdmFTY3JpcHRcclxuICogICAgICAgIGNvbnN0YW50IGxpdGVyYWxzLlxyXG4gKiAgICAgICogYGFzc2lnbmAgw6LigqzigJwgYHs/ZnVuY3Rpb24oY29udGV4dCwgdmFsdWUpfWAgw6LigqzigJwgaWYgdGhlIGV4cHJlc3Npb24gaXMgYXNzaWduYWJsZSwgdGhpcyB3aWxsIGJlXHJcbiAqICAgICAgICBzZXQgdG8gYSBmdW5jdGlvbiB0byBjaGFuZ2UgaXRzIHZhbHVlIG9uIHRoZSBnaXZlbiBjb250ZXh0LlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gJFBhcnNlUHJvdmlkZXIoKSB7XHJcbiAgdmFyIGNhY2hlID0ge307XHJcbiAgdGhpcy4kZ2V0ID0gWyckZmlsdGVyJywgJyRzbmlmZmVyJywgZnVuY3Rpb24oJGZpbHRlciwgJHNuaWZmZXIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihleHApIHtcclxuICAgICAgc3dpdGNoKHR5cGVvZiBleHApIHtcclxuICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmhhc093blByb3BlcnR5KGV4cClcclxuICAgICAgICAgICAgPyBjYWNoZVtleHBdXHJcbiAgICAgICAgICAgIDogY2FjaGVbZXhwXSA9ICBwYXJzZXIoZXhwLCBmYWxzZSwgJGZpbHRlciwgJHNuaWZmZXIuY3NwKTtcclxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcbiAgICAgICAgICByZXR1cm4gZXhwO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBzZXJ2aWNlXHJcbiAqIEBuYW1lIG5nLiRxXHJcbiAqIEByZXF1aXJlcyAkcm9vdFNjb3BlXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIHByb21pc2UvZGVmZXJyZWQgaW1wbGVtZW50YXRpb24gaW5zcGlyZWQgYnkgW0tyaXMgS293YWwncyBRXShodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EpLlxyXG4gKlxyXG4gKiBbVGhlIENvbW1vbkpTIFByb21pc2UgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1Byb21pc2VzKSBkZXNjcmliZXMgYSBwcm9taXNlIGFzIGFuXHJcbiAqIGludGVyZmFjZSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSByZXN1bHQgb2YgYW4gYWN0aW9uIHRoYXQgaXNcclxuICogcGVyZm9ybWVkIGFzeW5jaHJvbm91c2x5LCBhbmQgbWF5IG9yIG1heSBub3QgYmUgZmluaXNoZWQgYXQgYW55IGdpdmVuIHBvaW50IGluIHRpbWUuXHJcbiAqXHJcbiAqIEZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIGRlYWxpbmcgd2l0aCBlcnJvciBoYW5kbGluZywgZGVmZXJyZWQgYW5kIHByb21pc2UgQVBJcyBhcmUgdG9cclxuICogYXN5bmNocm9ub3VzIHByb2dyYW1taW5nIHdoYXQgYHRyeWAsIGBjYXRjaGAgYW5kIGB0aHJvd2Aga2V5d29yZHMgYXJlIHRvIHN5bmNocm9ub3VzIHByb2dyYW1taW5nLlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiAgIC8vIGZvciB0aGUgcHVycG9zZSBvZiB0aGlzIGV4YW1wbGUgbGV0J3MgYXNzdW1lIHRoYXQgdmFyaWFibGVzIGAkcWAgYW5kIGBzY29wZWAgYXJlXHJcbiAqICAgLy8gYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGUgKHRoZXkgY291bGQgaGF2ZSBiZWVuIGluamVjdGVkIG9yIHBhc3NlZCBpbikuXHJcbiAqXHJcbiAqICAgZnVuY3Rpb24gYXN5bmNHcmVldChuYW1lKSB7XHJcbiAqICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xyXG4gKlxyXG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICogICAgICAgLy8gc2luY2UgdGhpcyBmbiBleGVjdXRlcyBhc3luYyBpbiBhIGZ1dHVyZSB0dXJuIG9mIHRoZSBldmVudCBsb29wLCB3ZSBuZWVkIHRvIHdyYXBcclxuICogICAgICAgLy8gb3VyIGNvZGUgaW50byBhbiAkYXBwbHkgY2FsbCBzbyB0aGF0IHRoZSBtb2RlbCBjaGFuZ2VzIGFyZSBwcm9wZXJseSBvYnNlcnZlZC5cclxuICogICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgICAgIGRlZmVycmVkLm5vdGlmeSgnQWJvdXQgdG8gZ3JlZXQgJyArIG5hbWUgKyAnLicpO1xyXG4gKlxyXG4gKiAgICAgICAgIGlmIChva1RvR3JlZXQobmFtZSkpIHtcclxuICogICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoJ0hlbGxvLCAnICsgbmFtZSArICchJyk7XHJcbiAqICAgICAgICAgfSBlbHNlIHtcclxuICogICAgICAgICAgIGRlZmVycmVkLnJlamVjdCgnR3JlZXRpbmcgJyArIG5hbWUgKyAnIGlzIG5vdCBhbGxvd2VkLicpO1xyXG4gKiAgICAgICAgIH1cclxuICogICAgICAgfSk7XHJcbiAqICAgICB9LCAxMDAwKTtcclxuICpcclxuICogICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gKiAgIH1cclxuICpcclxuICogICB2YXIgcHJvbWlzZSA9IGFzeW5jR3JlZXQoJ1JvYmluIEhvb2QnKTtcclxuICogICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZ3JlZXRpbmcpIHtcclxuICogICAgIGFsZXJ0KCdTdWNjZXNzOiAnICsgZ3JlZXRpbmcpO1xyXG4gKiAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gKiAgICAgYWxlcnQoJ0ZhaWxlZDogJyArIHJlYXNvbik7XHJcbiAqICAgfSwgZnVuY3Rpb24odXBkYXRlKSB7XHJcbiAqICAgICBhbGVydCgnR290IG5vdGlmaWNhdGlvbjogJyArIHVwZGF0ZSk7XHJcbiAqICAgfSk7XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBBdCBmaXJzdCBpdCBtaWdodCBub3QgYmUgb2J2aW91cyB3aHkgdGhpcyBleHRyYSBjb21wbGV4aXR5IGlzIHdvcnRoIHRoZSB0cm91YmxlLiBUaGUgcGF5b2ZmXHJcbiAqIGNvbWVzIGluIHRoZSB3YXkgb2ZcclxuICogW2d1YXJhbnRlZXMgdGhhdCBwcm9taXNlIGFuZCBkZWZlcnJlZCBBUElzIG1ha2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvdW5jb21tb25qcy9ibG9iL21hc3Rlci9wcm9taXNlcy9zcGVjaWZpY2F0aW9uLm1kKS5cclxuICpcclxuICogQWRkaXRpb25hbGx5IHRoZSBwcm9taXNlIGFwaSBhbGxvd3MgZm9yIGNvbXBvc2l0aW9uIHRoYXQgaXMgdmVyeSBoYXJkIHRvIGRvIHdpdGggdGhlXHJcbiAqIHRyYWRpdGlvbmFsIGNhbGxiYWNrIChbQ1BTXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbnRpbnVhdGlvbi1wYXNzaW5nX3N0eWxlKSkgYXBwcm9hY2guXHJcbiAqIEZvciBtb3JlIG9uIHRoaXMgcGxlYXNlIHNlZSB0aGUgW1EgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xKSBlc3BlY2lhbGx5IHRoZVxyXG4gKiBzZWN0aW9uIG9uIHNlcmlhbCBvciBwYXJhbGxlbCBqb2luaW5nIG9mIHByb21pc2VzLlxyXG4gKlxyXG4gKlxyXG4gKiAjIFRoZSBEZWZlcnJlZCBBUElcclxuICpcclxuICogQSBuZXcgaW5zdGFuY2Ugb2YgZGVmZXJyZWQgaXMgY29uc3RydWN0ZWQgYnkgY2FsbGluZyBgJHEuZGVmZXIoKWAuXHJcbiAqXHJcbiAqIFRoZSBwdXJwb3NlIG9mIHRoZSBkZWZlcnJlZCBvYmplY3QgaXMgdG8gZXhwb3NlIHRoZSBhc3NvY2lhdGVkIFByb21pc2UgaW5zdGFuY2UgYXMgd2VsbCBhcyBBUElzXHJcbiAqIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHNpZ25hbGluZyB0aGUgc3VjY2Vzc2Z1bCBvciB1bnN1Y2Nlc3NmdWwgY29tcGxldGlvbiwgYXMgd2VsbCBhcyB0aGUgc3RhdHVzXHJcbiAqIG9mIHRoZSB0YXNrLlxyXG4gKlxyXG4gKiAqKk1ldGhvZHMqKlxyXG4gKlxyXG4gKiAtIGByZXNvbHZlKHZhbHVlKWAgw6LigqzigJwgcmVzb2x2ZXMgdGhlIGRlcml2ZWQgcHJvbWlzZSB3aXRoIHRoZSBgdmFsdWVgLiBJZiB0aGUgdmFsdWUgaXMgYSByZWplY3Rpb25cclxuICogICBjb25zdHJ1Y3RlZCB2aWEgYCRxLnJlamVjdGAsIHRoZSBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgaW5zdGVhZC5cclxuICogLSBgcmVqZWN0KHJlYXNvbilgIMOi4oKs4oCcIHJlamVjdHMgdGhlIGRlcml2ZWQgcHJvbWlzZSB3aXRoIHRoZSBgcmVhc29uYC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvXHJcbiAqICAgcmVzb2x2aW5nIGl0IHdpdGggYSByZWplY3Rpb24gY29uc3RydWN0ZWQgdmlhIGAkcS5yZWplY3RgLlxyXG4gKiAtIGBub3RpZnkodmFsdWUpYCAtIHByb3ZpZGVzIHVwZGF0ZXMgb24gdGhlIHN0YXR1cyBvZiB0aGUgcHJvbWlzZXMgZXhlY3V0aW9uLiBUaGlzIG1heSBiZSBjYWxsZWRcclxuICogICBtdWx0aXBsZSB0aW1lcyBiZWZvcmUgdGhlIHByb21pc2UgaXMgZWl0aGVyIHJlc29sdmVkIG9yIHJlamVjdGVkLlxyXG4gKlxyXG4gKiAqKlByb3BlcnRpZXMqKlxyXG4gKlxyXG4gKiAtIHByb21pc2Ugw6LigqzigJwgYHtQcm9taXNlfWAgw6LigqzigJwgcHJvbWlzZSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZGVmZXJyZWQuXHJcbiAqXHJcbiAqXHJcbiAqICMgVGhlIFByb21pc2UgQVBJXHJcbiAqXHJcbiAqIEEgbmV3IHByb21pc2UgaW5zdGFuY2UgaXMgY3JlYXRlZCB3aGVuIGEgZGVmZXJyZWQgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgY2FuIGJlIHJldHJpZXZlZCBieVxyXG4gKiBjYWxsaW5nIGBkZWZlcnJlZC5wcm9taXNlYC5cclxuICpcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhlIHByb21pc2Ugb2JqZWN0IGlzIHRvIGFsbG93IGZvciBpbnRlcmVzdGVkIHBhcnRpZXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcmVzdWx0XHJcbiAqIG9mIHRoZSBkZWZlcnJlZCB0YXNrIHdoZW4gaXQgY29tcGxldGVzLlxyXG4gKlxyXG4gKiAqKk1ldGhvZHMqKlxyXG4gKlxyXG4gKiAtIGB0aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaywgbm90aWZ5Q2FsbGJhY2spYCDDouKCrOKAnCByZWdhcmRsZXNzIG9mIHdoZW4gdGhlIHByb21pc2Ugd2FzIG9yXHJcbiAqICAgd2lsbCBiZSByZXNvbHZlZCBvciByZWplY3RlZCwgYHRoZW5gIGNhbGxzIG9uZSBvZiB0aGUgc3VjY2VzcyBvciBlcnJvciBjYWxsYmFja3MgYXN5bmNocm9ub3VzbHlcclxuICogICBhcyBzb29uIGFzIHRoZSByZXN1bHQgaXMgYXZhaWxhYmxlLiBUaGUgY2FsbGJhY2tzIGFyZSBjYWxsZWQgd2l0aCBhIHNpbmdsZSBhcmd1bWVudDogdGhlIHJlc3VsdFxyXG4gKiAgIG9yIHJlamVjdGlvbiByZWFzb24uIEFkZGl0aW9uYWxseSwgdGhlIG5vdGlmeSBjYWxsYmFjayBtYXkgYmUgY2FsbGVkIHplcm8gb3IgbW9yZSB0aW1lcyB0b1xyXG4gKiAgIHByb3ZpZGUgYSBwcm9ncmVzcyBpbmRpY2F0aW9uLCBiZWZvcmUgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuXHJcbiAqXHJcbiAqICAgVGhpcyBtZXRob2QgKnJldHVybnMgYSBuZXcgcHJvbWlzZSogd2hpY2ggaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgdmlhIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlXHJcbiAqICAgYHN1Y2Nlc3NDYWxsYmFja2AsIGBlcnJvckNhbGxiYWNrYC4gSXQgYWxzbyBub3RpZmllcyB2aWEgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYG5vdGlmeUNhbGxiYWNrYFxyXG4gKiAgIG1ldGhvZC4gVGhlIHByb21pc2UgY2FuIG5vdCBiZSByZXNvbHZlZCBvciByZWplY3RlZCBmcm9tIHRoZSBub3RpZnlDYWxsYmFjayBtZXRob2QuXHJcbiAqXHJcbiAqIC0gYGNhdGNoKGVycm9yQ2FsbGJhY2spYCDDouKCrOKAnCBzaG9ydGhhbmQgZm9yIGBwcm9taXNlLnRoZW4obnVsbCwgZXJyb3JDYWxsYmFjaylgXHJcbiAqXHJcbiAqIC0gYGZpbmFsbHkoY2FsbGJhY2spYCDDouKCrOKAnCBhbGxvd3MgeW91IHRvIG9ic2VydmUgZWl0aGVyIHRoZSBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gb2YgYSBwcm9taXNlLFxyXG4gKiAgIGJ1dCB0byBkbyBzbyB3aXRob3V0IG1vZGlmeWluZyB0aGUgZmluYWwgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIHRvIHJlbGVhc2UgcmVzb3VyY2VzIG9yIGRvIHNvbWVcclxuICogICBjbGVhbi11cCB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgd2hldGhlciB0aGUgcHJvbWlzZSB3YXMgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQuIFNlZSB0aGUgW2Z1bGxcclxuICogICBzcGVjaWZpY2F0aW9uXShodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3Evd2lraS9BUEktUmVmZXJlbmNlI3Byb21pc2VmaW5hbGx5Y2FsbGJhY2spIGZvclxyXG4gKiAgIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqICAgQmVjYXVzZSBgZmluYWxseWAgaXMgYSByZXNlcnZlZCB3b3JkIGluIEphdmFTY3JpcHQgYW5kIHJlc2VydmVkIGtleXdvcmRzIGFyZSBub3Qgc3VwcG9ydGVkIGFzXHJcbiAqICAgcHJvcGVydHkgbmFtZXMgYnkgRVMzLCB5b3UnbGwgbmVlZCB0byBpbnZva2UgdGhlIG1ldGhvZCBsaWtlIGBwcm9taXNlWydmaW5hbGx5J10oY2FsbGJhY2spYCB0b1xyXG4gKiAgIG1ha2UgeW91ciBjb2RlIElFOCBjb21wYXRpYmxlLlxyXG4gKlxyXG4gKiAjIENoYWluaW5nIHByb21pc2VzXHJcbiAqXHJcbiAqIEJlY2F1c2UgY2FsbGluZyB0aGUgYHRoZW5gIG1ldGhvZCBvZiBhIHByb21pc2UgcmV0dXJucyBhIG5ldyBkZXJpdmVkIHByb21pc2UsIGl0IGlzIGVhc2lseSBwb3NzaWJsZVxyXG4gKiB0byBjcmVhdGUgYSBjaGFpbiBvZiBwcm9taXNlczpcclxuICpcclxuICogPHByZT5cclxuICogICBwcm9taXNlQiA9IHByb21pc2VBLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAqICAgICByZXR1cm4gcmVzdWx0ICsgMTtcclxuICogICB9KTtcclxuICpcclxuICogICAvLyBwcm9taXNlQiB3aWxsIGJlIHJlc29sdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHByb21pc2VBIGlzIHJlc29sdmVkIGFuZCBpdHMgdmFsdWVcclxuICogICAvLyB3aWxsIGJlIHRoZSByZXN1bHQgb2YgcHJvbWlzZUEgaW5jcmVtZW50ZWQgYnkgMVxyXG4gKiA8L3ByZT5cclxuICpcclxuICogSXQgaXMgcG9zc2libGUgdG8gY3JlYXRlIGNoYWlucyBvZiBhbnkgbGVuZ3RoIGFuZCBzaW5jZSBhIHByb21pc2UgY2FuIGJlIHJlc29sdmVkIHdpdGggYW5vdGhlclxyXG4gKiBwcm9taXNlICh3aGljaCB3aWxsIGRlZmVyIGl0cyByZXNvbHV0aW9uIGZ1cnRoZXIpLCBpdCBpcyBwb3NzaWJsZSB0byBwYXVzZS9kZWZlciByZXNvbHV0aW9uIG9mXHJcbiAqIHRoZSBwcm9taXNlcyBhdCBhbnkgcG9pbnQgaW4gdGhlIGNoYWluLiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGltcGxlbWVudCBwb3dlcmZ1bCBBUElzIGxpa2VcclxuICogJGh0dHAncyByZXNwb25zZSBpbnRlcmNlcHRvcnMuXHJcbiAqXHJcbiAqXHJcbiAqICMgRGlmZmVyZW5jZXMgYmV0d2VlbiBLcmlzIEtvd2FsJ3MgUSBhbmQgJHFcclxuICpcclxuICogIFRoZXJlIGFyZSB0aHJlZSBtYWluIGRpZmZlcmVuY2VzOlxyXG4gKlxyXG4gKiAtICRxIGlzIGludGVncmF0ZWQgd2l0aCB0aGUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGV9IFNjb3BlIG1vZGVsIG9ic2VydmF0aW9uXHJcbiAqICAgbWVjaGFuaXNtIGluIGFuZ3VsYXIsIHdoaWNoIG1lYW5zIGZhc3RlciBwcm9wYWdhdGlvbiBvZiByZXNvbHV0aW9uIG9yIHJlamVjdGlvbiBpbnRvIHlvdXJcclxuICogICBtb2RlbHMgYW5kIGF2b2lkaW5nIHVubmVjZXNzYXJ5IGJyb3dzZXIgcmVwYWludHMsIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBmbGlja2VyaW5nIFVJLlxyXG4gKiAtICRxIHByb21pc2VzIGFyZSByZWNvZ25pemVkIGJ5IHRoZSB0ZW1wbGF0aW5nIGVuZ2luZSBpbiBhbmd1bGFyLCB3aGljaCBtZWFucyB0aGF0IGluIHRlbXBsYXRlc1xyXG4gKiAgIHlvdSBjYW4gdHJlYXQgcHJvbWlzZXMgYXR0YWNoZWQgdG8gYSBzY29wZSBhcyBpZiB0aGV5IHdlcmUgdGhlIHJlc3VsdGluZyB2YWx1ZXMuXHJcbiAqIC0gUSBoYXMgbWFueSBtb3JlIGZlYXR1cmVzIHRoYW4gJHEsIGJ1dCB0aGF0IGNvbWVzIGF0IGEgY29zdCBvZiBieXRlcy4gJHEgaXMgdGlueSwgYnV0IGNvbnRhaW5zXHJcbiAqICAgYWxsIHRoZSBpbXBvcnRhbnQgZnVuY3Rpb25hbGl0eSBuZWVkZWQgZm9yIGNvbW1vbiBhc3luYyB0YXNrcy5cclxuICpcclxuICogICMgVGVzdGluZ1xyXG4gKlxyXG4gKiAgPHByZT5cclxuICogICAgaXQoJ3Nob3VsZCBzaW11bGF0ZSBwcm9taXNlJywgaW5qZWN0KGZ1bmN0aW9uKCRxLCAkcm9vdFNjb3BlKSB7XHJcbiAqICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcclxuICogICAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XHJcbiAqICAgICAgdmFyIHJlc29sdmVkVmFsdWU7XHJcbiAqXHJcbiAqICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7IHJlc29sdmVkVmFsdWUgPSB2YWx1ZTsgfSk7XHJcbiAqICAgICAgZXhwZWN0KHJlc29sdmVkVmFsdWUpLnRvQmVVbmRlZmluZWQoKTtcclxuICpcclxuICogICAgICAvLyBTaW11bGF0ZSByZXNvbHZpbmcgb2YgcHJvbWlzZVxyXG4gKiAgICAgIGRlZmVycmVkLnJlc29sdmUoMTIzKTtcclxuICogICAgICAvLyBOb3RlIHRoYXQgdGhlICd0aGVuJyBmdW5jdGlvbiBkb2VzIG5vdCBnZXQgY2FsbGVkIHN5bmNocm9ub3VzbHkuXHJcbiAqICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIHdhbnQgdGhlIHByb21pc2UgQVBJIHRvIGFsd2F5cyBiZSBhc3luYywgd2hldGhlciBvciBub3RcclxuICogICAgICAvLyBpdCBnb3QgY2FsbGVkIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3VzbHkuXHJcbiAqICAgICAgZXhwZWN0KHJlc29sdmVkVmFsdWUpLnRvQmVVbmRlZmluZWQoKTtcclxuICpcclxuICogICAgICAvLyBQcm9wYWdhdGUgcHJvbWlzZSByZXNvbHV0aW9uIHRvICd0aGVuJyBmdW5jdGlvbnMgdXNpbmcgJGFwcGx5KCkuXHJcbiAqICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcclxuICogICAgICBleHBlY3QocmVzb2x2ZWRWYWx1ZSkudG9FcXVhbCgxMjMpO1xyXG4gKiAgICB9KTtcclxuICogIDwvcHJlPlxyXG4gKi9cclxuZnVuY3Rpb24gJFFQcm92aWRlcigpIHtcclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckcm9vdFNjb3BlJywgJyRleGNlcHRpb25IYW5kbGVyJywgZnVuY3Rpb24oJHJvb3RTY29wZSwgJGV4Y2VwdGlvbkhhbmRsZXIpIHtcclxuICAgIHJldHVybiBxRmFjdG9yeShmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAkcm9vdFNjb3BlLiRldmFsQXN5bmMoY2FsbGJhY2spO1xyXG4gICAgfSwgJGV4Y2VwdGlvbkhhbmRsZXIpO1xyXG4gIH1dO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBwcm9taXNlIG1hbmFnZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZnVuY3Rpb24pfSBuZXh0VGljayBGdW5jdGlvbiBmb3IgZXhlY3V0aW5nIGZ1bmN0aW9ucyBpbiB0aGUgbmV4dCB0dXJuLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopfSBleGNlcHRpb25IYW5kbGVyIEZ1bmN0aW9uIGludG8gd2hpY2ggdW5leHBlY3RlZCBleGNlcHRpb25zIGFyZSBwYXNzZWQgZm9yXHJcbiAqICAgICBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IFByb21pc2UgbWFuYWdlci5cclxuICovXHJcbmZ1bmN0aW9uIHFGYWN0b3J5KG5leHRUaWNrLCBleGNlcHRpb25IYW5kbGVyKSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvY1xyXG4gICAqIEBuYW1lIG5nLiRxI2RlZmVyXHJcbiAgICogQG1ldGhvZE9mIG5nLiRxXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogQ3JlYXRlcyBhIGBEZWZlcnJlZGAgb2JqZWN0IHdoaWNoIHJlcHJlc2VudHMgYSB0YXNrIHdoaWNoIHdpbGwgZmluaXNoIGluIHRoZSBmdXR1cmUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgZGVmZXJyZWQuXHJcbiAgICovXHJcbiAgdmFyIGRlZmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcGVuZGluZyA9IFtdLFxyXG4gICAgICAgIHZhbHVlLCBkZWZlcnJlZDtcclxuXHJcbiAgICBkZWZlcnJlZCA9IHtcclxuXHJcbiAgICAgIHJlc29sdmU6IGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gcGVuZGluZztcclxuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB2YWx1ZSA9IHJlZih2YWwpO1xyXG5cclxuICAgICAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIHZhciBjYWxsYmFjaztcclxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKGNhbGxiYWNrWzBdLCBjYWxsYmFja1sxXSwgY2FsbGJhY2tbMl0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuXHJcbiAgICAgIHJlamVjdDogZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZWplY3QocmVhc29uKSk7XHJcbiAgICAgIH0sXHJcblxyXG5cclxuICAgICAgbm90aWZ5OiBmdW5jdGlvbihwcm9ncmVzcykge1xyXG4gICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gcGVuZGluZztcclxuXHJcbiAgICAgICAgICBpZiAocGVuZGluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrO1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrWzJdKHByb2dyZXNzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcblxyXG4gICAgICBwcm9taXNlOiB7XHJcbiAgICAgICAgdGhlbjogZnVuY3Rpb24oY2FsbGJhY2ssIGVycmJhY2ssIHByb2dyZXNzYmFjaykge1xyXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGRlZmVyKCk7XHJcblxyXG4gICAgICAgICAgdmFyIHdyYXBwZWRDYWxsYmFjayA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoKGlzRnVuY3Rpb24oY2FsbGJhY2spID8gY2FsbGJhY2sgOiBkZWZhdWx0Q2FsbGJhY2spKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICB2YXIgd3JhcHBlZEVycmJhY2sgPSBmdW5jdGlvbihyZWFzb24pIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZSgoaXNGdW5jdGlvbihlcnJiYWNrKSA/IGVycmJhY2sgOiBkZWZhdWx0RXJyYmFjaykocmVhc29uKSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdC5yZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICB2YXIgd3JhcHBlZFByb2dyZXNzYmFjayA9IGZ1bmN0aW9uKHByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0Lm5vdGlmeSgoaXNGdW5jdGlvbihwcm9ncmVzc2JhY2spID8gcHJvZ3Jlc3NiYWNrIDogZGVmYXVsdENhbGxiYWNrKShwcm9ncmVzcykpO1xyXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICBleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHBlbmRpbmcucHVzaChbd3JhcHBlZENhbGxiYWNrLCB3cmFwcGVkRXJyYmFjaywgd3JhcHBlZFByb2dyZXNzYmFja10pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUudGhlbih3cmFwcGVkQ2FsbGJhY2ssIHdyYXBwZWRFcnJiYWNrLCB3cmFwcGVkUHJvZ3Jlc3NiYWNrKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnByb21pc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJjYXRjaFwiOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgXCJmaW5hbGx5XCI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblxyXG4gICAgICAgICAgZnVuY3Rpb24gbWFrZVByb21pc2UodmFsdWUsIHJlc29sdmVkKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBkZWZlcigpO1xyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5wcm9taXNlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrKHZhbHVlLCBpc1Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFja091dHB1dCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2tPdXRwdXQgPSAoY2FsbGJhY2sgfHxkZWZhdWx0Q2FsbGJhY2spKCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBtYWtlUHJvbWlzZShlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrT3V0cHV0ICYmIGlzRnVuY3Rpb24oY2FsbGJhY2tPdXRwdXQudGhlbikpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tPdXRwdXQudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUHJvbWlzZSh2YWx1ZSwgaXNSZXNvbHZlZCk7XHJcbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUHJvbWlzZShlcnJvciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldHVybiBtYWtlUHJvbWlzZSh2YWx1ZSwgaXNSZXNvbHZlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDYWxsYmFjayh2YWx1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2FsbGJhY2soZXJyb3IsIGZhbHNlKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gZGVmZXJyZWQ7XHJcbiAgfTtcclxuXHJcblxyXG4gIHZhciByZWYgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUudGhlbikpIHJldHVybiB2YWx1ZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRoZW46IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRlZmVyKCk7XHJcbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXN1bHQucmVzb2x2ZShjYWxsYmFjayh2YWx1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQucHJvbWlzZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jXHJcbiAgICogQG5hbWUgbmcuJHEjcmVqZWN0XHJcbiAgICogQG1ldGhvZE9mIG5nLiRxXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCBhcyByZWplY3RlZCB3aXRoIHRoZSBzcGVjaWZpZWQgYHJlYXNvbmAuIFRoaXMgYXBpIHNob3VsZCBiZVxyXG4gICAqIHVzZWQgdG8gZm9yd2FyZCByZWplY3Rpb24gaW4gYSBjaGFpbiBvZiBwcm9taXNlcy4gSWYgeW91IGFyZSBkZWFsaW5nIHdpdGggdGhlIGxhc3QgcHJvbWlzZSBpblxyXG4gICAqIGEgcHJvbWlzZSBjaGFpbiwgeW91IGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgaXQuXHJcbiAgICpcclxuICAgKiBXaGVuIGNvbXBhcmluZyBkZWZlcnJlZHMvcHJvbWlzZXMgdG8gdGhlIGZhbWlsaWFyIGJlaGF2aW9yIG9mIHRyeS9jYXRjaC90aHJvdywgdGhpbmsgb2ZcclxuICAgKiBgcmVqZWN0YCBhcyB0aGUgYHRocm93YCBrZXl3b3JkIGluIEphdmFTY3JpcHQuIFRoaXMgYWxzbyBtZWFucyB0aGF0IGlmIHlvdSBcImNhdGNoXCIgYW4gZXJyb3IgdmlhXHJcbiAgICogYSBwcm9taXNlIGVycm9yIGNhbGxiYWNrIGFuZCB5b3Ugd2FudCB0byBmb3J3YXJkIHRoZSBlcnJvciB0byB0aGUgcHJvbWlzZSBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICogY3VycmVudCBwcm9taXNlLCB5b3UgaGF2ZSB0byBcInJldGhyb3dcIiB0aGUgZXJyb3IgYnkgcmV0dXJuaW5nIGEgcmVqZWN0aW9uIGNvbnN0cnVjdGVkIHZpYVxyXG4gICAqIGByZWplY3RgLlxyXG4gICAqXHJcbiAgICogPHByZT5cclxuICAgKiAgIHByb21pc2VCID0gcHJvbWlzZUEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcclxuICAgKiAgICAgLy8gc3VjY2VzczogZG8gc29tZXRoaW5nIGFuZCByZXNvbHZlIHByb21pc2VCXHJcbiAgICogICAgIC8vICAgICAgICAgIHdpdGggdGhlIG9sZCBvciBhIG5ldyByZXN1bHRcclxuICAgKiAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgKiAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gICAqICAgICAvLyBlcnJvcjogaGFuZGxlIHRoZSBlcnJvciBpZiBwb3NzaWJsZSBhbmRcclxuICAgKiAgICAgLy8gICAgICAgIHJlc29sdmUgcHJvbWlzZUIgd2l0aCBuZXdQcm9taXNlT3JWYWx1ZSxcclxuICAgKiAgICAgLy8gICAgICAgIG90aGVyd2lzZSBmb3J3YXJkIHRoZSByZWplY3Rpb24gdG8gcHJvbWlzZUJcclxuICAgKiAgICAgaWYgKGNhbkhhbmRsZShyZWFzb24pKSB7XHJcbiAgICogICAgICAvLyBoYW5kbGUgdGhlIGVycm9yIGFuZCByZWNvdmVyXHJcbiAgICogICAgICByZXR1cm4gbmV3UHJvbWlzZU9yVmFsdWU7XHJcbiAgICogICAgIH1cclxuICAgKiAgICAgcmV0dXJuICRxLnJlamVjdChyZWFzb24pO1xyXG4gICAqICAgfSk7XHJcbiAgICogPC9wcmU+XHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHJlYXNvbiBDb25zdGFudCwgbWVzc2FnZSwgZXhjZXB0aW9uIG9yIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlamVjdGlvbiByZWFzb24uXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2FzIGFscmVhZHkgcmVzb2x2ZWQgYXMgcmVqZWN0ZWQgd2l0aCB0aGUgYHJlYXNvbmAuXHJcbiAgICovXHJcbiAgdmFyIHJlamVjdCA9IGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGhlbjogZnVuY3Rpb24oY2FsbGJhY2ssIGVycmJhY2spIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGVmZXIoKTtcclxuICAgICAgICBuZXh0VGljayhmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKChpc0Z1bmN0aW9uKGVycmJhY2spID8gZXJyYmFjayA6IGRlZmF1bHRFcnJiYWNrKShyZWFzb24pKTtcclxuICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICByZXN1bHQucmVqZWN0KGUpO1xyXG4gICAgICAgICAgICBleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQucHJvbWlzZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jXHJcbiAgICogQG5hbWUgbmcuJHEjd2hlblxyXG4gICAqIEBtZXRob2RPZiBuZy4kcVxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFdyYXBzIGFuIG9iamVjdCB0aGF0IG1pZ2h0IGJlIGEgdmFsdWUgb3IgYSAoM3JkIHBhcnR5KSB0aGVuLWFibGUgcHJvbWlzZSBpbnRvIGEgJHEgcHJvbWlzZS5cclxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCB0aGF0IG1pZ2h0IG9yIG1pZ2h0IG5vdCBiZSBhIHByb21pc2UsIG9yIGlmXHJcbiAgICogdGhlIHByb21pc2UgY29tZXMgZnJvbSBhIHNvdXJjZSB0aGF0IGNhbid0IGJlIHRydXN0ZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9yIGEgcHJvbWlzZVxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSBvZiB0aGUgcGFzc2VkIHZhbHVlIG9yIHByb21pc2VcclxuICAgKi9cclxuICB2YXIgd2hlbiA9IGZ1bmN0aW9uKHZhbHVlLCBjYWxsYmFjaywgZXJyYmFjaywgcHJvZ3Jlc3NiYWNrKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gZGVmZXIoKSxcclxuICAgICAgICBkb25lO1xyXG5cclxuICAgIHZhciB3cmFwcGVkQ2FsbGJhY2sgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihjYWxsYmFjaykgPyBjYWxsYmFjayA6IGRlZmF1bHRDYWxsYmFjaykodmFsdWUpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciB3cmFwcGVkRXJyYmFjayA9IGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihlcnJiYWNrKSA/IGVycmJhY2sgOiBkZWZhdWx0RXJyYmFjaykocmVhc29uKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgd3JhcHBlZFByb2dyZXNzYmFjayA9IGZ1bmN0aW9uKHByb2dyZXNzKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKHByb2dyZXNzYmFjaykgPyBwcm9ncmVzc2JhY2sgOiBkZWZhdWx0Q2FsbGJhY2spKHByb2dyZXNzKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJlZih2YWx1ZSkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XHJcbiAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgcmVzdWx0LnJlc29sdmUocmVmKHZhbHVlKS50aGVuKHdyYXBwZWRDYWxsYmFjaywgd3JhcHBlZEVycmJhY2ssIHdyYXBwZWRQcm9ncmVzc2JhY2spKTtcclxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XHJcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcclxuICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICByZXN1bHQucmVzb2x2ZSh3cmFwcGVkRXJyYmFjayhyZWFzb24pKTtcclxuICAgICAgfSwgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcclxuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xyXG4gICAgICAgIHJlc3VsdC5ub3RpZnkod3JhcHBlZFByb2dyZXNzYmFjayhwcm9ncmVzcykpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQucHJvbWlzZTtcclxuICB9O1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gZGVmYXVsdENhbGxiYWNrKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gZGVmYXVsdEVycmJhY2socmVhc29uKSB7XHJcbiAgICByZXR1cm4gcmVqZWN0KHJlYXNvbik7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jXHJcbiAgICogQG5hbWUgbmcuJHEjYWxsXHJcbiAgICogQG1ldGhvZE9mIG5nLiRxXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogQ29tYmluZXMgbXVsdGlwbGUgcHJvbWlzZXMgaW50byBhIHNpbmdsZSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiBhbGwgb2YgdGhlIGlucHV0XHJcbiAgICogcHJvbWlzZXMgYXJlIHJlc29sdmVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48UHJvbWlzZT58T2JqZWN0LjxQcm9taXNlPn0gcHJvbWlzZXMgQW4gYXJyYXkgb3IgaGFzaCBvZiBwcm9taXNlcy5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmV0dXJucyBhIHNpbmdsZSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIGFuIGFycmF5L2hhc2ggb2YgdmFsdWVzLFxyXG4gICAqICAgZWFjaCB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9taXNlIGF0IHRoZSBzYW1lIGluZGV4L2tleSBpbiB0aGUgYHByb21pc2VzYCBhcnJheS9oYXNoLiBJZiBhbnkgb2ZcclxuICAgKiAgIHRoZSBwcm9taXNlcyBpcyByZXNvbHZlZCB3aXRoIGEgcmVqZWN0aW9uLCB0aGlzIHJlc3VsdGluZyBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGVcclxuICAgKiAgIHNhbWUgcmVqZWN0aW9uLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xyXG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKSxcclxuICAgICAgICBjb3VudGVyID0gMCxcclxuICAgICAgICByZXN1bHRzID0gaXNBcnJheShwcm9taXNlcykgPyBbXSA6IHt9O1xyXG5cclxuICAgIGZvckVhY2gocHJvbWlzZXMsIGZ1bmN0aW9uKHByb21pc2UsIGtleSkge1xyXG4gICAgICBjb3VudGVyKys7XHJcbiAgICAgIHJlZihwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdHMuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuO1xyXG4gICAgICAgIHJlc3VsdHNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIGlmICghKC0tY291bnRlcikpIGRlZmVycmVkLnJlc29sdmUocmVzdWx0cyk7XHJcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xyXG4gICAgICAgIGlmIChyZXN1bHRzLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybjtcclxuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoY291bnRlciA9PT0gMCkge1xyXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGRlZmVyOiBkZWZlcixcclxuICAgIHJlamVjdDogcmVqZWN0LFxyXG4gICAgd2hlbjogd2hlbixcclxuICAgIGFsbDogYWxsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERFU0lHTiBOT1RFU1xyXG4gKlxyXG4gKiBUaGUgZGVzaWduIGRlY2lzaW9ucyBiZWhpbmQgdGhlIHNjb3BlIGFyZSBoZWF2aWx5IGZhdm9yZWQgZm9yIHNwZWVkIGFuZCBtZW1vcnkgY29uc3VtcHRpb24uXHJcbiAqXHJcbiAqIFRoZSB0eXBpY2FsIHVzZSBvZiBzY29wZSBpcyB0byB3YXRjaCB0aGUgZXhwcmVzc2lvbnMsIHdoaWNoIG1vc3Qgb2YgdGhlIHRpbWUgcmV0dXJuIHRoZSBzYW1lXHJcbiAqIHZhbHVlIGFzIGxhc3QgdGltZSBzbyB3ZSBvcHRpbWl6ZSB0aGUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBDbG9zdXJlcyBjb25zdHJ1Y3Rpb24gaXMgZXhwZW5zaXZlIGluIHRlcm1zIG9mIHNwZWVkIGFzIHdlbGwgYXMgbWVtb3J5OlxyXG4gKiAgIC0gTm8gY2xvc3VyZXMsIGluc3RlYWQgdXNlIHByb3RvdHlwaWNhbCBpbmhlcml0YW5jZSBmb3IgQVBJXHJcbiAqICAgLSBJbnRlcm5hbCBzdGF0ZSBuZWVkcyB0byBiZSBzdG9yZWQgb24gc2NvcGUgZGlyZWN0bHksIHdoaWNoIG1lYW5zIHRoYXQgcHJpdmF0ZSBzdGF0ZSBpc1xyXG4gKiAgICAgZXhwb3NlZCBhcyAkJF9fX18gcHJvcGVydGllc1xyXG4gKlxyXG4gKiBMb29wIG9wZXJhdGlvbnMgYXJlIG9wdGltaXplZCBieSB1c2luZyB3aGlsZShjb3VudC0tKSB7IC4uLiB9XHJcbiAqICAgLSB0aGlzIG1lYW5zIHRoYXQgaW4gb3JkZXIgdG8ga2VlcCB0aGUgc2FtZSBvcmRlciBvZiBleGVjdXRpb24gYXMgYWRkaXRpb24gd2UgaGF2ZSB0byBhZGRcclxuICogICAgIGl0ZW1zIHRvIHRoZSBhcnJheSBhdCB0aGUgYmVnaW5uaW5nIChzaGlmdCkgaW5zdGVhZCBvZiBhdCB0aGUgZW5kIChwdXNoKVxyXG4gKlxyXG4gKiBDaGlsZCBzY29wZXMgYXJlIGNyZWF0ZWQgYW5kIHJlbW92ZWQgb2Z0ZW5cclxuICogICAtIFVzaW5nIGFuIGFycmF5IHdvdWxkIGJlIHNsb3cgc2luY2UgaW5zZXJ0cyBpbiBtaWRkbGUgYXJlIGV4cGVuc2l2ZSBzbyB3ZSB1c2UgbGlua2VkIGxpc3RcclxuICpcclxuICogVGhlcmUgYXJlIGZldyB3YXRjaGVzIHRoZW4gYSBsb3Qgb2Ygb2JzZXJ2ZXJzLiBUaGlzIGlzIHdoeSB5b3UgZG9uJ3Qgd2FudCB0aGUgb2JzZXJ2ZXIgdG8gYmVcclxuICogaW1wbGVtZW50ZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHdhdGNoLiBXYXRjaCByZXF1aXJlcyByZXR1cm4gb2YgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24gd2hpY2hcclxuICogYXJlIGV4cGVuc2l2ZSB0byBjb25zdHJ1Y3QuXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRyb290U2NvcGVQcm92aWRlclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogUHJvdmlkZXIgZm9yIHRoZSAkcm9vdFNjb3BlIHNlcnZpY2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gKiBAbmFtZSBuZy4kcm9vdFNjb3BlUHJvdmlkZXIjZGlnZXN0VHRsXHJcbiAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlUHJvdmlkZXJcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFNldHMgdGhlIG51bWJlciBvZiBkaWdlc3QgaXRlcmF0aW9ucyB0aGUgc2NvcGUgc2hvdWxkIGF0dGVtcHQgdG8gZXhlY3V0ZSBiZWZvcmUgZ2l2aW5nIHVwIGFuZFxyXG4gKiBhc3N1bWluZyB0aGF0IHRoZSBtb2RlbCBpcyB1bnN0YWJsZS5cclxuICpcclxuICogVGhlIGN1cnJlbnQgZGVmYXVsdCBpcyAxMCBpdGVyYXRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXQgVGhlIG51bWJlciBvZiBkaWdlc3QgaXRlcmF0aW9ucy5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBvYmplY3RcclxuICogQG5hbWUgbmcuJHJvb3RTY29wZVxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogRXZlcnkgYXBwbGljYXRpb24gaGFzIGEgc2luZ2xlIHJvb3Qge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUgc2NvcGV9LlxyXG4gKiBBbGwgb3RoZXIgc2NvcGVzIGFyZSBjaGlsZCBzY29wZXMgb2YgdGhlIHJvb3Qgc2NvcGUuIFNjb3BlcyBwcm92aWRlIG1lY2hhbmlzbSBmb3Igd2F0Y2hpbmcgdGhlIG1vZGVsIGFuZCBwcm92aWRlXHJcbiAqIGV2ZW50IHByb2Nlc3NpbmcgbGlmZS1jeWNsZS4gU2VlIHtAbGluayBndWlkZS9zY29wZSBkZXZlbG9wZXIgZ3VpZGUgb24gc2NvcGVzfS5cclxuICovXHJcbmZ1bmN0aW9uICRSb290U2NvcGVQcm92aWRlcigpe1xyXG4gIHZhciBUVEwgPSAxMDtcclxuICB2YXIgJHJvb3RTY29wZU1pbkVyciA9IG1pbkVycignJHJvb3RTY29wZScpO1xyXG5cclxuICB0aGlzLmRpZ2VzdFR0bCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBUVEwgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBUVEw7XHJcbiAgfTtcclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckaW5qZWN0b3InLCAnJGV4Y2VwdGlvbkhhbmRsZXInLCAnJHBhcnNlJywgJyRicm93c2VyJyxcclxuICAgICAgZnVuY3Rpb24oICRpbmplY3RvciwgICAkZXhjZXB0aW9uSGFuZGxlciwgICAkcGFyc2UsICAgJGJyb3dzZXIpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogQSByb290IHNjb3BlIGNhbiBiZSByZXRyaWV2ZWQgdXNpbmcgdGhlIHtAbGluayBuZy4kcm9vdFNjb3BlICRyb290U2NvcGV9IGtleSBmcm9tIHRoZVxyXG4gICAgICoge0BsaW5rIEFVVE8uJGluamVjdG9yICRpbmplY3Rvcn0uIENoaWxkIHNjb3BlcyBhcmUgY3JlYXRlZCB1c2luZyB0aGVcclxuICAgICAqIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRuZXcgJG5ldygpfSBtZXRob2QuIChNb3N0IHNjb3BlcyBhcmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IHdoZW5cclxuICAgICAqIGNvbXBpbGVkIEhUTUwgdGVtcGxhdGUgaXMgZXhlY3V0ZWQuKVxyXG4gICAgICpcclxuICAgICAqIEhlcmUgaXMgYSBzaW1wbGUgc2NvcGUgc25pcHBldCB0byBzaG93IGhvdyB5b3UgY2FuIGludGVyYWN0IHdpdGggdGhlIHNjb3BlLlxyXG4gICAgICogPHByZT5cclxuICAgICAqIDxmaWxlIHNyYz1cIi4vdGVzdC9uZy9yb290U2NvcGVTcGVjLmpzXCIgdGFnPVwiZG9jczFcIiAvPlxyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKlxyXG4gICAgICogIyBJbmhlcml0YW5jZVxyXG4gICAgICogQSBzY29wZSBjYW4gaW5oZXJpdCBmcm9tIGEgcGFyZW50IHNjb3BlLCBhcyBpbiB0aGlzIGV4YW1wbGU6XHJcbiAgICAgKiA8cHJlPlxyXG4gICAgICAgICB2YXIgcGFyZW50ID0gJHJvb3RTY29wZTtcclxuICAgICAgICAgdmFyIGNoaWxkID0gcGFyZW50LiRuZXcoKTtcclxuXHJcbiAgICAgICAgIHBhcmVudC5zYWx1dGF0aW9uID0gXCJIZWxsb1wiO1xyXG4gICAgICAgICBjaGlsZC5uYW1lID0gXCJXb3JsZFwiO1xyXG4gICAgICAgICBleHBlY3QoY2hpbGQuc2FsdXRhdGlvbikudG9FcXVhbCgnSGVsbG8nKTtcclxuXHJcbiAgICAgICAgIGNoaWxkLnNhbHV0YXRpb24gPSBcIldlbGNvbWVcIjtcclxuICAgICAgICAgZXhwZWN0KGNoaWxkLnNhbHV0YXRpb24pLnRvRXF1YWwoJ1dlbGNvbWUnKTtcclxuICAgICAgICAgZXhwZWN0KHBhcmVudC5zYWx1dGF0aW9uKS50b0VxdWFsKCdIZWxsbycpO1xyXG4gICAgICogPC9wcmU+XHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uKCk+PX0gcHJvdmlkZXJzIE1hcCBvZiBzZXJ2aWNlIGZhY3Rvcnkgd2hpY2ggbmVlZCB0byBiZSBwcm92aWRlZFxyXG4gICAgICogICAgIGZvciB0aGUgY3VycmVudCBzY29wZS4gRGVmYXVsdHMgdG8ge0BsaW5rIG5nfS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsICo+PX0gaW5zdGFuY2VDYWNoZSBQcm92aWRlcyBwcmUtaW5zdGFudGlhdGVkIHNlcnZpY2VzIHdoaWNoIHNob3VsZFxyXG4gICAgICogICAgIGFwcGVuZC9vdmVycmlkZSBzZXJ2aWNlcyBwcm92aWRlZCBieSBgcHJvdmlkZXJzYC4gVGhpcyBpcyBoYW5keSB3aGVuIHVuaXQtdGVzdGluZyBhbmQgaGF2aW5nXHJcbiAgICAgKiAgICAgdGhlIG5lZWQgdG8gb3ZlcnJpZGUgYSBkZWZhdWx0IHNlcnZpY2UuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBOZXdseSBjcmVhdGVkIHNjb3BlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU2NvcGUoKSB7XHJcbiAgICAgIHRoaXMuJGlkID0gbmV4dFVpZCgpO1xyXG4gICAgICB0aGlzLiQkcGhhc2UgPSB0aGlzLiRwYXJlbnQgPSB0aGlzLiQkd2F0Y2hlcnMgPVxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLiQkbmV4dFNpYmxpbmcgPSB0aGlzLiQkcHJldlNpYmxpbmcgPVxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLiQkY2hpbGRIZWFkID0gdGhpcy4kJGNoaWxkVGFpbCA9IG51bGw7XHJcbiAgICAgIHRoaXNbJ3RoaXMnXSA9IHRoaXMuJHJvb3QgPSAgdGhpcztcclxuICAgICAgdGhpcy4kJGRlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLiQkYXN5bmNRdWV1ZSA9IFtdO1xyXG4gICAgICB0aGlzLiQkcG9zdERpZ2VzdFF1ZXVlID0gW107XHJcbiAgICAgIHRoaXMuJCRsaXN0ZW5lcnMgPSB7fTtcclxuICAgICAgdGhpcy4kJGlzb2xhdGVCaW5kaW5ncyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIHByb3BlcnR5XHJcbiAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRpZFxyXG4gICAgICogQHByb3BlcnR5T2YgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5pcXVlIHNjb3BlIElEIChtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgYWxwaGFudW1lcmljIHNlcXVlbmNlKSB1c2VmdWwgZm9yXHJcbiAgICAgKiAgIGRlYnVnZ2luZy5cclxuICAgICAqL1xyXG5cclxuXHJcbiAgICBTY29wZS5wcm90b3R5cGUgPSB7XHJcbiAgICAgIGNvbnN0cnVjdG9yOiBTY29wZSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRuZXdcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRyb290U2NvcGUuU2NvcGVcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBDcmVhdGVzIGEgbmV3IGNoaWxkIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIHNjb3BlfS5cclxuICAgICAgICpcclxuICAgICAgICogVGhlIHBhcmVudCBzY29wZSB3aWxsIHByb3BhZ2F0ZSB0aGUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdCAkZGlnZXN0KCl9IGFuZFxyXG4gICAgICAgKiB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkZGlnZXN0ICRkaWdlc3QoKX0gZXZlbnRzLiBUaGUgc2NvcGUgY2FuIGJlIHJlbW92ZWQgZnJvbSB0aGUgc2NvcGVcclxuICAgICAgICogaGllcmFyY2h5IHVzaW5nIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkZXN0cm95ICRkZXN0cm95KCl9LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkZGVzdHJveSAkZGVzdHJveSgpfSBtdXN0IGJlIGNhbGxlZCBvbiBhIHNjb3BlIHdoZW4gaXQgaXMgZGVzaXJlZCBmb3JcclxuICAgICAgICogdGhlIHNjb3BlIGFuZCBpdHMgY2hpbGQgc2NvcGVzIHRvIGJlIHBlcm1hbmVudGx5IGRldGFjaGVkIGZyb20gdGhlIHBhcmVudCBhbmQgdGh1cyBzdG9wXHJcbiAgICAgICAqIHBhcnRpY2lwYXRpbmcgaW4gbW9kZWwgY2hhbmdlIGRldGVjdGlvbiBhbmQgbGlzdGVuZXIgbm90aWZpY2F0aW9uIGJ5IGludm9raW5nLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzb2xhdGUgaWYgdHJ1ZSB0aGVuIHRoZSBzY29wZSBkb2VzIG5vdCBwcm90b3R5cGljYWxseSBpbmhlcml0IGZyb20gdGhlXHJcbiAgICAgICAqICAgICAgICAgcGFyZW50IHNjb3BlLiBUaGUgc2NvcGUgaXMgaXNvbGF0ZWQsIGFzIGl0IGNhbiBub3Qgc2VlIHBhcmVudCBzY29wZSBwcm9wZXJ0aWVzLlxyXG4gICAgICAgKiAgICAgICAgIFdoZW4gY3JlYXRpbmcgd2lkZ2V0cyBpdCBpcyB1c2VmdWwgZm9yIHRoZSB3aWRnZXQgdG8gbm90IGFjY2lkZW50YWxseSByZWFkIHBhcmVudFxyXG4gICAgICAgKiAgICAgICAgIHN0YXRlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbmV3bHkgY3JlYXRlZCBjaGlsZCBzY29wZS5cclxuICAgICAgICpcclxuICAgICAgICovXHJcbiAgICAgICRuZXc6IGZ1bmN0aW9uKGlzb2xhdGUpIHtcclxuICAgICAgICB2YXIgQ2hpbGQsXHJcbiAgICAgICAgICAgIGNoaWxkO1xyXG5cclxuICAgICAgICBpZiAoaXNvbGF0ZSkge1xyXG4gICAgICAgICAgY2hpbGQgPSBuZXcgU2NvcGUoKTtcclxuICAgICAgICAgIGNoaWxkLiRyb290ID0gdGhpcy4kcm9vdDtcclxuICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZXJlIGlzIGp1c3Qgb25lIGFzeW5jIHF1ZXVlIHBlciAkcm9vdFNjb3BlIGFuZCBpdCdzIGNoaWxkcmVuXHJcbiAgICAgICAgICBjaGlsZC4kJGFzeW5jUXVldWUgPSB0aGlzLiQkYXN5bmNRdWV1ZTtcclxuICAgICAgICAgIGNoaWxkLiQkcG9zdERpZ2VzdFF1ZXVlID0gdGhpcy4kJHBvc3REaWdlc3RRdWV1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgQ2hpbGQgPSBmdW5jdGlvbigpIHt9OyAvLyBzaG91bGQgYmUgYW5vbnltb3VzOyBUaGlzIGlzIHNvIHRoYXQgd2hlbiB0aGUgbWluaWZpZXIgbXVuZ2VzXHJcbiAgICAgICAgICAgIC8vIHRoZSBuYW1lIGl0IGRvZXMgbm90IGJlY29tZSByYW5kb20gc2V0IG9mIGNoYXJzLiBUaGVzZSB3aWxsIHRoZW4gc2hvdyB1cCBhcyBjbGFzc1xyXG4gICAgICAgICAgICAvLyBuYW1lIGluIHRoZSBkZWJ1Z2dlci5cclxuICAgICAgICAgIENoaWxkLnByb3RvdHlwZSA9IHRoaXM7XHJcbiAgICAgICAgICBjaGlsZCA9IG5ldyBDaGlsZCgpO1xyXG4gICAgICAgICAgY2hpbGQuJGlkID0gbmV4dFVpZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGlsZFsndGhpcyddID0gY2hpbGQ7XHJcbiAgICAgICAgY2hpbGQuJCRsaXN0ZW5lcnMgPSB7fTtcclxuICAgICAgICBjaGlsZC4kcGFyZW50ID0gdGhpcztcclxuICAgICAgICBjaGlsZC4kJHdhdGNoZXJzID0gY2hpbGQuJCRuZXh0U2libGluZyA9IGNoaWxkLiQkY2hpbGRIZWFkID0gY2hpbGQuJCRjaGlsZFRhaWwgPSBudWxsO1xyXG4gICAgICAgIGNoaWxkLiQkcHJldlNpYmxpbmcgPSB0aGlzLiQkY2hpbGRUYWlsO1xyXG4gICAgICAgIGlmICh0aGlzLiQkY2hpbGRIZWFkKSB7XHJcbiAgICAgICAgICB0aGlzLiQkY2hpbGRUYWlsLiQkbmV4dFNpYmxpbmcgPSBjaGlsZDtcclxuICAgICAgICAgIHRoaXMuJCRjaGlsZFRhaWwgPSBjaGlsZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy4kJGNoaWxkSGVhZCA9IHRoaXMuJCRjaGlsZFRhaWwgPSBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyR3YXRjaFxyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFJlZ2lzdGVycyBhIGBsaXN0ZW5lcmAgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgd2hlbmV2ZXIgdGhlIGB3YXRjaEV4cHJlc3Npb25gIGNoYW5nZXMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIC0gVGhlIGB3YXRjaEV4cHJlc3Npb25gIGlzIGNhbGxlZCBvbiBldmVyeSBjYWxsIHRvIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdCgpfSBhbmRcclxuICAgICAgICogICBzaG91bGQgcmV0dXJuIHRoZSB2YWx1ZSB3aGljaCB3aWxsIGJlIHdhdGNoZWQuIChTaW5jZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkZGlnZXN0ICRkaWdlc3QoKX1cclxuICAgICAgICogICByZXJ1bnMgd2hlbiBpdCBkZXRlY3RzIGNoYW5nZXMgdGhlIGB3YXRjaEV4cHJlc3Npb25gIGNhbiBleGVjdXRlIG11bHRpcGxlIHRpbWVzIHBlclxyXG4gICAgICAgKiAgIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdCgpfSBhbmQgc2hvdWxkIGJlIGlkZW1wb3RlbnQuKVxyXG4gICAgICAgKiAtIFRoZSBgbGlzdGVuZXJgIGlzIGNhbGxlZCBvbmx5IHdoZW4gdGhlIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgYHdhdGNoRXhwcmVzc2lvbmAgYW5kIHRoZVxyXG4gICAgICAgKiAgIHByZXZpb3VzIGNhbGwgdG8gYHdhdGNoRXhwcmVzc2lvbmAgYXJlIG5vdCBlcXVhbCAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSBpbml0aWFsIHJ1bixcclxuICAgICAgICogICBzZWUgYmVsb3cpLiBUaGUgaW5lcXVhbGl0eSBpcyBkZXRlcm1pbmVkIGFjY29yZGluZyB0b1xyXG4gICAgICAgKiAgIHtAbGluayBhbmd1bGFyLmVxdWFsc30gZnVuY3Rpb24uIFRvIHNhdmUgdGhlIHZhbHVlIG9mIHRoZSBvYmplY3QgZm9yIGxhdGVyIGNvbXBhcmlzb24sIHRoZVxyXG4gICAgICAgKiAgIHtAbGluayBhbmd1bGFyLmNvcHl9IGZ1bmN0aW9uIGlzIHVzZWQuIEl0IGFsc28gbWVhbnMgdGhhdCB3YXRjaGluZyBjb21wbGV4IG9wdGlvbnMgd2lsbFxyXG4gICAgICAgKiAgIGhhdmUgYWR2ZXJzZSBtZW1vcnkgYW5kIHBlcmZvcm1hbmNlIGltcGxpY2F0aW9ucy5cclxuICAgICAgICogLSBUaGUgd2F0Y2ggYGxpc3RlbmVyYCBtYXkgY2hhbmdlIHRoZSBtb2RlbCwgd2hpY2ggbWF5IHRyaWdnZXIgb3RoZXIgYGxpc3RlbmVyYHMgdG8gZmlyZS4gVGhpc1xyXG4gICAgICAgKiAgIGlzIGFjaGlldmVkIGJ5IHJlcnVubmluZyB0aGUgd2F0Y2hlcnMgdW50aWwgbm8gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQuIFRoZSByZXJ1biBpdGVyYXRpb25cclxuICAgICAgICogICBsaW1pdCBpcyAxMCB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AgZGVhZGxvY2suXHJcbiAgICAgICAqXHJcbiAgICAgICAqXHJcbiAgICAgICAqIElmIHlvdSB3YW50IHRvIGJlIG5vdGlmaWVkIHdoZW5ldmVyIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdH0gaXMgY2FsbGVkLFxyXG4gICAgICAgKiB5b3UgY2FuIHJlZ2lzdGVyIGEgYHdhdGNoRXhwcmVzc2lvbmAgZnVuY3Rpb24gd2l0aCBubyBgbGlzdGVuZXJgLiAoU2luY2UgYHdhdGNoRXhwcmVzc2lvbmBcclxuICAgICAgICogY2FuIGV4ZWN1dGUgbXVsdGlwbGUgdGltZXMgcGVyIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdH0gY3ljbGUgd2hlbiBhIGNoYW5nZSBpc1xyXG4gICAgICAgKiBkZXRlY3RlZCwgYmUgcHJlcGFyZWQgZm9yIG11bHRpcGxlIGNhbGxzIHRvIHlvdXIgbGlzdGVuZXIuKVxyXG4gICAgICAgKlxyXG4gICAgICAgKiBBZnRlciBhIHdhdGNoZXIgaXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBzY29wZSwgdGhlIGBsaXN0ZW5lcmAgZm4gaXMgY2FsbGVkIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgICAqICh2aWEge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGV2YWxBc3luYyAkZXZhbEFzeW5jfSkgdG8gaW5pdGlhbGl6ZSB0aGVcclxuICAgICAgICogd2F0Y2hlci4gSW4gcmFyZSBjYXNlcywgdGhpcyBpcyB1bmRlc2lyYWJsZSBiZWNhdXNlIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQgd2hlbiB0aGUgcmVzdWx0XHJcbiAgICAgICAqIG9mIGB3YXRjaEV4cHJlc3Npb25gIGRpZG4ndCBjaGFuZ2UuIFRvIGRldGVjdCB0aGlzIHNjZW5hcmlvIHdpdGhpbiB0aGUgYGxpc3RlbmVyYCBmbiwgeW91XHJcbiAgICAgICAqIGNhbiBjb21wYXJlIHRoZSBgbmV3VmFsYCBhbmQgYG9sZFZhbGAuIElmIHRoZXNlIHR3byB2YWx1ZXMgYXJlIGlkZW50aWNhbCAoYD09PWApIHRoZW4gdGhlXHJcbiAgICAgICAqIGxpc3RlbmVyIHdhcyBjYWxsZWQgZHVlIHRvIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgKlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAjIEV4YW1wbGVcclxuICAgICAgICogPHByZT5cclxuICAgICAgICAgICAvLyBsZXQncyBhc3N1bWUgdGhhdCBzY29wZSB3YXMgZGVwZW5kZW5jeSBpbmplY3RlZCBhcyB0aGUgJHJvb3RTY29wZVxyXG4gICAgICAgICAgIHZhciBzY29wZSA9ICRyb290U2NvcGU7XHJcbiAgICAgICAgICAgc2NvcGUubmFtZSA9ICdtaXNrbyc7XHJcbiAgICAgICAgICAgc2NvcGUuY291bnRlciA9IDA7XHJcblxyXG4gICAgICAgICAgIGV4cGVjdChzY29wZS5jb3VudGVyKS50b0VxdWFsKDApO1xyXG4gICAgICAgICAgIHNjb3BlLiR3YXRjaCgnbmFtZScsIGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgeyBzY29wZS5jb3VudGVyID0gc2NvcGUuY291bnRlciArIDE7IH0pO1xyXG4gICAgICAgICAgIGV4cGVjdChzY29wZS5jb3VudGVyKS50b0VxdWFsKDApO1xyXG5cclxuICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XHJcbiAgICAgICAgICAgLy8gbm8gdmFyaWFibGUgY2hhbmdlXHJcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmNvdW50ZXIpLnRvRXF1YWwoMCk7XHJcblxyXG4gICAgICAgICAgIHNjb3BlLm5hbWUgPSAnYWRhbSc7XHJcbiAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xyXG4gICAgICAgICAgIGV4cGVjdChzY29wZS5jb3VudGVyKS50b0VxdWFsKDEpO1xyXG4gICAgICAgKiA8L3ByZT5cclxuICAgICAgICpcclxuICAgICAgICpcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHsoZnVuY3Rpb24oKXxzdHJpbmcpfSB3YXRjaEV4cHJlc3Npb24gRXhwcmVzc2lvbiB0aGF0IGlzIGV2YWx1YXRlZCBvbiBlYWNoXHJcbiAgICAgICAqICAgIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdH0gY3ljbGUuIEEgY2hhbmdlIGluIHRoZSByZXR1cm4gdmFsdWUgdHJpZ2dlcnMgYVxyXG4gICAgICAgKiAgICBjYWxsIHRvIHRoZSBgbGlzdGVuZXJgLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAgICAtIGBzdHJpbmdgOiBFdmFsdWF0ZWQgYXMge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn1cclxuICAgICAgICogICAgLSBgZnVuY3Rpb24oc2NvcGUpYDogY2FsbGVkIHdpdGggY3VycmVudCBgc2NvcGVgIGFzIGEgcGFyYW1ldGVyLlxyXG4gICAgICAgKiBAcGFyYW0geyhmdW5jdGlvbigpfHN0cmluZyk9fSBsaXN0ZW5lciBDYWxsYmFjayBjYWxsZWQgd2hlbmV2ZXIgdGhlIHJldHVybiB2YWx1ZSBvZlxyXG4gICAgICAgKiAgIHRoZSBgd2F0Y2hFeHByZXNzaW9uYCBjaGFuZ2VzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAgICAtIGBzdHJpbmdgOiBFdmFsdWF0ZWQgYXMge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn1cclxuICAgICAgICogICAgLSBgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlLCBzY29wZSlgOiBjYWxsZWQgd2l0aCBjdXJyZW50IGFuZCBwcmV2aW91cyB2YWx1ZXMgYXMgcGFyYW1ldGVycy5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gb2JqZWN0RXF1YWxpdHkgQ29tcGFyZSBvYmplY3QgZm9yIGVxdWFsaXR5IHJhdGhlciB0aGFuIGZvciByZWZlcmVuY2UuXHJcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigpfSBSZXR1cm5zIGEgZGVyZWdpc3RyYXRpb24gZnVuY3Rpb24gZm9yIHRoaXMgbGlzdGVuZXIuXHJcbiAgICAgICAqL1xyXG4gICAgICAkd2F0Y2g6IGZ1bmN0aW9uKHdhdGNoRXhwLCBsaXN0ZW5lciwgb2JqZWN0RXF1YWxpdHkpIHtcclxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLFxyXG4gICAgICAgICAgICBnZXQgPSBjb21waWxlVG9Gbih3YXRjaEV4cCwgJ3dhdGNoJyksXHJcbiAgICAgICAgICAgIGFycmF5ID0gc2NvcGUuJCR3YXRjaGVycyxcclxuICAgICAgICAgICAgd2F0Y2hlciA9IHtcclxuICAgICAgICAgICAgICBmbjogbGlzdGVuZXIsXHJcbiAgICAgICAgICAgICAgbGFzdDogaW5pdFdhdGNoVmFsLFxyXG4gICAgICAgICAgICAgIGdldDogZ2V0LFxyXG4gICAgICAgICAgICAgIGV4cDogd2F0Y2hFeHAsXHJcbiAgICAgICAgICAgICAgZXE6ICEhb2JqZWN0RXF1YWxpdHlcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gaW4gdGhlIGNhc2UgdXNlciBwYXNzIHN0cmluZywgd2UgbmVlZCB0byBjb21waWxlIGl0LCBkbyB3ZSByZWFsbHkgbmVlZCB0aGlzID9cclxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICB2YXIgbGlzdGVuRm4gPSBjb21waWxlVG9GbihsaXN0ZW5lciB8fCBub29wLCAnbGlzdGVuZXInKTtcclxuICAgICAgICAgIHdhdGNoZXIuZm4gPSBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCwgc2NvcGUpIHtsaXN0ZW5GbihzY29wZSk7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygd2F0Y2hFeHAgPT0gJ3N0cmluZycgJiYgZ2V0LmNvbnN0YW50KSB7XHJcbiAgICAgICAgICB2YXIgb3JpZ2luYWxGbiA9IHdhdGNoZXIuZm47XHJcbiAgICAgICAgICB3YXRjaGVyLmZuID0gZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwsIHNjb3BlKSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsRm4uY2FsbCh0aGlzLCBuZXdWYWwsIG9sZFZhbCwgc2NvcGUpO1xyXG4gICAgICAgICAgICBhcnJheVJlbW92ZShhcnJheSwgd2F0Y2hlcik7XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFhcnJheSkge1xyXG4gICAgICAgICAgYXJyYXkgPSBzY29wZS4kJHdhdGNoZXJzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdlIHVzZSB1bnNoaWZ0IHNpbmNlIHdlIHVzZSBhIHdoaWxlIGxvb3AgaW4gJGRpZ2VzdCBmb3Igc3BlZWQuXHJcbiAgICAgICAgLy8gdGhlIHdoaWxlIGxvb3AgcmVhZHMgaW4gcmV2ZXJzZSBvcmRlci5cclxuICAgICAgICBhcnJheS51bnNoaWZ0KHdhdGNoZXIpO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBhcnJheVJlbW92ZShhcnJheSwgd2F0Y2hlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSxcclxuXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJHdhdGNoQ29sbGVjdGlvblxyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFNoYWxsb3cgd2F0Y2hlcyB0aGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYW5kIGZpcmVzIHdoZW5ldmVyIGFueSBvZiB0aGUgcHJvcGVydGllcyBjaGFuZ2VcclxuICAgICAgICogKGZvciBhcnJheXMgdGhpcyBpbXBsaWVzIHdhdGNoaW5nIHRoZSBhcnJheSBpdGVtcywgZm9yIG9iamVjdCBtYXBzIHRoaXMgaW1wbGllcyB3YXRjaGluZyB0aGUgcHJvcGVydGllcykuXHJcbiAgICAgICAqIElmIGEgY2hhbmdlIGlzIGRldGVjdGVkIHRoZSBgbGlzdGVuZXJgIGNhbGxiYWNrIGlzIGZpcmVkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAtIFRoZSBgb2JqYCBjb2xsZWN0aW9uIGlzIG9ic2VydmVkIHZpYSBzdGFuZGFyZCAkd2F0Y2ggb3BlcmF0aW9uIGFuZCBpcyBleGFtaW5lZCBvbiBldmVyeSBjYWxsIHRvICRkaWdlc3QoKSB0b1xyXG4gICAgICAgKiAgIHNlZSBpZiBhbnkgaXRlbXMgaGF2ZSBiZWVuIGFkZGVkLCByZW1vdmVkLCBvciBtb3ZlZC5cclxuICAgICAgICogLSBUaGUgYGxpc3RlbmVyYCBpcyBjYWxsZWQgd2hlbmV2ZXIgYW55dGhpbmcgd2l0aGluIHRoZSBgb2JqYCBoYXMgY2hhbmdlZC4gRXhhbXBsZXMgaW5jbHVkZSBhZGRpbmcgbmV3IGl0ZW1zXHJcbiAgICAgICAqICAgaW50byB0aGUgb2JqZWN0IG9yIGFycmF5LCByZW1vdmluZyBhbmQgbW92aW5nIGl0ZW1zIGFyb3VuZC5cclxuICAgICAgICpcclxuICAgICAgICpcclxuICAgICAgICogIyBFeGFtcGxlXHJcbiAgICAgICAqIDxwcmU+XHJcbiAgICAgICAgICAkc2NvcGUubmFtZXMgPSBbJ2lnb3InLCAnbWF0aWFzJywgJ21pc2tvJywgJ2phbWVzJ107XHJcbiAgICAgICAgICAkc2NvcGUuZGF0YUNvdW50ID0gNDtcclxuXHJcbiAgICAgICAgICAkc2NvcGUuJHdhdGNoQ29sbGVjdGlvbignbmFtZXMnLCBmdW5jdGlvbihuZXdOYW1lcywgb2xkTmFtZXMpIHtcclxuICAgICAgICAgICAgJHNjb3BlLmRhdGFDb3VudCA9IG5ld05hbWVzLmxlbmd0aDtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGV4cGVjdCgkc2NvcGUuZGF0YUNvdW50KS50b0VxdWFsKDQpO1xyXG4gICAgICAgICAgJHNjb3BlLiRkaWdlc3QoKTtcclxuXHJcbiAgICAgICAgICAvL3N0aWxsIGF0IDQgLi4uIG5vIGNoYW5nZXNcclxuICAgICAgICAgIGV4cGVjdCgkc2NvcGUuZGF0YUNvdW50KS50b0VxdWFsKDQpO1xyXG5cclxuICAgICAgICAgICRzY29wZS5uYW1lcy5wb3AoKTtcclxuICAgICAgICAgICRzY29wZS4kZGlnZXN0KCk7XHJcblxyXG4gICAgICAgICAgLy9ub3cgdGhlcmUncyBiZWVuIGEgY2hhbmdlXHJcbiAgICAgICAgICBleHBlY3QoJHNjb3BlLmRhdGFDb3VudCkudG9FcXVhbCgzKTtcclxuICAgICAgICogPC9wcmU+XHJcbiAgICAgICAqXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9uKHNjb3BlKX0gb2JqIEV2YWx1YXRlZCBhcyB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufS4gVGhlIGV4cHJlc3Npb24gdmFsdWVcclxuICAgICAgICogICAgc2hvdWxkIGV2YWx1YXRlIHRvIGFuIG9iamVjdCBvciBhbiBhcnJheSB3aGljaCBpcyBvYnNlcnZlZCBvbiBlYWNoXHJcbiAgICAgICAqICAgIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdH0gY3ljbGUuIEFueSBzaGFsbG93IGNoYW5nZSB3aXRoaW4gdGhlIGNvbGxlY3Rpb24gd2lsbCB0cmlnZ2VyXHJcbiAgICAgICAqICAgIGEgY2FsbCB0byB0aGUgYGxpc3RlbmVyYC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihuZXdDb2xsZWN0aW9uLCBvbGRDb2xsZWN0aW9uLCBzY29wZSl9IGxpc3RlbmVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBmaXJlZCB3aXRoIGJvdGhcclxuICAgICAgICogICAgdGhlIGBuZXdDb2xsZWN0aW9uYCBhbmQgYG9sZENvbGxlY3Rpb25gIGFzIHBhcmFtZXRlcnMuXHJcbiAgICAgICAqICAgIFRoZSBgbmV3Q29sbGVjdGlvbmAgb2JqZWN0IGlzIHRoZSBuZXdseSBtb2RpZmllZCBkYXRhIG9idGFpbmVkIGZyb20gdGhlIGBvYmpgIGV4cHJlc3Npb24gYW5kIHRoZVxyXG4gICAgICAgKiAgICBgb2xkQ29sbGVjdGlvbmAgb2JqZWN0IGlzIGEgY29weSBvZiB0aGUgZm9ybWVyIGNvbGxlY3Rpb24gZGF0YS5cclxuICAgICAgICogICAgVGhlIGBzY29wZWAgcmVmZXJzIHRvIHRoZSBjdXJyZW50IHNjb3BlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oKX0gUmV0dXJucyBhIGRlLXJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBmb3IgdGhpcyBsaXN0ZW5lci4gV2hlbiB0aGUgZGUtcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkXHJcbiAgICAgICAqIHRoZW4gdGhlIGludGVybmFsIHdhdGNoIG9wZXJhdGlvbiBpcyB0ZXJtaW5hdGVkLlxyXG4gICAgICAgKi9cclxuICAgICAgJHdhdGNoQ29sbGVjdGlvbjogZnVuY3Rpb24ob2JqLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgb2xkVmFsdWU7XHJcbiAgICAgICAgdmFyIG5ld1ZhbHVlO1xyXG4gICAgICAgIHZhciBjaGFuZ2VEZXRlY3RlZCA9IDA7XHJcbiAgICAgICAgdmFyIG9iakdldHRlciA9ICRwYXJzZShvYmopO1xyXG4gICAgICAgIHZhciBpbnRlcm5hbEFycmF5ID0gW107XHJcbiAgICAgICAgdmFyIGludGVybmFsT2JqZWN0ID0ge307XHJcbiAgICAgICAgdmFyIG9sZExlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uICR3YXRjaENvbGxlY3Rpb25XYXRjaCgpIHtcclxuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqR2V0dGVyKHNlbGYpO1xyXG4gICAgICAgICAgdmFyIG5ld0xlbmd0aCwga2V5O1xyXG5cclxuICAgICAgICAgIGlmICghaXNPYmplY3QobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgIGNoYW5nZURldGVjdGVkKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUxpa2UobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gaW50ZXJuYWxBcnJheSkge1xyXG4gICAgICAgICAgICAgIC8vIHdlIGFyZSB0cmFuc2l0aW9uaW5nIGZyb20gc29tZXRoaW5nIHdoaWNoIHdhcyBub3QgYW4gYXJyYXkgaW50byBhcnJheS5cclxuICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGludGVybmFsQXJyYXk7XHJcbiAgICAgICAgICAgICAgb2xkTGVuZ3RoID0gb2xkVmFsdWUubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RlZCsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBuZXdMZW5ndGggPSBuZXdWYWx1ZS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAob2xkTGVuZ3RoICE9PSBuZXdMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAvLyBpZiBsZW5ndGhzIGRvIG5vdCBtYXRjaCB3ZSBuZWVkIHRvIHRyaWdnZXIgY2hhbmdlIG5vdGlmaWNhdGlvblxyXG4gICAgICAgICAgICAgIGNoYW5nZURldGVjdGVkKys7XHJcbiAgICAgICAgICAgICAgb2xkVmFsdWUubGVuZ3RoID0gb2xkTGVuZ3RoID0gbmV3TGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvcHkgdGhlIGl0ZW1zIHRvIG9sZFZhbHVlIGFuZCBsb29rIGZvciBjaGFuZ2VzLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlW2ldICE9PSBuZXdWYWx1ZVtpXSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQrKztcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlW2ldID0gbmV3VmFsdWVbaV07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IGludGVybmFsT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgLy8gd2UgYXJlIHRyYW5zaXRpb25pbmcgZnJvbSBzb21ldGhpbmcgd2hpY2ggd2FzIG5vdCBhbiBvYmplY3QgaW50byBvYmplY3QuXHJcbiAgICAgICAgICAgICAgb2xkVmFsdWUgPSBpbnRlcm5hbE9iamVjdCA9IHt9O1xyXG4gICAgICAgICAgICAgIG9sZExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb3B5IHRoZSBpdGVtcyB0byBvbGRWYWx1ZSBhbmQgbG9vayBmb3IgY2hhbmdlcy5cclxuICAgICAgICAgICAgbmV3TGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgZm9yIChrZXkgaW4gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICBpZiAobmV3VmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbmV3TGVuZ3RoKys7XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWVba2V5XSAhPT0gbmV3VmFsdWVba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGVkKys7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVba2V5XSA9IG5ld1ZhbHVlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIG9sZExlbmd0aCsrO1xyXG4gICAgICAgICAgICAgICAgICBvbGRWYWx1ZVtrZXldID0gbmV3VmFsdWVba2V5XTtcclxuICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgIC8vIHdlIHVzZWQgdG8gaGF2ZSBtb3JlIGtleXMsIG5lZWQgdG8gZmluZCB0aGVtIGFuZCBkZXN0cm95IHRoZW0uXHJcbiAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQrKztcclxuICAgICAgICAgICAgICBmb3Ioa2V5IGluIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhbmV3VmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICBvbGRMZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgZGVsZXRlIG9sZFZhbHVlW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gY2hhbmdlRGV0ZWN0ZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiAkd2F0Y2hDb2xsZWN0aW9uQWN0aW9uKCkge1xyXG4gICAgICAgICAgbGlzdGVuZXIobmV3VmFsdWUsIG9sZFZhbHVlLCBzZWxmKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLiR3YXRjaCgkd2F0Y2hDb2xsZWN0aW9uV2F0Y2gsICR3YXRjaENvbGxlY3Rpb25BY3Rpb24pO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3RcclxuICAgICAgICogQG1ldGhvZE9mIG5nLiRyb290U2NvcGUuU2NvcGVcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKiBQcm9jZXNzZXMgYWxsIG9mIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkd2F0Y2ggd2F0Y2hlcnN9IG9mIHRoZSBjdXJyZW50IHNjb3BlIGFuZCBpdHMgY2hpbGRyZW4uXHJcbiAgICAgICAqIEJlY2F1c2UgYSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkd2F0Y2ggd2F0Y2hlcn0ncyBsaXN0ZW5lciBjYW4gY2hhbmdlIHRoZSBtb2RlbCwgdGhlXHJcbiAgICAgICAqIGAkZGlnZXN0KClgIGtlZXBzIGNhbGxpbmcgdGhlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyR3YXRjaCB3YXRjaGVyc30gdW50aWwgbm8gbW9yZSBsaXN0ZW5lcnMgYXJlXHJcbiAgICAgICAqIGZpcmluZy4gVGhpcyBtZWFucyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGdldCBpbnRvIGFuIGluZmluaXRlIGxvb3AuIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvd1xyXG4gICAgICAgKiBgJ01heGltdW0gaXRlcmF0aW9uIGxpbWl0IGV4Y2VlZGVkLidgIGlmIHRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyBleGNlZWRzIDEwLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBVc3VhbGx5IHlvdSBkb24ndCBjYWxsIGAkZGlnZXN0KClgIGRpcmVjdGx5IGluXHJcbiAgICAgICAqIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDb250cm9sbGVyIGNvbnRyb2xsZXJzfSBvciBpblxyXG4gICAgICAgKiB7QGxpbmsgbmcuJGNvbXBpbGVQcm92aWRlciNkaXJlY3RpdmUgZGlyZWN0aXZlc30uXHJcbiAgICAgICAqIEluc3RlYWQgYSBjYWxsIHRvIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRhcHBseSAkYXBwbHkoKX0gKHR5cGljYWxseSBmcm9tIHdpdGhpbiBhXHJcbiAgICAgICAqIHtAbGluayBuZy4kY29tcGlsZVByb3ZpZGVyI2RpcmVjdGl2ZSBkaXJlY3RpdmVzfSkgd2lsbCBmb3JjZSBhIGAkZGlnZXN0KClgLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBJZiB5b3Ugd2FudCB0byBiZSBub3RpZmllZCB3aGVuZXZlciBgJGRpZ2VzdCgpYCBpcyBjYWxsZWQsXHJcbiAgICAgICAqIHlvdSBjYW4gcmVnaXN0ZXIgYSBgd2F0Y2hFeHByZXNzaW9uYCBmdW5jdGlvbiAgd2l0aCB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkd2F0Y2ggJHdhdGNoKCl9XHJcbiAgICAgICAqIHdpdGggbm8gYGxpc3RlbmVyYC5cclxuICAgICAgICpcclxuICAgICAgICogWW91IG1heSBoYXZlIGEgbmVlZCB0byBjYWxsIGAkZGlnZXN0KClgIGZyb20gd2l0aGluIHVuaXQtdGVzdHMsIHRvIHNpbXVsYXRlIHRoZSBzY29wZVxyXG4gICAgICAgKiBsaWZlLWN5Y2xlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAjIEV4YW1wbGVcclxuICAgICAgICogPHByZT5cclxuICAgICAgICAgICB2YXIgc2NvcGUgPSAuLi47XHJcbiAgICAgICAgICAgc2NvcGUubmFtZSA9ICdtaXNrbyc7XHJcbiAgICAgICAgICAgc2NvcGUuY291bnRlciA9IDA7XHJcblxyXG4gICAgICAgICAgIGV4cGVjdChzY29wZS5jb3VudGVyKS50b0VxdWFsKDApO1xyXG4gICAgICAgICAgIHNjb3BlLiR3YXRjaCgnbmFtZScsIGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgc2NvcGUuY291bnRlciA9IHNjb3BlLmNvdW50ZXIgKyAxO1xyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIGV4cGVjdChzY29wZS5jb3VudGVyKS50b0VxdWFsKDApO1xyXG5cclxuICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XHJcbiAgICAgICAgICAgLy8gbm8gdmFyaWFibGUgY2hhbmdlXHJcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmNvdW50ZXIpLnRvRXF1YWwoMCk7XHJcblxyXG4gICAgICAgICAgIHNjb3BlLm5hbWUgPSAnYWRhbSc7XHJcbiAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xyXG4gICAgICAgICAgIGV4cGVjdChzY29wZS5jb3VudGVyKS50b0VxdWFsKDEpO1xyXG4gICAgICAgKiA8L3ByZT5cclxuICAgICAgICpcclxuICAgICAgICovXHJcbiAgICAgICRkaWdlc3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciB3YXRjaCwgdmFsdWUsIGxhc3QsXHJcbiAgICAgICAgICAgIHdhdGNoZXJzLFxyXG4gICAgICAgICAgICBhc3luY1F1ZXVlID0gdGhpcy4kJGFzeW5jUXVldWUsXHJcbiAgICAgICAgICAgIHBvc3REaWdlc3RRdWV1ZSA9IHRoaXMuJCRwb3N0RGlnZXN0UXVldWUsXHJcbiAgICAgICAgICAgIGxlbmd0aCxcclxuICAgICAgICAgICAgZGlydHksIHR0bCA9IFRUTCxcclxuICAgICAgICAgICAgbmV4dCwgY3VycmVudCwgdGFyZ2V0ID0gdGhpcyxcclxuICAgICAgICAgICAgd2F0Y2hMb2cgPSBbXSxcclxuICAgICAgICAgICAgbG9nSWR4LCBsb2dNc2c7XHJcblxyXG4gICAgICAgIGJlZ2luUGhhc2UoJyRkaWdlc3QnKTtcclxuXHJcbiAgICAgICAgZG8geyAvLyBcIndoaWxlIGRpcnR5XCIgbG9vcFxyXG4gICAgICAgICAgZGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgIGN1cnJlbnQgPSB0YXJnZXQ7XHJcblxyXG4gICAgICAgICAgd2hpbGUoYXN5bmNRdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjdXJyZW50LiRldmFsKGFzeW5jUXVldWUuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRvIHsgLy8gXCJ0cmF2ZXJzZSB0aGUgc2NvcGVzXCIgbG9vcFxyXG4gICAgICAgICAgICBpZiAoKHdhdGNoZXJzID0gY3VycmVudC4kJHdhdGNoZXJzKSkge1xyXG4gICAgICAgICAgICAgIC8vIHByb2Nlc3Mgb3VyIHdhdGNoZXNcclxuICAgICAgICAgICAgICBsZW5ndGggPSB3YXRjaGVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICB3YXRjaCA9IHdhdGNoZXJzW2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgIC8vIE1vc3QgY29tbW9uIHdhdGNoZXMgYXJlIG9uIHByaW1pdGl2ZXMsIGluIHdoaWNoIGNhc2Ugd2UgY2FuIHNob3J0XHJcbiAgICAgICAgICAgICAgICAgIC8vIGNpcmN1aXQgaXQgd2l0aCA9PT0gb3BlcmF0b3IsIG9ubHkgd2hlbiA9PT0gZmFpbHMgZG8gd2UgdXNlIC5lcXVhbHNcclxuICAgICAgICAgICAgICAgICAgaWYgKHdhdGNoICYmICh2YWx1ZSA9IHdhdGNoLmdldChjdXJyZW50KSkgIT09IChsYXN0ID0gd2F0Y2gubGFzdCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICEod2F0Y2guZXFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVxdWFscyh2YWx1ZSwgbGFzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA6ICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIGxhc3QgPT0gJ251bWJlcidcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBpc05hTih2YWx1ZSkgJiYgaXNOYU4obGFzdCkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB3YXRjaC5sYXN0ID0gd2F0Y2guZXEgPyBjb3B5KHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoLmZuKHZhbHVlLCAoKGxhc3QgPT09IGluaXRXYXRjaFZhbCkgPyB2YWx1ZSA6IGxhc3QpLCBjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHRsIDwgNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgbG9nSWR4ID0gNCAtIHR0bDtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmICghd2F0Y2hMb2dbbG9nSWR4XSkgd2F0Y2hMb2dbbG9nSWR4XSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgbG9nTXNnID0gKGlzRnVuY3Rpb24od2F0Y2guZXhwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdmbjogJyArICh3YXRjaC5leHAubmFtZSB8fCB3YXRjaC5leHAudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IHdhdGNoLmV4cDtcclxuICAgICAgICAgICAgICAgICAgICAgIGxvZ01zZyArPSAnOyBuZXdWYWw6ICcgKyB0b0pzb24odmFsdWUpICsgJzsgb2xkVmFsOiAnICsgdG9Kc29uKGxhc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2hMb2dbbG9nSWR4XS5wdXNoKGxvZ01zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW5zYW5pdHkgV2FybmluZzogc2NvcGUgZGVwdGgtZmlyc3QgdHJhdmVyc2FsXHJcbiAgICAgICAgICAgIC8vIHllcywgdGhpcyBjb2RlIGlzIGEgYml0IGNyYXp5LCBidXQgaXQgd29ya3MgYW5kIHdlIGhhdmUgdGVzdHMgdG8gcHJvdmUgaXQhXHJcbiAgICAgICAgICAgIC8vIHRoaXMgcGllY2Ugc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB0cmF2ZXJzYWwgaW4gJGJyb2FkY2FzdFxyXG4gICAgICAgICAgICBpZiAoIShuZXh0ID0gKGN1cnJlbnQuJCRjaGlsZEhlYWQgfHwgKGN1cnJlbnQgIT09IHRhcmdldCAmJiBjdXJyZW50LiQkbmV4dFNpYmxpbmcpKSkpIHtcclxuICAgICAgICAgICAgICB3aGlsZShjdXJyZW50ICE9PSB0YXJnZXQgJiYgIShuZXh0ID0gY3VycmVudC4kJG5leHRTaWJsaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuJHBhcmVudDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKChjdXJyZW50ID0gbmV4dCkpO1xyXG5cclxuICAgICAgICAgIGlmKGRpcnR5ICYmICEodHRsLS0pKSB7XHJcbiAgICAgICAgICAgIGNsZWFyUGhhc2UoKTtcclxuICAgICAgICAgICAgdGhyb3cgJHJvb3RTY29wZU1pbkVycignaW5mZGlnJyxcclxuICAgICAgICAgICAgICAgICd7MH0gJGRpZ2VzdCgpIGl0ZXJhdGlvbnMgcmVhY2hlZC4gQWJvcnRpbmchXFxuV2F0Y2hlcnMgZmlyZWQgaW4gdGhlIGxhc3QgNSBpdGVyYXRpb25zOiB7MX0nLFxyXG4gICAgICAgICAgICAgICAgVFRMLCB0b0pzb24od2F0Y2hMb2cpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChkaXJ0eSB8fCBhc3luY1F1ZXVlLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGNsZWFyUGhhc2UoKTtcclxuXHJcbiAgICAgICAgd2hpbGUocG9zdERpZ2VzdFF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcG9zdERpZ2VzdFF1ZXVlLnNoaWZ0KCkoKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZXZlbnRcclxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkZGVzdHJveVxyXG4gICAgICAgKiBAZXZlbnRPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgICAqIEBldmVudFR5cGUgYnJvYWRjYXN0IG9uIHNjb3BlIGJlaW5nIGRlc3Ryb3llZFxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogQnJvYWRjYXN0ZWQgd2hlbiBhIHNjb3BlIGFuZCBpdHMgY2hpbGRyZW4gYXJlIGJlaW5nIGRlc3Ryb3llZC5cclxuICAgICAgICpcclxuICAgICAgICogTm90ZSB0aGF0LCBpbiBBbmd1bGFySlMsIHRoZXJlIGlzIGFsc28gYSBgJGRlc3Ryb3lgIGpRdWVyeSBldmVudCwgd2hpY2ggY2FuIGJlIHVzZWQgdG9cclxuICAgICAgICogY2xlYW4gdXAgRE9NIGJpbmRpbmdzIGJlZm9yZSBhbiBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxyXG4gICAgICAgKi9cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkZGVzdHJveVxyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIFJlbW92ZXMgdGhlIGN1cnJlbnQgc2NvcGUgKGFuZCBhbGwgb2YgaXRzIGNoaWxkcmVuKSBmcm9tIHRoZSBwYXJlbnQgc2NvcGUuIFJlbW92YWwgaW1wbGllc1xyXG4gICAgICAgKiB0aGF0IGNhbGxzIHRvIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdCgpfSB3aWxsIG5vIGxvbmdlclxyXG4gICAgICAgKiBwcm9wYWdhdGUgdG8gdGhlIGN1cnJlbnQgc2NvcGUgYW5kIGl0cyBjaGlsZHJlbi4gUmVtb3ZhbCBhbHNvIGltcGxpZXMgdGhhdCB0aGUgY3VycmVudFxyXG4gICAgICAgKiBzY29wZSBpcyBlbGlnaWJsZSBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUaGUgYCRkZXN0cm95KClgIGlzIHVzdWFsbHkgdXNlZCBieSBkaXJlY3RpdmVzIHN1Y2ggYXNcclxuICAgICAgICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1JlcGVhdCBuZ1JlcGVhdH0gZm9yIG1hbmFnaW5nIHRoZVxyXG4gICAgICAgKiB1bnJvbGxpbmcgb2YgdGhlIGxvb3AuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEp1c3QgYmVmb3JlIGEgc2NvcGUgaXMgZGVzdHJveWVkIGEgYCRkZXN0cm95YCBldmVudCBpcyBicm9hZGNhc3RlZCBvbiB0aGlzIHNjb3BlLlxyXG4gICAgICAgKiBBcHBsaWNhdGlvbiBjb2RlIGNhbiByZWdpc3RlciBhIGAkZGVzdHJveWAgZXZlbnQgaGFuZGxlciB0aGF0IHdpbGwgZ2l2ZSBpdCBjaGFuY2UgdG9cclxuICAgICAgICogcGVyZm9ybSBhbnkgbmVjZXNzYXJ5IGNsZWFudXAuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIE5vdGUgdGhhdCwgaW4gQW5ndWxhckpTLCB0aGVyZSBpcyBhbHNvIGEgYCRkZXN0cm95YCBqUXVlcnkgZXZlbnQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvXHJcbiAgICAgICAqIGNsZWFuIHVwIERPTSBiaW5kaW5ncyBiZWZvcmUgYW4gZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cclxuICAgICAgICovXHJcbiAgICAgICRkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyB3ZSBjYW4ndCBkZXN0cm95IHRoZSByb290IHNjb3BlIG9yIGEgc2NvcGUgdGhhdCBoYXMgYmVlbiBhbHJlYWR5IGRlc3Ryb3llZFxyXG4gICAgICAgIGlmICgkcm9vdFNjb3BlID09IHRoaXMgfHwgdGhpcy4kJGRlc3Ryb3llZCkgcmV0dXJuO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XHJcblxyXG4gICAgICAgIHRoaXMuJGJyb2FkY2FzdCgnJGRlc3Ryb3knKTtcclxuICAgICAgICB0aGlzLiQkZGVzdHJveWVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmVudC4kJGNoaWxkSGVhZCA9PSB0aGlzKSBwYXJlbnQuJCRjaGlsZEhlYWQgPSB0aGlzLiQkbmV4dFNpYmxpbmc7XHJcbiAgICAgICAgaWYgKHBhcmVudC4kJGNoaWxkVGFpbCA9PSB0aGlzKSBwYXJlbnQuJCRjaGlsZFRhaWwgPSB0aGlzLiQkcHJldlNpYmxpbmc7XHJcbiAgICAgICAgaWYgKHRoaXMuJCRwcmV2U2libGluZykgdGhpcy4kJHByZXZTaWJsaW5nLiQkbmV4dFNpYmxpbmcgPSB0aGlzLiQkbmV4dFNpYmxpbmc7XHJcbiAgICAgICAgaWYgKHRoaXMuJCRuZXh0U2libGluZykgdGhpcy4kJG5leHRTaWJsaW5nLiQkcHJldlNpYmxpbmcgPSB0aGlzLiQkcHJldlNpYmxpbmc7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgaXMgYm9ndXMgY29kZSB0aGF0IHdvcmtzIGFyb3VuZCBDaHJvbWUncyBHQyBsZWFrXHJcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2lzc3Vlcy8xMzEzI2lzc3VlY29tbWVudC0xMDM3ODQ1MVxyXG4gICAgICAgIHRoaXMuJHBhcmVudCA9IHRoaXMuJCRuZXh0U2libGluZyA9IHRoaXMuJCRwcmV2U2libGluZyA9IHRoaXMuJCRjaGlsZEhlYWQgPVxyXG4gICAgICAgICAgICB0aGlzLiQkY2hpbGRUYWlsID0gbnVsbDtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkZXZhbFxyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIEV4ZWN1dGVzIHRoZSBgZXhwcmVzc2lvbmAgb24gdGhlIGN1cnJlbnQgc2NvcGUgcmV0dXJuaW5nIHRoZSByZXN1bHQuIEFueSBleGNlcHRpb25zIGluIHRoZVxyXG4gICAgICAgKiBleHByZXNzaW9uIGFyZSBwcm9wYWdhdGVkICh1bmNhdWdodCkuIFRoaXMgaXMgdXNlZnVsIHdoZW4gZXZhbHVhdGluZyBBbmd1bGFyIGV4cHJlc3Npb25zLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAjIEV4YW1wbGVcclxuICAgICAgICogPHByZT5cclxuICAgICAgICAgICB2YXIgc2NvcGUgPSBuZy4kcm9vdFNjb3BlLlNjb3BlKCk7XHJcbiAgICAgICAgICAgc2NvcGUuYSA9IDE7XHJcbiAgICAgICAgICAgc2NvcGUuYiA9IDI7XHJcblxyXG4gICAgICAgICAgIGV4cGVjdChzY29wZS4kZXZhbCgnYStiJykpLnRvRXF1YWwoMyk7XHJcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLiRldmFsKGZ1bmN0aW9uKHNjb3BlKXsgcmV0dXJuIHNjb3BlLmEgKyBzY29wZS5iOyB9KSkudG9FcXVhbCgzKTtcclxuICAgICAgICogPC9wcmU+XHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xmdW5jdGlvbigpKT19IGV4cHJlc3Npb24gQW4gYW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAgICAtIGBzdHJpbmdgOiBleGVjdXRlIHVzaW5nIHRoZSBydWxlcyBhcyBkZWZpbmVkIGluICB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufS5cclxuICAgICAgICogICAgLSBgZnVuY3Rpb24oc2NvcGUpYDogZXhlY3V0ZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgY3VycmVudCBgc2NvcGVgIHBhcmFtZXRlci5cclxuICAgICAgICpcclxuICAgICAgICogQHJldHVybnMgeyp9IFRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyB0aGUgZXhwcmVzc2lvbi5cclxuICAgICAgICovXHJcbiAgICAgICRldmFsOiBmdW5jdGlvbihleHByLCBsb2NhbHMpIHtcclxuICAgICAgICByZXR1cm4gJHBhcnNlKGV4cHIpKHRoaXMsIGxvY2Fscyk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJGV2YWxBc3luY1xyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIEV4ZWN1dGVzIHRoZSBleHByZXNzaW9uIG9uIHRoZSBjdXJyZW50IHNjb3BlIGF0IGEgbGF0ZXIgcG9pbnQgaW4gdGltZS5cclxuICAgICAgICpcclxuICAgICAgICogVGhlIGAkZXZhbEFzeW5jYCBtYWtlcyBubyBndWFyYW50ZWVzIGFzIHRvIHdoZW4gdGhlIGBleHByZXNzaW9uYCB3aWxsIGJlIGV4ZWN1dGVkLCBvbmx5IHRoYXQ6XHJcbiAgICAgICAqXHJcbiAgICAgICAqICAgLSBpdCB3aWxsIGV4ZWN1dGUgYWZ0ZXIgdGhlIGZ1bmN0aW9uIHRoYXQgc2NoZWR1bGUgdGhlIGV2YWx1YXRpb24gaXMgZG9uZSBydW5uaW5nIChwcmVmZXJhYmx5IGJlZm9yZSBET00gcmVuZGVyaW5nKS5cclxuICAgICAgICogICAtIGF0IGxlYXN0IG9uZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkZGlnZXN0ICRkaWdlc3QgY3ljbGV9IHdpbGwgYmUgcGVyZm9ybWVkIGFmdGVyIGBleHByZXNzaW9uYCBleGVjdXRpb24uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEFueSBleGNlcHRpb25zIGZyb20gdGhlIGV4ZWN1dGlvbiBvZiB0aGUgZXhwcmVzc2lvbiBhcmUgZm9yd2FyZGVkIHRvIHRoZVxyXG4gICAgICAgKiB7QGxpbmsgbmcuJGV4Y2VwdGlvbkhhbmRsZXIgJGV4Y2VwdGlvbkhhbmRsZXJ9IHNlcnZpY2UuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIF9fTm90ZTpfXyBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGAkZGlnZXN0YCBjeWNsZSwgYSBuZXcgJGRpZ2VzdCBjeWNsZSB3aWxsIGJlIHNjaGVkdWxlZC5cclxuICAgICAgICogSXQgaXMgaG93ZXZlciBlbmNvdXJhZ2VkIHRvIGFsd2F5cyBjYWxsIGNvZGUgdGhhdCBjaGFuZ2VzIHRoZSBtb2RlbCBmcm9tIHdpdGhpbmcgYW4gYCRhcHBseWAgY2FsbC5cclxuICAgICAgICogVGhhdCBpbmNsdWRlcyBjb2RlIGV2YWx1YXRlZCB2aWEgYCRldmFsQXN5bmNgLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0geyhzdHJpbmd8ZnVuY3Rpb24oKSk9fSBleHByZXNzaW9uIEFuIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZC5cclxuICAgICAgICpcclxuICAgICAgICogICAgLSBgc3RyaW5nYDogZXhlY3V0ZSB1c2luZyB0aGUgcnVsZXMgYXMgZGVmaW5lZCBpbiAge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0uXHJcbiAgICAgICAqICAgIC0gYGZ1bmN0aW9uKHNjb3BlKWA6IGV4ZWN1dGUgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGN1cnJlbnQgYHNjb3BlYCBwYXJhbWV0ZXIuXHJcbiAgICAgICAqXHJcbiAgICAgICAqL1xyXG4gICAgICAkZXZhbEFzeW5jOiBmdW5jdGlvbihleHByKSB7XHJcbiAgICAgICAgLy8gaWYgd2UgYXJlIG91dHNpZGUgb2YgYW4gJGRpZ2VzdCBsb29wIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlIGFyZSBzY2hlZHVsaW5nIGFzeW5jIHRhc2sgYWxzbyBzY2hlZHVsZVxyXG4gICAgICAgIC8vIGFzeW5jIGF1dG8tZmx1c2hcclxuICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSAmJiAhJHJvb3RTY29wZS4kJGFzeW5jUXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAkYnJvd3Nlci5kZWZlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJCRhc3luY1F1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGRpZ2VzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuJCRhc3luY1F1ZXVlLnB1c2goZXhwcik7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAkJHBvc3REaWdlc3QgOiBmdW5jdGlvbihleHByKSB7XHJcbiAgICAgICAgdGhpcy4kJHBvc3REaWdlc3RRdWV1ZS5wdXNoKGV4cHIpO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRhcHBseVxyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIGAkYXBwbHkoKWAgaXMgdXNlZCB0byBleGVjdXRlIGFuIGV4cHJlc3Npb24gaW4gYW5ndWxhciBmcm9tIG91dHNpZGUgb2YgdGhlIGFuZ3VsYXIgZnJhbWV3b3JrLlxyXG4gICAgICAgKiAoRm9yIGV4YW1wbGUgZnJvbSBicm93c2VyIERPTSBldmVudHMsIHNldFRpbWVvdXQsIFhIUiBvciB0aGlyZCBwYXJ0eSBsaWJyYXJpZXMpLlxyXG4gICAgICAgKiBCZWNhdXNlIHdlIGFyZSBjYWxsaW5nIGludG8gdGhlIGFuZ3VsYXIgZnJhbWV3b3JrIHdlIG5lZWQgdG8gcGVyZm9ybSBwcm9wZXIgc2NvcGUgbGlmZS1jeWNsZVxyXG4gICAgICAgKiBvZiB7QGxpbmsgbmcuJGV4Y2VwdGlvbkhhbmRsZXIgZXhjZXB0aW9uIGhhbmRsaW5nfSxcclxuICAgICAgICoge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdCBleGVjdXRpbmcgd2F0Y2hlc30uXHJcbiAgICAgICAqXHJcbiAgICAgICAqICMjIExpZmUgY3ljbGVcclxuICAgICAgICpcclxuICAgICAgICogIyBQc2V1ZG8tQ29kZSBvZiBgJGFwcGx5KClgXHJcbiAgICAgICAqIDxwcmU+XHJcbiAgICAgICAgICAgZnVuY3Rpb24gJGFwcGx5KGV4cHIpIHtcclxuICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiAkZXZhbChleHByKTtcclxuICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAkcm9vdC4kZGlnZXN0KCk7XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgKiA8L3ByZT5cclxuICAgICAgICpcclxuICAgICAgICpcclxuICAgICAgICogU2NvcGUncyBgJGFwcGx5KClgIG1ldGhvZCB0cmFuc2l0aW9ucyB0aHJvdWdoIHRoZSBmb2xsb3dpbmcgc3RhZ2VzOlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAxLiBUaGUge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0gaXMgZXhlY3V0ZWQgdXNpbmcgdGhlXHJcbiAgICAgICAqICAgIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRldmFsICRldmFsKCl9IG1ldGhvZC5cclxuICAgICAgICogMi4gQW55IGV4Y2VwdGlvbnMgZnJvbSB0aGUgZXhlY3V0aW9uIG9mIHRoZSBleHByZXNzaW9uIGFyZSBmb3J3YXJkZWQgdG8gdGhlXHJcbiAgICAgICAqICAgIHtAbGluayBuZy4kZXhjZXB0aW9uSGFuZGxlciAkZXhjZXB0aW9uSGFuZGxlcn0gc2VydmljZS5cclxuICAgICAgICogMy4gVGhlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyR3YXRjaCB3YXRjaH0gbGlzdGVuZXJzIGFyZSBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgZXhwcmVzc2lvblxyXG4gICAgICAgKiAgICB3YXMgZXhlY3V0ZWQgdXNpbmcgdGhlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRkaWdlc3QgJGRpZ2VzdCgpfSBtZXRob2QuXHJcbiAgICAgICAqXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xmdW5jdGlvbigpKT19IGV4cCBBbiBhbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqICAgIC0gYHN0cmluZ2A6IGV4ZWN1dGUgdXNpbmcgdGhlIHJ1bGVzIGFzIGRlZmluZWQgaW4ge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0uXHJcbiAgICAgICAqICAgIC0gYGZ1bmN0aW9uKHNjb3BlKWA6IGV4ZWN1dGUgdGhlIGZ1bmN0aW9uIHdpdGggY3VycmVudCBgc2NvcGVgIHBhcmFtZXRlci5cclxuICAgICAgICpcclxuICAgICAgICogQHJldHVybnMgeyp9IFRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyB0aGUgZXhwcmVzc2lvbi5cclxuICAgICAgICovXHJcbiAgICAgICRhcHBseTogZnVuY3Rpb24oZXhwcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBiZWdpblBoYXNlKCckYXBwbHknKTtcclxuICAgICAgICAgIHJldHVybiB0aGlzLiRldmFsKGV4cHIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBjbGVhclBoYXNlKCk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRkaWdlc3QoKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRvblxyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICpcclxuICAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICAqIExpc3RlbnMgb24gZXZlbnRzIG9mIGEgZ2l2ZW4gdHlwZS4gU2VlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRlbWl0ICRlbWl0fSBmb3IgZGlzY3Vzc2lvbiBvZlxyXG4gICAgICAgKiBldmVudCBsaWZlIGN5Y2xlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUaGUgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gZm9ybWF0IGlzOiBgZnVuY3Rpb24oZXZlbnQsIGFyZ3MuLi4pYC4gVGhlIGBldmVudGAgb2JqZWN0XHJcbiAgICAgICAqIHBhc3NlZCBpbnRvIHRoZSBsaXN0ZW5lciBoYXMgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxyXG4gICAgICAgKlxyXG4gICAgICAgKiAgIC0gYHRhcmdldFNjb3BlYCAtIGB7U2NvcGV9YDogdGhlIHNjb3BlIG9uIHdoaWNoIHRoZSBldmVudCB3YXMgYCRlbWl0YC1lZCBvciBgJGJyb2FkY2FzdGAtZWQuXHJcbiAgICAgICAqICAgLSBgY3VycmVudFNjb3BlYCAtIGB7U2NvcGV9YDogdGhlIGN1cnJlbnQgc2NvcGUgd2hpY2ggaXMgaGFuZGxpbmcgdGhlIGV2ZW50LlxyXG4gICAgICAgKiAgIC0gYG5hbWVgIC0gYHtzdHJpbmd9YDogTmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgICAqICAgLSBgc3RvcFByb3BhZ2F0aW9uYCAtIGB7ZnVuY3Rpb249fWA6IGNhbGxpbmcgYHN0b3BQcm9wYWdhdGlvbmAgZnVuY3Rpb24gd2lsbCBjYW5jZWwgZnVydGhlciBldmVudFxyXG4gICAgICAgKiAgICAgcHJvcGFnYXRpb24gKGF2YWlsYWJsZSBvbmx5IGZvciBldmVudHMgdGhhdCB3ZXJlIGAkZW1pdGAtZWQpLlxyXG4gICAgICAgKiAgIC0gYHByZXZlbnREZWZhdWx0YCAtIGB7ZnVuY3Rpb259YDogY2FsbGluZyBgcHJldmVudERlZmF1bHRgIHNldHMgYGRlZmF1bHRQcmV2ZW50ZWRgIGZsYWcgdG8gdHJ1ZS5cclxuICAgICAgICogICAtIGBkZWZhdWx0UHJldmVudGVkYCAtIGB7Ym9vbGVhbn1gOiB0cnVlIGlmIGBwcmV2ZW50RGVmYXVsdGAgd2FzIGNhbGxlZC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZSB0byBsaXN0ZW4gb24uXHJcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXZlbnQsIGFyZ3MuLi4pfSBsaXN0ZW5lciBGdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuXHJcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigpfSBSZXR1cm5zIGEgZGVyZWdpc3RyYXRpb24gZnVuY3Rpb24gZm9yIHRoaXMgbGlzdGVuZXIuXHJcbiAgICAgICAqL1xyXG4gICAgICAkb246IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdmFyIG5hbWVkTGlzdGVuZXJzID0gdGhpcy4kJGxpc3RlbmVyc1tuYW1lXTtcclxuICAgICAgICBpZiAoIW5hbWVkTGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICB0aGlzLiQkbGlzdGVuZXJzW25hbWVdID0gbmFtZWRMaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmFtZWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIG5hbWVkTGlzdGVuZXJzW2luZGV4T2YobmFtZWRMaXN0ZW5lcnMsIGxpc3RlbmVyKV0gPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcblxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRlbWl0XHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogRGlzcGF0Y2hlcyBhbiBldmVudCBgbmFtZWAgdXB3YXJkcyB0aHJvdWdoIHRoZSBzY29wZSBoaWVyYXJjaHkgbm90aWZ5aW5nIHRoZVxyXG4gICAgICAgKiByZWdpc3RlcmVkIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRvbn0gbGlzdGVuZXJzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUaGUgZXZlbnQgbGlmZSBjeWNsZSBzdGFydHMgYXQgdGhlIHNjb3BlIG9uIHdoaWNoIGAkZW1pdGAgd2FzIGNhbGxlZC4gQWxsXHJcbiAgICAgICAqIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRvbiBsaXN0ZW5lcnN9IGxpc3RlbmluZyBmb3IgYG5hbWVgIGV2ZW50IG9uIHRoaXMgc2NvcGUgZ2V0IG5vdGlmaWVkLlxyXG4gICAgICAgKiBBZnRlcndhcmRzLCB0aGUgZXZlbnQgdHJhdmVyc2VzIHVwd2FyZHMgdG93YXJkIHRoZSByb290IHNjb3BlIGFuZCBjYWxscyBhbGwgcmVnaXN0ZXJlZFxyXG4gICAgICAgKiBsaXN0ZW5lcnMgYWxvbmcgdGhlIHdheS4gVGhlIGV2ZW50IHdpbGwgc3RvcCBwcm9wYWdhdGluZyBpZiBvbmUgb2YgdGhlIGxpc3RlbmVycyBjYW5jZWxzIGl0LlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBBbnkgZXhjZXB0aW9uIGVtaXR0ZWQgZnJvbSB0aGUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJG9uIGxpc3RlbmVyc30gd2lsbCBiZSBwYXNzZWRcclxuICAgICAgICogb250byB0aGUge0BsaW5rIG5nLiRleGNlcHRpb25IYW5kbGVyICRleGNlcHRpb25IYW5kbGVyfSBzZXJ2aWNlLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFdmVudCBuYW1lIHRvIGVtaXQuXHJcbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBPcHRpb25hbCBzZXQgb2YgYXJndW1lbnRzIHdoaWNoIHdpbGwgYmUgcGFzc2VkIG9udG8gdGhlIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICogQHJldHVybiB7T2JqZWN0fSBFdmVudCBvYmplY3QsIHNlZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkb259XHJcbiAgICAgICAqL1xyXG4gICAgICAkZW1pdDogZnVuY3Rpb24obmFtZSwgYXJncykge1xyXG4gICAgICAgIHZhciBlbXB0eSA9IFtdLFxyXG4gICAgICAgICAgICBuYW1lZExpc3RlbmVycyxcclxuICAgICAgICAgICAgc2NvcGUgPSB0aGlzLFxyXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24gPSBmYWxzZSxcclxuICAgICAgICAgICAgZXZlbnQgPSB7XHJcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICB0YXJnZXRTY29wZTogc2NvcGUsXHJcbiAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtzdG9wUHJvcGFnYXRpb24gPSB0cnVlO30sXHJcbiAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsaXN0ZW5lckFyZ3MgPSBjb25jYXQoW2V2ZW50XSwgYXJndW1lbnRzLCAxKSxcclxuICAgICAgICAgICAgaSwgbGVuZ3RoO1xyXG5cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICBuYW1lZExpc3RlbmVycyA9IHNjb3BlLiQkbGlzdGVuZXJzW25hbWVdIHx8IGVtcHR5O1xyXG4gICAgICAgICAgZXZlbnQuY3VycmVudFNjb3BlID0gc2NvcGU7XHJcbiAgICAgICAgICBmb3IgKGk9MCwgbGVuZ3RoPW5hbWVkTGlzdGVuZXJzLmxlbmd0aDsgaTxsZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgbGlzdGVuZXJzIHdlcmUgZGVyZWdpc3RlcmVkLCBkZWZyYWdtZW50IHRoZSBhcnJheVxyXG4gICAgICAgICAgICBpZiAoIW5hbWVkTGlzdGVuZXJzW2ldKSB7XHJcbiAgICAgICAgICAgICAgbmFtZWRMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICBsZW5ndGgtLTtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIG5hbWVkTGlzdGVuZXJzW2ldLmFwcGx5KG51bGwsIGxpc3RlbmVyQXJncyk7XHJcbiAgICAgICAgICAgICAgaWYgKHN0b3BQcm9wYWdhdGlvbikgcmV0dXJuIGV2ZW50O1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vdHJhdmVyc2UgdXB3YXJkc1xyXG4gICAgICAgICAgc2NvcGUgPSBzY29wZS4kcGFyZW50O1xyXG4gICAgICAgIH0gd2hpbGUgKHNjb3BlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICB9LFxyXG5cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkYnJvYWRjYXN0XHJcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAgICogRGlzcGF0Y2hlcyBhbiBldmVudCBgbmFtZWAgZG93bndhcmRzIHRvIGFsbCBjaGlsZCBzY29wZXMgKGFuZCB0aGVpciBjaGlsZHJlbikgbm90aWZ5aW5nIHRoZVxyXG4gICAgICAgKiByZWdpc3RlcmVkIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIyRvbn0gbGlzdGVuZXJzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBUaGUgZXZlbnQgbGlmZSBjeWNsZSBzdGFydHMgYXQgdGhlIHNjb3BlIG9uIHdoaWNoIGAkYnJvYWRjYXN0YCB3YXMgY2FsbGVkLiBBbGxcclxuICAgICAgICoge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJG9uIGxpc3RlbmVyc30gbGlzdGVuaW5nIGZvciBgbmFtZWAgZXZlbnQgb24gdGhpcyBzY29wZSBnZXQgbm90aWZpZWQuXHJcbiAgICAgICAqIEFmdGVyd2FyZHMsIHRoZSBldmVudCBwcm9wYWdhdGVzIHRvIGFsbCBkaXJlY3QgYW5kIGluZGlyZWN0IHNjb3BlcyBvZiB0aGUgY3VycmVudCBzY29wZSBhbmRcclxuICAgICAgICogY2FsbHMgYWxsIHJlZ2lzdGVyZWQgbGlzdGVuZXJzIGFsb25nIHRoZSB3YXkuIFRoZSBldmVudCBjYW5ub3QgYmUgY2FuY2VsZWQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEFueSBleGNlcHRpb24gZW1pdHRlZCBmcm9tIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkb24gbGlzdGVuZXJzfSB3aWxsIGJlIHBhc3NlZFxyXG4gICAgICAgKiBvbnRvIHRoZSB7QGxpbmsgbmcuJGV4Y2VwdGlvbkhhbmRsZXIgJGV4Y2VwdGlvbkhhbmRsZXJ9IHNlcnZpY2UuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUgdG8gYnJvYWRjYXN0LlxyXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgT3B0aW9uYWwgc2V0IG9mIGFyZ3VtZW50cyB3aGljaCB3aWxsIGJlIHBhc3NlZCBvbnRvIHRoZSBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gRXZlbnQgb2JqZWN0LCBzZWUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJG9ufVxyXG4gICAgICAgKi9cclxuICAgICAgJGJyb2FkY2FzdDogZnVuY3Rpb24obmFtZSwgYXJncykge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLFxyXG4gICAgICAgICAgICBjdXJyZW50ID0gdGFyZ2V0LFxyXG4gICAgICAgICAgICBuZXh0ID0gdGFyZ2V0LFxyXG4gICAgICAgICAgICBldmVudCA9IHtcclxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgIHRhcmdldFNjb3BlOiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsaXN0ZW5lckFyZ3MgPSBjb25jYXQoW2V2ZW50XSwgYXJndW1lbnRzLCAxKSxcclxuICAgICAgICAgICAgbGlzdGVuZXJzLCBpLCBsZW5ndGg7XHJcblxyXG4gICAgICAgIC8vZG93biB3aGlsZSB5b3UgY2FuLCB0aGVuIHVwIGFuZCBuZXh0IHNpYmxpbmcgb3IgdXAgYW5kIG5leHQgc2libGluZyB1bnRpbCBiYWNrIGF0IHJvb3RcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcclxuICAgICAgICAgIGV2ZW50LmN1cnJlbnRTY29wZSA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBjdXJyZW50LiQkbGlzdGVuZXJzW25hbWVdIHx8IFtdO1xyXG4gICAgICAgICAgZm9yIChpPTAsIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGk8bGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gaWYgbGlzdGVuZXJzIHdlcmUgZGVyZWdpc3RlcmVkLCBkZWZyYWdtZW50IHRoZSBhcnJheVxyXG4gICAgICAgICAgICBpZiAoIWxpc3RlbmVyc1tpXSkge1xyXG4gICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgIGxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShudWxsLCBsaXN0ZW5lckFyZ3MpO1xyXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEluc2FuaXR5IFdhcm5pbmc6IHNjb3BlIGRlcHRoLWZpcnN0IHRyYXZlcnNhbFxyXG4gICAgICAgICAgLy8geWVzLCB0aGlzIGNvZGUgaXMgYSBiaXQgY3JhenksIGJ1dCBpdCB3b3JrcyBhbmQgd2UgaGF2ZSB0ZXN0cyB0byBwcm92ZSBpdCFcclxuICAgICAgICAgIC8vIHRoaXMgcGllY2Ugc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB0cmF2ZXJzYWwgaW4gJGRpZ2VzdFxyXG4gICAgICAgICAgaWYgKCEobmV4dCA9IChjdXJyZW50LiQkY2hpbGRIZWFkIHx8IChjdXJyZW50ICE9PSB0YXJnZXQgJiYgY3VycmVudC4kJG5leHRTaWJsaW5nKSkpKSB7XHJcbiAgICAgICAgICAgIHdoaWxlKGN1cnJlbnQgIT09IHRhcmdldCAmJiAhKG5leHQgPSBjdXJyZW50LiQkbmV4dFNpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuJHBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKChjdXJyZW50ID0gbmV4dCkpO1xyXG5cclxuICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyICRyb290U2NvcGUgPSBuZXcgU2NvcGUoKTtcclxuXHJcbiAgICByZXR1cm4gJHJvb3RTY29wZTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gYmVnaW5QaGFzZShwaGFzZSkge1xyXG4gICAgICBpZiAoJHJvb3RTY29wZS4kJHBoYXNlKSB7XHJcbiAgICAgICAgdGhyb3cgJHJvb3RTY29wZU1pbkVycignaW5wcm9nJywgJ3swfSBhbHJlYWR5IGluIHByb2dyZXNzJywgJHJvb3RTY29wZS4kJHBoYXNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgJHJvb3RTY29wZS4kJHBoYXNlID0gcGhhc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xlYXJQaGFzZSgpIHtcclxuICAgICAgJHJvb3RTY29wZS4kJHBoYXNlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21waWxlVG9GbihleHAsIG5hbWUpIHtcclxuICAgICAgdmFyIGZuID0gJHBhcnNlKGV4cCk7XHJcbiAgICAgIGFzc2VydEFyZ0ZuKGZuLCBuYW1lKTtcclxuICAgICAgcmV0dXJuIGZuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZnVuY3Rpb24gdXNlZCBhcyBhbiBpbml0aWFsIHZhbHVlIGZvciB3YXRjaGVycy5cclxuICAgICAqIGJlY2F1c2UgaXQncyB1bmlxdWUgd2UgY2FuIGVhc2lseSB0ZWxsIGl0IGFwYXJ0IGZyb20gb3RoZXIgdmFsdWVzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGluaXRXYXRjaFZhbCgpIHt9XHJcbiAgfV07XHJcbn1cclxuXHJcbnZhciAkc2NlTWluRXJyID0gbWluRXJyKCckc2NlJyk7XHJcblxyXG52YXIgU0NFX0NPTlRFWFRTID0ge1xyXG4gIEhUTUw6ICdodG1sJyxcclxuICBDU1M6ICdjc3MnLFxyXG4gIFVSTDogJ3VybCcsXHJcbiAgLy8gUkVTT1VSQ0VfVVJMIGlzIGEgc3VidHlwZSBvZiBVUkwgdXNlZCBpbiBjb250ZXh0cyB3aGVyZSBhIHByaXZpbGVnZWQgcmVzb3VyY2UgaXMgc291cmNlZCBmcm9tIGFcclxuICAvLyB1cmwuICAoZS5nLiBuZy1pbmNsdWRlLCBzY3JpcHQgc3JjLCB0ZW1wbGF0ZVVybClcclxuICBSRVNPVVJDRV9VUkw6ICdyZXNvdXJjZVVybCcsXHJcbiAgSlM6ICdqcydcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIHNlcnZpY2VcclxuICogQG5hbWUgbmcuJHNjZURlbGVnYXRlXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogYCRzY2VEZWxlZ2F0ZWAgaXMgYSBzZXJ2aWNlIHRoYXQgaXMgdXNlZCBieSB0aGUgYCRzY2VgIHNlcnZpY2UgdG8gcHJvdmlkZSB7QGxpbmsgbmcuJHNjZSBTdHJpY3RcclxuICogQ29udGV4dHVhbCBFc2NhcGluZyAoU0NFKX0gc2VydmljZXMgdG8gQW5ndWxhckpTLlxyXG4gKlxyXG4gKiBUeXBpY2FsbHksIHlvdSB3b3VsZCBjb25maWd1cmUgb3Igb3ZlcnJpZGUgdGhlIHtAbGluayBuZy4kc2NlRGVsZWdhdGUgJHNjZURlbGVnYXRlfSBpbnN0ZWFkIG9mXHJcbiAqIHRoZSBgJHNjZWAgc2VydmljZSB0byBjdXN0b21pemUgdGhlIHdheSBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyB3b3JrcyBpbiBBbmd1bGFySlMuICBUaGlzIGlzXHJcbiAqIGJlY2F1c2UsIHdoaWxlIHRoZSBgJHNjZWAgcHJvdmlkZXMgbnVtZXJvdXMgc2hvcnRoYW5kIG1ldGhvZHMsIGV0Yy4sIHlvdSByZWFsbHkgb25seSBuZWVkIHRvXHJcbiAqIG92ZXJyaWRlIDMgY29yZSBmdW5jdGlvbnMgKGB0cnVzdEFzYCwgYGdldFRydXN0ZWRgIGFuZCBgdmFsdWVPZmApIHRvIHJlcGxhY2UgdGhlIHdheSB0aGluZ3NcclxuICogd29yayBiZWNhdXNlIGAkc2NlYCBkZWxlZ2F0ZXMgdG8gYCRzY2VEZWxlZ2F0ZWAgZm9yIHRoZXNlIG9wZXJhdGlvbnMuXHJcbiAqXHJcbiAqIFJlZmVyIHtAbGluayBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciAkc2NlRGVsZWdhdGVQcm92aWRlcn0gdG8gY29uZmlndXJlIHRoaXMgc2VydmljZS5cclxuICpcclxuICogVGhlIGRlZmF1bHQgaW5zdGFuY2Ugb2YgYCRzY2VEZWxlZ2F0ZWAgc2hvdWxkIHdvcmsgb3V0IG9mIHRoZSBib3ggd2l0aCBsaXR0bGUgcGFpbi4gIFdoaWxlIHlvdVxyXG4gKiBjYW4gb3ZlcnJpZGUgaXQgY29tcGxldGVseSB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIGAkc2NlYCwgdGhlIGNvbW1vbiBjYXNlIHdvdWxkXHJcbiAqIGludm9sdmUgY29uZmlndXJpbmcgdGhlIHtAbGluayBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciAkc2NlRGVsZWdhdGVQcm92aWRlcn0gaW5zdGVhZCBieSBzZXR0aW5nXHJcbiAqIHlvdXIgb3duIHdoaXRlbGlzdHMgYW5kIGJsYWNrbGlzdHMgZm9yIHRydXN0aW5nIFVSTHMgdXNlZCBmb3IgbG9hZGluZyBBbmd1bGFySlMgcmVzb3VyY2VzIHN1Y2ggYXNcclxuICogdGVtcGxhdGVzLiAgUmVmZXIge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyI3Jlc291cmNlVXJsV2hpdGVsaXN0XHJcbiAqICRzY2VEZWxlZ2F0ZVByb3ZpZGVyLnJlc291cmNlVXJsV2hpdGVsaXN0fSBhbmQge0BsaW5rXHJcbiAqIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyI3Jlc291cmNlVXJsQmxhY2tsaXN0ICRzY2VEZWxlZ2F0ZVByb3ZpZGVyLnJlc291cmNlVXJsQmxhY2tsaXN0fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBUaGUgJHNjZURlbGVnYXRlUHJvdmlkZXIgcHJvdmlkZXIgYWxsb3dzIGRldmVsb3BlcnMgdG8gY29uZmlndXJlIHRoZSB7QGxpbmsgbmcuJHNjZURlbGVnYXRlXHJcbiAqICRzY2VEZWxlZ2F0ZX0gc2VydmljZS4gIFRoaXMgYWxsb3dzIG9uZSB0byBnZXQvc2V0IHRoZSB3aGl0ZWxpc3RzIGFuZCBibGFja2xpc3RzIHVzZWQgdG8gZW5zdXJlXHJcbiAqIHRoYXQgVVJMcyB1c2VkIGZvciBzb3VyY2luZyBBbmd1bGFyIHRlbXBsYXRlcyBhcmUgc2FmZS4gIFJlZmVyIHtAbGlua1xyXG4gKiBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciNyZXNvdXJjZVVybFdoaXRlbGlzdCAkc2NlRGVsZWdhdGVQcm92aWRlci5yZXNvdXJjZVVybFdoaXRlbGlzdH0gYW5kXHJcbiAqIHtAbGluayBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciNyZXNvdXJjZVVybEJsYWNrbGlzdCAkc2NlRGVsZWdhdGVQcm92aWRlci5yZXNvdXJjZVVybEJsYWNrbGlzdH1cclxuICpcclxuICogUmVhZCBtb3JlIGFib3V0IHtAbGluayBuZy4kc2NlIFN0cmljdCBDb250ZXh0dWFsIEVzY2FwaW5nIChTQ0UpfS5cclxuICovXHJcblxyXG5mdW5jdGlvbiAkU2NlRGVsZWdhdGVQcm92aWRlcigpIHtcclxuICB0aGlzLlNDRV9DT05URVhUUyA9IFNDRV9DT05URVhUUztcclxuXHJcbiAgLy8gUmVzb3VyY2UgVVJMcyBjYW4gYWxzbyBiZSB0cnVzdGVkIGJ5IHBvbGljeS5cclxuICB2YXIgcmVzb3VyY2VVcmxXaGl0ZWxpc3QgPSBbJ3NlbGYnXSxcclxuICAgICAgcmVzb3VyY2VVcmxCbGFja2xpc3QgPSBbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgbmcuc2NlRGVsZWdhdGVQcm92aWRlciNyZXNvdXJjZVVybFdoaXRlbGlzdFxyXG4gICAqIEBtZXRob2RPZiBuZy4kc2NlRGVsZWdhdGVQcm92aWRlclxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheT19IHdoaXRlbGlzdCBXaGVuIHByb3ZpZGVkLCByZXBsYWNlcyB0aGUgcmVzb3VyY2VVcmxXaGl0ZWxpc3Qgd2l0aCB0aGUgdmFsdWVcclxuICAgKiAgICAgcHJvdmlkZWQuICBUaGlzIG11c3QgYmUgYW4gYXJyYXkuXHJcbiAgICpcclxuICAgKiAgICAgRWFjaCBlbGVtZW50IG9mIHRoaXMgYXJyYXkgbXVzdCBlaXRoZXIgYmUgYSByZWdleCBvciB0aGUgc3BlY2lhbCBzdHJpbmcgYCdzZWxmJ2AuXHJcbiAgICpcclxuICAgKiAgICAgV2hlbiBhIHJlZ2V4IGlzIHVzZWQsIGl0IGlzIG1hdGNoZWQgYWdhaW5zdCB0aGUgbm9ybWFsaXplZCAvIGFic29sdXRlIFVSTCBvZiB0aGUgcmVzb3VyY2VcclxuICAgKiAgICAgYmVpbmcgdGVzdGVkLlxyXG4gICAqXHJcbiAgICogICAgIFRoZSAqKnNwZWNpYWwgc3RyaW5nKiogYCdzZWxmJ2AgY2FuIGJlIHVzZWQgdG8gbWF0Y2ggYWdhaW5zdCBhbGwgVVJMcyBvZiB0aGUgc2FtZSBkb21haW4gYXMgdGhlXHJcbiAgICogICAgIGFwcGxpY2F0aW9uIGRvY3VtZW50IHdpdGggdGhlIHNhbWUgcHJvdG9jb2wgKGFsbG93cyBzb3VyY2luZyBodHRwcyByZXNvdXJjZXMgZnJvbSBodHRwIGRvY3VtZW50cy4pXHJcbiAgICpcclxuICAgKiAgICAgUGxlYXNlIG5vdGUgdGhhdCAqKmFuIGVtcHR5IHdoaXRlbGlzdCBhcnJheSB3aWxsIGJsb2NrIGFsbCBVUkxzKiohXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtBcnJheX0gdGhlIGN1cnJlbnRseSBzZXQgd2hpdGVsaXN0IGFycmF5LlxyXG4gICAqXHJcbiAgICogVGhlICoqZGVmYXVsdCB2YWx1ZSoqIHdoZW4gbm8gd2hpdGVsaXN0IGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0IGlzIGBbJ3NlbGYnXWAuXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBTZXRzL0dldHMgdGhlIHdoaXRlbGlzdCBvZiB0cnVzdGVkIHJlc291cmNlIFVSTHMuXHJcbiAgICovXHJcbiAgdGhpcy5yZXNvdXJjZVVybFdoaXRlbGlzdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmVzb3VyY2VVcmxXaGl0ZWxpc3QgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXNvdXJjZVVybFdoaXRlbGlzdDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy5zY2VEZWxlZ2F0ZVByb3ZpZGVyI3Jlc291cmNlVXJsQmxhY2tsaXN0XHJcbiAgICogQG1ldGhvZE9mIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5PX0gYmxhY2tsaXN0IFdoZW4gcHJvdmlkZWQsIHJlcGxhY2VzIHRoZSByZXNvdXJjZVVybEJsYWNrbGlzdCB3aXRoIHRoZSB2YWx1ZVxyXG4gICAqICAgICBwcm92aWRlZC4gIFRoaXMgbXVzdCBiZSBhbiBhcnJheS5cclxuICAgKlxyXG4gICAqICAgICBFYWNoIGVsZW1lbnQgb2YgdGhpcyBhcnJheSBtdXN0IGVpdGhlciBiZSBhIHJlZ2V4IG9yIHRoZSBzcGVjaWFsIHN0cmluZyBgJ3NlbGYnYCAoc2VlXHJcbiAgICogICAgIGByZXNvdXJjZVVybFdoaXRlbGlzdGAgZm9yIG1lYW5pbmcgLSBpdCdzIG9ubHkgcmVhbGx5IHVzZWZ1bCB0aGVyZS4pXHJcbiAgICpcclxuICAgKiAgICAgV2hlbiBhIHJlZ2V4IGlzIHVzZWQsIGl0IGlzIG1hdGNoZWQgYWdhaW5zdCB0aGUgbm9ybWFsaXplZCAvIGFic29sdXRlIFVSTCBvZiB0aGUgcmVzb3VyY2VcclxuICAgKiAgICAgYmVpbmcgdGVzdGVkLlxyXG4gICAqXHJcbiAgICogICAgIFRoZSB0eXBpY2FsIHVzYWdlIGZvciB0aGUgYmxhY2tsaXN0IGlzIHRvICoqYmxvY2sgW29wZW4gcmVkaXJlY3RzXShodHRwOi8vY3dlLm1pdHJlLm9yZy9kYXRhL2RlZmluaXRpb25zLzYwMS5odG1sKSoqXHJcbiAgICogICAgIHNlcnZlZCBieSB5b3VyIGRvbWFpbiBhcyB0aGVzZSB3b3VsZCBvdGhlcndpc2UgYmUgdHJ1c3RlZCBidXQgYWN0dWFsbHkgcmV0dXJuIGNvbnRlbnQgZnJvbSB0aGUgcmVkaXJlY3RlZFxyXG4gICAqICAgICBkb21haW4uXHJcbiAgICpcclxuICAgKiAgICAgRmluYWxseSwgKip0aGUgYmxhY2tsaXN0IG92ZXJyaWRlcyB0aGUgd2hpdGVsaXN0KiogYW5kIGhhcyB0aGUgZmluYWwgc2F5LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7QXJyYXl9IHRoZSBjdXJyZW50bHkgc2V0IGJsYWNrbGlzdCBhcnJheS5cclxuICAgKlxyXG4gICAqIFRoZSAqKmRlZmF1bHQgdmFsdWUqKiB3aGVuIG5vIHdoaXRlbGlzdCBoYXMgYmVlbiBleHBsaWNpdGx5IHNldCBpcyB0aGUgZW1wdHkgYXJyYXkgKGkuZS4gdGhlcmUgaXNcclxuICAgKiBubyBibGFja2xpc3QuKVxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogU2V0cy9HZXRzIHRoZSBibGFja2xpc3Qgb2YgdHJ1c3RlZCByZXNvdXJjZSBVUkxzLlxyXG4gICAqL1xyXG5cclxuICB0aGlzLnJlc291cmNlVXJsQmxhY2tsaXN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXNvdXJjZVVybEJsYWNrbGlzdCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc291cmNlVXJsQmxhY2tsaXN0O1xyXG4gIH07XHJcblxyXG4gIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hdGNoaW5nIHJlc291cmNlIHVybHMgYnkgcG9saWN5LlxyXG4gIGZ1bmN0aW9uIGlzQ29tcGF0aWJsZVByb3RvY29sKGRvY3VtZW50UHJvdG9jb2wsIHJlc291cmNlUHJvdG9jb2wpIHtcclxuICAgIHJldHVybiAoKGRvY3VtZW50UHJvdG9jb2wgPT09IHJlc291cmNlUHJvdG9jb2wpIHx8XHJcbiAgICAgICAgICAgIChkb2N1bWVudFByb3RvY29sID09PSBcImh0dHA6XCIgJiYgcmVzb3VyY2VQcm90b2NvbCA9PT0gXCJodHRwczpcIikpO1xyXG4gIH1cclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckbG9nJywgJyRkb2N1bWVudCcsICckaW5qZWN0b3InLCAnJCR1cmxVdGlscycsIGZ1bmN0aW9uKFxyXG4gICAgICAgICAgICAgICAgJGxvZywgICAkZG9jdW1lbnQsICAgJGluamVjdG9yLCAgICQkdXJsVXRpbHMpIHtcclxuXHJcbiAgICB2YXIgaHRtbFNhbml0aXplciA9IGZ1bmN0aW9uIGh0bWxTYW5pdGl6ZXIoaHRtbCkge1xyXG4gICAgICB0aHJvdyAkc2NlTWluRXJyKCd1bnNhZmUnLCAnQXR0ZW1wdGluZyB0byB1c2UgYW4gdW5zYWZlIHZhbHVlIGluIGEgc2FmZSBjb250ZXh0LicpO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoJGluamVjdG9yLmhhcygnJHNhbml0aXplJykpIHtcclxuICAgICAgaHRtbFNhbml0aXplciA9ICRpbmplY3Rvci5nZXQoJyRzYW5pdGl6ZScpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBtYXRjaFVybChtYXRjaGVyLCBwYXJzZWRVcmwpIHtcclxuICAgICAgaWYgKG1hdGNoZXIgPT09ICdzZWxmJykge1xyXG4gICAgICAgIHJldHVybiAkJHVybFV0aWxzLmlzU2FtZU9yaWdpbihwYXJzZWRVcmwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAhIXBhcnNlZFVybC5ocmVmLm1hdGNoKG1hdGNoZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNSZXNvdXJjZVVybEFsbG93ZWRCeVBvbGljeSh1cmwpIHtcclxuICAgICAgdmFyIHBhcnNlZFVybCA9ICQkdXJsVXRpbHMucmVzb2x2ZSh1cmwudG9TdHJpbmcoKSwgdHJ1ZSk7XHJcbiAgICAgIHZhciBpLCBuLCBhbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGF0IGxlYXN0IG9uZSBpdGVtIGZyb20gdGhlIHdoaXRlbGlzdCBhbGxvd3MgdGhpcyB1cmwuXHJcbiAgICAgIGZvciAoaSA9IDAsIG4gPSByZXNvdXJjZVVybFdoaXRlbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBpZiAobWF0Y2hVcmwocmVzb3VyY2VVcmxXaGl0ZWxpc3RbaV0sIHBhcnNlZFVybCkpIHtcclxuICAgICAgICAgIGFsbG93ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChhbGxvd2VkKSB7XHJcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gaXRlbSBmcm9tIHRoZSBibGFja2xpc3QgYmxvY2tlZCB0aGlzIHVybC5cclxuICAgICAgICBmb3IgKGkgPSAwLCBuID0gcmVzb3VyY2VVcmxCbGFja2xpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAobWF0Y2hVcmwocmVzb3VyY2VVcmxCbGFja2xpc3RbaV0sIHBhcnNlZFVybCkpIHtcclxuICAgICAgICAgICAgYWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFsbG93ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVIb2xkZXJUeXBlKGJhc2UpIHtcclxuICAgICAgdmFyIGhvbGRlclR5cGUgPSBmdW5jdGlvbiBUcnVzdGVkVmFsdWVIb2xkZXJUeXBlKHRydXN0ZWRWYWx1ZSkge1xyXG4gICAgICAgIHRoaXMuJCR1bndyYXBUcnVzdGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVzdGVkVmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuICAgICAgaWYgKGJhc2UpIHtcclxuICAgICAgICBob2xkZXJUeXBlLnByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgaG9sZGVyVHlwZS5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uIHNjZVZhbHVlT2YoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJCR1bndyYXBUcnVzdGVkVmFsdWUoKTtcclxuICAgICAgfVxyXG4gICAgICBob2xkZXJUeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHNjZVRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiQkdW53cmFwVHJ1c3RlZFZhbHVlKCkudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaG9sZGVyVHlwZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdHJ1c3RlZFZhbHVlSG9sZGVyQmFzZSA9IGdlbmVyYXRlSG9sZGVyVHlwZSgpLFxyXG4gICAgICAgIGJ5VHlwZSA9IHt9O1xyXG5cclxuICAgIGJ5VHlwZVtTQ0VfQ09OVEVYVFMuSFRNTF0gPSBnZW5lcmF0ZUhvbGRlclR5cGUodHJ1c3RlZFZhbHVlSG9sZGVyQmFzZSk7XHJcbiAgICBieVR5cGVbU0NFX0NPTlRFWFRTLkNTU10gPSBnZW5lcmF0ZUhvbGRlclR5cGUodHJ1c3RlZFZhbHVlSG9sZGVyQmFzZSk7XHJcbiAgICBieVR5cGVbU0NFX0NPTlRFWFRTLlVSTF0gPSBnZW5lcmF0ZUhvbGRlclR5cGUodHJ1c3RlZFZhbHVlSG9sZGVyQmFzZSk7XHJcbiAgICBieVR5cGVbU0NFX0NPTlRFWFRTLkpTXSA9IGdlbmVyYXRlSG9sZGVyVHlwZSh0cnVzdGVkVmFsdWVIb2xkZXJCYXNlKTtcclxuICAgIGJ5VHlwZVtTQ0VfQ09OVEVYVFMuUkVTT1VSQ0VfVVJMXSA9IGdlbmVyYXRlSG9sZGVyVHlwZShieVR5cGVbU0NFX0NPTlRFWFRTLlVSTF0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZURlbGVnYXRlI3RydXN0QXNcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlRGVsZWdhdGVcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgaXMgdHJ1c3RlZCBieSBhbmd1bGFyIGZvciB1c2UgaW4gc3BlY2lmaWVkIHN0cmljdFxyXG4gICAgICogY29udGV4dHVhbCBlc2NhcGluZyBjb250ZXh0cyAoc3VjaCBhcyBuZy1odG1sLWJpbmQtdW5zYWZlLCBuZy1pbmNsdWRlLCBhbnkgc3JjXHJcbiAgICAgKiBhdHRyaWJ1dGUgaW50ZXJwb2xhdGlvbiwgYW55IGRvbSBldmVudCBiaW5kaW5nIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uXHJcbiAgICAgKiBzdWNoIGFzIGZvciBvbmNsaWNrLCAgZXRjLikgdGhhdCB1c2VzIHRoZSBwcm92aWRlZCB2YWx1ZS5cclxuICAgICAqIFNlZSB7QGxpbmsgbmcuJHNjZSAkc2NlfSBmb3IgZW5hYmxpbmcgc3RyaWN0IGNvbnRleHR1YWwgZXNjYXBpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGtpbmQgb2YgY29udGV4dCBpbiB3aGljaCB0aGlzIHZhbHVlIGlzIHNhZmUgZm9yIHVzZS4gIGUuZy4gdXJsLFxyXG4gICAgICogICByZXNvdXJjZVVybCwgaHRtbCwganMgYW5kIGNzcy5cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoYXQgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCB0cnVzdGVkL3NhZmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gQSB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0YW5kIGluIGZvciB0aGUgcHJvdmlkZWQgYHZhbHVlYCBpbiBwbGFjZXNcclxuICAgICAqIHdoZXJlIEFuZ3VsYXIgZXhwZWN0cyBhICRzY2UudHJ1c3RBcygpIHJldHVybiB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJ1c3RBcyh0eXBlLCB0cnVzdGVkVmFsdWUpIHtcclxuICAgICAgdmFyIGNvbnN0cnVjdG9yID0gKGJ5VHlwZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IGJ5VHlwZVt0eXBlXSA6IG51bGwpO1xyXG4gICAgICBpZiAoIWNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgdGhyb3cgJHNjZU1pbkVycignaWNvbnRleHQnLCAnQXR0ZW1wdGVkIHRvIHRydXN0IGEgdmFsdWUgaW4gaW52YWxpZCBjb250ZXh0LiBDb250ZXh0OiB7MH07IFZhbHVlOiB7MX0nLFxyXG4gICAgICAgICAgICB0eXBlLCB0cnVzdGVkVmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0cnVzdGVkVmFsdWUgPT09IG51bGwgfHwgdHJ1c3RlZFZhbHVlID09PSB1bmRlZmluZWQgfHwgdHJ1c3RlZFZhbHVlID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiB0cnVzdGVkVmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gQWxsIHRoZSBjdXJyZW50IGNvbnRleHRzIGluIFNDRV9DT05URVhUUyBoYXBwZW4gdG8gYmUgc3RyaW5ncy4gIEluIG9yZGVyIHRvIGF2b2lkIHRydXN0aW5nXHJcbiAgICAgIC8vIG11dGFibGUgb2JqZWN0cywgd2UgZW5zdXJlIGhlcmUgdGhhdCB0aGUgdmFsdWUgcGFzc2VkIGluIGlzIGFjdHVhbGx5IGEgc3RyaW5nLlxyXG4gICAgICBpZiAodHlwZW9mIHRydXN0ZWRWYWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyAkc2NlTWluRXJyKCdpdHlwZScsXHJcbiAgICAgICAgICAgICdBdHRlbXB0ZWQgdG8gdHJ1c3QgYSBub24tc3RyaW5nIHZhbHVlIGluIGEgY29udGVudCByZXF1aXJpbmcgYSBzdHJpbmc6IENvbnRleHQ6IHswfScsXHJcbiAgICAgICAgICAgIHR5cGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3IodHJ1c3RlZFZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2VEZWxlZ2F0ZSN2YWx1ZU9mXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZURlbGVnYXRlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBJZiB0aGUgcGFzc2VkIHBhcmFtZXRlciBoYWQgYmVlbiByZXR1cm5lZCBieSBhIHByaW9yIGNhbGwgdG8ge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzXHJcbiAgICAgKiBgJHNjZURlbGVnYXRlLnRydXN0QXNgfSwgcmV0dXJucyB0aGUgdmFsdWUgdGhhdCBoYWQgYmVlbiBwYXNzZWQgdG8ge0BsaW5rXHJcbiAgICAgKiBuZy4kc2NlRGVsZWdhdGUjdHJ1c3RBcyBgJHNjZURlbGVnYXRlLnRydXN0QXNgfS5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGUgcGFzc2VkIHBhcmFtZXRlciBpcyBub3QgYSB2YWx1ZSB0aGF0IGhhZCBiZWVuIHJldHVybmVkIGJ5IHtAbGlua1xyXG4gICAgICogbmcuJHNjZURlbGVnYXRlI3RydXN0QXMgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzYH0sIHJldHVybnMgaXQgYXMtaXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcmVzdWx0IG9mIGEgcHJpb3Ige0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzIGAkc2NlRGVsZWdhdGUudHJ1c3RBc2B9XHJcbiAgICAgKiAgICAgIGNhbGwgb3IgYW55dGhpbmcgZWxzZS5cclxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhlIHdhcyBvcmlnaW5hbGx5IHByb3ZpZGVkIHRvIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjdHJ1c3RBc1xyXG4gICAgICogICAgIGAkc2NlRGVsZWdhdGUudHJ1c3RBc2B9IGlmIGB2YWx1ZWAgaXMgdGhlIHJlc3VsdCBvZiBzdWNoIGEgY2FsbC4gIE90aGVyd2lzZSwgcmV0dXJucyBgdmFsdWVgXHJcbiAgICAgKiAgICAgdW5jaGFuZ2VkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG1heWJlVHJ1c3RlZCkge1xyXG4gICAgICBpZiAobWF5YmVUcnVzdGVkIGluc3RhbmNlb2YgdHJ1c3RlZFZhbHVlSG9sZGVyQmFzZSkge1xyXG4gICAgICAgIHJldHVybiBtYXliZVRydXN0ZWQuJCR1bndyYXBUcnVzdGVkVmFsdWUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbWF5YmVUcnVzdGVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlRGVsZWdhdGUjZ2V0VHJ1c3RlZFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VEZWxlZ2F0ZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogVGFrZXMgdGhlIHJlc3VsdCBvZiBhIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjdHJ1c3RBcyBgJHNjZURlbGVnYXRlLnRydXN0QXNgfSBjYWxsIGFuZCByZXR1cm5zIHRoZVxyXG4gICAgICogb3JpZ2luYWxseSBzdXBwbGllZCB2YWx1ZSBpZiB0aGUgcXVlcmllZCBjb250ZXh0IHR5cGUgaXMgYSBzdXBlcnR5cGUgb2YgdGhlIGNyZWF0ZWQgdHlwZS4gIElmXHJcbiAgICAgKiB0aGlzIGNvbmRpdGlvbiBpc24ndCBzYXRpc2ZpZWQsIHRocm93cyBhbiBleGNlcHRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIGtpbmQgb2YgY29udGV4dCBpbiB3aGljaCB0aGlzIHZhbHVlIGlzIHRvIGJlIHVzZWQuXHJcbiAgICAgKiBAcGFyYW0geyp9IG1heWJlVHJ1c3RlZCBUaGUgcmVzdWx0IG9mIGEgcHJpb3Ige0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzXHJcbiAgICAgKiBgJHNjZURlbGVnYXRlLnRydXN0QXNgfSBjYWxsLlxyXG4gICAgICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGUgd2FzIG9yaWdpbmFsbHkgcHJvdmlkZWQgdG8ge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzXHJcbiAgICAgKiAgICAgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzYH0gaWYgdmFsaWQgaW4gdGhpcyBjb250ZXh0LiAgT3RoZXJ3aXNlLCB0aHJvd3MgYW4gZXhjZXB0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRUcnVzdGVkKHR5cGUsIG1heWJlVHJ1c3RlZCkge1xyXG4gICAgICBpZiAobWF5YmVUcnVzdGVkID09PSBudWxsIHx8IG1heWJlVHJ1c3RlZCA9PT0gdW5kZWZpbmVkIHx8IG1heWJlVHJ1c3RlZCA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gbWF5YmVUcnVzdGVkO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBjb25zdHJ1Y3RvciA9IChieVR5cGUuaGFzT3duUHJvcGVydHkodHlwZSkgPyBieVR5cGVbdHlwZV0gOiBudWxsKTtcclxuICAgICAgaWYgKGNvbnN0cnVjdG9yICYmIG1heWJlVHJ1c3RlZCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG1heWJlVHJ1c3RlZC4kJHVud3JhcFRydXN0ZWRWYWx1ZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB0aGVuIHdlIG1heSBvbmx5IHRha2Ugb25lIG9mIHR3byBhY3Rpb25zLlxyXG4gICAgICAvLyAxLiBzYW5pdGl6ZSB0aGUgdmFsdWUgZm9yIHRoZSByZXF1ZXN0ZWQgdHlwZSwgb3JcclxuICAgICAgLy8gMi4gdGhyb3cgYW4gZXhjZXB0aW9uLlxyXG4gICAgICBpZiAodHlwZSA9PT0gU0NFX0NPTlRFWFRTLlJFU09VUkNFX1VSTCkge1xyXG4gICAgICAgIGlmIChpc1Jlc291cmNlVXJsQWxsb3dlZEJ5UG9saWN5KG1heWJlVHJ1c3RlZCkpIHtcclxuICAgICAgICAgIHJldHVybiBtYXliZVRydXN0ZWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93ICRzY2VNaW5FcnIoJ2luc2VjdXJsJyxcclxuICAgICAgICAgICAgICAnQmxvY2tlZCBsb2FkaW5nIHJlc291cmNlIGZyb20gdXJsIG5vdCBhbGxvd2VkIGJ5ICRzY2VEZWxlZ2F0ZSBwb2xpY3kuICBVUkw6IHswfScsIG1heWJlVHJ1c3RlZC50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gU0NFX0NPTlRFWFRTLkhUTUwpIHtcclxuICAgICAgICByZXR1cm4gaHRtbFNhbml0aXplcihtYXliZVRydXN0ZWQpO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93ICRzY2VNaW5FcnIoJ3Vuc2FmZScsICdBdHRlbXB0aW5nIHRvIHVzZSBhbiB1bnNhZmUgdmFsdWUgaW4gYSBzYWZlIGNvbnRleHQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgdHJ1c3RBczogdHJ1c3RBcyxcclxuICAgICAgICAgICAgIGdldFRydXN0ZWQ6IGdldFRydXN0ZWQsXHJcbiAgICAgICAgICAgICB2YWx1ZU9mOiB2YWx1ZU9mIH07XHJcbiAgfV07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy4kc2NlUHJvdmlkZXJcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIFRoZSAkc2NlUHJvdmlkZXIgcHJvdmlkZXIgYWxsb3dzIGRldmVsb3BlcnMgdG8gY29uZmlndXJlIHRoZSB7QGxpbmsgbmcuJHNjZSAkc2NlfSBzZXJ2aWNlLlxyXG4gKiAtICAgZW5hYmxlL2Rpc2FibGUgU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmcgKFNDRSkgaW4gYSBtb2R1bGVcclxuICogLSAgIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpdGggYSBjdXN0b20gZGVsZWdhdGVcclxuICpcclxuICogUmVhZCBtb3JlIGFib3V0IHtAbGluayBuZy4kc2NlIFN0cmljdCBDb250ZXh0dWFsIEVzY2FwaW5nIChTQ0UpfS5cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIHNlcnZpY2VcclxuICogQG5hbWUgbmcuJHNjZVxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIGAkc2NlYCBpcyBhIHNlcnZpY2UgdGhhdCBwcm92aWRlcyBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyBzZXJ2aWNlcyB0byBBbmd1bGFySlMuXHJcbiAqXHJcbiAqICMgU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmdcclxuICpcclxuICogU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmcgKFNDRSkgaXMgYSBtb2RlIGluIHdoaWNoIEFuZ3VsYXJKUyByZXF1aXJlcyBiaW5kaW5ncyBpbiBjZXJ0YWluXHJcbiAqIGNvbnRleHRzIHRvIHJlc3VsdCBpbiBhIHZhbHVlIHRoYXQgaXMgbWFya2VkIGFzIHNhZmUgdG8gdXNlIGZvciB0aGF0IGNvbnRleHQgT25lIGV4YW1wbGUgb2Ygc3VjaFxyXG4gKiBhIGNvbnRleHQgaXMgYmluZGluZyBhcmJpdHJhcnkgaHRtbCBjb250cm9sbGVkIGJ5IHRoZSB1c2VyIHZpYSBgbmctYmluZC1odG1sYC4gIFdlIHJlZmVyIHRvIHRoZXNlXHJcbiAqIGNvbnRleHRzIGFzIHByaXZpbGVnZWQgb3IgU0NFIGNvbnRleHRzLlxyXG4gKlxyXG4gKiBBcyBvZiB2ZXJzaW9uIDEuMiwgQW5ndWxhciBzaGlwcyB3aXRoIFNDRSBlbmFibGVkIGJ5IGRlZmF1bHQuXHJcbiAqXHJcbiAqIE5vdGU6ICBXaGVuIGVuYWJsZWQgKHRoZSBkZWZhdWx0KSwgSUU4IGluIHF1aXJrcyBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQuICBJbiB0aGlzIG1vZGUsIElFOCBhbGxvd3NcclxuICogb25lIHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGphdmFzY3JpcHQgYnkgdGhlIHVzZSBvZiB0aGUgZXhwcmVzc2lvbigpIHN5bnRheC4gIFJlZmVyXHJcbiAqIDxodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZS9hcmNoaXZlLzIwMDgvMTAvMTYvZW5kaW5nLWV4cHJlc3Npb25zLmFzcHg+IHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlbS5cclxuICogWW91IGNhbiBlbnN1cmUgeW91ciBkb2N1bWVudCBpcyBpbiBzdGFuZGFyZHMgbW9kZSBhbmQgbm90IHF1aXJrcyBtb2RlIGJ5IGFkZGluZyBgPCFkb2N0eXBlIGh0bWw+YFxyXG4gKiB0byB0aGUgdG9wIG9mIHlvdXIgSFRNTCBkb2N1bWVudC5cclxuICpcclxuICogU0NFIGFzc2lzdHMgaW4gd3JpdGluZyBjb2RlIGluIHdheSB0aGF0IChhKSBpcyBzZWN1cmUgYnkgZGVmYXVsdCBhbmQgKGIpIG1ha2VzIGF1ZGl0aW5nIGZvclxyXG4gKiBzZWN1cml0eSB2dWxuZXJhYmlsaXRpZXMgc3VjaCBhcyBYU1MsIGNsaWNramFja2luZywgZXRjLiBhIGxvdCBlYXNpZXIuXHJcbiAqXHJcbiAqIEhlcmUncyBhbiBleGFtcGxlIG9mIGEgYmluZGluZyBpbiBhIHByaXZpbGVnZWQgY29udGV4dDpcclxuICpcclxuICogPHByZSBjbGFzcz1cInByZXR0eXByaW50XCI+XHJcbiAqICAgICA8aW5wdXQgbmctbW9kZWw9XCJ1c2VySHRtbFwiPlxyXG4gKiAgICAgPGRpdiBuZy1iaW5kLWh0bWw9XCJ7e3VzZXJIdG1sfX1cIj5cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIE5vdGljZSB0aGF0IGBuZy1iaW5kLWh0bWxgIGlzIGJvdW5kIHRvIGB7e3VzZXJIdG1sfX1gIGNvbnRyb2xsZWQgYnkgdGhlIHVzZXIuICBXaXRoIFNDRVxyXG4gKiBkaXNhYmxlZCwgdGhpcyBhcHBsaWNhdGlvbiBhbGxvd3MgdGhlIHVzZXIgdG8gcmVuZGVyIGFyYml0cmFyeSBIVE1MIGludG8gdGhlIERJVi5cclxuICogSW4gYSBtb3JlIHJlYWxpc3RpYyBleGFtcGxlLCBvbmUgbWF5IGJlIHJlbmRlcmluZyB1c2VyIGNvbW1lbnRzLCBibG9nIGFydGljbGVzLCBldGMuIHZpYVxyXG4gKiBiaW5kaW5ncy4gIChIVE1MIGlzIGp1c3Qgb25lIGV4YW1wbGUgb2YgYSBjb250ZXh0IHdoZXJlIHJlbmRlcmluZyB1c2VyIGNvbnRyb2xsZWQgaW5wdXQgY3JlYXRlc1xyXG4gKiBzZWN1cml0eSB2dWxuZXJhYmlsaXRpZXMuKVxyXG4gKlxyXG4gKiBGb3IgdGhlIGNhc2Ugb2YgSFRNTCwgeW91IG1pZ2h0IHVzZSBhIGxpYnJhcnksIGVpdGhlciBvbiB0aGUgY2xpZW50IHNpZGUsIG9yIG9uIHRoZSBzZXJ2ZXIgc2lkZSxcclxuICogdG8gc2FuaXRpemUgdW5zYWZlIEhUTUwgYmVmb3JlIGJpbmRpbmcgdG8gdGhlIHZhbHVlIGFuZCByZW5kZXJpbmcgaXQgaW4gdGhlIGRvY3VtZW50LlxyXG4gKlxyXG4gKiBIb3cgd291bGQgeW91IGVuc3VyZSB0aGF0IGV2ZXJ5IHBsYWNlIHRoYXQgdXNlZCB0aGVzZSB0eXBlcyBvZiBiaW5kaW5ncyB3YXMgYm91bmQgdG8gYSB2YWx1ZSB0aGF0XHJcbiAqIHdhcyBzYW5pdGl6ZWQgYnkgeW91ciBsaWJyYXJ5IChvciByZXR1cm5lZCBhcyBzYWZlIGZvciByZW5kZXJpbmcgYnkgeW91ciBzZXJ2ZXI/KSAgSG93IGNhbiB5b3VcclxuICogZW5zdXJlIHRoYXQgeW91IGRpZG4ndCBhY2NpZGVudGFsbHkgZGVsZXRlIHRoZSBsaW5lIHRoYXQgc2FuaXRpemVkIHRoZSB2YWx1ZSwgb3IgcmVuYW1lZCBzb21lXHJcbiAqIHByb3BlcnRpZXMvZmllbGRzIGFuZCBmb3Jnb3QgdG8gdXBkYXRlIHRoZSBiaW5kaW5nIHRvIHRoZSBzYW5pdGl6ZWQgdmFsdWU/XHJcbiAqXHJcbiAqIFRvIGJlIHNlY3VyZSBieSBkZWZhdWx0LCB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCBhbnkgc3VjaCBiaW5kaW5ncyBhcmUgZGlzYWxsb3dlZCB1bmxlc3MgeW91IGNhblxyXG4gKiBkZXRlcm1pbmUgdGhhdCBzb21ldGhpbmcgZXhwbGljaXRseSBzYXlzIGl0J3Mgc2FmZSB0byB1c2UgYSB2YWx1ZSBmb3IgYmluZGluZyBpbiB0aGF0XHJcbiAqIGNvbnRleHQuICBZb3UgY2FuIHRoZW4gYXVkaXQgeW91ciBjb2RlIChhIHNpbXBsZSBncmVwIHdvdWxkIGRvKSB0byBlbnN1cmUgdGhhdCB0aGlzIGlzIG9ubHkgZG9uZVxyXG4gKiBmb3IgdGhvc2UgdmFsdWVzIHRoYXQgeW91IGNhbiBlYXNpbHkgdGVsbCBhcmUgc2FmZSAtIGJlY2F1c2UgdGhleSB3ZXJlIHJlY2VpdmVkIGZyb20geW91ciBzZXJ2ZXIsXHJcbiAqIHNhbml0aXplZCBieSB5b3VyIGxpYnJhcnksIGV0Yy4gIFlvdSBjYW4gb3JnYW5pemUgeW91ciBjb2RlYmFzZSB0byBoZWxwIHdpdGggdGhpcyAtIHBlcmhhcHNcclxuICogYWxsb3dpbmcgb25seSB0aGUgZmlsZXMgaW4gYSBzcGVjaWZpYyBkaXJlY3RvcnkgdG8gZG8gdGhpcy4gIEVuc3VyaW5nIHRoYXQgdGhlIGludGVybmFsIEFQSVxyXG4gKiBleHBvc2VkIGJ5IHRoYXQgY29kZSBkb2Vzbid0IG1hcmt1cCBhcmJpdHJhcnkgdmFsdWVzIGFzIHNhZmUgdGhlbiBiZWNvbWVzIGEgbW9yZSBtYW5hZ2VhYmxlIHRhc2suXHJcbiAqXHJcbiAqIEluIHRoZSBjYXNlIG9mIEFuZ3VsYXJKUycgU0NFIHNlcnZpY2UsIG9uZSB1c2VzIHtAbGluayBuZy4kc2NlI3RydXN0QXMgJHNjZS50cnVzdEFzfSAoYW5kIHNob3J0aGFuZFxyXG4gKiBtZXRob2RzIHN1Y2ggYXMge0BsaW5rIG5nLiRzY2UjdHJ1c3RBc0h0bWwgJHNjZS50cnVzdEFzSHRtbH0sIGV0Yy4pIHRvIG9idGFpbiB2YWx1ZXMgdGhhdCB3aWxsIGJlXHJcbiAqIGFjY2VwdGVkIGJ5IFNDRSAvIHByaXZpbGVnZWQgY29udGV4dHMuXHJcbiAqXHJcbiAqXHJcbiAqICMjIEhvdyBkb2VzIGl0IHdvcms/XHJcbiAqXHJcbiAqIEluIHByaXZpbGVnZWQgY29udGV4dHMsIGRpcmVjdGl2ZXMgYW5kIGNvZGUgd2lsbCBiaW5kIHRvIHRoZSByZXN1bHQgb2Yge0BsaW5rIG5nLiRzY2UjZ2V0VHJ1c3RlZFxyXG4gKiAkc2NlLmdldFRydXN0ZWQoY29udGV4dCwgdmFsdWUpfSByYXRoZXIgdGhhbiB0byB0aGUgdmFsdWUgZGlyZWN0bHkuICBEaXJlY3RpdmVzIHVzZSB7QGxpbmtcclxuICogbmcuJHNjZSNwYXJzZSAkc2NlLnBhcnNlQXN9IHJhdGhlciB0aGFuIGAkcGFyc2VgIHRvIHdhdGNoIGF0dHJpYnV0ZSBiaW5kaW5ncywgd2hpY2ggcGVyZm9ybXMgdGhlXHJcbiAqIHtAbGluayBuZy4kc2NlI2dldFRydXN0ZWQgJHNjZS5nZXRUcnVzdGVkfSBiZWhpbmQgdGhlIHNjZW5lcyBvbiBub24tY29uc3RhbnQgbGl0ZXJhbHMuXHJcbiAqXHJcbiAqIEFzIGFuIGV4YW1wbGUsIHtAbGluayBuZy5kaXJlY3RpdmU6bmdCaW5kSHRtbCBuZ0JpbmRIdG1sfSB1c2VzIHtAbGlua1xyXG4gKiBuZy4kc2NlI3BhcnNlQXNIdG1sICRzY2UucGFyc2VBc0h0bWwoYmluZGluZyBleHByZXNzaW9uKX0uICBIZXJlJ3MgdGhlIGFjdHVhbCBjb2RlIChzbGlnaHRseVxyXG4gKiBzaW1wbGlmaWVkKTpcclxuICpcclxuICogPHByZSBjbGFzcz1cInByZXR0eXByaW50XCI+XHJcbiAqICAgdmFyIG5nQmluZEh0bWxEaXJlY3RpdmUgPSBbJyRzY2UnLCBmdW5jdGlvbigkc2NlKSB7XHJcbiAqICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICogICAgICAgc2NvcGUuJHdhdGNoKCRzY2UucGFyc2VBc0h0bWwoYXR0ci5uZ0JpbmRIdG1sKSwgZnVuY3Rpb24odmFsdWUpIHtcclxuICogICAgICAgICBlbGVtZW50Lmh0bWwodmFsdWUgfHwgJycpO1xyXG4gKiAgICAgICB9KTtcclxuICogICAgIH07XHJcbiAqICAgfV07XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiAjIyBJbXBhY3Qgb24gbG9hZGluZyB0ZW1wbGF0ZXNcclxuICpcclxuICogVGhpcyBhcHBsaWVzIGJvdGggdG8gdGhlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdJbmNsdWRlIGBuZy1pbmNsdWRlYH0gZGlyZWN0aXZlIGFzIHdlbGwgYXNcclxuICogYHRlbXBsYXRlVXJsYCdzIHNwZWNpZmllZCBieSB7QGxpbmsgZ3VpZGUvZGlyZWN0aXZlIGRpcmVjdGl2ZXN9LlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBBbmd1bGFyIG9ubHkgbG9hZHMgdGVtcGxhdGVzIGZyb20gdGhlIHNhbWUgZG9tYWluIGFuZCBwcm90b2NvbCBhcyB0aGUgYXBwbGljYXRpb25cclxuICogZG9jdW1lbnQuICBUaGlzIGlzIGRvbmUgYnkgY2FsbGluZyB7QGxpbmsgbmcuJHNjZSNnZXRUcnVzdGVkUmVzb3VyY2VVcmxcclxuICogJHNjZS5nZXRUcnVzdGVkUmVzb3VyY2VVcmx9IG9uIHRoZSB0ZW1wbGF0ZSBVUkwuICBUbyBsb2FkIHRlbXBsYXRlcyBmcm9tIG90aGVyIGRvbWFpbnMgYW5kL29yXHJcbiAqIHByb3RvY29scywgeW91IG1heSBlaXRoZXIgZWl0aGVyIHtAbGluayBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciNyZXNvdXJjZVVybFdoaXRlbGlzdCB3aGl0ZWxpc3RcclxuICogdGhlbX0gb3Ige0BsaW5rIG5nLiRzY2UjdHJ1c3RBc1Jlc291cmNlVXJsIHdyYXAgaXR9IGludG8gYSB0cnVzdGVkIHZhbHVlLlxyXG4gKlxyXG4gKiAqUGxlYXNlIG5vdGUqOlxyXG4gKiBUaGUgYnJvd3NlcidzXHJcbiAqIHtAbGluayBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Jyb3dzZXJzZWMvd2lraS9QYXJ0MiNTYW1lLW9yaWdpbl9wb2xpY3lfZm9yX1hNTEh0dHBSZXF1ZXN0XHJcbiAqIFNhbWUgT3JpZ2luIFBvbGljeX0gYW5kIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9jb3JzLyBDcm9zcy1PcmlnaW4gUmVzb3VyY2UgU2hhcmluZyAoQ09SUyl9XHJcbiAqIHBvbGljeSBhcHBseSBpbiBhZGRpdGlvbiB0byB0aGlzIGFuZCBtYXkgZnVydGhlciByZXN0cmljdCB3aGV0aGVyIHRoZSB0ZW1wbGF0ZSBpcyBzdWNjZXNzZnVsbHlcclxuICogbG9hZGVkLiAgVGhpcyBtZWFucyB0aGF0IHdpdGhvdXQgdGhlIHJpZ2h0IENPUlMgcG9saWN5LCBsb2FkaW5nIHRlbXBsYXRlcyBmcm9tIGEgZGlmZmVyZW50IGRvbWFpblxyXG4gKiB3b24ndCB3b3JrIG9uIGFsbCBicm93c2Vycy4gIEFsc28sIGxvYWRpbmcgdGVtcGxhdGVzIGZyb20gYGZpbGU6Ly9gIFVSTCBkb2VzIG5vdCB3b3JrIG9uIHNvbWVcclxuICogYnJvd3NlcnMuXHJcbiAqXHJcbiAqICMjIFRoaXMgZmVlbHMgbGlrZSB0b28gbXVjaCBvdmVyaGVhZCBmb3IgdGhlIGRldmVsb3Blcj9cclxuICpcclxuICogSXQncyBpbXBvcnRhbnQgdG8gcmVtZW1iZXIgdGhhdCBTQ0Ugb25seSBhcHBsaWVzIHRvIGludGVycG9sYXRpb24gZXhwcmVzc2lvbnMuXHJcbiAqXHJcbiAqIElmIHlvdXIgZXhwcmVzc2lvbnMgYXJlIGNvbnN0YW50IGxpdGVyYWxzLCB0aGV5J3JlIGF1dG9tYXRpY2FsbHkgdHJ1c3RlZCBhbmQgeW91IGRvbid0IG5lZWQgdG9cclxuICogY2FsbCBgJHNjZS50cnVzdEFzYCBvbiB0aGVtLiAgKGUuZy5cclxuICogYDxkaXYgbmctaHRtbC1iaW5kLXVuc2FmZT1cIic8Yj5pbXBsaWNpdGx5IHRydXN0ZWQ8L2I+J1wiPjwvZGl2PmApIGp1c3Qgd29ya3MuXHJcbiAqXHJcbiAqIEFkZGl0aW9uYWxseSwgYGFbaHJlZl1gIGFuZCBgaW1nW3NyY11gIGF1dG9tYXRpY2FsbHkgc2FuaXRpemUgdGhlaXIgVVJMcyBhbmQgZG8gbm90IHBhc3MgdGhlbVxyXG4gKiB0aHJvdWdoIHtAbGluayBuZy4kc2NlI2dldFRydXN0ZWQgJHNjZS5nZXRUcnVzdGVkfS4gIFNDRSBkb2Vzbid0IHBsYXkgYSByb2xlIGhlcmUuXHJcbiAqXHJcbiAqIFRoZSBpbmNsdWRlZCB7QGxpbmsgbmcuJHNjZURlbGVnYXRlICRzY2VEZWxlZ2F0ZX0gY29tZXMgd2l0aCBzYW5lIGRlZmF1bHRzIHRvIGFsbG93IHlvdSB0byBsb2FkXHJcbiAqIHRlbXBsYXRlcyBpbiBgbmctaW5jbHVkZWAgZnJvbSB5b3VyIGFwcGxpY2F0aW9uJ3MgZG9tYWluIHdpdGhvdXQgaGF2aW5nIHRvIGV2ZW4ga25vdyBhYm91dCBTQ0UuXHJcbiAqIEl0IGJsb2NrcyBsb2FkaW5nIHRlbXBsYXRlcyBmcm9tIG90aGVyIGRvbWFpbnMgb3IgbG9hZGluZyB0ZW1wbGF0ZXMgb3ZlciBodHRwIGZyb20gYW4gaHR0cHNcclxuICogc2VydmVkIGRvY3VtZW50LiAgWW91IGNhbiBjaGFuZ2UgdGhlc2UgYnkgc2V0dGluZyB5b3VyIG93biBjdXN0b20ge0BsaW5rXHJcbiAqIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyI3Jlc291cmNlVXJsV2hpdGVsaXN0IHdoaXRlbGlzdHN9IGFuZCB7QGxpbmtcclxuICogbmcuJHNjZURlbGVnYXRlUHJvdmlkZXIjcmVzb3VyY2VVcmxCbGFja2xpc3QgYmxhY2tsaXN0c30gZm9yIG1hdGNoaW5nIHN1Y2ggVVJMcy5cclxuICpcclxuICogVGhpcyBzaWduaWZpY2FudGx5IHJlZHVjZXMgdGhlIG92ZXJoZWFkLiAgSXQgaXMgZmFyIGVhc2llciB0byBwYXkgdGhlIHNtYWxsIG92ZXJoZWFkIGFuZCBoYXZlIGFuXHJcbiAqIGFwcGxpY2F0aW9uIHRoYXQncyBzZWN1cmUgYW5kIGNhbiBiZSBhdWRpdGVkIHRvIHZlcmlmeSB0aGF0IHdpdGggbXVjaCBtb3JlIGVhc2UgdGhhbiBib2x0aW5nXHJcbiAqIHNlY3VyaXR5IG9udG8gYW4gYXBwbGljYXRpb24gbGF0ZXIuXHJcbiAqXHJcbiAqICMjIFdoYXQgdHJ1c3RlZCBjb250ZXh0IHR5cGVzIGFyZSBzdXBwb3J0ZWQ/PGEgbmFtZT1cImNvbnRleHRzXCI+PC9hPlxyXG4gKlxyXG4gKiB8IENvbnRleHQgICAgICAgICAgICAgfCBOb3RlcyAgICAgICAgICB8XHJcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLXxcclxuICogfCBgJHNjZS5IVE1MYCAgICAgICAgIHwgRm9yIEhUTUwgdGhhdCdzIHNhZmUgdG8gc291cmNlIGludG8gdGhlIGFwcGxpY2F0aW9uLiAgVGhlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdCaW5kSHRtbCBuZ0JpbmRIdG1sfSBkaXJlY3RpdmUgdXNlcyB0aGlzIGNvbnRleHQgZm9yIGJpbmRpbmdzLiB8XHJcbiAqIHwgYCRzY2UuQ1NTYCAgICAgICAgICB8IEZvciBDU1MgdGhhdCdzIHNhZmUgdG8gc291cmNlIGludG8gdGhlIGFwcGxpY2F0aW9uLiAgQ3VycmVudGx5IHVudXNlZC4gIEZlZWwgZnJlZSB0byB1c2UgaXQgaW4geW91ciBvd24gZGlyZWN0aXZlcy4gfFxyXG4gKiB8IGAkc2NlLlVSTGAgICAgICAgICAgfCBGb3IgVVJMcyB0aGF0IGFyZSBzYWZlIHRvIGZvbGxvdyBhcyBsaW5rcy4gIEN1cnJlbnRseSB1bnVzZWQgKGA8YSBocmVmPWAgYW5kIGA8aW1nIHNyYz1gIHNhbml0aXplIHRoZWlyIHVybHMgYW5kIGRvbid0IGNvbnNpdGl0dXRlIGFuIFNDRSBjb250ZXh0LiB8XHJcbiAqIHwgYCRzY2UuUkVTT1VSQ0VfVVJMYCB8IEZvciBVUkxzIHRoYXQgYXJlIG5vdCBvbmx5IHNhZmUgdG8gZm9sbG93IGFzIGxpbmtzLCBidXQgd2hvc2UgY29udGVucyBhcmUgYWxzbyBzYWZlIHRvIGluY2x1ZGUgaW4geW91ciBhcHBsaWNhdGlvbi4gIEV4YW1wbGVzIGluY2x1ZGUgYG5nLWluY2x1ZGVgLCBgc3JjYCAvIGBuZ1NyY2AgYmluZGluZ3MgZm9yIHRhZ3Mgb3RoZXIgdGhhbiBgSU1HYCAoZS5nLiBgSUZSQU1FYCwgYE9CSkVDVGAsIGV0Yy4pICA8YnI+PGJyPk5vdGUgdGhhdCBgJHNjZS5SRVNPVVJDRV9VUkxgIG1ha2VzIGEgc3Ryb25nZXIgc3RhdGVtZW50IGFib3V0IHRoZSBVUkwgdGhhbiBgJHNjZS5VUkxgIGRvZXMgYW5kIHRoZXJlZm9yZSBjb250ZXh0cyByZXF1aXJpbmcgdmFsdWVzIHRydXN0ZWQgZm9yIGAkc2NlLlJFU09VUkNFX1VSTGAgY2FuIGJlIHVzZWQgYW55d2hlcmUgdGhhdCB2YWx1ZXMgdHJ1c3RlZCBmb3IgYCRzY2UuVVJMYCBhcmUgcmVxdWlyZWQuIHxcclxuICogfCBgJHNjZS5KU2AgICAgICAgICAgIHwgRm9yIEphdmFTY3JpcHQgdGhhdCBpcyBzYWZlIHRvIGV4ZWN1dGUgaW4geW91ciBhcHBsaWNhdGlvbidzIGNvbnRleHQuICBDdXJyZW50bHkgdW51c2VkLiAgRmVlbCBmcmVlIHRvIHVzZSBpdCBpbiB5b3VyIG93biBkaXJlY3RpdmVzLiB8XHJcbiAqXHJcbiAqICMjIFNob3cgbWUgYW4gZXhhbXBsZS5cclxuICpcclxuICpcclxuICpcclxuICogQGV4YW1wbGVcclxuIDxleGFtcGxlIG1vZHVsZT1cIm15U2NlQXBwXCI+XHJcbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgIDxkaXYgbmctY29udHJvbGxlcj1cIm15QXBwQ29udHJvbGxlciBhcyBteUN0cmxcIj5cclxuICAgICAgPGkgbmctYmluZC1odG1sPVwibXlDdHJsLmV4cGxpY2l0bHlUcnVzdGVkSHRtbFwiIGlkPVwiZXhwbGljaXRseVRydXN0ZWRIdG1sXCI+PC9pPjxicj48YnI+XHJcbiAgICAgIDxiPlVzZXIgY29tbWVudHM8L2I+PGJyPlxyXG4gICAgICBCeSBkZWZhdWx0LCBIVE1MIHRoYXQgaXNuJ3QgZXhwbGljaXRseSB0cnVzdGVkIChlLmcuIEFsaWNlJ3MgY29tbWVudCkgaXMgc2FuaXRpemVkIHdoZW4gJHNhbml0aXplIGlzIGF2YWlsYWJsZS4gIElmICRzYW5pdGl6ZSBpc24ndCBhdmFpbGFibGUsIHRoaXMgcmVzdWx0cyBpbiBhbiBlcnJvciBpbnN0ZWFkIG9mIGFuIGV4cGxvaXQuXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJ3ZWxsXCI+XHJcbiAgICAgICAgPGRpdiBuZy1yZXBlYXQ9XCJ1c2VyQ29tbWVudCBpbiBteUN0cmwudXNlckNvbW1lbnRzXCI+XHJcbiAgICAgICAgICA8Yj57e3VzZXJDb21tZW50Lm5hbWV9fTwvYj46XHJcbiAgICAgICAgICA8c3BhbiBuZy1iaW5kLWh0bWw9XCJ1c2VyQ29tbWVudC5odG1sQ29tbWVudFwiIGNsYXNzPVwiaHRtbENvbW1lbnRcIj48L3NwYW4+XHJcbiAgICAgICAgICA8YnI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgPC9maWxlPlxyXG5cclxuICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XHJcbiAgICB2YXIgbXlTY2VBcHAgPSBhbmd1bGFyLm1vZHVsZSgnbXlTY2VBcHAnLCBbJ25nU2FuaXRpemUnXSk7XHJcblxyXG4gICAgbXlTY2VBcHAuY29udHJvbGxlcihcIm15QXBwQ29udHJvbGxlclwiLCBmdW5jdGlvbiBteUFwcENvbnRyb2xsZXIoJGh0dHAsICR0ZW1wbGF0ZUNhY2hlLCAkc2NlKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgJGh0dHAuZ2V0KFwidGVzdF9kYXRhLmpzb25cIiwge2NhY2hlOiAkdGVtcGxhdGVDYWNoZX0pLnN1Y2Nlc3MoZnVuY3Rpb24odXNlckNvbW1lbnRzKSB7XHJcbiAgICAgICAgc2VsZi51c2VyQ29tbWVudHMgPSB1c2VyQ29tbWVudHM7XHJcbiAgICAgIH0pO1xyXG4gICAgICBzZWxmLmV4cGxpY2l0bHlUcnVzdGVkSHRtbCA9ICRzY2UudHJ1c3RBc0h0bWwoXHJcbiAgICAgICAgICAnPHNwYW4gb25tb3VzZW92ZXI9XCJ0aGlzLnRleHRDb250ZW50PSZxdW90O0V4cGxpY2l0bHkgdHJ1c3RlZCBIVE1MIGJ5cGFzc2VzICcgK1xyXG4gICAgICAgICAgJ3Nhbml0aXphdGlvbi4mcXVvdDtcIj5Ib3ZlciBvdmVyIHRoaXMgdGV4dC48L3NwYW4+Jyk7XHJcbiAgICB9KTtcclxuICA8L2ZpbGU+XHJcblxyXG4gIDxmaWxlIG5hbWU9XCJ0ZXN0X2RhdGEuanNvblwiPlxyXG4gICAgW1xyXG4gICAgICB7IFwibmFtZVwiOiBcIkFsaWNlXCIsXHJcbiAgICAgICAgXCJodG1sQ29tbWVudFwiOiBcIjxzcGFuIG9ubW91c2VvdmVyPSd0aGlzLnRleHRDb250ZW50PVxcXCJQV04zRCFcXFwiJz5JcyA8aT5hbnlvbmU8L2k+IHJlYWRpbmcgdGhpcz88L3NwYW4+XCJcclxuICAgICAgfSxcclxuICAgICAgeyBcIm5hbWVcIjogXCJCb2JcIixcclxuICAgICAgICBcImh0bWxDb21tZW50XCI6IFwiPGk+WWVzITwvaT4gIEFtIEkgdGhlIG9ubHkgb3RoZXIgb25lP1wiXHJcbiAgICAgIH1cclxuICAgIF1cclxuICA8L2ZpbGU+XHJcblxyXG4gIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxyXG4gICAgZGVzY3JpYmUoJ1NDRSBkb2MgZGVtbycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpdCgnc2hvdWxkIHNhbml0aXplIHVudHJ1c3RlZCB2YWx1ZXMnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBleHBlY3QoZWxlbWVudCgnLmh0bWxDb21tZW50JykuaHRtbCgpKS50b0JlKCc8c3Bhbj5JcyA8aT5hbnlvbmU8L2k+IHJlYWRpbmcgdGhpcz88L3NwYW4+Jyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpdCgnc2hvdWxkIE5PVCBzYW5pdGl6ZSBleHBsaWNpdGx5IHRydXN0ZWQgdmFsdWVzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNleHBsaWNpdGx5VHJ1c3RlZEh0bWwnKS5odG1sKCkpLnRvQmUoXHJcbiAgICAgICAgICAgICc8c3BhbiBvbm1vdXNlb3Zlcj1cInRoaXMudGV4dENvbnRlbnQ9JnF1b3Q7RXhwbGljaXRseSB0cnVzdGVkIEhUTUwgYnlwYXNzZXMgJyArXHJcbiAgICAgICAgICAgICdzYW5pdGl6YXRpb24uJnF1b3Q7XCI+SG92ZXIgb3ZlciB0aGlzIHRleHQuPC9zcGFuPicpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIDwvZmlsZT5cclxuIDwvZXhhbXBsZT5cclxuICpcclxuICpcclxuICpcclxuICogIyMgQ2FuIEkgZGlzYWJsZSBTQ0UgY29tcGxldGVseT9cclxuICpcclxuICogWWVzLCB5b3UgY2FuLiAgSG93ZXZlciwgdGhpcyBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gIFNDRSBnaXZlcyB5b3UgYSBsb3Qgb2Ygc2VjdXJpdHkgYmVuZWZpdHNcclxuICogZm9yIGxpdHRsZSBjb2Rpbmcgb3ZlcmhlYWQuICBJdCB3aWxsIGJlIG11Y2ggaGFyZGVyIHRvIHRha2UgYW4gU0NFIGRpc2FibGVkIGFwcGxpY2F0aW9uIGFuZFxyXG4gKiBlaXRoZXIgc2VjdXJlIGl0IG9uIHlvdXIgb3duIG9yIGVuYWJsZSBTQ0UgYXQgYSBsYXRlciBzdGFnZS4gIEl0IG1pZ2h0IG1ha2Ugc2Vuc2UgdG8gZGlzYWJsZSBTQ0VcclxuICogZm9yIGNhc2VzIHdoZXJlIHlvdSBoYXZlIGEgbG90IG9mIGV4aXN0aW5nIGNvZGUgdGhhdCB3YXMgd3JpdHRlbiBiZWZvcmUgU0NFIHdhcyBpbnRyb2R1Y2VkIGFuZFxyXG4gKiB5b3UncmUgbWlncmF0aW5nIHRoZW0gYSBtb2R1bGUgYXQgYSB0aW1lLlxyXG4gKlxyXG4gKiBUaGF0IHNhaWQsIGhlcmUncyBob3cgeW91IGNhbiBjb21wbGV0ZWx5IGRpc2FibGUgU0NFOlxyXG4gKlxyXG4gKiA8cHJlIGNsYXNzPVwicHJldHR5cHJpbnRcIj5cclxuICogICBhbmd1bGFyLm1vZHVsZSgnbXlBcHBXaXRoU2NlRGlzYWJsZWRteUFwcCcsIFtdKS5jb25maWcoZnVuY3Rpb24oJHNjZVByb3ZpZGVyKSB7XHJcbiAqICAgICAvLyBDb21wbGV0ZWx5IGRpc2FibGUgU0NFLiAgRm9yIGRlbW9uc3RyYXRpb24gcHVycG9zZXMgb25seSFcclxuICogICAgIC8vIERvIG5vdCB1c2UgaW4gbmV3IHByb2plY3RzLlxyXG4gKiAgICAgJHNjZVByb3ZpZGVyLmVuYWJsZWQoZmFsc2UpO1xyXG4gKiAgIH0pO1xyXG4gKiA8L3ByZT5cclxuICpcclxuICovXHJcblxyXG5mdW5jdGlvbiAkU2NlUHJvdmlkZXIoKSB7XHJcbiAgdmFyIGVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy5zY2VQcm92aWRlciNlbmFibGVkXHJcbiAgICogQG1ldGhvZE9mIG5nLiRzY2VQcm92aWRlclxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdmFsdWUgSWYgcHJvdmlkZWQsIHRoZW4gZW5hYmxlcy9kaXNhYmxlcyBTQ0UuXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBTQ0UgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogRW5hYmxlcy9kaXNhYmxlcyBTQ0UgYW5kIHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUuXHJcbiAgICovXHJcbiAgdGhpcy5lbmFibGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBlbmFibGVkID0gISF2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbmFibGVkO1xyXG4gIH07XHJcblxyXG5cclxuICAvKiBEZXNpZ24gbm90ZXMgb24gdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIFNDRS5cclxuICAgKlxyXG4gICAqIFRoZSBBUEkgY29udHJhY3QgZm9yIHRoZSBTQ0UgZGVsZWdhdGVcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogVGhlIFNDRSBkZWxlZ2F0ZSBvYmplY3QgbXVzdCBwcm92aWRlIHRoZSBmb2xsb3dpbmcgMyBtZXRob2RzOlxyXG4gICAqXHJcbiAgICogLSB0cnVzdEFzKGNvbnRleHRFbnVtLCB2YWx1ZSlcclxuICAgKiAgICAgVGhpcyBtZXRob2QgaXMgdXNlZCB0byB0ZWxsIHRoZSBTQ0Ugc2VydmljZSB0aGF0IHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBPSyB0byB1c2UgaW4gdGhlXHJcbiAgICogICAgIGNvbnRleHRzIHNwZWNpZmllZCBieSBjb250ZXh0RW51bS4gIEl0IG11c3QgcmV0dXJuIGFuIG9iamVjdCB0aGF0IHdpbGwgYmUgYWNjZXB0ZWQgYnlcclxuICAgKiAgICAgZ2V0VHJ1c3RlZCgpIGZvciBhIGNvbXBhdGlibGUgY29udGV4dEVudW0gYW5kIHJldHVybiB0aGlzIHZhbHVlLlxyXG4gICAqXHJcbiAgICogLSB2YWx1ZU9mKHZhbHVlKVxyXG4gICAqICAgICBGb3IgdmFsdWVzIHRoYXQgd2VyZSBub3QgcHJvZHVjZWQgYnkgdHJ1c3RBcygpLCByZXR1cm4gdGhlbSBhcyBpcy4gIEZvciB2YWx1ZXMgdGhhdCB3ZXJlXHJcbiAgICogICAgIHByb2R1Y2VkIGJ5IHRydXN0QXMoKSwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIGlucHV0IHZhbHVlIHRvIHRydXN0QXMuICBCYXNpY2FsbHksIGlmXHJcbiAgICogICAgIHRydXN0QXMgaXMgd3JhcHBpbmcgdGhlIGdpdmVuIHZhbHVlcyBpbnRvIHNvbWUgdHlwZSwgdGhpcyBvcGVyYXRpb24gdW53cmFwcyBpdCB3aGVuIGdpdmVuXHJcbiAgICogICAgIHN1Y2ggYSB2YWx1ZS5cclxuICAgKlxyXG4gICAqIC0gZ2V0VHJ1c3RlZChjb250ZXh0RW51bSwgdmFsdWUpXHJcbiAgICogICAgIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiB0aGUgYSB2YWx1ZSB0aGF0IGlzIHNhZmUgdG8gdXNlIGluIHRoZSBjb250ZXh0IHNwZWNpZmllZCBieVxyXG4gICAqICAgICBjb250ZXh0RW51bSBvciB0aHJvdyBhbmQgZXhjZXB0aW9uIG90aGVyd2lzZS5cclxuICAgKlxyXG4gICAqIE5PVEU6IFRoaXMgY29udHJhY3QgZGVsaWJlcmF0ZWx5IGRvZXMgTk9UIHN0YXRlIHRoYXQgdmFsdWVzIHJldHVybmVkIGJ5IHRydXN0QXMoKSBtdXN0IGJlIG9wYXF1ZVxyXG4gICAqIG9yIHdyYXBwZWQgaW4gc29tZSBob2xkZXIgb2JqZWN0LiAgVGhhdCBoYXBwZW5zIHRvIGJlIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC4gIEZvciBpbnN0YW5jZSxcclxuICAgKiBhbiBpbXBsZW1lbnRhdGlvbiBjb3VsZCBtYWludGFpbiBhIHJlZ2lzdHJ5IG9mIGFsbCB0cnVzdGVkIG9iamVjdHMgYnkgY29udGV4dC4gIEluIHN1Y2ggYSBjYXNlLFxyXG4gICAqIHRydXN0QXMoKSB3b3VsZCByZXR1cm4gdGhlIHNhbWUgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBpbi4gIGdldFRydXN0ZWQoKSB3b3VsZCByZXR1cm4gdGhlIHNhbWVcclxuICAgKiBvYmplY3QgcGFzc2VkIGluIGlmIGl0IHdhcyBmb3VuZCBpbiB0aGUgcmVnaXN0cnkgdW5kZXIgYSBjb21wYXRpYmxlIGNvbnRleHQgb3IgdGhyb3cgYW5cclxuICAgKiBleGNlcHRpb24gb3RoZXJ3aXNlLiAgQW4gaW1wbGVtZW50YXRpb24gbWlnaHQgb25seSB3cmFwIHZhbHVlcyBzb21lIG9mIHRoZSB0aW1lIGJhc2VkIG9uXHJcbiAgICogc29tZSBjcml0ZXJpYS4gIGdldFRydXN0ZWQoKSBtaWdodCByZXR1cm4gYSB2YWx1ZSBhbmQgbm90IHRocm93IGFuIGV4Y2VwdGlvbiBmb3Igc3BlY2lhbFxyXG4gICAqIGNvbnN0YW50cyBvciBvYmplY3RzIGV2ZW4gaWYgbm90IHdyYXBwZWQuICBBbGwgc3VjaCBpbXBsZW1lbnRhdGlvbnMgZnVsZmlsbCB0aGlzIGNvbnRyYWN0LlxyXG4gICAqXHJcbiAgICpcclxuICAgKiBBIG5vdGUgb24gdGhlIGluaGVyaXRhbmNlIG1vZGVsIGZvciBTQ0UgY29udGV4dHNcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBJJ3ZlIHVzZWQgaW5oZXJpdGFuY2UgYW5kIG1hZGUgUkVTT1VSQ0VfVVJMIHdyYXBwZWQgdHlwZXMgYSBzdWJ0eXBlIG9mIFVSTCB3cmFwcGVkIHR5cGVzLiAgVGhpc1xyXG4gICAqIGlzIHB1cmVseSBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxyXG4gICAqXHJcbiAgICogVGhlIGNvbnRyYWN0IGlzIHNpbXBseSB0aGlzOlxyXG4gICAqXHJcbiAgICogICAgIGdldFRydXN0ZWQoJHNjZS5SRVNPVVJDRV9VUkwsIHZhbHVlKSBzdWNjZWVkaW5nIGltcGxpZXMgdGhhdCBnZXRUcnVzdGVkKCRzY2UuVVJMLCB2YWx1ZSlcclxuICAgKiAgICAgd2lsbCBhbHNvIHN1Y2NlZWQuXHJcbiAgICpcclxuICAgKiBJbmhlcml0YW5jZSBoYXBwZW5zIHRvIGNhcHR1cmUgdGhpcyBpbiBhIG5hdHVyYWwgd2F5LiAgSW4gc29tZSBmdXR1cmUsIHdlXHJcbiAgICogbWF5IG5vdCB1c2UgaW5oZXJpdGFuY2UgYW55bW9yZS4gIFRoYXQgaXMgT0sgYmVjYXVzZSBubyBjb2RlIG91dHNpZGUgb2ZcclxuICAgKiBzY2UuanMgYW5kIHNjZVNwZWNzLmpzIHdvdWxkIG5lZWQgdG8gYmUgYXdhcmUgb2YgdGhpcyBkZXRhaWwuXHJcbiAgICovXHJcblxyXG4gIHRoaXMuJGdldCA9IFsnJHBhcnNlJywgJyRkb2N1bWVudCcsICckc2NlRGVsZWdhdGUnLCBmdW5jdGlvbihcclxuICAgICAgICAgICAgICAgICRwYXJzZSwgICAkZG9jdW1lbnQsICAgJHNjZURlbGVnYXRlKSB7XHJcbiAgICAvLyBQcmVyZXE6IEVuc3VyZSB0aGF0IHdlJ3JlIG5vdCBydW5uaW5nIGluIElFOCBxdWlya3MgbW9kZS4gIEluIHRoYXQgbW9kZSwgSUUgYWxsb3dzXHJcbiAgICAvLyB0aGUgXCJleHByZXNzaW9uKGphdmFzY3JpcHQgZXhwcmVzc2lvbilcIiBzeW50YXggd2hpY2ggaXMgaW5zZWN1cmUuXHJcbiAgICBpZiAoZW5hYmxlZCAmJiBtc2llKSB7XHJcbiAgICAgIHZhciBkb2N1bWVudE1vZGUgPSAkZG9jdW1lbnRbMF0uZG9jdW1lbnRNb2RlO1xyXG4gICAgICBpZiAoZG9jdW1lbnRNb2RlICE9PSB1bmRlZmluZWQgJiYgZG9jdW1lbnRNb2RlIDwgOCkge1xyXG4gICAgICAgIHRocm93ICRzY2VNaW5FcnIoJ2llcXVpcmtzJyxcclxuICAgICAgICAgICdTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyBkb2VzIG5vdCBzdXBwb3J0IEludGVybmV0IEV4cGxvcmVyIHZlcnNpb24gPCA5IGluIHF1aXJrcyAnICtcclxuICAgICAgICAgICdtb2RlLiAgWW91IGNhbiBmaXggdGhpcyBieSBhZGRpbmcgdGhlIHRleHQgPCFkb2N0eXBlIGh0bWw+IHRvIHRoZSB0b3Agb2YgeW91ciBIVE1MICcgK1xyXG4gICAgICAgICAgJ2RvY3VtZW50LiAgU2VlIGh0dHA6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nLiRzY2UgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2NlID0gY29weShTQ0VfQ09OVEVYVFMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBuZy5zY2UjaXNFbmFibGVkXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBTQ0UgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLiAgSWYgeW91IHdhbnQgdG8gc2V0IHRoZSB2YWx1ZSwgeW91XHJcbiAgICAgKiBoYXZlIHRvIGRvIGl0IGF0IG1vZHVsZSBjb25maWcgdGltZSBvbiB7QGxpbmsgbmcuJHNjZVByb3ZpZGVyICRzY2VQcm92aWRlcn0uXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIFNDRSBpcyBlbmFibGVkLlxyXG4gICAgICovXHJcbiAgICBzY2UuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gZW5hYmxlZDtcclxuICAgIH07XHJcbiAgICBzY2UudHJ1c3RBcyA9ICRzY2VEZWxlZ2F0ZS50cnVzdEFzO1xyXG4gICAgc2NlLmdldFRydXN0ZWQgPSAkc2NlRGVsZWdhdGUuZ2V0VHJ1c3RlZDtcclxuICAgIHNjZS52YWx1ZU9mID0gJHNjZURlbGVnYXRlLnZhbHVlT2Y7XHJcblxyXG4gICAgaWYgKCFlbmFibGVkKSB7XHJcbiAgICAgIHNjZS50cnVzdEFzID0gc2NlLmdldFRydXN0ZWQgPSBmdW5jdGlvbih0eXBlLCB2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH0sXHJcbiAgICAgIHNjZS52YWx1ZU9mID0gaWRlbnRpdHlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjcGFyc2VcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBDb252ZXJ0cyBBbmd1bGFyIHtAbGluayBndWlkZS9leHByZXNzaW9uIGV4cHJlc3Npb259IGludG8gYSBmdW5jdGlvbi4gIFRoaXMgaXMgbGlrZSB7QGxpbmtcclxuICAgICAqIG5nLiRwYXJzZSAkcGFyc2V9IGFuZCBpcyBpZGVudGljYWwgd2hlbiB0aGUgZXhwcmVzc2lvbiBpcyBhIGxpdGVyYWwgY29uc3RhbnQuICBPdGhlcndpc2UsIGl0XHJcbiAgICAgKiB3cmFwcyB0aGUgZXhwcmVzc2lvbiBpbiBhIGNhbGwgdG8ge0BsaW5rIG5nLiRzY2UjZ2V0VHJ1c3RlZCAkc2NlLmdldFRydXN0ZWQoKnR5cGUqLFxyXG4gICAgICogKnJlc3VsdCopfVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBraW5kIG9mIFNDRSBjb250ZXh0IGluIHdoaWNoIHRoaXMgcmVzdWx0IHdpbGwgYmUgdXNlZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFN0cmluZyBleHByZXNzaW9uIHRvIGNvbXBpbGUuXHJcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oY29udGV4dCwgbG9jYWxzKX0gYSBmdW5jdGlvbiB3aGljaCByZXByZXNlbnRzIHRoZSBjb21waWxlZCBleHByZXNzaW9uOlxyXG4gICAgICpcclxuICAgICAqICAgICogYGNvbnRleHRgIMOi4oKs4oCcIGB7b2JqZWN0fWAgw6LigqzigJwgYW4gb2JqZWN0IGFnYWluc3Qgd2hpY2ggYW55IGV4cHJlc3Npb25zIGVtYmVkZGVkIGluIHRoZSBzdHJpbmdzXHJcbiAgICAgKiAgICAgIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCAodHlwaWNhbGx5IGEgc2NvcGUgb2JqZWN0KS5cclxuICAgICAqICAgICogYGxvY2Fsc2Agw6LigqzigJwgYHtvYmplY3Q9fWAgw6LigqzigJwgbG9jYWwgdmFyaWFibGVzIGNvbnRleHQgb2JqZWN0LCB1c2VmdWwgZm9yIG92ZXJyaWRpbmcgdmFsdWVzIGluXHJcbiAgICAgKiAgICAgIGBjb250ZXh0YC5cclxuICAgICAqL1xyXG4gICAgc2NlLnBhcnNlQXMgPSBmdW5jdGlvbiBzY2VQYXJzZUFzKHR5cGUsIGV4cHIpIHtcclxuICAgICAgdmFyIHBhcnNlZCA9ICRwYXJzZShleHByKTtcclxuICAgICAgaWYgKHBhcnNlZC5saXRlcmFsICYmIHBhcnNlZC5jb25zdGFudCkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNjZVBhcnNlQXNUcnVzdGVkKHNlbGYsIGxvY2Fscykge1xyXG4gICAgICAgICAgcmV0dXJuIHNjZS5nZXRUcnVzdGVkKHR5cGUsIHBhcnNlZChzZWxmLCBsb2NhbHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI3RydXN0QXNcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBEZWxlZ2F0ZXMgdG8ge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzIGAkc2NlRGVsZWdhdGUudHJ1c3RBc2B9LiAgQXMgc3VjaCwgcmV0dXJucyBhbiBvYmplY3RcclxuICAgICAqIHRoYXQgaXMgdHJ1c3RlZCBieSBhbmd1bGFyIGZvciB1c2UgaW4gc3BlY2lmaWVkIHN0cmljdCBjb250ZXh0dWFsIGVzY2FwaW5nIGNvbnRleHRzIChzdWNoIGFzXHJcbiAgICAgKiBuZy1odG1sLWJpbmQtdW5zYWZlLCBuZy1pbmNsdWRlLCBhbnkgc3JjIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uLCBhbnkgZG9tIGV2ZW50IGJpbmRpbmdcclxuICAgICAqIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uIHN1Y2ggYXMgZm9yIG9uY2xpY2ssICBldGMuKSB0aGF0IHVzZXMgdGhlIHByb3ZpZGVkIHZhbHVlLiAgU2VlICpcclxuICAgICAqIHtAbGluayBuZy4kc2NlICRzY2V9IGZvciBlbmFibGluZyBzdHJpY3QgY29udGV4dHVhbCBlc2NhcGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUga2luZCBvZiBjb250ZXh0IGluIHdoaWNoIHRoaXMgdmFsdWUgaXMgc2FmZSBmb3IgdXNlLiAgZS5nLiB1cmwsXHJcbiAgICAgKiAgIHJlc291cmNlX3VybCwgaHRtbCwganMgYW5kIGNzcy5cclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoYXQgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCB0cnVzdGVkL3NhZmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gQSB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0YW5kIGluIGZvciB0aGUgcHJvdmlkZWQgYHZhbHVlYCBpbiBwbGFjZXNcclxuICAgICAqIHdoZXJlIEFuZ3VsYXIgZXhwZWN0cyBhICRzY2UudHJ1c3RBcygpIHJldHVybiB2YWx1ZS5cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZSN0cnVzdEFzSHRtbFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS50cnVzdEFzSHRtbCh2YWx1ZSlgIMOi4oCg4oCZIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjdHJ1c3RBcyBgJHNjZURlbGVnYXRlLnRydXN0QXMoJHNjZS5IVE1MLCB2YWx1ZSlgfVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRydXN0QXMuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbmcuJHNjZSNnZXRUcnVzdGVkSHRtbFxyXG4gICAgICogICAgICRzY2UuZ2V0VHJ1c3RlZEh0bWwodmFsdWUpfSB0byBvYnRhaW4gdGhlIG9yaWdpbmFsIHZhbHVlLiAgKHByaXZpbGVnZWQgZGlyZWN0aXZlc1xyXG4gICAgICogICAgIG9ubHkgYWNjZXB0IGV4cHJlc3Npb25zIHRoYXQgYXJlIGVpdGhlciBsaXRlcmFsIGNvbnN0YW50cyBvciBhcmUgdGhlXHJcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlIG9mIHtAbGluayBuZy4kc2NlI3RydXN0QXMgJHNjZS50cnVzdEFzfS4pXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjdHJ1c3RBc1VybFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS50cnVzdEFzVXJsKHZhbHVlKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzIGAkc2NlRGVsZWdhdGUudHJ1c3RBcygkc2NlLlVSTCwgdmFsdWUpYH1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0cnVzdEFzLlxyXG4gICAgICogQHJldHVybnMgeyp9IEFuIG9iamVjdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8ge0BsaW5rIG5nLiRzY2UjZ2V0VHJ1c3RlZFVybFxyXG4gICAgICogICAgICRzY2UuZ2V0VHJ1c3RlZFVybCh2YWx1ZSl9IHRvIG9idGFpbiB0aGUgb3JpZ2luYWwgdmFsdWUuICAocHJpdmlsZWdlZCBkaXJlY3RpdmVzXHJcbiAgICAgKiAgICAgb25seSBhY2NlcHQgZXhwcmVzc2lvbnMgdGhhdCBhcmUgZWl0aGVyIGxpdGVyYWwgY29uc3RhbnRzIG9yIGFyZSB0aGVcclxuICAgICAqICAgICByZXR1cm4gdmFsdWUgb2Yge0BsaW5rIG5nLiRzY2UjdHJ1c3RBcyAkc2NlLnRydXN0QXN9LilcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZSN0cnVzdEFzUmVzb3VyY2VVcmxcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UudHJ1c3RBc1Jlc291cmNlVXJsKHZhbHVlKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzIGAkc2NlRGVsZWdhdGUudHJ1c3RBcygkc2NlLlJFU09VUkNFX1VSTCwgdmFsdWUpYH1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0cnVzdEFzLlxyXG4gICAgICogQHJldHVybnMgeyp9IEFuIG9iamVjdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8ge0BsaW5rIG5nLiRzY2UjZ2V0VHJ1c3RlZFJlc291cmNlVXJsXHJcbiAgICAgKiAgICAgJHNjZS5nZXRUcnVzdGVkUmVzb3VyY2VVcmwodmFsdWUpfSB0byBvYnRhaW4gdGhlIG9yaWdpbmFsIHZhbHVlLiAgKHByaXZpbGVnZWQgZGlyZWN0aXZlc1xyXG4gICAgICogICAgIG9ubHkgYWNjZXB0IGV4cHJlc3Npb25zIHRoYXQgYXJlIGVpdGhlciBsaXRlcmFsIGNvbnN0YW50cyBvciBhcmUgdGhlIHJldHVyblxyXG4gICAgICogICAgIHZhbHVlIG9mIHtAbGluayBuZy4kc2NlI3RydXN0QXMgJHNjZS50cnVzdEFzfS4pXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjdHJ1c3RBc0pzXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLnRydXN0QXNKcyh2YWx1ZSlgIMOi4oCg4oCZIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjdHJ1c3RBcyBgJHNjZURlbGVnYXRlLnRydXN0QXMoJHNjZS5KUywgdmFsdWUpYH1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0cnVzdEFzLlxyXG4gICAgICogQHJldHVybnMgeyp9IEFuIG9iamVjdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8ge0BsaW5rIG5nLiRzY2UjZ2V0VHJ1c3RlZEpzXHJcbiAgICAgKiAgICAgJHNjZS5nZXRUcnVzdGVkSnModmFsdWUpfSB0byBvYnRhaW4gdGhlIG9yaWdpbmFsIHZhbHVlLiAgKHByaXZpbGVnZWQgZGlyZWN0aXZlc1xyXG4gICAgICogICAgIG9ubHkgYWNjZXB0IGV4cHJlc3Npb25zIHRoYXQgYXJlIGVpdGhlciBsaXRlcmFsIGNvbnN0YW50cyBvciBhcmUgdGhlXHJcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlIG9mIHtAbGluayBuZy4kc2NlI3RydXN0QXMgJHNjZS50cnVzdEFzfS4pXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjZ2V0VHJ1c3RlZFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIERlbGVnYXRlcyB0byB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI2dldFRydXN0ZWQgYCRzY2VEZWxlZ2F0ZS5nZXRUcnVzdGVkYH0uICBBcyBzdWNoLCB0YWtlc1xyXG4gICAgICogdGhlIHJlc3VsdCBvZiBhIHtAbGluayBuZy4kc2NlI3RydXN0QXMgYCRzY2UudHJ1c3RBc2B9KCkgY2FsbCBhbmQgcmV0dXJucyB0aGUgb3JpZ2luYWxseSBzdXBwbGllZFxyXG4gICAgICogdmFsdWUgaWYgdGhlIHF1ZXJpZWQgY29udGV4dCB0eXBlIGlzIGEgc3VwZXJ0eXBlIG9mIHRoZSBjcmVhdGVkIHR5cGUuICBJZiB0aGlzIGNvbmRpdGlvblxyXG4gICAgICogaXNuJ3Qgc2F0aXNmaWVkLCB0aHJvd3MgYW4gZXhjZXB0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBraW5kIG9mIGNvbnRleHQgaW4gd2hpY2ggdGhpcyB2YWx1ZSBpcyB0byBiZSB1c2VkLlxyXG4gICAgICogQHBhcmFtIHsqfSBtYXliZVRydXN0ZWQgVGhlIHJlc3VsdCBvZiBhIHByaW9yIHtAbGluayBuZy4kc2NlI3RydXN0QXMgYCRzY2UudHJ1c3RBc2B9IGNhbGwuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoZSB3YXMgb3JpZ2luYWxseSBwcm92aWRlZCB0byB7QGxpbmsgbmcuJHNjZSN0cnVzdEFzIGAkc2NlLnRydXN0QXNgfSBpZlxyXG4gICAgICogICAgIHZhbGlkIGluIHRoaXMgY29udGV4dC4gIE90aGVyd2lzZSwgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZSNnZXRUcnVzdGVkSHRtbFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5nZXRUcnVzdGVkSHRtbCh2YWx1ZSlgIMOi4oCg4oCZIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjZ2V0VHJ1c3RlZCBgJHNjZURlbGVnYXRlLmdldFRydXN0ZWQoJHNjZS5IVE1MLCB2YWx1ZSlgfVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhc3MgdG8gYCRzY2UuZ2V0VHJ1c3RlZGAuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBgJHNjZS5nZXRUcnVzdGVkKCRzY2UuSFRNTCwgdmFsdWUpYFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI2dldFRydXN0ZWRDc3NcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UuZ2V0VHJ1c3RlZENzcyh2YWx1ZSlgIMOi4oCg4oCZIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjZ2V0VHJ1c3RlZCBgJHNjZURlbGVnYXRlLmdldFRydXN0ZWQoJHNjZS5DU1MsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFzcyB0byBgJHNjZS5nZXRUcnVzdGVkYC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGAkc2NlLmdldFRydXN0ZWQoJHNjZS5DU1MsIHZhbHVlKWBcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZSNnZXRUcnVzdGVkVXJsXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLmdldFRydXN0ZWRVcmwodmFsdWUpYCDDouKAoOKAmSB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI2dldFRydXN0ZWQgYCRzY2VEZWxlZ2F0ZS5nZXRUcnVzdGVkKCRzY2UuVVJMLCB2YWx1ZSlgfVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhc3MgdG8gYCRzY2UuZ2V0VHJ1c3RlZGAuXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBgJHNjZS5nZXRUcnVzdGVkKCRzY2UuVVJMLCB2YWx1ZSlgXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuZ2RvYyBtZXRob2RcclxuICAgICAqIEBuYW1lIG5nLiRzY2UjZ2V0VHJ1c3RlZFJlc291cmNlVXJsXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLmdldFRydXN0ZWRSZXNvdXJjZVVybCh2YWx1ZSlgIMOi4oCg4oCZIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjZ2V0VHJ1c3RlZCBgJHNjZURlbGVnYXRlLmdldFRydXN0ZWQoJHNjZS5SRVNPVVJDRV9VUkwsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFzcyB0byBgJHNjZURlbGVnYXRlLmdldFRydXN0ZWRgLlxyXG4gICAgICogQHJldHVybnMgeyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgYCRzY2UuZ2V0VHJ1c3RlZCgkc2NlLlJFU09VUkNFX1VSTCwgdmFsdWUpYFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI2dldFRydXN0ZWRKc1xyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5nZXRUcnVzdGVkSnModmFsdWUpYCDDouKAoOKAmSB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI2dldFRydXN0ZWQgYCRzY2VEZWxlZ2F0ZS5nZXRUcnVzdGVkKCRzY2UuSlMsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFzcyB0byBgJHNjZS5nZXRUcnVzdGVkYC5cclxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGAkc2NlLmdldFRydXN0ZWQoJHNjZS5KUywgdmFsdWUpYFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI3BhcnNlQXNIdG1sXHJcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLnBhcnNlQXNIdG1sKGV4cHJlc3Npb24gc3RyaW5nKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2UjcGFyc2UgYCRzY2UucGFyc2VBcygkc2NlLkhUTUwsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gU3RyaW5nIGV4cHJlc3Npb24gdG8gY29tcGlsZS5cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihjb250ZXh0LCBsb2NhbHMpfSBhIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb246XHJcbiAgICAgKlxyXG4gICAgICogICAgKiBgY29udGV4dGAgw6LigqzigJwgYHtvYmplY3R9YCDDouKCrOKAnCBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3NcclxuICAgICAqICAgICAgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0ICh0eXBpY2FsbHkgYSBzY29wZSBvYmplY3QpLlxyXG4gICAgICogICAgKiBgbG9jYWxzYCDDouKCrOKAnCBge29iamVjdD19YCDDouKCrOKAnCBsb2NhbCB2YXJpYWJsZXMgY29udGV4dCBvYmplY3QsIHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyB2YWx1ZXMgaW5cclxuICAgICAqICAgICAgYGNvbnRleHRgLlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI3BhcnNlQXNDc3NcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UucGFyc2VBc0Nzcyh2YWx1ZSlgIMOi4oCg4oCZIHtAbGluayBuZy4kc2NlI3BhcnNlIGAkc2NlLnBhcnNlQXMoJHNjZS5DU1MsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gU3RyaW5nIGV4cHJlc3Npb24gdG8gY29tcGlsZS5cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihjb250ZXh0LCBsb2NhbHMpfSBhIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb246XHJcbiAgICAgKlxyXG4gICAgICogICAgKiBgY29udGV4dGAgw6LigqzigJwgYHtvYmplY3R9YCDDouKCrOKAnCBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3NcclxuICAgICAqICAgICAgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0ICh0eXBpY2FsbHkgYSBzY29wZSBvYmplY3QpLlxyXG4gICAgICogICAgKiBgbG9jYWxzYCDDouKCrOKAnCBge29iamVjdD19YCDDouKCrOKAnCBsb2NhbCB2YXJpYWJsZXMgY29udGV4dCBvYmplY3QsIHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyB2YWx1ZXMgaW5cclxuICAgICAqICAgICAgYGNvbnRleHRgLlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI3BhcnNlQXNVcmxcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UucGFyc2VBc1VybCh2YWx1ZSlgIMOi4oCg4oCZIHtAbGluayBuZy4kc2NlI3BhcnNlIGAkc2NlLnBhcnNlQXMoJHNjZS5VUkwsIHZhbHVlKWB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gU3RyaW5nIGV4cHJlc3Npb24gdG8gY29tcGlsZS5cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihjb250ZXh0LCBsb2NhbHMpfSBhIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb246XHJcbiAgICAgKlxyXG4gICAgICogICAgKiBgY29udGV4dGAgw6LigqzigJwgYHtvYmplY3R9YCDDouKCrOKAnCBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3NcclxuICAgICAqICAgICAgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0ICh0eXBpY2FsbHkgYSBzY29wZSBvYmplY3QpLlxyXG4gICAgICogICAgKiBgbG9jYWxzYCDDouKCrOKAnCBge29iamVjdD19YCDDouKCrOKAnCBsb2NhbCB2YXJpYWJsZXMgY29udGV4dCBvYmplY3QsIHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyB2YWx1ZXMgaW5cclxuICAgICAqICAgICAgYGNvbnRleHRgLlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmdkb2MgbWV0aG9kXHJcbiAgICAgKiBAbmFtZSBuZy4kc2NlI3BhcnNlQXNSZXNvdXJjZVVybFxyXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5wYXJzZUFzUmVzb3VyY2VVcmwodmFsdWUpYCDDouKAoOKAmSB7QGxpbmsgbmcuJHNjZSNwYXJzZSBgJHNjZS5wYXJzZUFzKCRzY2UuUkVTT1VSQ0VfVVJMLCB2YWx1ZSlgfVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFN0cmluZyBleHByZXNzaW9uIHRvIGNvbXBpbGUuXHJcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oY29udGV4dCwgbG9jYWxzKX0gYSBmdW5jdGlvbiB3aGljaCByZXByZXNlbnRzIHRoZSBjb21waWxlZCBleHByZXNzaW9uOlxyXG4gICAgICpcclxuICAgICAqICAgICogYGNvbnRleHRgIMOi4oKs4oCcIGB7b2JqZWN0fWAgw6LigqzigJwgYW4gb2JqZWN0IGFnYWluc3Qgd2hpY2ggYW55IGV4cHJlc3Npb25zIGVtYmVkZGVkIGluIHRoZSBzdHJpbmdzXHJcbiAgICAgKiAgICAgIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCAodHlwaWNhbGx5IGEgc2NvcGUgb2JqZWN0KS5cclxuICAgICAqICAgICogYGxvY2Fsc2Agw6LigqzigJwgYHtvYmplY3Q9fWAgw6LigqzigJwgbG9jYWwgdmFyaWFibGVzIGNvbnRleHQgb2JqZWN0LCB1c2VmdWwgZm9yIG92ZXJyaWRpbmcgdmFsdWVzIGluXHJcbiAgICAgKiAgICAgIGBjb250ZXh0YC5cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5nZG9jIG1ldGhvZFxyXG4gICAgICogQG5hbWUgbmcuJHNjZSNwYXJzZUFzSnNcclxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UucGFyc2VBc0pzKHZhbHVlKWAgw6LigKDigJkge0BsaW5rIG5nLiRzY2UjcGFyc2UgYCRzY2UucGFyc2VBcygkc2NlLkpTLCB2YWx1ZSlgfVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFN0cmluZyBleHByZXNzaW9uIHRvIGNvbXBpbGUuXHJcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oY29udGV4dCwgbG9jYWxzKX0gYSBmdW5jdGlvbiB3aGljaCByZXByZXNlbnRzIHRoZSBjb21waWxlZCBleHByZXNzaW9uOlxyXG4gICAgICpcclxuICAgICAqICAgICogYGNvbnRleHRgIMOi4oKs4oCcIGB7b2JqZWN0fWAgw6LigqzigJwgYW4gb2JqZWN0IGFnYWluc3Qgd2hpY2ggYW55IGV4cHJlc3Npb25zIGVtYmVkZGVkIGluIHRoZSBzdHJpbmdzXHJcbiAgICAgKiAgICAgIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCAodHlwaWNhbGx5IGEgc2NvcGUgb2JqZWN0KS5cclxuICAgICAqICAgICogYGxvY2Fsc2Agw6LigqzigJwgYHtvYmplY3Q9fWAgw6LigqzigJwgbG9jYWwgdmFyaWFibGVzIGNvbnRleHQgb2JqZWN0LCB1c2VmdWwgZm9yIG92ZXJyaWRpbmcgdmFsdWVzIGluXHJcbiAgICAgKiAgICAgIGBjb250ZXh0YC5cclxuICAgICAqL1xyXG5cclxuICAgIC8vIFNob3J0aGFuZCBkZWxlZ2F0aW9ucy5cclxuICAgIHZhciBwYXJzZSA9IHNjZS5wYXJzZUFzLFxyXG4gICAgICAgIGdldFRydXN0ZWQgPSBzY2UuZ2V0VHJ1c3RlZCxcclxuICAgICAgICB0cnVzdEFzID0gc2NlLnRydXN0QXM7XHJcblxyXG4gICAgYW5ndWxhci5mb3JFYWNoKFNDRV9DT05URVhUUywgZnVuY3Rpb24gKGVudW1WYWx1ZSwgbmFtZSkge1xyXG4gICAgICB2YXIgbE5hbWUgPSBsb3dlcmNhc2UobmFtZSk7XHJcbiAgICAgIHNjZVtjYW1lbENhc2UoXCJwYXJzZV9hc19cIiArIGxOYW1lKV0gPSBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgIHJldHVybiBwYXJzZShlbnVtVmFsdWUsIGV4cHIpO1xyXG4gICAgICB9XHJcbiAgICAgIHNjZVtjYW1lbENhc2UoXCJnZXRfdHJ1c3RlZF9cIiArIGxOYW1lKV0gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZ2V0VHJ1c3RlZChlbnVtVmFsdWUsIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBzY2VbY2FtZWxDYXNlKFwidHJ1c3RfYXNfXCIgKyBsTmFtZSldID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydXN0QXMoZW51bVZhbHVlLCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBzY2U7XHJcbiAgfV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiAhISEgVGhpcyBpcyBhbiB1bmRvY3VtZW50ZWQgXCJwcml2YXRlXCIgc2VydmljZSAhISFcclxuICpcclxuICogQG5hbWUgbmcuJHNuaWZmZXJcclxuICogQHJlcXVpcmVzICR3aW5kb3dcclxuICogQHJlcXVpcmVzICRkb2N1bWVudFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhpc3RvcnkgRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGh0bWw1IGhpc3RvcnkgYXBpID9cclxuICogQHByb3BlcnR5IHtib29sZWFufSBoYXNoY2hhbmdlIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCBoYXNoY2hhbmdlIGV2ZW50ID9cclxuICogQHByb3BlcnR5IHtib29sZWFufSB0cmFuc2l0aW9ucyBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgQ1NTIHRyYW5zaXRpb24gZXZlbnRzID9cclxuICogQHByb3BlcnR5IHtib29sZWFufSBhbmltYXRpb25zIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCBDU1MgYW5pbWF0aW9uIGV2ZW50cyA/XHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGlzIGlzIHZlcnkgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIHRlc3RpbmcgYnJvd3NlcidzIGZlYXR1cmVzLlxyXG4gKi9cclxuZnVuY3Rpb24gJFNuaWZmZXJQcm92aWRlcigpIHtcclxuICB0aGlzLiRnZXQgPSBbJyR3aW5kb3cnLCAnJGRvY3VtZW50JywgZnVuY3Rpb24oJHdpbmRvdywgJGRvY3VtZW50KSB7XHJcbiAgICB2YXIgZXZlbnRTdXBwb3J0ID0ge30sXHJcbiAgICAgICAgYW5kcm9pZCA9IGludCgoL2FuZHJvaWQgKFxcZCspLy5leGVjKGxvd2VyY2FzZSgoJHdpbmRvdy5uYXZpZ2F0b3IgfHwge30pLnVzZXJBZ2VudCkpIHx8IFtdKVsxXSksXHJcbiAgICAgICAgYm94ZWUgPSAvQm94ZWUvaS50ZXN0KCgkd2luZG93Lm5hdmlnYXRvciB8fCB7fSkudXNlckFnZW50KSxcclxuICAgICAgICBkb2N1bWVudCA9ICRkb2N1bWVudFswXSB8fCB7fSxcclxuICAgICAgICB2ZW5kb3JQcmVmaXgsXHJcbiAgICAgICAgdmVuZG9yUmVnZXggPSAvXihNb3p8d2Via2l0fE98bXMpKD89W0EtWl0pLyxcclxuICAgICAgICBib2R5U3R5bGUgPSBkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuc3R5bGUsXHJcbiAgICAgICAgdHJhbnNpdGlvbnMgPSBmYWxzZSxcclxuICAgICAgICBhbmltYXRpb25zID0gZmFsc2UsXHJcbiAgICAgICAgbWF0Y2g7XHJcblxyXG4gICAgaWYgKGJvZHlTdHlsZSkge1xyXG4gICAgICBmb3IodmFyIHByb3AgaW4gYm9keVN0eWxlKSB7XHJcbiAgICAgICAgaWYobWF0Y2ggPSB2ZW5kb3JSZWdleC5leGVjKHByb3ApKSB7XHJcbiAgICAgICAgICB2ZW5kb3JQcmVmaXggPSBtYXRjaFswXTtcclxuICAgICAgICAgIHZlbmRvclByZWZpeCA9IHZlbmRvclByZWZpeC5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIHZlbmRvclByZWZpeC5zdWJzdHIoMSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKCF2ZW5kb3JQcmVmaXgpIHtcclxuICAgICAgICB2ZW5kb3JQcmVmaXggPSAoJ1dlYmtpdE9wYWNpdHknIGluIGJvZHlTdHlsZSkgJiYgJ3dlYmtpdCc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyYW5zaXRpb25zID0gISEoKCd0cmFuc2l0aW9uJyBpbiBib2R5U3R5bGUpIHx8ICh2ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbicgaW4gYm9keVN0eWxlKSk7XHJcbiAgICAgIGFuaW1hdGlvbnMgID0gISEoKCdhbmltYXRpb24nIGluIGJvZHlTdHlsZSkgfHwgKHZlbmRvclByZWZpeCArICdBbmltYXRpb24nIGluIGJvZHlTdHlsZSkpO1xyXG5cclxuICAgICAgaWYgKGFuZHJvaWQgJiYgKCF0cmFuc2l0aW9uc3x8IWFuaW1hdGlvbnMpKSB7XHJcbiAgICAgICAgdHJhbnNpdGlvbnMgPSBpc1N0cmluZyhkb2N1bWVudC5ib2R5LnN0eWxlLndlYmtpdFRyYW5zaXRpb24pO1xyXG4gICAgICAgIGFuaW1hdGlvbnMgPSBpc1N0cmluZyhkb2N1bWVudC5ib2R5LnN0eWxlLndlYmtpdEFuaW1hdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLy8gQW5kcm9pZCBoYXMgaGlzdG9yeS5wdXNoU3RhdGUsIGJ1dCBpdCBkb2VzIG5vdCB1cGRhdGUgbG9jYXRpb24gY29ycmVjdGx5XHJcbiAgICAgIC8vIHNvIGxldCdzIG5vdCB1c2UgdGhlIGhpc3RvcnkgQVBJIGF0IGFsbC5cclxuICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2FuZHJvaWQvaXNzdWVzL2RldGFpbD9pZD0xNzQ3MVxyXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2lzc3Vlcy85MDRcclxuXHJcbiAgICAgIC8vIG9sZGVyIHdlYml0IGJyb3dzZXIgKDUzMy45KSBvbiBCb3hlZSBib3ggaGFzIGV4YWN0bHkgdGhlIHNhbWUgcHJvYmxlbSBhcyBBbmRyb2lkIGhhc1xyXG4gICAgICAvLyBzbyBsZXQncyBub3QgdXNlIHRoZSBoaXN0b3J5IEFQSSBhbHNvXHJcbiAgICAgIGhpc3Rvcnk6ICEhKCR3aW5kb3cuaGlzdG9yeSAmJiAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlICYmICEoYW5kcm9pZCA8IDQpICYmICFib3hlZSksXHJcbiAgICAgIGhhc2hjaGFuZ2U6ICdvbmhhc2hjaGFuZ2UnIGluICR3aW5kb3cgJiZcclxuICAgICAgICAgICAgICAgICAgLy8gSUU4IGNvbXBhdGlibGUgbW9kZSBsaWVzXHJcbiAgICAgICAgICAgICAgICAgICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDcpLFxyXG4gICAgICBoYXNFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAvLyBJRTkgaW1wbGVtZW50cyAnaW5wdXQnIGV2ZW50IGl0J3Mgc28gZnViYXJlZCB0aGF0IHdlIHJhdGhlciBwcmV0ZW5kIHRoYXQgaXQgZG9lc24ndCBoYXZlXHJcbiAgICAgICAgLy8gaXQuIEluIHBhcnRpY3VsYXIgdGhlIGV2ZW50IGlzIG5vdCBmaXJlZCB3aGVuIGJhY2tzcGFjZSBvciBkZWxldGUga2V5IGFyZSBwcmVzc2VkIG9yXHJcbiAgICAgICAgLy8gd2hlbiBjdXQgb3BlcmF0aW9uIGlzIHBlcmZvcm1lZC5cclxuICAgICAgICBpZiAoZXZlbnQgPT0gJ2lucHV0JyAmJiBtc2llID09IDkpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGV2ZW50U3VwcG9ydFtldmVudF0pKSB7XHJcbiAgICAgICAgICB2YXIgZGl2RWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICBldmVudFN1cHBvcnRbZXZlbnRdID0gJ29uJyArIGV2ZW50IGluIGRpdkVsbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBldmVudFN1cHBvcnRbZXZlbnRdO1xyXG4gICAgICB9LFxyXG4gICAgICBjc3A6IGRvY3VtZW50LnNlY3VyaXR5UG9saWN5ID8gZG9jdW1lbnQuc2VjdXJpdHlQb2xpY3kuaXNBY3RpdmUgOiBmYWxzZSxcclxuICAgICAgdmVuZG9yUHJlZml4OiB2ZW5kb3JQcmVmaXgsXHJcbiAgICAgIHRyYW5zaXRpb25zIDogdHJhbnNpdGlvbnMsXHJcbiAgICAgIGFuaW1hdGlvbnMgOiBhbmltYXRpb25zXHJcbiAgICB9O1xyXG4gIH1dO1xyXG59XHJcblxyXG5mdW5jdGlvbiAkVGltZW91dFByb3ZpZGVyKCkge1xyXG4gIHRoaXMuJGdldCA9IFsnJHJvb3RTY29wZScsICckYnJvd3NlcicsICckcScsICckZXhjZXB0aW9uSGFuZGxlcicsXHJcbiAgICAgICBmdW5jdGlvbigkcm9vdFNjb3BlLCAgICRicm93c2VyLCAgICRxLCAgICRleGNlcHRpb25IYW5kbGVyKSB7XHJcbiAgICB2YXIgZGVmZXJyZWRzID0ge307XHJcblxyXG5cclxuICAgICAvKipcclxuICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgKiBAbmFtZSBuZy4kdGltZW91dFxyXG4gICAgICAqIEByZXF1aXJlcyAkYnJvd3NlclxyXG4gICAgICAqXHJcbiAgICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgICogQW5ndWxhcidzIHdyYXBwZXIgZm9yIGB3aW5kb3cuc2V0VGltZW91dGAuIFRoZSBgZm5gIGZ1bmN0aW9uIGlzIHdyYXBwZWQgaW50byBhIHRyeS9jYXRjaFxyXG4gICAgICAqIGJsb2NrIGFuZCBkZWxlZ2F0ZXMgYW55IGV4Y2VwdGlvbnMgdG9cclxuICAgICAgKiB7QGxpbmsgbmcuJGV4Y2VwdGlvbkhhbmRsZXIgJGV4Y2VwdGlvbkhhbmRsZXJ9IHNlcnZpY2UuXHJcbiAgICAgICpcclxuICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHJlZ2lzdGVyaW5nIGEgdGltZW91dCBmdW5jdGlvbiBpcyBhIHByb21pc2UsIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgd2hlblxyXG4gICAgICAqIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQgYW5kIHRoZSB0aW1lb3V0IGZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxyXG4gICAgICAqXHJcbiAgICAgICogVG8gY2FuY2VsIGEgdGltZW91dCByZXF1ZXN0LCBjYWxsIGAkdGltZW91dC5jYW5jZWwocHJvbWlzZSlgLlxyXG4gICAgICAqXHJcbiAgICAgICogSW4gdGVzdHMgeW91IGNhbiB1c2Uge0BsaW5rIG5nTW9jay4kdGltZW91dCBgJHRpbWVvdXQuZmx1c2goKWB9IHRvXHJcbiAgICAgICogc3luY2hyb25vdXNseSBmbHVzaCB0aGUgcXVldWUgb2YgZGVmZXJyZWQgZnVuY3Rpb25zLlxyXG4gICAgICAqXHJcbiAgICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBmbiBBIGZ1bmN0aW9uLCB3aG9zZSBleGVjdXRpb24gc2hvdWxkIGJlIGRlbGF5ZWQuXHJcbiAgICAgICogQHBhcmFtIHtudW1iZXI9fSBbZGVsYXk9MF0gRGVsYXkgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtpbnZva2VBcHBseT10cnVlXSBJZiBzZXQgdG8gYGZhbHNlYCBza2lwcyBtb2RlbCBkaXJ0eSBjaGVja2luZywgb3RoZXJ3aXNlXHJcbiAgICAgICogICB3aWxsIGludm9rZSBgZm5gIHdpdGhpbiB0aGUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjJGFwcGx5ICRhcHBseX0gYmxvY2suXHJcbiAgICAgICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHRpbWVvdXQgaXMgcmVhY2hlZC4gVGhlIHZhbHVlIHRoaXNcclxuICAgICAgKiAgIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoIGlzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGBmbmAgZnVuY3Rpb24uXHJcbiAgICAgICovXHJcbiAgICBmdW5jdGlvbiB0aW1lb3V0KGZuLCBkZWxheSwgaW52b2tlQXBwbHkpIHtcclxuICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKSxcclxuICAgICAgICAgIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlLFxyXG4gICAgICAgICAgc2tpcEFwcGx5ID0gKGlzRGVmaW5lZChpbnZva2VBcHBseSkgJiYgIWludm9rZUFwcGx5KSxcclxuICAgICAgICAgIHRpbWVvdXRJZDtcclxuXHJcbiAgICAgIHRpbWVvdXRJZCA9ICRicm93c2VyLmRlZmVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGZuKCkpO1xyXG4gICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgZGVsZXRlIGRlZmVycmVkc1twcm9taXNlLiQkdGltZW91dElkXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghc2tpcEFwcGx5KSAkcm9vdFNjb3BlLiRhcHBseSgpO1xyXG4gICAgICB9LCBkZWxheSk7XHJcblxyXG4gICAgICBwcm9taXNlLiQkdGltZW91dElkID0gdGltZW91dElkO1xyXG4gICAgICBkZWZlcnJlZHNbdGltZW91dElkXSA9IGRlZmVycmVkO1xyXG5cclxuICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcblxyXG5cclxuICAgICAvKipcclxuICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgICAgKiBAbmFtZSBuZy4kdGltZW91dCNjYW5jZWxcclxuICAgICAgKiBAbWV0aG9kT2YgbmcuJHRpbWVvdXRcclxuICAgICAgKlxyXG4gICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICAqIENhbmNlbHMgYSB0YXNrIGFzc29jaWF0ZWQgd2l0aCB0aGUgYHByb21pc2VgLiBBcyBhIHJlc3VsdCBvZiB0aGlzLCB0aGUgcHJvbWlzZSB3aWxsIGJlXHJcbiAgICAgICogcmVzb2x2ZWQgd2l0aCBhIHJlamVjdGlvbi5cclxuICAgICAgKlxyXG4gICAgICAqIEBwYXJhbSB7UHJvbWlzZT19IHByb21pc2UgUHJvbWlzZSByZXR1cm5lZCBieSB0aGUgYCR0aW1lb3V0YCBmdW5jdGlvbi5cclxuICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRhc2sgaGFzbid0IGV4ZWN1dGVkIHlldCBhbmQgd2FzIHN1Y2Nlc3NmdWxseVxyXG4gICAgICAqICAgY2FuY2VsZWQuXHJcbiAgICAgICovXHJcbiAgICB0aW1lb3V0LmNhbmNlbCA9IGZ1bmN0aW9uKHByb21pc2UpIHtcclxuICAgICAgaWYgKHByb21pc2UgJiYgcHJvbWlzZS4kJHRpbWVvdXRJZCBpbiBkZWZlcnJlZHMpIHtcclxuICAgICAgICBkZWZlcnJlZHNbcHJvbWlzZS4kJHRpbWVvdXRJZF0ucmVqZWN0KCdjYW5jZWxlZCcpO1xyXG4gICAgICAgIGRlbGV0ZSBkZWZlcnJlZHNbcHJvbWlzZS4kJHRpbWVvdXRJZF07XHJcbiAgICAgICAgcmV0dXJuICRicm93c2VyLmRlZmVyLmNhbmNlbChwcm9taXNlLiQkdGltZW91dElkKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB0aW1lb3V0O1xyXG4gIH1dO1xyXG59XHJcblxyXG5mdW5jdGlvbiAkJFVybFV0aWxzUHJvdmlkZXIoKSB7XHJcbiAgdGhpcy4kZ2V0ID0gW2Z1bmN0aW9uKCkge1xyXG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIiksXHJcbiAgICAgICAgLy8gTk9URTogIFRoZSB1c2FnZSBvZiB3aW5kb3cgYW5kIGRvY3VtZW50IGluc3RlYWQgb2YgJHdpbmRvdyBhbmQgJGRvY3VtZW50IGhlcmUgaXNcclxuICAgICAgICAvLyBkZWxpYmVyYXRlLiAgVGhpcyBzZXJ2aWNlIGRlcGVuZHMgb24gdGhlIHNwZWNpZmljIGJlaGF2aW9yIG9mIGFuY2hvciBub2RlcyBjcmVhdGVkIGJ5IHRoZVxyXG4gICAgICAgIC8vIGJyb3dzZXIgKHJlc29sdmluZyBhbmQgcGFyc2luZyBVUkxzKSB0aGF0IGlzIHVubGlrZWx5IHRvIGJlIHByb3ZpZGVkIGJ5IG1vY2sgb2JqZWN0cyBhbmRcclxuICAgICAgICAvLyBjYXVzZSB1cyB0byBicmVhayB0ZXN0cy4gIEluIGFkZGl0aW9uLCB3aGVuIHRoZSBicm93c2VyIHJlc29sdmVzIGEgVVJMIGZvciBYSFIsIGl0XHJcbiAgICAgICAgLy8gZG9lc24ndCBrbm93IGFib3V0IG1vY2tlZCBsb2NhdGlvbnMgYW5kIHJlc29sdmVzIFVSTHMgdG8gdGhlIHJlYWwgZG9jdW1lbnQgLSB3aGljaCBpc1xyXG4gICAgICAgIC8vIGV4YWN0bHkgdGhlIGJlaGF2aW9yIG5lZWRlZCBoZXJlLiAgVGhlcmUgaXMgbGl0dGxlIHZhbHVlIGlzIG1vY2tpbmcgdGhlc2Ugb3VyIGZvciB0aGlzXHJcbiAgICAgICAgLy8gc2VydmljZS5cclxuICAgICAgICBvcmlnaW5VcmwgPSByZXNvbHZlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogTm9ybWFsaXplcyBhbmQgb3B0aW9uYWxseSBwYXJzZXMgYSBVUkwuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogIFRoaXMgaXMgYSBwcml2YXRlIHNlcnZpY2UuICBUaGUgQVBJIGlzIHN1YmplY3QgdG8gY2hhbmdlIHVucHJlZGljdGFibHkgaW4gYW55IGNvbW1pdC5cclxuICAgICAqXHJcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBOb3RlcyBmb3Igbm9uLUlFIGJyb3dzZXJzXHJcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgKiBBc3NpZ25pbmcgYSBVUkwgdG8gdGhlIGhyZWYgcHJvcGVydHkgb2YgYW4gYW5jaG9yIERPTSBub2RlLCBldmVuIG9uZSBhdHRhY2hlZCB0byB0aGUgRE9NLFxyXG4gICAgICogcmVzdWx0cyBib3RoIGluIHRoZSBub3JtYWxpemluZyBhbmQgcGFyc2luZyBvZiB0aGUgVVJMLiAgTm9ybWFsaXppbmcgbWVhbnMgdGhhdCBhIHJlbGF0aXZlXHJcbiAgICAgKiBVUkwgd2lsbCBiZSByZXNvbHZlZCBpbnRvIGFuIGFic29sdXRlIFVSTCBpbiB0aGUgY29udGV4dCBvZiB0aGUgYXBwbGljYXRpb24gZG9jdW1lbnQuXHJcbiAgICAgKiBQYXJzaW5nIG1lYW5zIHRoYXQgdGhlIGFuY2hvciBub2RlJ3MgaG9zdCwgaG9zdG5hbWUsIHByb3RvY29sLCBwb3J0LCBwYXRobmFtZSBhbmQgcmVsYXRlZFxyXG4gICAgICogcHJvcGVydGllcyBhcmUgYWxsIHBvcHVsYXRlZCB0byByZWZsZWN0IHRoZSBub3JtYWxpemVkIFVSTC4gIFRoaXMgYXBwcm9hY2ggaGFzIHdpZGVcclxuICAgICAqIGNvbXBhdGliaWxpdHkgLSBTYWZhcmkgMSssIE1vemlsbGEgMSssIE9wZXJhIDcrLGUgZXRjLiAgU2VlXHJcbiAgICAgKiBodHRwOi8vd3d3LmFwdGFuYS5jb20vcmVmZXJlbmNlL2h0bWwvYXBpL0hUTUxBbmNob3JFbGVtZW50Lmh0bWxcclxuICAgICAqXHJcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBOb3RlcyBmb3IgSUVcclxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICogSUUgPj0gOCBhbmQgPD0gMTAgbm9ybWFsaXplcyB0aGUgVVJMIHdoZW4gYXNzaWduZWQgdG8gdGhlIGFuY2hvciBub2RlIHNpbWlsYXIgdG8gdGhlIG90aGVyXHJcbiAgICAgKiBicm93c2Vycy4gIEhvd2V2ZXIsIHRoZSBwYXJzZWQgY29tcG9uZW50cyB3aWxsIG5vdCBiZSBzZXQgaWYgdGhlIFVSTCBhc3NpZ25lZCBkaWQgbm90IHNwZWNpZnlcclxuICAgICAqIHRoZW0uICAoZS5nLiBpZiB5b3UgYXNzaWduIGEuaHJlZiA9IFwiZm9vXCIsIHRoZW4gYS5wcm90b2NvbCwgYS5ob3N0LCBldGMuIHdpbGwgYmUgZW1wdHkuKSAgV2VcclxuICAgICAqIHdvcmsgYXJvdW5kIHRoYXQgYnkgcGVyZm9ybWluZyB0aGUgcGFyc2luZyBpbiBhIDJuZCBzdGVwIGJ5IHRha2luZyBhIHByZXZpb3VzbHkgbm9ybWFsaXplZFxyXG4gICAgICogVVJMIChlLmcuIGJ5IGFzc2luaW5nIHRvIGEuaHJlZikgYW5kIGFzc2lnbmluZyBpdCBhLmhyZWYgYWdhaW4uICBUaGlzIGNvcnJlY3RseSBwb3B1bGF0ZXMgdGhlXHJcbiAgICAgKiBwcm9wZXJ0aWVzIHN1Y2ggYXMgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0LCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogSUU3IGRvZXMgbm90IG5vcm1hbGl6ZSB0aGUgVVJMIHdoZW4gYXNzaWduZWQgdG8gYW4gYW5jaG9yIG5vZGUuICAoQXBwYXJlbnRseSwgaXQgZG9lcywgaWYgb25lXHJcbiAgICAgKiB1c2VzIHRoZSBpbm5lciBIVE1MIGFwcHJvYWNoIHRvIGFzc2lnbiB0aGUgVVJMIGFzIHBhcnQgb2YgYW4gSFRNTCBzbmlwcGV0IC1cclxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ3MjcyOSkgIEhvd2V2ZXIsIHNldHRpbmcgaW1nW3NyY10gZG9lcyBub3JtYWxpemUgdGhlIFVSTC5cclxuICAgICAqIFVuZm9ydHVuYXRlbHksIHNldHRpbmcgaW1nW3NyY10gdG8gc29tZXRoaW5nIGxpa2UgXCJqYXZhc2NyaXB0OmZvb1wiIG9uIElFIHRocm93cyBhbiBleGNlcHRpb24uXHJcbiAgICAgKiBTaW5jZSB0aGUgcHJpbWFyeSB1c2FnZSBmb3Igbm9ybWFsaXppbmcgVVJMcyBpcyB0byBzYW5pdGl6ZSBzdWNoIFVSTHMsIHdlIGNhbid0IHVzZSB0aGF0XHJcbiAgICAgKiBtZXRob2QgYW5kIElFIDwgOCBpcyB1bnN1cHBvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBSZWZlcmVuY2VzOlxyXG4gICAgICogICBodHRwOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQW5jaG9yRWxlbWVudFxyXG4gICAgICogICBodHRwOi8vd3d3LmFwdGFuYS5jb20vcmVmZXJlbmNlL2h0bWwvYXBpL0hUTUxBbmNob3JFbGVtZW50Lmh0bWxcclxuICAgICAqICAgaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXHJcbiAgICAgKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvcHVsbC8yOTAyXHJcbiAgICAgKiAgIGh0dHA6Ly9qYW1lcy5wYWRvbHNleS5jb20vamF2YXNjcmlwdC9wYXJzaW5nLXVybHMtd2l0aC10aGUtZG9tL1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwYXJzZSBXaGVuIHRydWUsIHJldHVybnMgYW4gb2JqZWN0IGZvciB0aGUgcGFyc2VkIFVSTC4gIE90aGVyd2lzZSwgcmV0dXJuc1xyXG4gICAgICogICBhIHNpbmdsZSBzdHJpbmcgdGhhdCBpcyB0aGUgbm9ybWFsaXplZCBVUkwuXHJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fHN0cmluZ30gV2hlbiBwYXJzZSBpcyB0cnVlLCByZXR1cm5zIHRoZSBub3JtYWxpemVkIFVSTCBhcyBhIHN0cmluZy5cclxuICAgICAqIE90aGVyd2lzZSwgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG1lbWJlcnMuXHJcbiAgICAgKlxyXG4gICAgICogICB8IG1lbWJlciBuYW1lICAgfCBEZXNjcmlwdGlvbiAgICB8XHJcbiAgICAgKiAgIHwtLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLXxcclxuICAgICAqICAgfCBocmVmICAgICAgICAgIHwgQSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIHByb3ZpZGVkIFVSTCBpZiBpdCB3YXMgbm90IGFuIGFic29sdXRlIFVSTCB8XHJcbiAgICAgKiAgIHwgcHJvdG9jb2wgICAgICB8IFRoZSBwcm90b2NvbCBpbmNsdWRpbmcgdGhlIHRyYWlsaW5nIGNvbG9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICogICB8IGhvc3QgICAgICAgICAgfCBUaGUgaG9zdCBhbmQgcG9ydCAoaWYgdGhlIHBvcnQgaXMgbm9uLWRlZmF1bHQpIG9mIHRoZSBub3JtYWxpemVkVXJsICAgIHxcclxuICAgICAqXHJcbiAgICAgKiBUaGVzZSBmaWVsZHMgZnJvbSB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIGFyZSBjdXJyZW50bHkgbm90IG5lZWRlZCBhbmQgaGVuY2Ugbm90IHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqICAgfCBtZW1iZXIgbmFtZSAgIHwgRGVzY3JpcHRpb24gICAgfFxyXG4gICAgICogICB8LS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS18XHJcbiAgICAgKiAgIHwgaG9zdG5hbWUgICAgICB8IFRoZSBob3N0IHdpdGhvdXQgdGhlIHBvcnQgb2YgdGhlIG5vcm1hbGl6ZWRVcmwgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICogICB8IHBhdGhuYW1lICAgICAgfCBUaGUgcGF0aCBmb2xsb3dpbmcgdGhlIGhvc3QgaW4gdGhlIG5vcm1hbGl6ZWRVcmwgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAqICAgfCBoYXNoICAgICAgICAgIHwgVGhlIFVSTCBoYXNoIGlmIHByZXNlbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgKiAgIHwgc2VhcmNoICAgICAgICB8IFRoZSBxdWVyeSBzdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh1cmwsIHBhcnNlKSB7XHJcbiAgICAgIHZhciBocmVmID0gdXJsO1xyXG4gICAgICBpZiAobXNpZSA8PSAxMSkge1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBiZWZvcmUgcGFyc2UuICBSZWZlciBJbXBsZW1lbnRhdGlvbiBOb3RlcyBvbiB3aHkgdGhpcyBpc1xyXG4gICAgICAgIC8vIGRvbmUgaW4gdHdvIHN0ZXBzIG9uIElFLlxyXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgaHJlZik7XHJcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XHJcbiAgICAgIH1cclxuICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XHJcblxyXG4gICAgICBpZiAoIXBhcnNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHVybFBhcnNpbmdOb2RlLmhyZWY7XHJcbiAgICAgIH1cclxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXHJcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLFxyXG4gICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3RcclxuICAgICAgICAvLyBDdXJyZW50bHkgdW51c2VkIGFuZCBoZW5jZSBjb21tZW50ZWQgb3V0LlxyXG4gICAgICAgIC8vIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcclxuICAgICAgICAvLyBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxyXG4gICAgICAgIC8vIHBhdGhuYW1lOiB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSxcclxuICAgICAgICAvLyBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoLFxyXG4gICAgICAgIC8vIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFBhcnNlIGEgcmVxdWVzdCBVUkwgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBzYW1lLW9yaWdpbiByZXF1ZXN0IGFzIHRoZSBhcHBsaWNhdGlvbiBkb2N1bWVudC5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZXF1ZXN0VXJsIFRoZSB1cmwgb2YgdGhlIHJlcXVlc3QgYXMgYSBzdHJpbmcgdGhhdCB3aWxsIGJlIHJlc29sdmVkXHJcbiAgICAgICAqIG9yIGEgcGFyc2VkIFVSTCBvYmplY3QuXHJcbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGFwcGxpY2F0aW9uIGRvY3VtZW50LlxyXG4gICAgICAgKi9cclxuICAgICAgaXNTYW1lT3JpZ2luOiBmdW5jdGlvbiBpc1NhbWVPcmlnaW4ocmVxdWVzdFVybCkge1xyXG4gICAgICAgIHZhciBwYXJzZWQgPSAodHlwZW9mIHJlcXVlc3RVcmwgPT09ICdzdHJpbmcnKSA/IHJlc29sdmUocmVxdWVzdFVybCwgdHJ1ZSkgOiByZXF1ZXN0VXJsO1xyXG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VcmwucHJvdG9jb2wgJiZcclxuICAgICAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VcmwuaG9zdCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfV07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiR3aW5kb3dcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEgcmVmZXJlbmNlIHRvIHRoZSBicm93c2VyJ3MgYHdpbmRvd2Agb2JqZWN0LiBXaGlsZSBgd2luZG93YFxyXG4gKiBpcyBnbG9iYWxseSBhdmFpbGFibGUgaW4gSmF2YVNjcmlwdCwgaXQgY2F1c2VzIHRlc3RhYmlsaXR5IHByb2JsZW1zLCBiZWNhdXNlXHJcbiAqIGl0IGlzIGEgZ2xvYmFsIHZhcmlhYmxlLiBJbiBhbmd1bGFyIHdlIGFsd2F5cyByZWZlciB0byBpdCB0aHJvdWdoIHRoZVxyXG4gKiBgJHdpbmRvd2Agc2VydmljZSwgc28gaXQgbWF5IGJlIG92ZXJyaWRkZW4sIHJlbW92ZWQgb3IgbW9ja2VkIGZvciB0ZXN0aW5nLlxyXG4gKlxyXG4gKiBFeHByZXNzaW9ucywgbGlrZSB0aGUgb25lIGRlZmluZWQgZm9yIHRoZSBgbmdDbGlja2AgZGlyZWN0aXZlIGluIHRoZSBleGFtcGxlXHJcbiAqIGJlbG93LCBhcmUgZXZhbHVhdGVkIHdpdGggcmVzcGVjdCB0byB0aGUgY3VycmVudCBzY29wZS4gIFRoZXJlZm9yZSwgdGhlcmUgaXNcclxuICogbm8gcmlzayBvZiBpbmFkdmVydGVudGx5IGNvZGluZyBpbiBhIGRlcGVuZGVuY3kgb24gYSBnbG9iYWwgdmFsdWUgaW4gc3VjaCBhblxyXG4gKiBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSwgJHdpbmRvdykge1xyXG4gICAgICAgICAgICRzY29wZS4kd2luZG93ID0gJHdpbmRvdztcclxuICAgICAgICAgICAkc2NvcGUuZ3JlZXRpbmcgPSAnSGVsbG8sIFdvcmxkISc7XHJcbiAgICAgICAgIH1cclxuICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cImdyZWV0aW5nXCIgLz5cclxuICAgICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cIiR3aW5kb3cuYWxlcnQoZ3JlZXRpbmcpXCI+QUxFUlQ8L2J1dHRvbj5cclxuICAgICAgIDwvZGl2PlxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICBpdCgnc2hvdWxkIGRpc3BsYXkgdGhlIGdyZWV0aW5nIGluIHRoZSBpbnB1dCBib3gnLCBmdW5jdGlvbigpIHtcclxuICAgICAgIGlucHV0KCdncmVldGluZycpLmVudGVyKCdIZWxsbywgRTJFIFRlc3RzJyk7XHJcbiAgICAgICAvLyBJZiB3ZSBjbGljayB0aGUgYnV0dG9uIGl0IHdpbGwgYmxvY2sgdGhlIHRlc3QgcnVubmVyXHJcbiAgICAgICAvLyBlbGVtZW50KCc6YnV0dG9uJykuY2xpY2soKTtcclxuICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG5mdW5jdGlvbiAkV2luZG93UHJvdmlkZXIoKXtcclxuICB0aGlzLiRnZXQgPSB2YWx1ZUZuKHdpbmRvdyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLiRmaWx0ZXJQcm92aWRlclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogRmlsdGVycyBhcmUganVzdCBmdW5jdGlvbnMgd2hpY2ggdHJhbnNmb3JtIGlucHV0IHRvIGFuIG91dHB1dC4gSG93ZXZlciBmaWx0ZXJzIG5lZWQgdG8gYmUgRGVwZW5kZW5jeSBJbmplY3RlZC4gVG9cclxuICogYWNoaWV2ZSB0aGlzIGEgZmlsdGVyIGRlZmluaXRpb24gY29uc2lzdHMgb2YgYSBmYWN0b3J5IGZ1bmN0aW9uIHdoaWNoIGlzIGFubm90YXRlZCB3aXRoIGRlcGVuZGVuY2llcyBhbmQgaXNcclxuICogcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGEgZmlsdGVyIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiAgIC8vIEZpbHRlciByZWdpc3RyYXRpb25cclxuICogICBmdW5jdGlvbiBNeU1vZHVsZSgkcHJvdmlkZSwgJGZpbHRlclByb3ZpZGVyKSB7XHJcbiAqICAgICAvLyBjcmVhdGUgYSBzZXJ2aWNlIHRvIGRlbW9uc3RyYXRlIGluamVjdGlvbiAobm90IGFsd2F5cyBuZWVkZWQpXHJcbiAqICAgICAkcHJvdmlkZS52YWx1ZSgnZ3JlZXQnLCBmdW5jdGlvbihuYW1lKXtcclxuICogICAgICAgcmV0dXJuICdIZWxsbyAnICsgbmFtZSArICchJztcclxuICogICAgIH0pO1xyXG4gKlxyXG4gKiAgICAgLy8gcmVnaXN0ZXIgYSBmaWx0ZXIgZmFjdG9yeSB3aGljaCB1c2VzIHRoZVxyXG4gKiAgICAgLy8gZ3JlZXQgc2VydmljZSB0byBkZW1vbnN0cmF0ZSBESS5cclxuICogICAgICRmaWx0ZXJQcm92aWRlci5yZWdpc3RlcignZ3JlZXQnLCBmdW5jdGlvbihncmVldCl7XHJcbiAqICAgICAgIC8vIHJldHVybiB0aGUgZmlsdGVyIGZ1bmN0aW9uIHdoaWNoIHVzZXMgdGhlIGdyZWV0IHNlcnZpY2VcclxuICogICAgICAgLy8gdG8gZ2VuZXJhdGUgc2FsdXRhdGlvblxyXG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xyXG4gKiAgICAgICAgIC8vIGZpbHRlcnMgbmVlZCB0byBiZSBmb3JnaXZpbmcgc28gY2hlY2sgaW5wdXQgdmFsaWRpdHlcclxuICogICAgICAgICByZXR1cm4gdGV4dCAmJiBncmVldCh0ZXh0KSB8fCB0ZXh0O1xyXG4gKiAgICAgICB9O1xyXG4gKiAgICAgfSk7XHJcbiAqICAgfVxyXG4gKiA8L3ByZT5cclxuICpcclxuICogVGhlIGZpbHRlciBmdW5jdGlvbiBpcyByZWdpc3RlcmVkIHdpdGggdGhlIGAkaW5qZWN0b3JgIHVuZGVyIHRoZSBmaWx0ZXIgbmFtZSBzdWZmaXggd2l0aCBgRmlsdGVyYC5cclxuICogPHByZT5cclxuICogICBpdCgnc2hvdWxkIGJlIHRoZSBzYW1lIGluc3RhbmNlJywgaW5qZWN0KFxyXG4gKiAgICAgZnVuY3Rpb24oJGZpbHRlclByb3ZpZGVyKSB7XHJcbiAqICAgICAgICRmaWx0ZXJQcm92aWRlci5yZWdpc3RlcigncmV2ZXJzZScsIGZ1bmN0aW9uKCl7XHJcbiAqICAgICAgICAgcmV0dXJuIC4uLjtcclxuICogICAgICAgfSk7XHJcbiAqICAgICB9LFxyXG4gKiAgICAgZnVuY3Rpb24oJGZpbHRlciwgcmV2ZXJzZUZpbHRlcikge1xyXG4gKiAgICAgICBleHBlY3QoJGZpbHRlcigncmV2ZXJzZScpKS50b0JlKHJldmVyc2VGaWx0ZXIpO1xyXG4gKiAgICAgfSk7XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKlxyXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgYW5ndWxhciBmaWx0ZXJzIHdvcmssIGFuZCBob3cgdG8gY3JlYXRlIHlvdXIgb3duIGZpbHRlcnMsIHNlZVxyXG4gKiB7QGxpbmsgZ3VpZGUvZGV2X2d1aWRlLnRlbXBsYXRlcy5maWx0ZXJzIFVuZGVyc3RhbmRpbmcgQW5ndWxhciBGaWx0ZXJzfSBpbiB0aGUgYW5ndWxhciBEZXZlbG9wZXJcclxuICogR3VpZGUuXHJcbiAqL1xyXG4vKipcclxuICogQG5nZG9jIG1ldGhvZFxyXG4gKiBAbmFtZSBuZy4kZmlsdGVyUHJvdmlkZXIjcmVnaXN0ZXJcclxuICogQG1ldGhvZE9mIG5nLiRmaWx0ZXJQcm92aWRlclxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogUmVnaXN0ZXIgZmlsdGVyIGZhY3RvcnkgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGZpbHRlci5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZpbHRlciBmYWN0b3J5IGZ1bmN0aW9uIHdoaWNoIGlzIGluamVjdGFibGUuXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgbmcuJGZpbHRlclxyXG4gKiBAZnVuY3Rpb25cclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEZpbHRlcnMgYXJlIHVzZWQgZm9yIGZvcm1hdHRpbmcgZGF0YSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXHJcbiAqXHJcbiAqIFRoZSBnZW5lcmFsIHN5bnRheCBpbiB0ZW1wbGF0ZXMgaXMgYXMgZm9sbG93czpcclxuICpcclxuICogICAgICAgICB7eyBleHByZXNzaW9uIFt8IGZpbHRlcl9uYW1lWzpwYXJhbWV0ZXJfdmFsdWVdIC4uLiBdIH19XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGZpbHRlciBmdW5jdGlvbiB0byByZXRyaWV2ZVxyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGZpbHRlciBmdW5jdGlvblxyXG4gKi9cclxuJEZpbHRlclByb3ZpZGVyLiRpbmplY3QgPSBbJyRwcm92aWRlJ107XHJcbmZ1bmN0aW9uICRGaWx0ZXJQcm92aWRlcigkcHJvdmlkZSkge1xyXG4gIHZhciBzdWZmaXggPSAnRmlsdGVyJztcclxuXHJcbiAgZnVuY3Rpb24gcmVnaXN0ZXIobmFtZSwgZmFjdG9yeSkge1xyXG4gICAgcmV0dXJuICRwcm92aWRlLmZhY3RvcnkobmFtZSArIHN1ZmZpeCwgZmFjdG9yeSk7XHJcbiAgfVxyXG4gIHRoaXMucmVnaXN0ZXIgPSByZWdpc3RlcjtcclxuXHJcbiAgdGhpcy4kZ2V0ID0gWyckaW5qZWN0b3InLCBmdW5jdGlvbigkaW5qZWN0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIHJldHVybiAkaW5qZWN0b3IuZ2V0KG5hbWUgKyBzdWZmaXgpO1xyXG4gICAgfVxyXG4gIH1dO1xyXG5cclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4gIHJlZ2lzdGVyKCdjdXJyZW5jeScsIGN1cnJlbmN5RmlsdGVyKTtcclxuICByZWdpc3RlcignZGF0ZScsIGRhdGVGaWx0ZXIpO1xyXG4gIHJlZ2lzdGVyKCdmaWx0ZXInLCBmaWx0ZXJGaWx0ZXIpO1xyXG4gIHJlZ2lzdGVyKCdqc29uJywganNvbkZpbHRlcik7XHJcbiAgcmVnaXN0ZXIoJ2xpbWl0VG8nLCBsaW1pdFRvRmlsdGVyKTtcclxuICByZWdpc3RlcignbG93ZXJjYXNlJywgbG93ZXJjYXNlRmlsdGVyKTtcclxuICByZWdpc3RlcignbnVtYmVyJywgbnVtYmVyRmlsdGVyKTtcclxuICByZWdpc3Rlcignb3JkZXJCeScsIG9yZGVyQnlGaWx0ZXIpO1xyXG4gIHJlZ2lzdGVyKCd1cHBlcmNhc2UnLCB1cHBlcmNhc2VGaWx0ZXIpO1xyXG59XHJcblxyXG4vKipcclxuICogQG5nZG9jIGZpbHRlclxyXG4gKiBAbmFtZSBuZy5maWx0ZXI6ZmlsdGVyXHJcbiAqIEBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU2VsZWN0cyBhIHN1YnNldCBvZiBpdGVtcyBmcm9tIGBhcnJheWAgYW5kIHJldHVybnMgaXQgYXMgYSBuZXcgYXJyYXkuXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdWdtZW50IHRoZSBgQXJyYXlgIHR5cGUgaW4gQW5ndWxhciBleHByZXNzaW9ucy4gU2VlXHJcbiAqIHtAbGluayBuZy4kZmlsdGVyfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBBbmd1bGFyIGFycmF5cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvdXJjZSBhcnJheS5cclxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fGZ1bmN0aW9uKCl9IGV4cHJlc3Npb24gVGhlIHByZWRpY2F0ZSB0byBiZSB1c2VkIGZvciBzZWxlY3RpbmcgaXRlbXMgZnJvbVxyXG4gKiAgIGBhcnJheWAuXHJcbiAqXHJcbiAqICAgQ2FuIGJlIG9uZSBvZjpcclxuICpcclxuICogICAtIGBzdHJpbmdgOiBQcmVkaWNhdGUgdGhhdCByZXN1bHRzIGluIGEgc3Vic3RyaW5nIG1hdGNoIHVzaW5nIHRoZSB2YWx1ZSBvZiBgZXhwcmVzc2lvbmBcclxuICogICAgIHN0cmluZy4gQWxsIHN0cmluZ3Mgb3Igb2JqZWN0cyB3aXRoIHN0cmluZyBwcm9wZXJ0aWVzIGluIGBhcnJheWAgdGhhdCBjb250YWluIHRoaXMgc3RyaW5nXHJcbiAqICAgICB3aWxsIGJlIHJldHVybmVkLiBUaGUgcHJlZGljYXRlIGNhbiBiZSBuZWdhdGVkIGJ5IHByZWZpeGluZyB0aGUgc3RyaW5nIHdpdGggYCFgLlxyXG4gKlxyXG4gKiAgIC0gYE9iamVjdGA6IEEgcGF0dGVybiBvYmplY3QgY2FuIGJlIHVzZWQgdG8gZmlsdGVyIHNwZWNpZmljIHByb3BlcnRpZXMgb24gb2JqZWN0cyBjb250YWluZWRcclxuICogICAgIGJ5IGBhcnJheWAuIEZvciBleGFtcGxlIGB7bmFtZTpcIk1cIiwgcGhvbmU6XCIxXCJ9YCBwcmVkaWNhdGUgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgaXRlbXNcclxuICogICAgIHdoaWNoIGhhdmUgcHJvcGVydHkgYG5hbWVgIGNvbnRhaW5pbmcgXCJNXCIgYW5kIHByb3BlcnR5IGBwaG9uZWAgY29udGFpbmluZyBcIjFcIi4gQSBzcGVjaWFsXHJcbiAqICAgICBwcm9wZXJ0eSBuYW1lIGAkYCBjYW4gYmUgdXNlZCAoYXMgaW4gYHskOlwidGV4dFwifWApIHRvIGFjY2VwdCBhIG1hdGNoIGFnYWluc3QgYW55XHJcbiAqICAgICBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LiBUaGF0J3MgZXF1aXZhbGVudCB0byB0aGUgc2ltcGxlIHN1YnN0cmluZyBtYXRjaCB3aXRoIGEgYHN0cmluZ2BcclxuICogICAgIGFzIGRlc2NyaWJlZCBhYm92ZS5cclxuICpcclxuICogICAtIGBmdW5jdGlvbmA6IEEgcHJlZGljYXRlIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHdyaXRlIGFyYml0cmFyeSBmaWx0ZXJzLiBUaGUgZnVuY3Rpb24gaXNcclxuICogICAgIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAuIFRoZSBmaW5hbCByZXN1bHQgaXMgYW4gYXJyYXkgb2YgdGhvc2UgZWxlbWVudHMgdGhhdFxyXG4gKiAgICAgdGhlIHByZWRpY2F0ZSByZXR1cm5lZCB0cnVlIGZvci5cclxuICpcclxuICogQHBhcmFtIHtmdW5jdGlvbihleHBlY3RlZCwgYWN0dWFsKXx0cnVlfHVuZGVmaW5lZH0gY29tcGFyYXRvciBDb21wYXJhdG9yIHdoaWNoIGlzIHVzZWQgaW5cclxuICogICAgIGRldGVybWluaW5nIGlmIHRoZSBleHBlY3RlZCB2YWx1ZSAoZnJvbSB0aGUgZmlsdGVyIGV4cHJlc3Npb24pIGFuZCBhY3R1YWwgdmFsdWUgKGZyb21cclxuICogICAgIHRoZSBvYmplY3QgaW4gdGhlIGFycmF5KSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIG1hdGNoLlxyXG4gKlxyXG4gKiAgIENhbiBiZSBvbmUgb2Y6XHJcbiAqXHJcbiAqICAgICAtIGBmdW5jdGlvbihleHBlY3RlZCwgYWN0dWFsKWA6XHJcbiAqICAgICAgIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGdpdmVuIHRoZSBvYmplY3QgdmFsdWUgYW5kIHRoZSBwcmVkaWNhdGUgdmFsdWUgdG8gY29tcGFyZSBhbmRcclxuICogICAgICAgc2hvdWxkIHJldHVybiB0cnVlIGlmIHRoZSBpdGVtIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBmaWx0ZXJlZCByZXN1bHQuXHJcbiAqXHJcbiAqICAgICAtIGB0cnVlYDogQSBzaG9ydGhhbmQgZm9yIGBmdW5jdGlvbihleHBlY3RlZCwgYWN0dWFsKSB7IHJldHVybiBhbmd1bGFyLmVxdWFscyhleHBlY3RlZCwgYWN0dWFsKX1gLlxyXG4gKiAgICAgICB0aGlzIGlzIGVzc2VudGlhbGx5IHN0cmljdCBjb21wYXJpc29uIG9mIGV4cGVjdGVkIGFuZCBhY3R1YWwuXHJcbiAqXHJcbiAqICAgICAtIGBmYWxzZXx1bmRlZmluZWRgOiBBIHNob3J0IGhhbmQgZm9yIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBsb29rIGZvciBhIHN1YnN0cmluZyBtYXRjaCBpbiBjYXNlXHJcbiAqICAgICAgIGluc2Vuc2l0aXZlIHdheS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgPGRvYzpleGFtcGxlPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgPGRpdiBuZy1pbml0PVwiZnJpZW5kcyA9IFt7bmFtZTonSm9obicsIHBob25lOic1NTUtMTI3Nid9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOidNYXJ5JywgcGhvbmU6JzgwMC1CSUctTUFSWSd9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOidNaWtlJywgcGhvbmU6JzU1NS00MzIxJ30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6J0FkYW0nLCBwaG9uZTonNTU1LTU2NzgnfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTonSnVsaWUnLCBwaG9uZTonNTU1LTg3NjUnfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTonSnVsaWV0dGUnLCBwaG9uZTonNTU1LTU2NzgnfV1cIj48L2Rpdj5cclxuXHJcbiAgICAgICBTZWFyY2g6IDxpbnB1dCBuZy1tb2RlbD1cInNlYXJjaFRleHRcIj5cclxuICAgICAgIDx0YWJsZSBpZD1cInNlYXJjaFRleHRSZXN1bHRzXCI+XHJcbiAgICAgICAgIDx0cj48dGg+TmFtZTwvdGg+PHRoPlBob25lPC90aD48L3RyPlxyXG4gICAgICAgICA8dHIgbmctcmVwZWF0PVwiZnJpZW5kIGluIGZyaWVuZHMgfCBmaWx0ZXI6c2VhcmNoVGV4dFwiPlxyXG4gICAgICAgICAgIDx0ZD57e2ZyaWVuZC5uYW1lfX08L3RkPlxyXG4gICAgICAgICAgIDx0ZD57e2ZyaWVuZC5waG9uZX19PC90ZD5cclxuICAgICAgICAgPC90cj5cclxuICAgICAgIDwvdGFibGU+XHJcbiAgICAgICA8aHI+XHJcbiAgICAgICBBbnk6IDxpbnB1dCBuZy1tb2RlbD1cInNlYXJjaC4kXCI+IDxicj5cclxuICAgICAgIE5hbWUgb25seSA8aW5wdXQgbmctbW9kZWw9XCJzZWFyY2gubmFtZVwiPjxicj5cclxuICAgICAgIFBob25lIG9ubHkgPGlucHV0IG5nLW1vZGVsPVwic2VhcmNoLnBob25lXCI+PGJyPlxyXG4gICAgICAgRXF1YWxpdHkgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwic3RyaWN0XCI+PGJyPlxyXG4gICAgICAgPHRhYmxlIGlkPVwic2VhcmNoT2JqUmVzdWx0c1wiPlxyXG4gICAgICAgICA8dHI+PHRoPk5hbWU8L3RoPjx0aD5QaG9uZTwvdGg+PC90cj5cclxuICAgICAgICAgPHRyIG5nLXJlcGVhdD1cImZyaWVuZCBpbiBmcmllbmRzIHwgZmlsdGVyOnNlYXJjaDpzdHJpY3RcIj5cclxuICAgICAgICAgICA8dGQ+e3tmcmllbmQubmFtZX19PC90ZD5cclxuICAgICAgICAgICA8dGQ+e3tmcmllbmQucGhvbmV9fTwvdGQ+XHJcbiAgICAgICAgIDwvdHI+XHJcbiAgICAgICA8L3RhYmxlPlxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBzZWFyY2ggYWNyb3NzIGFsbCBmaWVsZHMgd2hlbiBmaWx0ZXJpbmcgd2l0aCBhIHN0cmluZycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBpbnB1dCgnc2VhcmNoVGV4dCcpLmVudGVyKCdtJyk7XHJcbiAgICAgICAgIGV4cGVjdChyZXBlYXRlcignI3NlYXJjaFRleHRSZXN1bHRzIHRyJywgJ2ZyaWVuZCBpbiBmcmllbmRzJykuY29sdW1uKCdmcmllbmQubmFtZScpKS5cclxuICAgICAgICAgICB0b0VxdWFsKFsnTWFyeScsICdNaWtlJywgJ0FkYW0nXSk7XHJcblxyXG4gICAgICAgICBpbnB1dCgnc2VhcmNoVGV4dCcpLmVudGVyKCc3NicpO1xyXG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJyNzZWFyY2hUZXh0UmVzdWx0cyB0cicsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLm5hbWUnKSkuXHJcbiAgICAgICAgICAgdG9FcXVhbChbJ0pvaG4nLCAnSnVsaWUnXSk7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgICBpdCgnc2hvdWxkIHNlYXJjaCBpbiBzcGVjaWZpYyBmaWVsZHMgd2hlbiBmaWx0ZXJpbmcgd2l0aCBhIHByZWRpY2F0ZSBvYmplY3QnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgaW5wdXQoJ3NlYXJjaC4kJykuZW50ZXIoJ2knKTtcclxuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCcjc2VhcmNoT2JqUmVzdWx0cyB0cicsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLm5hbWUnKSkuXHJcbiAgICAgICAgICAgdG9FcXVhbChbJ01hcnknLCAnTWlrZScsICdKdWxpZScsICdKdWxpZXR0ZSddKTtcclxuICAgICAgIH0pO1xyXG4gICAgICAgaXQoJ3Nob3VsZCB1c2UgYSBlcXVhbCBjb21wYXJpc29uIHdoZW4gY29tcGFyYXRvciBpcyB0cnVlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGlucHV0KCdzZWFyY2gubmFtZScpLmVudGVyKCdKdWxpZScpO1xyXG4gICAgICAgICBpbnB1dCgnc3RyaWN0JykuY2hlY2soKTtcclxuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCcjc2VhcmNoT2JqUmVzdWx0cyB0cicsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLm5hbWUnKSkuXHJcbiAgICAgICAgICAgdG9FcXVhbChbJ0p1bGllJ10pO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG5mdW5jdGlvbiBmaWx0ZXJGaWx0ZXIoKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBleHByZXNzaW9uLCBjb21wZXJhdG9yKSB7XHJcbiAgICBpZiAoIWlzQXJyYXkoYXJyYXkpKSByZXR1cm4gYXJyYXk7XHJcbiAgICB2YXIgcHJlZGljYXRlcyA9IFtdO1xyXG4gICAgcHJlZGljYXRlcy5jaGVjayA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJlZGljYXRlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmKCFwcmVkaWNhdGVzW2pdKHZhbHVlKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBzd2l0Y2godHlwZW9mIGNvbXBlcmF0b3IpIHtcclxuICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgaWYoY29tcGVyYXRvciA9PSB0cnVlKSB7XHJcbiAgICAgICAgICBjb21wZXJhdG9yID0gZnVuY3Rpb24ob2JqLCB0ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbmd1bGFyLmVxdWFscyhvYmosIHRleHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNvbXBlcmF0b3IgPSBmdW5jdGlvbihvYmosIHRleHQpIHtcclxuICAgICAgICAgIHRleHQgPSAoJycrdGV4dCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgIHJldHVybiAoJycrb2JqKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGV4dCkgPiAtMVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgc2VhcmNoID0gZnVuY3Rpb24ob2JqLCB0ZXh0KXtcclxuICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09ICdzdHJpbmcnICYmIHRleHQuY2hhckF0KDApID09PSAnIScpIHtcclxuICAgICAgICByZXR1cm4gIXNlYXJjaChvYmosIHRleHQuc3Vic3RyKDEpKTtcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKHR5cGVvZiBvYmopIHtcclxuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxyXG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICAgICAgICByZXR1cm4gY29tcGVyYXRvcihvYmosIHRleHQpO1xyXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHRleHQpIHtcclxuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICAgICAgICAgIHJldHVybiBjb21wZXJhdG9yKG9iaiwgdGV4dCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgZm9yICggdmFyIG9iaktleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmpLZXkuY2hhckF0KDApICE9PSAnJCcgJiYgc2VhcmNoKG9ialtvYmpLZXldLCB0ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XHJcbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHNlYXJjaChvYmpbaV0sIHRleHQpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgc3dpdGNoICh0eXBlb2YgZXhwcmVzc2lvbikge1xyXG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxyXG4gICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICBleHByZXNzaW9uID0geyQ6ZXhwcmVzc2lvbn07XHJcbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgaWYgKGtleSA9PSAnJCcpIHtcclxuICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIGlmICghZXhwcmVzc2lvbltrZXldKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgdmFyIHBhdGggPSBrZXlcclxuICAgICAgICAgICAgICBwcmVkaWNhdGVzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWFyY2godmFsdWUsIGV4cHJlc3Npb25bcGF0aF0pO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KSgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YoZXhwcmVzc2lvbltrZXldKSA9PSAndW5kZWZpbmVkJykgeyByZXR1cm47IH1cclxuICAgICAgICAgICAgICB2YXIgcGF0aCA9IGtleTtcclxuICAgICAgICAgICAgICBwcmVkaWNhdGVzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWFyY2goZ2V0dGVyKHZhbHVlLHBhdGgpLCBleHByZXNzaW9uW3BhdGhdKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuICAgICAgICBwcmVkaWNhdGVzLnB1c2goZXhwcmVzc2lvbik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG4gICAgdmFyIGZpbHRlcmVkID0gW107XHJcbiAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBhcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtqXTtcclxuICAgICAgaWYgKHByZWRpY2F0ZXMuY2hlY2sodmFsdWUpKSB7XHJcbiAgICAgICAgZmlsdGVyZWQucHVzaCh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmaWx0ZXJlZDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZmlsdGVyXHJcbiAqIEBuYW1lIG5nLmZpbHRlcjpjdXJyZW5jeVxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEZvcm1hdHMgYSBudW1iZXIgYXMgYSBjdXJyZW5jeSAoaWUgJDEsMjM0LjU2KS4gV2hlbiBubyBjdXJyZW5jeSBzeW1ib2wgaXMgcHJvdmlkZWQsIGRlZmF1bHRcclxuICogc3ltYm9sIGZvciBjdXJyZW50IGxvY2FsZSBpcyB1c2VkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IElucHV0IHRvIGZpbHRlci5cclxuICogQHBhcmFtIHtzdHJpbmc9fSBzeW1ib2wgQ3VycmVuY3kgc3ltYm9sIG9yIGlkZW50aWZpZXIgdG8gYmUgZGlzcGxheWVkLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgbnVtYmVyLlxyXG4gKlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICRzY29wZS5hbW91bnQgPSAxMjM0LjU2O1xyXG4gICAgICAgICB9XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBuZy1tb2RlbD1cImFtb3VudFwiPiA8YnI+XHJcbiAgICAgICAgIGRlZmF1bHQgY3VycmVuY3kgc3ltYm9sICgkKToge3thbW91bnQgfCBjdXJyZW5jeX19PGJyPlxyXG4gICAgICAgICBjdXN0b20gY3VycmVuY3kgaWRlbnRpZmllciAoVVNEJCk6IHt7YW1vdW50IHwgY3VycmVuY3k6XCJVU0QkXCJ9fVxyXG4gICAgICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGluaXQgd2l0aCAxMjM0LjU2JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdhbW91bnQgfCBjdXJyZW5jeScpKS50b0JlKCckMSwyMzQuNTYnKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2Ftb3VudCB8IGN1cnJlbmN5OlwiVVNEJFwiJykpLnRvQmUoJ1VTRCQxLDIzNC41NicpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBpbnB1dCgnYW1vdW50JykuZW50ZXIoJy0xMjM0Jyk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdhbW91bnQgfCBjdXJyZW5jeScpKS50b0JlKCcoJDEsMjM0LjAwKScpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnYW1vdW50IHwgY3VycmVuY3k6XCJVU0QkXCInKSkudG9CZSgnKFVTRCQxLDIzNC4wMCknKTtcclxuICAgICAgIH0pO1xyXG4gICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICA8L2RvYzpleGFtcGxlPlxyXG4gKi9cclxuY3VycmVuY3lGaWx0ZXIuJGluamVjdCA9IFsnJGxvY2FsZSddO1xyXG5mdW5jdGlvbiBjdXJyZW5jeUZpbHRlcigkbG9jYWxlKSB7XHJcbiAgdmFyIGZvcm1hdHMgPSAkbG9jYWxlLk5VTUJFUl9GT1JNQVRTO1xyXG4gIHJldHVybiBmdW5jdGlvbihhbW91bnQsIGN1cnJlbmN5U3ltYm9sKXtcclxuICAgIGlmIChpc1VuZGVmaW5lZChjdXJyZW5jeVN5bWJvbCkpIGN1cnJlbmN5U3ltYm9sID0gZm9ybWF0cy5DVVJSRU5DWV9TWU07XHJcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKGFtb3VudCwgZm9ybWF0cy5QQVRURVJOU1sxXSwgZm9ybWF0cy5HUk9VUF9TRVAsIGZvcm1hdHMuREVDSU1BTF9TRVAsIDIpLlxyXG4gICAgICAgICAgICAgICAgcmVwbGFjZSgvXFx1MDBBNC9nLCBjdXJyZW5jeVN5bWJvbCk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmaWx0ZXJcclxuICogQG5hbWUgbmcuZmlsdGVyOm51bWJlclxyXG4gKiBAZnVuY3Rpb25cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEZvcm1hdHMgYSBudW1iZXIgYXMgdGV4dC5cclxuICpcclxuICogSWYgdGhlIGlucHV0IGlzIG5vdCBhIG51bWJlciBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbnVtYmVyIE51bWJlciB0byBmb3JtYXQuXHJcbiAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpPX0gZnJhY3Rpb25TaXplIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byByb3VuZCB0aGUgbnVtYmVyIHRvLlxyXG4gKiBJZiB0aGlzIGlzIG5vdCBwcm92aWRlZCB0aGVuIHRoZSBmcmFjdGlvbiBzaXplIGlzIGNvbXB1dGVkIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlJ3MgbnVtYmVyXHJcbiAqIGZvcm1hdHRpbmcgcGF0dGVybi4gSW4gdGhlIGNhc2Ugb2YgdGhlIGRlZmF1bHQgbG9jYWxlLCBpdCB3aWxsIGJlIDMuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IE51bWJlciByb3VuZGVkIHRvIGRlY2ltYWxQbGFjZXMgYW5kIHBsYWNlcyBhIMOi4oKsxZMsw6LigqzCnSBhZnRlciBlYWNoIHRoaXJkIGRpZ2l0LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICRzY29wZS52YWwgPSAxMjM0LjU2Nzg5O1xyXG4gICAgICAgICB9XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICAgRW50ZXIgbnVtYmVyOiA8aW5wdXQgbmctbW9kZWw9J3ZhbCc+PGJyPlxyXG4gICAgICAgICBEZWZhdWx0IGZvcm1hdHRpbmc6IHt7dmFsIHwgbnVtYmVyfX08YnI+XHJcbiAgICAgICAgIE5vIGZyYWN0aW9uczoge3t2YWwgfCBudW1iZXI6MH19PGJyPlxyXG4gICAgICAgICBOZWdhdGl2ZSBudW1iZXI6IHt7LXZhbCB8IG51bWJlcjo0fX1cclxuICAgICAgIDwvZGl2PlxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBmb3JtYXQgbnVtYmVycycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygndmFsIHwgbnVtYmVyJykpLnRvQmUoJzEsMjM0LjU2OCcpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygndmFsIHwgbnVtYmVyOjAnKSkudG9CZSgnMSwyMzUnKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJy12YWwgfCBudW1iZXI6NCcpKS50b0JlKCctMSwyMzQuNTY3OScpO1xyXG4gICAgICAgfSk7XHJcblxyXG4gICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgaW5wdXQoJ3ZhbCcpLmVudGVyKCczMzc0LjMzMycpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygndmFsIHwgbnVtYmVyJykpLnRvQmUoJzMsMzc0LjMzMycpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygndmFsIHwgbnVtYmVyOjAnKSkudG9CZSgnMywzNzQnKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJy12YWwgfCBudW1iZXI6NCcpKS50b0JlKCctMywzNzQuMzMzMCcpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG5cclxuXHJcbm51bWJlckZpbHRlci4kaW5qZWN0ID0gWyckbG9jYWxlJ107XHJcbmZ1bmN0aW9uIG51bWJlckZpbHRlcigkbG9jYWxlKSB7XHJcbiAgdmFyIGZvcm1hdHMgPSAkbG9jYWxlLk5VTUJFUl9GT1JNQVRTO1xyXG4gIHJldHVybiBmdW5jdGlvbihudW1iZXIsIGZyYWN0aW9uU2l6ZSkge1xyXG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcihudW1iZXIsIGZvcm1hdHMuUEFUVEVSTlNbMF0sIGZvcm1hdHMuR1JPVVBfU0VQLCBmb3JtYXRzLkRFQ0lNQUxfU0VQLFxyXG4gICAgICBmcmFjdGlvblNpemUpO1xyXG4gIH07XHJcbn1cclxuXHJcbnZhciBERUNJTUFMX1NFUCA9ICcuJztcclxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bWJlciwgcGF0dGVybiwgZ3JvdXBTZXAsIGRlY2ltYWxTZXAsIGZyYWN0aW9uU2l6ZSkge1xyXG4gIGlmIChpc05hTihudW1iZXIpIHx8ICFpc0Zpbml0ZShudW1iZXIpKSByZXR1cm4gJyc7XHJcblxyXG4gIHZhciBpc05lZ2F0aXZlID0gbnVtYmVyIDwgMDtcclxuICBudW1iZXIgPSBNYXRoLmFicyhudW1iZXIpO1xyXG4gIHZhciBudW1TdHIgPSBudW1iZXIgKyAnJyxcclxuICAgICAgZm9ybWF0ZWRUZXh0ID0gJycsXHJcbiAgICAgIHBhcnRzID0gW107XHJcblxyXG4gIHZhciBoYXNFeHBvbmVudCA9IGZhbHNlO1xyXG4gIGlmIChudW1TdHIuaW5kZXhPZignZScpICE9PSAtMSkge1xyXG4gICAgdmFyIG1hdGNoID0gbnVtU3RyLm1hdGNoKC8oW1xcZFxcLl0rKWUoLT8pKFxcZCspLyk7XHJcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMl0gPT0gJy0nICYmIG1hdGNoWzNdID4gZnJhY3Rpb25TaXplICsgMSkge1xyXG4gICAgICBudW1TdHIgPSAnMCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3JtYXRlZFRleHQgPSBudW1TdHI7XHJcbiAgICAgIGhhc0V4cG9uZW50ID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICghaGFzRXhwb25lbnQpIHtcclxuICAgIHZhciBmcmFjdGlvbkxlbiA9IChudW1TdHIuc3BsaXQoREVDSU1BTF9TRVApWzFdIHx8ICcnKS5sZW5ndGg7XHJcblxyXG4gICAgLy8gZGV0ZXJtaW5lIGZyYWN0aW9uU2l6ZSBpZiBpdCBpcyBub3Qgc3BlY2lmaWVkXHJcbiAgICBpZiAoaXNVbmRlZmluZWQoZnJhY3Rpb25TaXplKSkge1xyXG4gICAgICBmcmFjdGlvblNpemUgPSBNYXRoLm1pbihNYXRoLm1heChwYXR0ZXJuLm1pbkZyYWMsIGZyYWN0aW9uTGVuKSwgcGF0dGVybi5tYXhGcmFjKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcG93ID0gTWF0aC5wb3coMTAsIGZyYWN0aW9uU2l6ZSk7XHJcbiAgICBudW1iZXIgPSBNYXRoLnJvdW5kKG51bWJlciAqIHBvdykgLyBwb3c7XHJcbiAgICB2YXIgZnJhY3Rpb24gPSAoJycgKyBudW1iZXIpLnNwbGl0KERFQ0lNQUxfU0VQKTtcclxuICAgIHZhciB3aG9sZSA9IGZyYWN0aW9uWzBdO1xyXG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvblsxXSB8fCAnJztcclxuXHJcbiAgICB2YXIgcG9zID0gMCxcclxuICAgICAgICBsZ3JvdXAgPSBwYXR0ZXJuLmxnU2l6ZSxcclxuICAgICAgICBncm91cCA9IHBhdHRlcm4uZ1NpemU7XHJcblxyXG4gICAgaWYgKHdob2xlLmxlbmd0aCA+PSAobGdyb3VwICsgZ3JvdXApKSB7XHJcbiAgICAgIHBvcyA9IHdob2xlLmxlbmd0aCAtIGxncm91cDtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3M7IGkrKykge1xyXG4gICAgICAgIGlmICgocG9zIC0gaSklZ3JvdXAgPT09IDAgJiYgaSAhPT0gMCkge1xyXG4gICAgICAgICAgZm9ybWF0ZWRUZXh0ICs9IGdyb3VwU2VwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXRlZFRleHQgKz0gd2hvbGUuY2hhckF0KGkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gcG9zOyBpIDwgd2hvbGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKCh3aG9sZS5sZW5ndGggLSBpKSVsZ3JvdXAgPT09IDAgJiYgaSAhPT0gMCkge1xyXG4gICAgICAgIGZvcm1hdGVkVGV4dCArPSBncm91cFNlcDtcclxuICAgICAgfVxyXG4gICAgICBmb3JtYXRlZFRleHQgKz0gd2hvbGUuY2hhckF0KGkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZvcm1hdCBmcmFjdGlvbiBwYXJ0LlxyXG4gICAgd2hpbGUoZnJhY3Rpb24ubGVuZ3RoIDwgZnJhY3Rpb25TaXplKSB7XHJcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZnJhY3Rpb25TaXplICYmIGZyYWN0aW9uU2l6ZSAhPT0gXCIwXCIpIGZvcm1hdGVkVGV4dCArPSBkZWNpbWFsU2VwICsgZnJhY3Rpb24uc3Vic3RyKDAsIGZyYWN0aW9uU2l6ZSk7XHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICBpZiAoZnJhY3Rpb25TaXplID4gMCAmJiBudW1iZXIgPiAtMSAmJiBudW1iZXIgPCAxKSB7XHJcbiAgICAgIGZvcm1hdGVkVGV4dCA9IG51bWJlci50b0ZpeGVkKGZyYWN0aW9uU2l6ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwYXJ0cy5wdXNoKGlzTmVnYXRpdmUgPyBwYXR0ZXJuLm5lZ1ByZSA6IHBhdHRlcm4ucG9zUHJlKTtcclxuICBwYXJ0cy5wdXNoKGZvcm1hdGVkVGV4dCk7XHJcbiAgcGFydHMucHVzaChpc05lZ2F0aXZlID8gcGF0dGVybi5uZWdTdWYgOiBwYXR0ZXJuLnBvc1N1Zik7XHJcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWROdW1iZXIobnVtLCBkaWdpdHMsIHRyaW0pIHtcclxuICB2YXIgbmVnID0gJyc7XHJcbiAgaWYgKG51bSA8IDApIHtcclxuICAgIG5lZyA9ICAnLSc7XHJcbiAgICBudW0gPSAtbnVtO1xyXG4gIH1cclxuICBudW0gPSAnJyArIG51bTtcclxuICB3aGlsZShudW0ubGVuZ3RoIDwgZGlnaXRzKSBudW0gPSAnMCcgKyBudW07XHJcbiAgaWYgKHRyaW0pXHJcbiAgICBudW0gPSBudW0uc3Vic3RyKG51bS5sZW5ndGggLSBkaWdpdHMpO1xyXG4gIHJldHVybiBuZWcgKyBudW07XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBkYXRlR2V0dGVyKG5hbWUsIHNpemUsIG9mZnNldCwgdHJpbSkge1xyXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xyXG4gIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBkYXRlWydnZXQnICsgbmFtZV0oKTtcclxuICAgIGlmIChvZmZzZXQgPiAwIHx8IHZhbHVlID4gLW9mZnNldClcclxuICAgICAgdmFsdWUgKz0gb2Zmc2V0O1xyXG4gICAgaWYgKHZhbHVlID09PSAwICYmIG9mZnNldCA9PSAtMTIgKSB2YWx1ZSA9IDEyO1xyXG4gICAgcmV0dXJuIHBhZE51bWJlcih2YWx1ZSwgc2l6ZSwgdHJpbSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGF0ZVN0ckdldHRlcihuYW1lLCBzaG9ydEZvcm0pIHtcclxuICByZXR1cm4gZnVuY3Rpb24oZGF0ZSwgZm9ybWF0cykge1xyXG4gICAgdmFyIHZhbHVlID0gZGF0ZVsnZ2V0JyArIG5hbWVdKCk7XHJcbiAgICB2YXIgZ2V0ID0gdXBwZXJjYXNlKHNob3J0Rm9ybSA/ICgnU0hPUlQnICsgbmFtZSkgOiBuYW1lKTtcclxuXHJcbiAgICByZXR1cm4gZm9ybWF0c1tnZXRdW3ZhbHVlXTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aW1lWm9uZUdldHRlcihkYXRlKSB7XHJcbiAgdmFyIHpvbmUgPSAtMSAqIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcclxuICB2YXIgcGFkZGVkWm9uZSA9ICh6b25lID49IDApID8gXCIrXCIgOiBcIlwiO1xyXG5cclxuICBwYWRkZWRab25lICs9IHBhZE51bWJlcihNYXRoW3pvbmUgPiAwID8gJ2Zsb29yJyA6ICdjZWlsJ10oem9uZSAvIDYwKSwgMikgK1xyXG4gICAgICAgICAgICAgICAgcGFkTnVtYmVyKE1hdGguYWJzKHpvbmUgJSA2MCksIDIpO1xyXG5cclxuICByZXR1cm4gcGFkZGVkWm9uZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYW1wbUdldHRlcihkYXRlLCBmb3JtYXRzKSB7XHJcbiAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKSA8IDEyID8gZm9ybWF0cy5BTVBNU1swXSA6IGZvcm1hdHMuQU1QTVNbMV07XHJcbn1cclxuXHJcbnZhciBEQVRFX0ZPUk1BVFMgPSB7XHJcbiAgeXl5eTogZGF0ZUdldHRlcignRnVsbFllYXInLCA0KSxcclxuICAgIHl5OiBkYXRlR2V0dGVyKCdGdWxsWWVhcicsIDIsIDAsIHRydWUpLFxyXG4gICAgIHk6IGRhdGVHZXR0ZXIoJ0Z1bGxZZWFyJywgMSksXHJcbiAgTU1NTTogZGF0ZVN0ckdldHRlcignTW9udGgnKSxcclxuICAgTU1NOiBkYXRlU3RyR2V0dGVyKCdNb250aCcsIHRydWUpLFxyXG4gICAgTU06IGRhdGVHZXR0ZXIoJ01vbnRoJywgMiwgMSksXHJcbiAgICAgTTogZGF0ZUdldHRlcignTW9udGgnLCAxLCAxKSxcclxuICAgIGRkOiBkYXRlR2V0dGVyKCdEYXRlJywgMiksXHJcbiAgICAgZDogZGF0ZUdldHRlcignRGF0ZScsIDEpLFxyXG4gICAgSEg6IGRhdGVHZXR0ZXIoJ0hvdXJzJywgMiksXHJcbiAgICAgSDogZGF0ZUdldHRlcignSG91cnMnLCAxKSxcclxuICAgIGhoOiBkYXRlR2V0dGVyKCdIb3VycycsIDIsIC0xMiksXHJcbiAgICAgaDogZGF0ZUdldHRlcignSG91cnMnLCAxLCAtMTIpLFxyXG4gICAgbW06IGRhdGVHZXR0ZXIoJ01pbnV0ZXMnLCAyKSxcclxuICAgICBtOiBkYXRlR2V0dGVyKCdNaW51dGVzJywgMSksXHJcbiAgICBzczogZGF0ZUdldHRlcignU2Vjb25kcycsIDIpLFxyXG4gICAgIHM6IGRhdGVHZXR0ZXIoJ1NlY29uZHMnLCAxKSxcclxuICAgICAvLyB3aGlsZSBJU08gODYwMSByZXF1aXJlcyBmcmFjdGlvbnMgdG8gYmUgcHJlZml4ZWQgd2l0aCBgLmAgb3IgYCxgXHJcbiAgICAgLy8gd2UgY2FuIGJlIGp1c3Qgc2FmZWx5IHJlbHkgb24gdXNpbmcgYHNzc2Agc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IHN1cHBvcnQgc2luZ2xlIG9yIHR3byBkaWdpdCBmcmFjdGlvbnNcclxuICAgc3NzOiBkYXRlR2V0dGVyKCdNaWxsaXNlY29uZHMnLCAzKSxcclxuICBFRUVFOiBkYXRlU3RyR2V0dGVyKCdEYXknKSxcclxuICAgRUVFOiBkYXRlU3RyR2V0dGVyKCdEYXknLCB0cnVlKSxcclxuICAgICBhOiBhbXBtR2V0dGVyLFxyXG4gICAgIFo6IHRpbWVab25lR2V0dGVyXHJcbn07XHJcblxyXG52YXIgREFURV9GT1JNQVRTX1NQTElUID0gLygoPzpbXnlNZEhobXNhWkUnXSspfCg/OicoPzpbXiddfCcnKSonKXwoPzpFK3x5K3xNK3xkK3xIK3xoK3xtK3xzK3xhfFopKSguKikvLFxyXG4gICAgTlVNQkVSX1NUUklORyA9IC9eXFxkKyQvO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmaWx0ZXJcclxuICogQG5hbWUgbmcuZmlsdGVyOmRhdGVcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIEZvcm1hdHMgYGRhdGVgIHRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSByZXF1ZXN0ZWQgYGZvcm1hdGAuXHJcbiAqXHJcbiAqICAgYGZvcm1hdGAgc3RyaW5nIGNhbiBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGVsZW1lbnRzOlxyXG4gKlxyXG4gKiAgICogYCd5eXl5J2A6IDQgZGlnaXQgcmVwcmVzZW50YXRpb24gb2YgeWVhciAoZS5nLiBBRCAxID0+IDAwMDEsIEFEIDIwMTAgPT4gMjAxMClcclxuICogICAqIGAneXknYDogMiBkaWdpdCByZXByZXNlbnRhdGlvbiBvZiB5ZWFyLCBwYWRkZWQgKDAwLTk5KS4gKGUuZy4gQUQgMjAwMSA9PiAwMSwgQUQgMjAxMCA9PiAxMClcclxuICogICAqIGAneSdgOiAxIGRpZ2l0IHJlcHJlc2VudGF0aW9uIG9mIHllYXIsIGUuZy4gKEFEIDEgPT4gMSwgQUQgMTk5ID0+IDE5OSlcclxuICogICAqIGAnTU1NTSdgOiBNb250aCBpbiB5ZWFyIChKYW51YXJ5LURlY2VtYmVyKVxyXG4gKiAgICogYCdNTU0nYDogTW9udGggaW4geWVhciAoSmFuLURlYylcclxuICogICAqIGAnTU0nYDogTW9udGggaW4geWVhciwgcGFkZGVkICgwMS0xMilcclxuICogICAqIGAnTSdgOiBNb250aCBpbiB5ZWFyICgxLTEyKVxyXG4gKiAgICogYCdkZCdgOiBEYXkgaW4gbW9udGgsIHBhZGRlZCAoMDEtMzEpXHJcbiAqICAgKiBgJ2QnYDogRGF5IGluIG1vbnRoICgxLTMxKVxyXG4gKiAgICogYCdFRUVFJ2A6IERheSBpbiBXZWVrLChTdW5kYXktU2F0dXJkYXkpXHJcbiAqICAgKiBgJ0VFRSdgOiBEYXkgaW4gV2VlaywgKFN1bi1TYXQpXHJcbiAqICAgKiBgJ0hIJ2A6IEhvdXIgaW4gZGF5LCBwYWRkZWQgKDAwLTIzKVxyXG4gKiAgICogYCdIJ2A6IEhvdXIgaW4gZGF5ICgwLTIzKVxyXG4gKiAgICogYCdoaCdgOiBIb3VyIGluIGFtL3BtLCBwYWRkZWQgKDAxLTEyKVxyXG4gKiAgICogYCdoJ2A6IEhvdXIgaW4gYW0vcG0sICgxLTEyKVxyXG4gKiAgICogYCdtbSdgOiBNaW51dGUgaW4gaG91ciwgcGFkZGVkICgwMC01OSlcclxuICogICAqIGAnbSdgOiBNaW51dGUgaW4gaG91ciAoMC01OSlcclxuICogICAqIGAnc3MnYDogU2Vjb25kIGluIG1pbnV0ZSwgcGFkZGVkICgwMC01OSlcclxuICogICAqIGAncydgOiBTZWNvbmQgaW4gbWludXRlICgwLTU5KVxyXG4gKiAgICogYCcuc3NzJyBvciAnLHNzcydgOiBNaWxsaXNlY29uZCBpbiBzZWNvbmQsIHBhZGRlZCAoMDAwLTk5OSlcclxuICogICAqIGAnYSdgOiBhbS9wbSBtYXJrZXJcclxuICogICAqIGAnWidgOiA0IGRpZ2l0ICgrc2lnbikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpbWV6b25lIG9mZnNldCAoLTEyMDAtKzEyMDApXHJcbiAqXHJcbiAqICAgYGZvcm1hdGAgc3RyaW5nIGNhbiBhbHNvIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHByZWRlZmluZWRcclxuICogICB7QGxpbmsgZ3VpZGUvaTE4biBsb2NhbGl6YWJsZSBmb3JtYXRzfTpcclxuICpcclxuICogICAqIGAnbWVkaXVtJ2A6IGVxdWl2YWxlbnQgdG8gYCdNTU0gZCwgeSBoOm1tOnNzIGEnYCBmb3IgZW5fVVMgbG9jYWxlXHJcbiAqICAgICAoZS5nLiBTZXAgMywgMjAxMCAxMjowNTowOCBwbSlcclxuICogICAqIGAnc2hvcnQnYDogZXF1aXZhbGVudCB0byBgJ00vZC95eSBoOm1tIGEnYCBmb3IgZW5fVVMgIGxvY2FsZSAoZS5nLiA5LzMvMTAgMTI6MDUgcG0pXHJcbiAqICAgKiBgJ2Z1bGxEYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCdFRUVFLCBNTU1NIGQseSdgIGZvciBlbl9VUyAgbG9jYWxlXHJcbiAqICAgICAoZS5nLiBGcmlkYXksIFNlcHRlbWJlciAzLCAyMDEwKVxyXG4gKiAgICogYCdsb25nRGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAnTU1NTSBkLCB5J2AgZm9yIGVuX1VTICBsb2NhbGUgKGUuZy4gU2VwdGVtYmVyIDMsIDIwMTApXHJcbiAqICAgKiBgJ21lZGl1bURhdGUnYDogZXF1aXZhbGVudCB0byBgJ01NTSBkLCB5J2AgZm9yIGVuX1VTICBsb2NhbGUgKGUuZy4gU2VwIDMsIDIwMTApXHJcbiAqICAgKiBgJ3Nob3J0RGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAnTS9kL3l5J2AgZm9yIGVuX1VTIGxvY2FsZSAoZS5nLiA5LzMvMTApXHJcbiAqICAgKiBgJ21lZGl1bVRpbWUnYDogZXF1aXZhbGVudCB0byBgJ2g6bW06c3MgYSdgIGZvciBlbl9VUyBsb2NhbGUgKGUuZy4gMTI6MDU6MDggcG0pXHJcbiAqICAgKiBgJ3Nob3J0VGltZSdgOiBlcXVpdmFsZW50IHRvIGAnaDptbSBhJ2AgZm9yIGVuX1VTIGxvY2FsZSAoZS5nLiAxMjowNSBwbSlcclxuICpcclxuICogICBgZm9ybWF0YCBzdHJpbmcgY2FuIGNvbnRhaW4gbGl0ZXJhbCB2YWx1ZXMuIFRoZXNlIG5lZWQgdG8gYmUgcXVvdGVkIHdpdGggc2luZ2xlIHF1b3RlcyAoZS5nLlxyXG4gKiAgIGBcImggJ2luIHRoZSBtb3JuaW5nJ1wiYCkuIEluIG9yZGVyIHRvIG91dHB1dCBzaW5nbGUgcXVvdGUsIHVzZSB0d28gc2luZ2xlIHF1b3RlcyBpbiBhIHNlcXVlbmNlXHJcbiAqICAgKGUuZy4gYFwiaCAnbycnY2xvY2snXCJgKS5cclxuICpcclxuICogQHBhcmFtIHsoRGF0ZXxudW1iZXJ8c3RyaW5nKX0gZGF0ZSBEYXRlIHRvIGZvcm1hdCBlaXRoZXIgYXMgRGF0ZSBvYmplY3QsIG1pbGxpc2Vjb25kcyAoc3RyaW5nIG9yXHJcbiAqICAgIG51bWJlcikgb3IgdmFyaW91cyBJU08gODYwMSBkYXRldGltZSBzdHJpbmcgZm9ybWF0cyAoZS5nLiB5eXl5LU1NLWRkVEhIOm1tOnNzLlNTU1ogYW5kIGl0c1xyXG4gKiAgICBzaG9ydGVyIHZlcnNpb25zIGxpa2UgeXl5eS1NTS1kZFRISDptbVosIHl5eXktTU0tZGQgb3IgeXl5eU1NZGRUSEhtbXNzWikuIElmIG5vIHRpbWV6b25lIGlzXHJcbiAqICAgIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGlucHV0LCB0aGUgdGltZSBpcyBjb25zaWRlcmVkIHRvIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cclxuICogQHBhcmFtIHtzdHJpbmc9fSBmb3JtYXQgRm9ybWF0dGluZyBydWxlcyAoc2VlIERlc2NyaXB0aW9uKS4gSWYgbm90IHNwZWNpZmllZCxcclxuICogICAgYG1lZGl1bURhdGVgIGlzIHVzZWQuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBzdHJpbmcgb3IgdGhlIGlucHV0IGlmIGlucHV0IGlzIG5vdCByZWNvZ25pemVkIGFzIGRhdGUvbWlsbGlzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c3BhbiBuZy1ub24tYmluZGFibGU+e3sxMjg4MzIzNjIzMDA2IHwgZGF0ZTonbWVkaXVtJ319PC9zcGFuPjpcclxuICAgICAgICAgICB7ezEyODgzMjM2MjMwMDYgfCBkYXRlOidtZWRpdW0nfX08YnI+XHJcbiAgICAgICA8c3BhbiBuZy1ub24tYmluZGFibGU+e3sxMjg4MzIzNjIzMDA2IHwgZGF0ZToneXl5eS1NTS1kZCBISDptbTpzcyBaJ319PC9zcGFuPjpcclxuICAgICAgICAgIHt7MTI4ODMyMzYyMzAwNiB8IGRhdGU6J3l5eXktTU0tZGQgSEg6bW06c3MgWid9fTxicj5cclxuICAgICAgIDxzcGFuIG5nLW5vbi1iaW5kYWJsZT57ezEyODgzMjM2MjMwMDYgfCBkYXRlOidNTS9kZC95eXl5IEAgaDptbWEnfX08L3NwYW4+OlxyXG4gICAgICAgICAge3snMTI4ODMyMzYyMzAwNicgfCBkYXRlOidNTS9kZC95eXl5IEAgaDptbWEnfX08YnI+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGZvcm1hdCBkYXRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKFwiMTI4ODMyMzYyMzAwNiB8IGRhdGU6J21lZGl1bSdcIikpLlxyXG4gICAgICAgICAgICB0b01hdGNoKC9PY3QgMlxcZCwgMjAxMCBcXGR7MSwyfTpcXGR7Mn06XFxkezJ9IChBTXxQTSkvKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoXCIxMjg4MzIzNjIzMDA2IHwgZGF0ZToneXl5eS1NTS1kZCBISDptbTpzcyBaJ1wiKSkuXHJcbiAgICAgICAgICAgIHRvTWF0Y2goLzIwMTBcXC0xMFxcLTJcXGQgXFxkezJ9OlxcZHsyfTpcXGR7Mn0gKFxcLXxcXCspP1xcZHs0fS8pO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZyhcIicxMjg4MzIzNjIzMDA2JyB8IGRhdGU6J01NL2RkL3l5eXkgQCBoOm1tYSdcIikpLlxyXG4gICAgICAgICAgICB0b01hdGNoKC8xMFxcLzJcXGRcXC8yMDEwIEAgXFxkezEsMn06XFxkezJ9KEFNfFBNKS8pO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG5kYXRlRmlsdGVyLiRpbmplY3QgPSBbJyRsb2NhbGUnXTtcclxuZnVuY3Rpb24gZGF0ZUZpbHRlcigkbG9jYWxlKSB7XHJcblxyXG5cclxuICB2YXIgUl9JU084NjAxX1NUUiA9IC9eKFxcZHs0fSktPyhcXGRcXGQpLT8oXFxkXFxkKSg/OlQoXFxkXFxkKSg/Ojo/KFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86XFwuKFxcZCspKT8pPyk/KFp8KFsrLV0pKFxcZFxcZCk6PyhcXGRcXGQpKT8pPyQvO1xyXG4gICAgICAgICAgICAgICAgICAgICAvLyAxICAgICAgICAyICAgICAgIDMgICAgICAgICA0ICAgICAgICAgIDUgICAgICAgICAgNiAgICAgICAgICA3ICAgICAgICAgIDggIDkgICAgIDEwICAgICAgMTFcclxuICBmdW5jdGlvbiBqc29uU3RyaW5nVG9EYXRlKHN0cmluZykge1xyXG4gICAgdmFyIG1hdGNoO1xyXG4gICAgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKFJfSVNPODYwMV9TVFIpKSB7XHJcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoMCksXHJcbiAgICAgICAgICB0ekhvdXIgPSAwLFxyXG4gICAgICAgICAgdHpNaW4gID0gMCxcclxuICAgICAgICAgIGRhdGVTZXR0ZXIgPSBtYXRjaFs4XSA/IGRhdGUuc2V0VVRDRnVsbFllYXIgOiBkYXRlLnNldEZ1bGxZZWFyLFxyXG4gICAgICAgICAgdGltZVNldHRlciA9IG1hdGNoWzhdID8gZGF0ZS5zZXRVVENIb3VycyA6IGRhdGUuc2V0SG91cnM7XHJcblxyXG4gICAgICBpZiAobWF0Y2hbOV0pIHtcclxuICAgICAgICB0ekhvdXIgPSBpbnQobWF0Y2hbOV0gKyBtYXRjaFsxMF0pO1xyXG4gICAgICAgIHR6TWluID0gaW50KG1hdGNoWzldICsgbWF0Y2hbMTFdKTtcclxuICAgICAgfVxyXG4gICAgICBkYXRlU2V0dGVyLmNhbGwoZGF0ZSwgaW50KG1hdGNoWzFdKSwgaW50KG1hdGNoWzJdKSAtIDEsIGludChtYXRjaFszXSkpO1xyXG4gICAgICB2YXIgaCA9IGludChtYXRjaFs0XXx8MCkgLSB0ekhvdXI7XHJcbiAgICAgIHZhciBtID0gaW50KG1hdGNoWzVdfHwwKSAtIHR6TWluXHJcbiAgICAgIHZhciBzID0gaW50KG1hdGNoWzZdfHwwKTtcclxuICAgICAgdmFyIG1zID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KCcwLicgKyAobWF0Y2hbN118fDApKSAqIDEwMDApO1xyXG4gICAgICB0aW1lU2V0dGVyLmNhbGwoZGF0ZSwgaCwgbSwgcywgbXMpO1xyXG4gICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHJpbmc7XHJcbiAgfVxyXG5cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCkge1xyXG4gICAgdmFyIHRleHQgPSAnJyxcclxuICAgICAgICBwYXJ0cyA9IFtdLFxyXG4gICAgICAgIGZuLCBtYXRjaDtcclxuXHJcbiAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJ21lZGl1bURhdGUnO1xyXG4gICAgZm9ybWF0ID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTW2Zvcm1hdF0gfHwgZm9ybWF0O1xyXG4gICAgaWYgKGlzU3RyaW5nKGRhdGUpKSB7XHJcbiAgICAgIGlmIChOVU1CRVJfU1RSSU5HLnRlc3QoZGF0ZSkpIHtcclxuICAgICAgICBkYXRlID0gaW50KGRhdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGUgPSBqc29uU3RyaW5nVG9EYXRlKGRhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTnVtYmVyKGRhdGUpKSB7XHJcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzRGF0ZShkYXRlKSkge1xyXG4gICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZShmb3JtYXQpIHtcclxuICAgICAgbWF0Y2ggPSBEQVRFX0ZPUk1BVFNfU1BMSVQuZXhlYyhmb3JtYXQpO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBwYXJ0cyA9IGNvbmNhdChwYXJ0cywgbWF0Y2gsIDEpO1xyXG4gICAgICAgIGZvcm1hdCA9IHBhcnRzLnBvcCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnRzLnB1c2goZm9ybWF0KTtcclxuICAgICAgICBmb3JtYXQgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yRWFjaChwYXJ0cywgZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICBmbiA9IERBVEVfRk9STUFUU1t2YWx1ZV07XHJcbiAgICAgIHRleHQgKz0gZm4gPyBmbihkYXRlLCAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMpXHJcbiAgICAgICAgICAgICAgICAgOiB2YWx1ZS5yZXBsYWNlKC8oXid8JyQpL2csICcnKS5yZXBsYWNlKC8nJy9nLCBcIidcIik7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdGV4dDtcclxuICB9O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBmaWx0ZXJcclxuICogQG5hbWUgbmcuZmlsdGVyOmpzb25cclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiAgIEFsbG93cyB5b3UgdG8gY29udmVydCBhIEphdmFTY3JpcHQgb2JqZWN0IGludG8gSlNPTiBzdHJpbmcuXHJcbiAqXHJcbiAqICAgVGhpcyBmaWx0ZXIgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgZGVidWdnaW5nLiBXaGVuIHVzaW5nIHRoZSBkb3VibGUgY3VybHkge3t2YWx1ZX19IG5vdGF0aW9uXHJcbiAqICAgdGhlIGJpbmRpbmcgaXMgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gSlNPTi5cclxuICpcclxuICogQHBhcmFtIHsqfSBvYmplY3QgQW55IEphdmFTY3JpcHQgb2JqZWN0IChpbmNsdWRpbmcgYXJyYXlzIGFuZCBwcmltaXRpdmUgdHlwZXMpIHRvIGZpbHRlci5cclxuICogQHJldHVybnMge3N0cmluZ30gSlNPTiBzdHJpbmcuXHJcbiAqXHJcbiAqXHJcbiAqIEBleGFtcGxlOlxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8cHJlPnt7IHsnbmFtZSc6J3ZhbHVlJ30gfCBqc29uIH19PC9wcmU+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGpzb25pZnkgZmlsdGVyZWQgb2JqZWN0cycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZyhcInsnbmFtZSc6J3ZhbHVlJ31cIikpLnRvTWF0Y2goL1xce1xcbiAgXCJuYW1lXCI6ID9cInZhbHVlXCJcXG59Lyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGpzb25GaWx0ZXIoKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgcmV0dXJuIHRvSnNvbihvYmplY3QsIHRydWUpO1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZpbHRlclxyXG4gKiBAbmFtZSBuZy5maWx0ZXI6bG93ZXJjYXNlXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ29udmVydHMgc3RyaW5nIHRvIGxvd2VyY2FzZS5cclxuICogQHNlZSBhbmd1bGFyLmxvd2VyY2FzZVxyXG4gKi9cclxudmFyIGxvd2VyY2FzZUZpbHRlciA9IHZhbHVlRm4obG93ZXJjYXNlKTtcclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGZpbHRlclxyXG4gKiBAbmFtZSBuZy5maWx0ZXI6dXBwZXJjYXNlXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ29udmVydHMgc3RyaW5nIHRvIHVwcGVyY2FzZS5cclxuICogQHNlZSBhbmd1bGFyLnVwcGVyY2FzZVxyXG4gKi9cclxudmFyIHVwcGVyY2FzZUZpbHRlciA9IHZhbHVlRm4odXBwZXJjYXNlKTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgbmcuZmlsdGVyOmxpbWl0VG9cclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDcmVhdGVzIGEgbmV3IGFycmF5IG9yIHN0cmluZyBjb250YWluaW5nIG9ubHkgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVsZW1lbnRzLiBUaGUgZWxlbWVudHNcclxuICogYXJlIHRha2VuIGZyb20gZWl0aGVyIHRoZSBiZWdpbm5pbmcgb3IgdGhlIGVuZCBvZiB0aGUgc291cmNlIGFycmF5IG9yIHN0cmluZywgYXMgc3BlY2lmaWVkIGJ5XHJcbiAqIHRoZSB2YWx1ZSBhbmQgc2lnbiAocG9zaXRpdmUgb3IgbmVnYXRpdmUpIG9mIGBsaW1pdGAuXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdWdtZW50IHRoZSBgQXJyYXlgIHR5cGUgaW4gQW5ndWxhciBleHByZXNzaW9ucy4gU2VlXHJcbiAqIHtAbGluayBuZy4kZmlsdGVyfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBBbmd1bGFyIGFycmF5cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGlucHV0IFNvdXJjZSBhcnJheSBvciBzdHJpbmcgdG8gYmUgbGltaXRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBsaW1pdCBUaGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBhcnJheSBvciBzdHJpbmcuIElmIHRoZSBgbGltaXRgIG51bWJlciBcclxuICogICAgIGlzIHBvc2l0aXZlLCBgbGltaXRgIG51bWJlciBvZiBpdGVtcyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNvdXJjZSBhcnJheS9zdHJpbmcgYXJlIGNvcGllZC5cclxuICogICAgIElmIHRoZSBudW1iZXIgaXMgbmVnYXRpdmUsIGBsaW1pdGAgbnVtYmVyICBvZiBpdGVtcyBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBhcnJheS9zdHJpbmcgXHJcbiAqICAgICBhcmUgY29waWVkLiBUaGUgYGxpbWl0YCB3aWxsIGJlIHRyaW1tZWQgaWYgaXQgZXhjZWVkcyBgYXJyYXkubGVuZ3RoYFxyXG4gKiBAcmV0dXJucyB7QXJyYXl8c3RyaW5nfSBBIG5ldyBzdWItYXJyYXkgb3Igc3Vic3RyaW5nIG9mIGxlbmd0aCBgbGltaXRgIG9yIGxlc3MgaWYgaW5wdXQgYXJyYXlcclxuICogICAgIGhhZCBsZXNzIHRoYW4gYGxpbWl0YCBlbGVtZW50cy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgPGRvYzpleGFtcGxlPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAkc2NvcGUubnVtYmVycyA9IFsxLDIsMyw0LDUsNiw3LDgsOV07XHJcbiAgICAgICAgICAgJHNjb3BlLmxldHRlcnMgPSBcImFiY2RlZmdoaVwiO1xyXG4gICAgICAgICAgICRzY29wZS5udW1MaW1pdCA9IDM7XHJcbiAgICAgICAgICAgJHNjb3BlLmxldHRlckxpbWl0ID0gMztcclxuICAgICAgICAgfVxyXG4gICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgIExpbWl0IHt7bnVtYmVyc319IHRvOiA8aW5wdXQgdHlwZT1cImludGVnZXJcIiBuZy1tb2RlbD1cIm51bUxpbWl0XCI+XHJcbiAgICAgICAgIDxwPk91dHB1dCBudW1iZXJzOiB7eyBudW1iZXJzIHwgbGltaXRUbzpudW1MaW1pdCB9fTwvcD5cclxuICAgICAgICAgTGltaXQge3tsZXR0ZXJzfX0gdG86IDxpbnB1dCB0eXBlPVwiaW50ZWdlclwiIG5nLW1vZGVsPVwibGV0dGVyTGltaXRcIj5cclxuICAgICAgICAgPHA+T3V0cHV0IGxldHRlcnM6IHt7IGxldHRlcnMgfCBsaW1pdFRvOmxldHRlckxpbWl0IH19PC9wPlxyXG4gICAgICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGxpbWl0IHRoZSBudW1iZXIgYXJyYXkgdG8gZmlyc3QgdGhyZWUgaXRlbXMnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIGlucHV0W25nLW1vZGVsPW51bUxpbWl0XScpLnZhbCgpKS50b0JlKCczJyk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBpbnB1dFtuZy1tb2RlbD1sZXR0ZXJMaW1pdF0nKS52YWwoKSkudG9CZSgnMycpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnbnVtYmVycyB8IGxpbWl0VG86bnVtTGltaXQnKSkudG9FcXVhbCgnWzEsMiwzXScpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnbGV0dGVycyB8IGxpbWl0VG86bGV0dGVyTGltaXQnKSkudG9FcXVhbCgnYWJjJyk7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSB0aGUgb3V0cHV0IHdoZW4gLTMgaXMgZW50ZXJlZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBpbnB1dCgnbnVtTGltaXQnKS5lbnRlcigtMyk7XHJcbiAgICAgICAgIGlucHV0KCdsZXR0ZXJMaW1pdCcpLmVudGVyKC0zKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ251bWJlcnMgfCBsaW1pdFRvOm51bUxpbWl0JykpLnRvRXF1YWwoJ1s3LDgsOV0nKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2xldHRlcnMgfCBsaW1pdFRvOmxldHRlckxpbWl0JykpLnRvRXF1YWwoJ2doaScpO1xyXG4gICAgICAgfSk7XHJcblxyXG4gICAgICAgaXQoJ3Nob3VsZCBub3QgZXhjZWVkIHRoZSBtYXhpbXVtIHNpemUgb2YgaW5wdXQgYXJyYXknLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgaW5wdXQoJ251bUxpbWl0JykuZW50ZXIoMTAwKTtcclxuICAgICAgICAgaW5wdXQoJ2xldHRlckxpbWl0JykuZW50ZXIoMTAwKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ251bWJlcnMgfCBsaW1pdFRvOm51bUxpbWl0JykpLnRvRXF1YWwoJ1sxLDIsMyw0LDUsNiw3LDgsOV0nKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2xldHRlcnMgfCBsaW1pdFRvOmxldHRlckxpbWl0JykpLnRvRXF1YWwoJ2FiY2RlZmdoaScpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG5mdW5jdGlvbiBsaW1pdFRvRmlsdGVyKCl7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBsaW1pdCkge1xyXG4gICAgaWYgKCFpc0FycmF5KGlucHV0KSAmJiAhaXNTdHJpbmcoaW5wdXQpKSByZXR1cm4gaW5wdXQ7XHJcbiAgICBcclxuICAgIGxpbWl0ID0gaW50KGxpbWl0KTtcclxuXHJcbiAgICBpZiAoaXNTdHJpbmcoaW5wdXQpKSB7XHJcbiAgICAgIC8vTmFOIGNoZWNrIG9uIGxpbWl0XHJcbiAgICAgIGlmIChsaW1pdCkge1xyXG4gICAgICAgIHJldHVybiBsaW1pdCA+PSAwID8gaW5wdXQuc2xpY2UoMCwgbGltaXQpIDogaW5wdXQuc2xpY2UobGltaXQsIGlucHV0Lmxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgb3V0ID0gW10sXHJcbiAgICAgIGksIG47XHJcblxyXG4gICAgLy8gaWYgYWJzKGxpbWl0KSBleGNlZWRzIG1heGltdW0gbGVuZ3RoLCB0cmltIGl0XHJcbiAgICBpZiAobGltaXQgPiBpbnB1dC5sZW5ndGgpXHJcbiAgICAgIGxpbWl0ID0gaW5wdXQubGVuZ3RoO1xyXG4gICAgZWxzZSBpZiAobGltaXQgPCAtaW5wdXQubGVuZ3RoKVxyXG4gICAgICBsaW1pdCA9IC1pbnB1dC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGxpbWl0ID4gMCkge1xyXG4gICAgICBpID0gMDtcclxuICAgICAgbiA9IGxpbWl0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaSA9IGlucHV0Lmxlbmd0aCArIGxpbWl0O1xyXG4gICAgICBuID0gaW5wdXQubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoOyBpPG47IGkrKykge1xyXG4gICAgICBvdXQucHVzaChpbnB1dFtpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZnVuY3Rpb25cclxuICogQG5hbWUgbmcuZmlsdGVyOm9yZGVyQnlcclxuICogQGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBPcmRlcnMgYSBzcGVjaWZpZWQgYGFycmF5YCBieSB0aGUgYGV4cHJlc3Npb25gIHByZWRpY2F0ZS5cclxuICpcclxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF1Z21lbnQgdGhlIGBBcnJheWAgdHlwZSBpbiBBbmd1bGFyIGV4cHJlc3Npb25zLiBTZWVcclxuICoge0BsaW5rIG5nLiRmaWx0ZXJ9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IEFuZ3VsYXIgYXJyYXlzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cclxuICogQHBhcmFtIHtmdW5jdGlvbigqKXxzdHJpbmd8QXJyYXkuPChmdW5jdGlvbigqKXxzdHJpbmcpPn0gZXhwcmVzc2lvbiBBIHByZWRpY2F0ZSB0byBiZVxyXG4gKiAgICB1c2VkIGJ5IHRoZSBjb21wYXJhdG9yIHRvIGRldGVybWluZSB0aGUgb3JkZXIgb2YgZWxlbWVudHMuXHJcbiAqXHJcbiAqICAgIENhbiBiZSBvbmUgb2Y6XHJcbiAqXHJcbiAqICAgIC0gYGZ1bmN0aW9uYDogR2V0dGVyIGZ1bmN0aW9uLiBUaGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzb3J0ZWQgdXNpbmcgdGhlXHJcbiAqICAgICAgYDxgLCBgPWAsIGA+YCBvcGVyYXRvci5cclxuICogICAgLSBgc3RyaW5nYDogQW4gQW5ndWxhciBleHByZXNzaW9uIHdoaWNoIGV2YWx1YXRlcyB0byBhbiBvYmplY3QgdG8gb3JkZXIgYnksIHN1Y2ggYXMgJ25hbWUnXHJcbiAqICAgICAgdG8gc29ydCBieSBhIHByb3BlcnR5IGNhbGxlZCAnbmFtZScuIE9wdGlvbmFsbHkgcHJlZml4ZWQgd2l0aCBgK2Agb3IgYC1gIHRvIGNvbnRyb2xcclxuICogICAgICBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZyBzb3J0IG9yZGVyIChmb3IgZXhhbXBsZSwgK25hbWUgb3IgLW5hbWUpLlxyXG4gKiAgICAtIGBBcnJheWA6IEFuIGFycmF5IG9mIGZ1bmN0aW9uIG9yIHN0cmluZyBwcmVkaWNhdGVzLiBUaGUgZmlyc3QgcHJlZGljYXRlIGluIHRoZSBhcnJheVxyXG4gKiAgICAgIGlzIHVzZWQgZm9yIHNvcnRpbmcsIGJ1dCB3aGVuIHR3byBpdGVtcyBhcmUgZXF1aXZhbGVudCwgdGhlIG5leHQgcHJlZGljYXRlIGlzIHVzZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHJldmVyc2UgUmV2ZXJzZSB0aGUgb3JkZXIgdGhlIGFycmF5LlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IFNvcnRlZCBjb3B5IG9mIHRoZSBzb3VyY2UgYXJyYXkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAgJHNjb3BlLmZyaWVuZHMgPVxyXG4gICAgICAgICAgICAgICBbe25hbWU6J0pvaG4nLCBwaG9uZTonNTU1LTEyMTInLCBhZ2U6MTB9LFxyXG4gICAgICAgICAgICAgICAge25hbWU6J01hcnknLCBwaG9uZTonNTU1LTk4NzYnLCBhZ2U6MTl9LFxyXG4gICAgICAgICAgICAgICAge25hbWU6J01pa2UnLCBwaG9uZTonNTU1LTQzMjEnLCBhZ2U6MjF9LFxyXG4gICAgICAgICAgICAgICAge25hbWU6J0FkYW0nLCBwaG9uZTonNTU1LTU2NzgnLCBhZ2U6MzV9LFxyXG4gICAgICAgICAgICAgICAge25hbWU6J0p1bGllJywgcGhvbmU6JzU1NS04NzY1JywgYWdlOjI5fV1cclxuICAgICAgICAgICAkc2NvcGUucHJlZGljYXRlID0gJy1hZ2UnO1xyXG4gICAgICAgICB9XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICAgPHByZT5Tb3J0aW5nIHByZWRpY2F0ZSA9IHt7cHJlZGljYXRlfX07IHJldmVyc2UgPSB7e3JldmVyc2V9fTwvcHJlPlxyXG4gICAgICAgICA8aHIvPlxyXG4gICAgICAgICBbIDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cInByZWRpY2F0ZT0nJ1wiPnVuc29ydGVkPC9hPiBdXHJcbiAgICAgICAgIDx0YWJsZSBjbGFzcz1cImZyaWVuZFwiPlxyXG4gICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgIDx0aD48YSBocmVmPVwiXCIgbmctY2xpY2s9XCJwcmVkaWNhdGUgPSAnbmFtZSc7IHJldmVyc2U9ZmFsc2VcIj5OYW1lPC9hPlxyXG4gICAgICAgICAgICAgICAgICg8YSBocmVmIG5nLWNsaWNrPVwicHJlZGljYXRlID0gJy1uYW1lJzsgcmV2ZXJzZT1mYWxzZVwiPl48L2E+KTwvdGg+XHJcbiAgICAgICAgICAgICA8dGg+PGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwicHJlZGljYXRlID0gJ3Bob25lJzsgcmV2ZXJzZT0hcmV2ZXJzZVwiPlBob25lIE51bWJlcjwvYT48L3RoPlxyXG4gICAgICAgICAgICAgPHRoPjxhIGhyZWY9XCJcIiBuZy1jbGljaz1cInByZWRpY2F0ZSA9ICdhZ2UnOyByZXZlcnNlPSFyZXZlcnNlXCI+QWdlPC9hPjwvdGg+XHJcbiAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICA8dHIgbmctcmVwZWF0PVwiZnJpZW5kIGluIGZyaWVuZHMgfCBvcmRlckJ5OnByZWRpY2F0ZTpyZXZlcnNlXCI+XHJcbiAgICAgICAgICAgICA8dGQ+e3tmcmllbmQubmFtZX19PC90ZD5cclxuICAgICAgICAgICAgIDx0ZD57e2ZyaWVuZC5waG9uZX19PC90ZD5cclxuICAgICAgICAgICAgIDx0ZD57e2ZyaWVuZC5hZ2V9fTwvdGQ+XHJcbiAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgPC90YWJsZT5cclxuICAgICAgIDwvZGl2PlxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBiZSByZXZlcnNlIG9yZGVyZWQgYnkgYWdlZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygncHJlZGljYXRlJykpLnRvQmUoJy1hZ2UnKTtcclxuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCd0YWJsZS5mcmllbmQnLCAnZnJpZW5kIGluIGZyaWVuZHMnKS5jb2x1bW4oJ2ZyaWVuZC5hZ2UnKSkuXHJcbiAgICAgICAgICAgdG9FcXVhbChbJzM1JywgJzI5JywgJzIxJywgJzE5JywgJzEwJ10pO1xyXG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJ3RhYmxlLmZyaWVuZCcsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLm5hbWUnKSkuXHJcbiAgICAgICAgICAgdG9FcXVhbChbJ0FkYW0nLCAnSnVsaWUnLCAnTWlrZScsICdNYXJ5JywgJ0pvaG4nXSk7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgICBpdCgnc2hvdWxkIHJlb3JkZXIgdGhlIHRhYmxlIHdoZW4gdXNlciBzZWxlY3RzIGRpZmZlcmVudCBwcmVkaWNhdGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgYTpjb250YWlucyhcIk5hbWVcIiknKS5jbGljaygpO1xyXG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJ3RhYmxlLmZyaWVuZCcsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLm5hbWUnKSkuXHJcbiAgICAgICAgICAgdG9FcXVhbChbJ0FkYW0nLCAnSm9obicsICdKdWxpZScsICdNYXJ5JywgJ01pa2UnXSk7XHJcbiAgICAgICAgIGV4cGVjdChyZXBlYXRlcigndGFibGUuZnJpZW5kJywgJ2ZyaWVuZCBpbiBmcmllbmRzJykuY29sdW1uKCdmcmllbmQuYWdlJykpLlxyXG4gICAgICAgICAgIHRvRXF1YWwoWyczNScsICcxMCcsICcyOScsICcxOScsICcyMSddKTtcclxuXHJcbiAgICAgICAgIGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIGE6Y29udGFpbnMoXCJQaG9uZVwiKScpLmNsaWNrKCk7XHJcbiAgICAgICAgIGV4cGVjdChyZXBlYXRlcigndGFibGUuZnJpZW5kJywgJ2ZyaWVuZCBpbiBmcmllbmRzJykuY29sdW1uKCdmcmllbmQucGhvbmUnKSkuXHJcbiAgICAgICAgICAgdG9FcXVhbChbJzU1NS05ODc2JywgJzU1NS04NzY1JywgJzU1NS01Njc4JywgJzU1NS00MzIxJywgJzU1NS0xMjEyJ10pO1xyXG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJ3RhYmxlLmZyaWVuZCcsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLm5hbWUnKSkuXHJcbiAgICAgICAgICAgdG9FcXVhbChbJ01hcnknLCAnSnVsaWUnLCAnQWRhbScsICdNaWtlJywgJ0pvaG4nXSk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbm9yZGVyQnlGaWx0ZXIuJGluamVjdCA9IFsnJHBhcnNlJ107XHJcbmZ1bmN0aW9uIG9yZGVyQnlGaWx0ZXIoJHBhcnNlKXtcclxuICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHNvcnRQcmVkaWNhdGUsIHJldmVyc2VPcmRlcikge1xyXG4gICAgaWYgKCFpc0FycmF5KGFycmF5KSkgcmV0dXJuIGFycmF5O1xyXG4gICAgaWYgKCFzb3J0UHJlZGljYXRlKSByZXR1cm4gYXJyYXk7XHJcbiAgICBzb3J0UHJlZGljYXRlID0gaXNBcnJheShzb3J0UHJlZGljYXRlKSA/IHNvcnRQcmVkaWNhdGU6IFtzb3J0UHJlZGljYXRlXTtcclxuICAgIHNvcnRQcmVkaWNhdGUgPSBtYXAoc29ydFByZWRpY2F0ZSwgZnVuY3Rpb24ocHJlZGljYXRlKXtcclxuICAgICAgdmFyIGRlc2NlbmRpbmcgPSBmYWxzZSwgZ2V0ID0gcHJlZGljYXRlIHx8IGlkZW50aXR5O1xyXG4gICAgICBpZiAoaXNTdHJpbmcocHJlZGljYXRlKSkge1xyXG4gICAgICAgIGlmICgocHJlZGljYXRlLmNoYXJBdCgwKSA9PSAnKycgfHwgcHJlZGljYXRlLmNoYXJBdCgwKSA9PSAnLScpKSB7XHJcbiAgICAgICAgICBkZXNjZW5kaW5nID0gcHJlZGljYXRlLmNoYXJBdCgwKSA9PSAnLSc7XHJcbiAgICAgICAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgPSAkcGFyc2UocHJlZGljYXRlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmV2ZXJzZUNvbXBhcmF0b3IoZnVuY3Rpb24oYSxiKXtcclxuICAgICAgICByZXR1cm4gY29tcGFyZShnZXQoYSksZ2V0KGIpKTtcclxuICAgICAgfSwgZGVzY2VuZGluZyk7XHJcbiAgICB9KTtcclxuICAgIHZhciBhcnJheUNvcHkgPSBbXTtcclxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7IGFycmF5Q29weS5wdXNoKGFycmF5W2ldKTsgfVxyXG4gICAgcmV0dXJuIGFycmF5Q29weS5zb3J0KHJldmVyc2VDb21wYXJhdG9yKGNvbXBhcmF0b3IsIHJldmVyc2VPcmRlcikpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmF0b3IobzEsIG8yKXtcclxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc29ydFByZWRpY2F0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjb21wID0gc29ydFByZWRpY2F0ZVtpXShvMSwgbzIpO1xyXG4gICAgICAgIGlmIChjb21wICE9PSAwKSByZXR1cm4gY29tcDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJldmVyc2VDb21wYXJhdG9yKGNvbXAsIGRlc2NlbmRpbmcpIHtcclxuICAgICAgcmV0dXJuIHRvQm9vbGVhbihkZXNjZW5kaW5nKVxyXG4gICAgICAgICAgPyBmdW5jdGlvbihhLGIpe3JldHVybiBjb21wKGIsYSk7fVxyXG4gICAgICAgICAgOiBjb21wO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcGFyZSh2MSwgdjIpe1xyXG4gICAgICB2YXIgdDEgPSB0eXBlb2YgdjE7XHJcbiAgICAgIHZhciB0MiA9IHR5cGVvZiB2MjtcclxuICAgICAgaWYgKHQxID09IHQyKSB7XHJcbiAgICAgICAgaWYgKHQxID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICB2MSA9IHYxLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgdjIgPSB2Mi50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodjEgPT09IHYyKSByZXR1cm4gMDtcclxuICAgICAgICByZXR1cm4gdjEgPCB2MiA/IC0xIDogMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdDEgPCB0MiA/IC0xIDogMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbmdEaXJlY3RpdmUoZGlyZWN0aXZlKSB7XHJcbiAgaWYgKGlzRnVuY3Rpb24oZGlyZWN0aXZlKSkge1xyXG4gICAgZGlyZWN0aXZlID0ge1xyXG4gICAgICBsaW5rOiBkaXJlY3RpdmVcclxuICAgIH1cclxuICB9XHJcbiAgZGlyZWN0aXZlLnJlc3RyaWN0ID0gZGlyZWN0aXZlLnJlc3RyaWN0IHx8ICdBQyc7XHJcbiAgcmV0dXJuIHZhbHVlRm4oZGlyZWN0aXZlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOmFcclxuICogQHJlc3RyaWN0IEVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIE1vZGlmaWVzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGh0bWwgQSB0YWcsIHNvIHRoYXQgdGhlIGRlZmF1bHQgYWN0aW9uIGlzIHByZXZlbnRlZCB3aGVuIGhyZWZcclxuICogYXR0cmlidXRlIGlzIGVtcHR5LlxyXG4gKlxyXG4gKiBUaGUgcmVhc29uaW5nIGZvciB0aGlzIGNoYW5nZSBpcyB0byBhbGxvdyBlYXN5IGNyZWF0aW9uIG9mIGFjdGlvbiBsaW5rcyB3aXRoIGBuZ0NsaWNrYCBkaXJlY3RpdmVcclxuICogd2l0aG91dCBjaGFuZ2luZyB0aGUgbG9jYXRpb24gb3IgY2F1c2luZyBwYWdlIHJlbG9hZHMsIGUuZy46XHJcbiAqIGA8YSBocmVmPVwiXCIgbmctY2xpY2s9XCJtb2RlbC4kc2F2ZSgpXCI+U2F2ZTwvYT5gXHJcbiAqL1xyXG52YXIgaHRtbEFuY2hvckRpcmVjdGl2ZSA9IHZhbHVlRm4oe1xyXG4gIHJlc3RyaWN0OiAnRScsXHJcbiAgY29tcGlsZTogZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xyXG5cclxuICAgIGlmIChtc2llIDw9IDgpIHtcclxuXHJcbiAgICAgIC8vIHR1cm4gPGEgaHJlZiBuZy1jbGljaz1cIi4uXCI+bGluazwvYT4gaW50byBhIHN0eWxhYmxlIGxpbmsgaW4gSUVcclxuICAgICAgLy8gYnV0IG9ubHkgaWYgaXQgZG9lc24ndCBoYXZlIG5hbWUgYXR0cmlidXRlLCBpbiB3aGljaCBjYXNlIGl0J3MgYW4gYW5jaG9yXHJcbiAgICAgIGlmICghYXR0ci5ocmVmICYmICFhdHRyLm5hbWUpIHtcclxuICAgICAgICBhdHRyLiRzZXQoJ2hyZWYnLCAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFkZCBhIGNvbW1lbnQgbm9kZSB0byBhbmNob3JzIHRvIHdvcmthcm91bmQgSUUgYnVnIHRoYXQgY2F1c2VzIGVsZW1lbnQgY29udGVudCB0byBiZSByZXNldFxyXG4gICAgICAvLyB0byBuZXcgYXR0cmlidXRlIGNvbnRlbnQgaWYgYXR0cmlidXRlIGlzIHVwZGF0ZWQgd2l0aCB2YWx1ZSBjb250YWluaW5nIEAgYW5kIGVsZW1lbnQgYWxzb1xyXG4gICAgICAvLyBjb250YWlucyB2YWx1ZSB3aXRoIEBcclxuICAgICAgLy8gc2VlIGlzc3VlICMxOTQ5XHJcbiAgICAgIGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ0lFIGZpeCcpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQpIHtcclxuICAgICAgZWxlbWVudC5vbignY2xpY2snLCBmdW5jdGlvbihldmVudCl7XHJcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBubyBocmVmIHVybCwgdGhlbiBkb24ndCBuYXZpZ2F0ZSBhbnl3aGVyZS5cclxuICAgICAgICBpZiAoIWVsZW1lbnQuYXR0cignaHJlZicpKSB7XHJcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0hyZWZcclxuICogQHJlc3RyaWN0IEFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFVzaW5nIEFuZ3VsYXIgbWFya3VwIGxpa2Uge3toYXNofX0gaW4gYW4gaHJlZiBhdHRyaWJ1dGUgbWFrZXNcclxuICogdGhlIHBhZ2Ugb3BlbiB0byBhIHdyb25nIFVSTCwgaWYgdGhlIHVzZXIgY2xpY2tzIHRoYXQgbGluayBiZWZvcmVcclxuICogYW5ndWxhciBoYXMgYSBjaGFuY2UgdG8gcmVwbGFjZSB0aGUge3toYXNofX0gd2l0aCBhY3R1YWwgVVJMLCB0aGVcclxuICogbGluayB3aWxsIGJlIGJyb2tlbiBhbmQgd2lsbCBtb3N0IGxpa2VseSByZXR1cm4gYSA0MDQgZXJyb3IuXHJcbiAqIFRoZSBgbmdIcmVmYCBkaXJlY3RpdmUgc29sdmVzIHRoaXMgcHJvYmxlbS5cclxuICpcclxuICogVGhlIGJ1Z2d5IHdheSB0byB3cml0ZSBpdDpcclxuICogPHByZT5cclxuICogPGEgaHJlZj1cImh0dHA6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci97e2hhc2h9fVwiLz5cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIFRoZSBjb3JyZWN0IHdheSB0byB3cml0ZSBpdDpcclxuICogPHByZT5cclxuICogPGEgbmctaHJlZj1cImh0dHA6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci97e2hhc2h9fVwiLz5cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIEBlbGVtZW50IEFcclxuICogQHBhcmFtIHt0ZW1wbGF0ZX0gbmdIcmVmIGFueSBzdHJpbmcgd2hpY2ggY2FuIGNvbnRhaW4gYHt7fX1gIG1hcmt1cC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogVGhpcyBleGFtcGxlIHVzZXMgYGxpbmtgIHZhcmlhYmxlIGluc2lkZSBgaHJlZmAgYXR0cmlidXRlOlxyXG4gICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICA8aW5wdXQgbmctbW9kZWw9XCJ2YWx1ZVwiIC8+PGJyIC8+XHJcbiAgICAgICAgPGEgaWQ9XCJsaW5rLTFcIiBocmVmIG5nLWNsaWNrPVwidmFsdWUgPSAxXCI+bGluayAxPC9hPiAobGluaywgZG9uJ3QgcmVsb2FkKTxiciAvPlxyXG4gICAgICAgIDxhIGlkPVwibGluay0yXCIgaHJlZj1cIlwiIG5nLWNsaWNrPVwidmFsdWUgPSAyXCI+bGluayAyPC9hPiAobGluaywgZG9uJ3QgcmVsb2FkKTxiciAvPlxyXG4gICAgICAgIDxhIGlkPVwibGluay0zXCIgbmctaHJlZj1cIi97eycxMjMnfX1cIj5saW5rIDM8L2E+IChsaW5rLCByZWxvYWQhKTxiciAvPlxyXG4gICAgICAgIDxhIGlkPVwibGluay00XCIgaHJlZj1cIlwiIG5hbWU9XCJ4eFwiIG5nLWNsaWNrPVwidmFsdWUgPSA0XCI+YW5jaG9yPC9hPiAobGluaywgZG9uJ3QgcmVsb2FkKTxiciAvPlxyXG4gICAgICAgIDxhIGlkPVwibGluay01XCIgbmFtZT1cInh4eFwiIG5nLWNsaWNrPVwidmFsdWUgPSA1XCI+YW5jaG9yPC9hPiAobm8gbGluayk8YnIgLz5cclxuICAgICAgICA8YSBpZD1cImxpbmstNlwiIG5nLWhyZWY9XCJ7e3ZhbHVlfX1cIj5saW5rPC9hPiAobGluaywgY2hhbmdlIGxvY2F0aW9uKVxyXG4gICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgaXQoJ3Nob3VsZCBleGVjdXRlIG5nLWNsaWNrIGJ1dCBub3QgcmVsb2FkIHdoZW4gaHJlZiB3aXRob3V0IHZhbHVlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBlbGVtZW50KCcjbGluay0xJykuY2xpY2soKTtcclxuICAgICAgICAgIGV4cGVjdChpbnB1dCgndmFsdWUnKS52YWwoKSkudG9FcXVhbCgnMScpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNsaW5rLTEnKS5hdHRyKCdocmVmJykpLnRvQmUoXCJcIik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBuZy1jbGljayBidXQgbm90IHJlbG9hZCB3aGVuIGhyZWYgZW1wdHkgc3RyaW5nJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBlbGVtZW50KCcjbGluay0yJykuY2xpY2soKTtcclxuICAgICAgICAgIGV4cGVjdChpbnB1dCgndmFsdWUnKS52YWwoKSkudG9FcXVhbCgnMicpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNsaW5rLTInKS5hdHRyKCdocmVmJykpLnRvQmUoXCJcIik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBuZy1jbGljayBhbmQgY2hhbmdlIHVybCB3aGVuIG5nLWhyZWYgc3BlY2lmaWVkJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2xpbmstMycpLmF0dHIoJ2hyZWYnKSkudG9CZShcIi8xMjNcIik7XHJcblxyXG4gICAgICAgICAgZWxlbWVudCgnI2xpbmstMycpLmNsaWNrKCk7XHJcbiAgICAgICAgICBleHBlY3QoYnJvd3NlcigpLndpbmRvdygpLnBhdGgoKSkudG9FcXVhbCgnLzEyMycpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGV4ZWN1dGUgbmctY2xpY2sgYnV0IG5vdCByZWxvYWQgd2hlbiBocmVmIGVtcHR5IHN0cmluZyBhbmQgbmFtZSBzcGVjaWZpZWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGVsZW1lbnQoJyNsaW5rLTQnKS5jbGljaygpO1xyXG4gICAgICAgICAgZXhwZWN0KGlucHV0KCd2YWx1ZScpLnZhbCgpKS50b0VxdWFsKCc0Jyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2xpbmstNCcpLmF0dHIoJ2hyZWYnKSkudG9CZSgnJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBuZy1jbGljayBidXQgbm90IHJlbG9hZCB3aGVuIG5vIGhyZWYgYnV0IG5hbWUgc3BlY2lmaWVkJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBlbGVtZW50KCcjbGluay01JykuY2xpY2soKTtcclxuICAgICAgICAgIGV4cGVjdChpbnB1dCgndmFsdWUnKS52YWwoKSkudG9FcXVhbCgnNScpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNsaW5rLTUnKS5hdHRyKCdocmVmJykpLnRvQmUodW5kZWZpbmVkKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBvbmx5IGNoYW5nZSB1cmwgd2hlbiBvbmx5IG5nLWhyZWYnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlucHV0KCd2YWx1ZScpLmVudGVyKCc2Jyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2xpbmstNicpLmF0dHIoJ2hyZWYnKSkudG9CZSgnNicpO1xyXG5cclxuICAgICAgICAgIGVsZW1lbnQoJyNsaW5rLTYnKS5jbGljaygpO1xyXG4gICAgICAgICAgZXhwZWN0KGJyb3dzZXIoKS5sb2NhdGlvbigpLnVybCgpKS50b0VxdWFsKCcvNicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nU3JjXHJcbiAqIEByZXN0cmljdCBBXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBVc2luZyBBbmd1bGFyIG1hcmt1cCBsaWtlIGB7e2hhc2h9fWAgaW4gYSBgc3JjYCBhdHRyaWJ1dGUgZG9lc24ndFxyXG4gKiB3b3JrIHJpZ2h0OiBUaGUgYnJvd3NlciB3aWxsIGZldGNoIGZyb20gdGhlIFVSTCB3aXRoIHRoZSBsaXRlcmFsXHJcbiAqIHRleHQgYHt7aGFzaH19YCB1bnRpbCBBbmd1bGFyIHJlcGxhY2VzIHRoZSBleHByZXNzaW9uIGluc2lkZVxyXG4gKiBge3toYXNofX1gLiBUaGUgYG5nU3JjYCBkaXJlY3RpdmUgc29sdmVzIHRoaXMgcHJvYmxlbS5cclxuICpcclxuICogVGhlIGJ1Z2d5IHdheSB0byB3cml0ZSBpdDpcclxuICogPHByZT5cclxuICogPGltZyBzcmM9XCJodHRwOi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIve3toYXNofX1cIi8+XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBUaGUgY29ycmVjdCB3YXkgdG8gd3JpdGUgaXQ6XHJcbiAqIDxwcmU+XHJcbiAqIDxpbWcgbmctc3JjPVwiaHR0cDovL3d3dy5ncmF2YXRhci5jb20vYXZhdGFyL3t7aGFzaH19XCIvPlxyXG4gKiA8L3ByZT5cclxuICpcclxuICogQGVsZW1lbnQgSU1HXHJcbiAqIEBwYXJhbSB7dGVtcGxhdGV9IG5nU3JjIGFueSBzdHJpbmcgd2hpY2ggY2FuIGNvbnRhaW4gYHt7fX1gIG1hcmt1cC5cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdTcmNzZXRcclxuICogQHJlc3RyaWN0IEFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFVzaW5nIEFuZ3VsYXIgbWFya3VwIGxpa2UgYHt7aGFzaH19YCBpbiBhIGBzcmNzZXRgIGF0dHJpYnV0ZSBkb2Vzbid0XHJcbiAqIHdvcmsgcmlnaHQ6IFRoZSBicm93c2VyIHdpbGwgZmV0Y2ggZnJvbSB0aGUgVVJMIHdpdGggdGhlIGxpdGVyYWxcclxuICogdGV4dCBge3toYXNofX1gIHVudGlsIEFuZ3VsYXIgcmVwbGFjZXMgdGhlIGV4cHJlc3Npb24gaW5zaWRlXHJcbiAqIGB7e2hhc2h9fWAuIFRoZSBgbmdTcmNzZXRgIGRpcmVjdGl2ZSBzb2x2ZXMgdGhpcyBwcm9ibGVtLlxyXG4gKlxyXG4gKiBUaGUgYnVnZ3kgd2F5IHRvIHdyaXRlIGl0OlxyXG4gKiA8cHJlPlxyXG4gKiA8aW1nIHNyY3NldD1cImh0dHA6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci97e2hhc2h9fSAyeFwiLz5cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIFRoZSBjb3JyZWN0IHdheSB0byB3cml0ZSBpdDpcclxuICogPHByZT5cclxuICogPGltZyBuZy1zcmNzZXQ9XCJodHRwOi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIve3toYXNofX0gMnhcIi8+XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBAZWxlbWVudCBJTUdcclxuICogQHBhcmFtIHt0ZW1wbGF0ZX0gbmdTcmNzZXQgYW55IHN0cmluZyB3aGljaCBjYW4gY29udGFpbiBge3t9fWAgbWFya3VwLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0Rpc2FibGVkXHJcbiAqIEByZXN0cmljdCBBXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBUaGUgZm9sbG93aW5nIG1hcmt1cCB3aWxsIG1ha2UgdGhlIGJ1dHRvbiBlbmFibGVkIG9uIENocm9tZS9GaXJlZm94IGJ1dCBub3Qgb24gSUU4IGFuZCBvbGRlciBJRXM6XHJcbiAqIDxwcmU+XHJcbiAqIDxkaXYgbmctaW5pdD1cInNjb3BlID0geyBpc0Rpc2FibGVkOiBmYWxzZSB9XCI+XHJcbiAqICA8YnV0dG9uIGRpc2FibGVkPVwie3tzY29wZS5pc0Rpc2FibGVkfX1cIj5EaXNhYmxlZDwvYnV0dG9uPlxyXG4gKiA8L2Rpdj5cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIFRoZSBIVE1MIHNwZWNzIGRvIG5vdCByZXF1aXJlIGJyb3dzZXJzIHRvIHByZXNlcnZlIHRoZSBzcGVjaWFsIGF0dHJpYnV0ZXMgc3VjaCBhcyBkaXNhYmxlZC5cclxuICogKFRoZSBwcmVzZW5jZSBvZiB0aGVtIG1lYW5zIHRydWUgYW5kIGFic2VuY2UgbWVhbnMgZmFsc2UpXHJcbiAqIFRoaXMgcHJldmVudHMgdGhlIGFuZ3VsYXIgY29tcGlsZXIgZnJvbSBjb3JyZWN0bHkgcmV0cmlldmluZyB0aGUgYmluZGluZyBleHByZXNzaW9uLlxyXG4gKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIHdlIGludHJvZHVjZSB0aGUgYG5nRGlzYWJsZWRgIGRpcmVjdGl2ZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgQ2xpY2sgbWUgdG8gdG9nZ2xlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJjaGVja2VkXCI+PGJyLz5cclxuICAgICAgICA8YnV0dG9uIG5nLW1vZGVsPVwiYnV0dG9uXCIgbmctZGlzYWJsZWQ9XCJjaGVja2VkXCI+QnV0dG9uPC9idXR0b24+XHJcbiAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICBpdCgnc2hvdWxkIHRvZ2dsZSBidXR0b24nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSA6YnV0dG9uJykucHJvcCgnZGlzYWJsZWQnKSkudG9CZUZhbHN5KCk7XHJcbiAgICAgICAgICBpbnB1dCgnY2hlY2tlZCcpLmNoZWNrKCk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgOmJ1dHRvbicpLnByb3AoJ2Rpc2FibGVkJykpLnRvQmVUcnV0aHkoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICA8L2RvYzpleGFtcGxlPlxyXG4gKlxyXG4gKiBAZWxlbWVudCBJTlBVVFxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nRGlzYWJsZWQgQW5ndWxhciBleHByZXNzaW9uIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQuXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0NoZWNrZWRcclxuICogQHJlc3RyaWN0IEFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBIVE1MIHNwZWNzIGRvIG5vdCByZXF1aXJlIGJyb3dzZXJzIHRvIHByZXNlcnZlIHRoZSBzcGVjaWFsIGF0dHJpYnV0ZXMgc3VjaCBhcyBjaGVja2VkLlxyXG4gKiAoVGhlIHByZXNlbmNlIG9mIHRoZW0gbWVhbnMgdHJ1ZSBhbmQgYWJzZW5jZSBtZWFucyBmYWxzZSlcclxuICogVGhpcyBwcmV2ZW50cyB0aGUgYW5ndWxhciBjb21waWxlciBmcm9tIGNvcnJlY3RseSByZXRyaWV2aW5nIHRoZSBiaW5kaW5nIGV4cHJlc3Npb24uXHJcbiAqIFRvIHNvbHZlIHRoaXMgcHJvYmxlbSwgd2UgaW50cm9kdWNlIHRoZSBgbmdDaGVja2VkYCBkaXJlY3RpdmUuXHJcbiAqIEBleGFtcGxlXHJcbiAgICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgIENoZWNrIG1lIHRvIGNoZWNrIGJvdGg6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cIm1hc3RlclwiPjxici8+XHJcbiAgICAgICAgPGlucHV0IGlkPVwiY2hlY2tTbGF2ZVwiIHR5cGU9XCJjaGVja2JveFwiIG5nLWNoZWNrZWQ9XCJtYXN0ZXJcIj5cclxuICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgIGl0KCdzaG91bGQgY2hlY2sgYm90aCBjaGVja0JveGVzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI2NoZWNrU2xhdmUnKS5wcm9wKCdjaGVja2VkJykpLnRvQmVGYWxzeSgpO1xyXG4gICAgICAgICAgaW5wdXQoJ21hc3RlcicpLmNoZWNrKCk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI2NoZWNrU2xhdmUnKS5wcm9wKCdjaGVja2VkJykpLnRvQmVUcnV0aHkoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICA8L2RvYzpleGFtcGxlPlxyXG4gKlxyXG4gKiBAZWxlbWVudCBJTlBVVFxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQ2hlY2tlZCBBbmd1bGFyIGV4cHJlc3Npb24gdGhhdCB3aWxsIGJlIGV2YWx1YXRlZC5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nUmVhZG9ubHlcclxuICogQHJlc3RyaWN0IEFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBIVE1MIHNwZWNzIGRvIG5vdCByZXF1aXJlIGJyb3dzZXJzIHRvIHByZXNlcnZlIHRoZSBzcGVjaWFsIGF0dHJpYnV0ZXMgc3VjaCBhcyByZWFkb25seS5cclxuICogKFRoZSBwcmVzZW5jZSBvZiB0aGVtIG1lYW5zIHRydWUgYW5kIGFic2VuY2UgbWVhbnMgZmFsc2UpXHJcbiAqIFRoaXMgcHJldmVudHMgdGhlIGFuZ3VsYXIgY29tcGlsZXIgZnJvbSBjb3JyZWN0bHkgcmV0cmlldmluZyB0aGUgYmluZGluZyBleHByZXNzaW9uLlxyXG4gKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIHdlIGludHJvZHVjZSB0aGUgYG5nUmVhZG9ubHlgIGRpcmVjdGl2ZS5cclxuICogQGV4YW1wbGVcclxuICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgQ2hlY2sgbWUgdG8gbWFrZSB0ZXh0IHJlYWRvbmx5OiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJjaGVja2VkXCI+PGJyLz5cclxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1yZWFkb25seT1cImNoZWNrZWRcIiB2YWx1ZT1cIkknbSBBbmd1bGFyXCIvPlxyXG4gICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgaXQoJ3Nob3VsZCB0b2dnbGUgcmVhZG9ubHkgYXR0cicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIDp0ZXh0JykucHJvcCgncmVhZG9ubHknKSkudG9CZUZhbHN5KCk7XHJcbiAgICAgICAgICBpbnB1dCgnY2hlY2tlZCcpLmNoZWNrKCk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgOnRleHQnKS5wcm9wKCdyZWFkb25seScpKS50b0JlVHJ1dGh5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICAgPC9kb2M6ZXhhbXBsZT5cclxuICpcclxuICogQGVsZW1lbnQgSU5QVVRcclxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gQW5ndWxhciBleHByZXNzaW9uIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQuXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ1NlbGVjdGVkXHJcbiAqIEByZXN0cmljdCBBXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgSFRNTCBzcGVjcyBkbyBub3QgcmVxdWlyZSBicm93c2VycyB0byBwcmVzZXJ2ZSB0aGUgc3BlY2lhbCBhdHRyaWJ1dGVzIHN1Y2ggYXMgc2VsZWN0ZWQuXHJcbiAqIChUaGUgcHJlc2VuY2Ugb2YgdGhlbSBtZWFucyB0cnVlIGFuZCBhYnNlbmNlIG1lYW5zIGZhbHNlKVxyXG4gKiBUaGlzIHByZXZlbnRzIHRoZSBhbmd1bGFyIGNvbXBpbGVyIGZyb20gY29ycmVjdGx5IHJldHJpZXZpbmcgdGhlIGJpbmRpbmcgZXhwcmVzc2lvbi5cclxuICogVG8gc29sdmUgdGhpcyBwcm9ibGVtLCB3ZSBpbnRyb2R1Y2VkIHRoZSBgbmdTZWxlY3RlZGAgZGlyZWN0aXZlLlxyXG4gKiBAZXhhbXBsZVxyXG4gICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICBDaGVjayBtZSB0byBzZWxlY3Q6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cInNlbGVjdGVkXCI+PGJyLz5cclxuICAgICAgICA8c2VsZWN0PlxyXG4gICAgICAgICAgPG9wdGlvbj5IZWxsbyE8L29wdGlvbj5cclxuICAgICAgICAgIDxvcHRpb24gaWQ9XCJncmVldFwiIG5nLXNlbGVjdGVkPVwic2VsZWN0ZWRcIj5HcmVldGluZ3MhPC9vcHRpb24+XHJcbiAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICBpdCgnc2hvdWxkIHNlbGVjdCBHcmVldGluZ3MhJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI2dyZWV0JykucHJvcCgnc2VsZWN0ZWQnKSkudG9CZUZhbHN5KCk7XHJcbiAgICAgICAgICBpbnB1dCgnc2VsZWN0ZWQnKS5jaGVjaygpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlICNncmVldCcpLnByb3AoJ3NlbGVjdGVkJykpLnRvQmVUcnV0aHkoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICA8L2RvYzpleGFtcGxlPlxyXG4gKlxyXG4gKiBAZWxlbWVudCBPUFRJT05cclxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gQW5ndWxhciBleHByZXNzaW9uIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nT3BlblxyXG4gKiBAcmVzdHJpY3QgQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIEhUTUwgc3BlY3MgZG8gbm90IHJlcXVpcmUgYnJvd3NlcnMgdG8gcHJlc2VydmUgdGhlIHNwZWNpYWwgYXR0cmlidXRlcyBzdWNoIGFzIG9wZW4uXHJcbiAqIChUaGUgcHJlc2VuY2Ugb2YgdGhlbSBtZWFucyB0cnVlIGFuZCBhYnNlbmNlIG1lYW5zIGZhbHNlKVxyXG4gKiBUaGlzIHByZXZlbnRzIHRoZSBhbmd1bGFyIGNvbXBpbGVyIGZyb20gY29ycmVjdGx5IHJldHJpZXZpbmcgdGhlIGJpbmRpbmcgZXhwcmVzc2lvbi5cclxuICogVG8gc29sdmUgdGhpcyBwcm9ibGVtLCB3ZSBpbnRyb2R1Y2UgdGhlIGBuZ09wZW5gIGRpcmVjdGl2ZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICAgQ2hlY2sgbWUgY2hlY2sgbXVsdGlwbGU6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cIm9wZW5cIj48YnIvPlxyXG4gICAgICAgICA8ZGV0YWlscyBpZD1cImRldGFpbHNcIiBuZy1vcGVuPVwib3BlblwiPlxyXG4gICAgICAgICAgICA8c3VtbWFyeT5TaG93L0hpZGUgbWU8L3N1bW1hcnk+XHJcbiAgICAgICAgIDwvZGV0YWlscz5cclxuICAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgIGl0KCdzaG91bGQgdG9nZ2xlIG9wZW4nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2RldGFpbHMnKS5wcm9wKCdvcGVuJykpLnRvQmVGYWxzeSgpO1xyXG4gICAgICAgICAgIGlucHV0KCdvcGVuJykuY2hlY2soKTtcclxuICAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2RldGFpbHMnKS5wcm9wKCdvcGVuJykpLnRvQmVUcnV0aHkoKTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgICA8L2RvYzpleGFtcGxlPlxyXG4gKlxyXG4gKiBAZWxlbWVudCBERVRBSUxTXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIEFuZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHdpbGwgYmUgZXZhbHVhdGVkLlxyXG4gKi9cclxuXHJcbnZhciBuZ0F0dHJpYnV0ZUFsaWFzRGlyZWN0aXZlcyA9IHt9O1xyXG5cclxuXHJcbi8vIGJvb2xlYW4gYXR0cnMgYXJlIGV2YWx1YXRlZFxyXG5mb3JFYWNoKEJPT0xFQU5fQVRUUiwgZnVuY3Rpb24ocHJvcE5hbWUsIGF0dHJOYW1lKSB7XHJcbiAgLy8gYmluZGluZyB0byBtdWx0aXBsZSBpcyBub3Qgc3VwcG9ydGVkXHJcbiAgaWYgKHByb3BOYW1lID09IFwibXVsdGlwbGVcIikgcmV0dXJuO1xyXG5cclxuICB2YXIgbm9ybWFsaXplZCA9IGRpcmVjdGl2ZU5vcm1hbGl6ZSgnbmctJyArIGF0dHJOYW1lKTtcclxuICBuZ0F0dHJpYnV0ZUFsaWFzRGlyZWN0aXZlc1tub3JtYWxpemVkXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcHJpb3JpdHk6IDEwMCxcclxuICAgICAgY29tcGlsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcbiAgICAgICAgICBzY29wZS4kd2F0Y2goYXR0cltub3JtYWxpemVkXSwgZnVuY3Rpb24gbmdCb29sZWFuQXR0cldhdGNoQWN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGF0dHIuJHNldChhdHRyTmFtZSwgISF2YWx1ZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcbn0pO1xyXG5cclxuXHJcbi8vIG5nLXNyYywgbmctc3Jjc2V0LCBuZy1ocmVmIGFyZSBpbnRlcnBvbGF0ZWRcclxuZm9yRWFjaChbJ3NyYycsICdzcmNzZXQnLCAnaHJlZiddLCBmdW5jdGlvbihhdHRyTmFtZSkge1xyXG4gIHZhciBub3JtYWxpemVkID0gZGlyZWN0aXZlTm9ybWFsaXplKCduZy0nICsgYXR0ck5hbWUpO1xyXG4gIG5nQXR0cmlidXRlQWxpYXNEaXJlY3RpdmVzW25vcm1hbGl6ZWRdID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwcmlvcml0eTogOTksIC8vIGl0IG5lZWRzIHRvIHJ1biBhZnRlciB0aGUgYXR0cmlidXRlcyBhcmUgaW50ZXJwb2xhdGVkXHJcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcbiAgICAgICAgYXR0ci4kb2JzZXJ2ZShub3JtYWxpemVkLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgaWYgKCF2YWx1ZSlcclxuICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICBhdHRyLiRzZXQoYXR0ck5hbWUsIHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAvLyBvbiBJRSwgaWYgXCJuZzpzcmNcIiBkaXJlY3RpdmUgZGVjbGFyYXRpb24gaXMgdXNlZCBhbmQgXCJzcmNcIiBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgLy8gdGhlbiBjYWxsaW5nIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCAnZm9vJykgZG9lc24ndCBkbyBhbnl0aGluZywgc28gd2UgbmVlZFxyXG4gICAgICAgICAgLy8gdG8gc2V0IHRoZSBwcm9wZXJ0eSBhcyB3ZWxsIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxyXG4gICAgICAgICAgLy8gd2UgdXNlIGF0dHJbYXR0ck5hbWVdIHZhbHVlIHNpbmNlICRzZXQgY2FuIHNhbml0aXplIHRoZSB1cmwuXHJcbiAgICAgICAgICBpZiAobXNpZSkgZWxlbWVudC5wcm9wKGF0dHJOYW1lLCBhdHRyW2F0dHJOYW1lXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfTtcclxufSk7XHJcblxyXG52YXIgbnVsbEZvcm1DdHJsID0ge1xyXG4gICRhZGRDb250cm9sOiBub29wLFxyXG4gICRyZW1vdmVDb250cm9sOiBub29wLFxyXG4gICRzZXRWYWxpZGl0eTogbm9vcCxcclxuICAkc2V0RGlydHk6IG5vb3AsXHJcbiAgJHNldFByaXN0aW5lOiBub29wXHJcbn07XHJcblxyXG4vKipcclxuICogQG5nZG9jIG9iamVjdFxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlclxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICRwcmlzdGluZSBUcnVlIGlmIHVzZXIgaGFzIG5vdCBpbnRlcmFjdGVkIHdpdGggdGhlIGZvcm0geWV0LlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICRkaXJ0eSBUcnVlIGlmIHVzZXIgaGFzIGFscmVhZHkgaW50ZXJhY3RlZCB3aXRoIHRoZSBmb3JtLlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICR2YWxpZCBUcnVlIGlmIGFsbCBvZiB0aGUgY29udGFpbmluZyBmb3JtcyBhbmQgY29udHJvbHMgYXJlIHZhbGlkLlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICRpbnZhbGlkIFRydWUgaWYgYXQgbGVhc3Qgb25lIGNvbnRhaW5pbmcgY29udHJvbCBvciBmb3JtIGlzIGludmFsaWQuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkZXJyb3IgSXMgYW4gb2JqZWN0IGhhc2gsIGNvbnRhaW5pbmcgcmVmZXJlbmNlcyB0byBhbGwgaW52YWxpZCBjb250cm9scyBvclxyXG4gKiAgZm9ybXMsIHdoZXJlOlxyXG4gKlxyXG4gKiAgLSBrZXlzIGFyZSB2YWxpZGF0aW9uIHRva2VucyAoZXJyb3IgbmFtZXMpIMOi4oKs4oCdIHN1Y2ggYXMgYHJlcXVpcmVkYCwgYHVybGAgb3IgYGVtYWlsYCksXHJcbiAqICAtIHZhbHVlcyBhcmUgYXJyYXlzIG9mIGNvbnRyb2xzIG9yIGZvcm1zIHRoYXQgYXJlIGludmFsaWQgd2l0aCBnaXZlbiBlcnJvci5cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIGBGb3JtQ29udHJvbGxlcmAga2VlcHMgdHJhY2sgb2YgYWxsIGl0cyBjb250cm9scyBhbmQgbmVzdGVkIGZvcm1zIGFzIHdlbGwgYXMgc3RhdGUgb2YgdGhlbSxcclxuICogc3VjaCBhcyBiZWluZyB2YWxpZC9pbnZhbGlkIG9yIGRpcnR5L3ByaXN0aW5lLlxyXG4gKlxyXG4gKiBFYWNoIHtAbGluayBuZy5kaXJlY3RpdmU6Zm9ybSBmb3JtfSBkaXJlY3RpdmUgY3JlYXRlcyBhbiBpbnN0YW5jZVxyXG4gKiBvZiBgRm9ybUNvbnRyb2xsZXJgLlxyXG4gKlxyXG4gKi9cclxuLy9hc2tzIGZvciAkc2NvcGUgdG8gZm9vbCB0aGUgQkMgY29udHJvbGxlciBtb2R1bGVcclxuRm9ybUNvbnRyb2xsZXIuJGluamVjdCA9IFsnJGVsZW1lbnQnLCAnJGF0dHJzJywgJyRzY29wZSddO1xyXG5mdW5jdGlvbiBGb3JtQ29udHJvbGxlcihlbGVtZW50LCBhdHRycykge1xyXG4gIHZhciBmb3JtID0gdGhpcyxcclxuICAgICAgcGFyZW50Rm9ybSA9IGVsZW1lbnQucGFyZW50KCkuY29udHJvbGxlcignZm9ybScpIHx8IG51bGxGb3JtQ3RybCxcclxuICAgICAgaW52YWxpZENvdW50ID0gMCwgLy8gdXNlZCB0byBlYXNpbHkgZGV0ZXJtaW5lIGlmIHdlIGFyZSB2YWxpZFxyXG4gICAgICBlcnJvcnMgPSBmb3JtLiRlcnJvciA9IHt9LFxyXG4gICAgICBjb250cm9scyA9IFtdO1xyXG5cclxuICAvLyBpbml0IHN0YXRlXHJcbiAgZm9ybS4kbmFtZSA9IGF0dHJzLm5hbWUgfHwgYXR0cnMubmdGb3JtO1xyXG4gIGZvcm0uJGRpcnR5ID0gZmFsc2U7XHJcbiAgZm9ybS4kcHJpc3RpbmUgPSB0cnVlO1xyXG4gIGZvcm0uJHZhbGlkID0gdHJ1ZTtcclxuICBmb3JtLiRpbnZhbGlkID0gZmFsc2U7XHJcblxyXG4gIHBhcmVudEZvcm0uJGFkZENvbnRyb2woZm9ybSk7XHJcblxyXG4gIC8vIFNldHVwIGluaXRpYWwgc3RhdGUgb2YgdGhlIGNvbnRyb2xcclxuICBlbGVtZW50LmFkZENsYXNzKFBSSVNUSU5FX0NMQVNTKTtcclxuICB0b2dnbGVWYWxpZENzcyh0cnVlKTtcclxuXHJcbiAgLy8gY29udmVuaWVuY2UgbWV0aG9kIGZvciBlYXN5IHRvZ2dsaW5nIG9mIGNsYXNzZXNcclxuICBmdW5jdGlvbiB0b2dnbGVWYWxpZENzcyhpc1ZhbGlkLCB2YWxpZGF0aW9uRXJyb3JLZXkpIHtcclxuICAgIHZhbGlkYXRpb25FcnJvcktleSA9IHZhbGlkYXRpb25FcnJvcktleSA/ICctJyArIHNuYWtlX2Nhc2UodmFsaWRhdGlvbkVycm9yS2V5LCAnLScpIDogJyc7XHJcbiAgICBlbGVtZW50LlxyXG4gICAgICByZW1vdmVDbGFzcygoaXNWYWxpZCA/IElOVkFMSURfQ0xBU1MgOiBWQUxJRF9DTEFTUykgKyB2YWxpZGF0aW9uRXJyb3JLZXkpLlxyXG4gICAgICBhZGRDbGFzcygoaXNWYWxpZCA/IFZBTElEX0NMQVNTIDogSU5WQUxJRF9DTEFTUykgKyB2YWxpZGF0aW9uRXJyb3JLZXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGZ1bmN0aW9uXHJcbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOmZvcm0uRm9ybUNvbnRyb2xsZXIjJGFkZENvbnRyb2xcclxuICAgKiBAbWV0aG9kT2YgbmcuZGlyZWN0aXZlOmZvcm0uRm9ybUNvbnRyb2xsZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFJlZ2lzdGVyIGEgY29udHJvbCB3aXRoIHRoZSBmb3JtLlxyXG4gICAqXHJcbiAgICogSW5wdXQgZWxlbWVudHMgdXNpbmcgbmdNb2RlbENvbnRyb2xsZXIgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IHdoZW4gdGhleSBhcmUgbGlua2VkLlxyXG4gICAqL1xyXG4gIGZvcm0uJGFkZENvbnRyb2wgPSBmdW5jdGlvbihjb250cm9sKSB7XHJcbiAgICBjb250cm9scy5wdXNoKGNvbnRyb2wpO1xyXG5cclxuICAgIGlmIChjb250cm9sLiRuYW1lICYmICFmb3JtLmhhc093blByb3BlcnR5KGNvbnRyb2wuJG5hbWUpKSB7XHJcbiAgICAgIGZvcm1bY29udHJvbC4kbmFtZV0gPSBjb250cm9sO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyIyRyZW1vdmVDb250cm9sXHJcbiAgICogQG1ldGhvZE9mIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBEZXJlZ2lzdGVyIGEgY29udHJvbCBmcm9tIHRoZSBmb3JtLlxyXG4gICAqXHJcbiAgICogSW5wdXQgZWxlbWVudHMgdXNpbmcgbmdNb2RlbENvbnRyb2xsZXIgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IHdoZW4gdGhleSBhcmUgZGVzdHJveWVkLlxyXG4gICAqL1xyXG4gIGZvcm0uJHJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbihjb250cm9sKSB7XHJcbiAgICBpZiAoY29udHJvbC4kbmFtZSAmJiBmb3JtW2NvbnRyb2wuJG5hbWVdID09PSBjb250cm9sKSB7XHJcbiAgICAgIGRlbGV0ZSBmb3JtW2NvbnRyb2wuJG5hbWVdO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaChlcnJvcnMsIGZ1bmN0aW9uKHF1ZXVlLCB2YWxpZGF0aW9uVG9rZW4pIHtcclxuICAgICAgZm9ybS4kc2V0VmFsaWRpdHkodmFsaWRhdGlvblRva2VuLCB0cnVlLCBjb250cm9sKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFycmF5UmVtb3ZlKGNvbnRyb2xzLCBjb250cm9sKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlciMkc2V0VmFsaWRpdHlcclxuICAgKiBAbWV0aG9kT2YgbmcuZGlyZWN0aXZlOmZvcm0uRm9ybUNvbnRyb2xsZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFNldHMgdGhlIHZhbGlkaXR5IG9mIGEgZm9ybSBjb250cm9sLlxyXG4gICAqXHJcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBhbHNvIHByb3BhZ2F0ZSB0byBwYXJlbnQgZm9ybXMuXHJcbiAgICovXHJcbiAgZm9ybS4kc2V0VmFsaWRpdHkgPSBmdW5jdGlvbih2YWxpZGF0aW9uVG9rZW4sIGlzVmFsaWQsIGNvbnRyb2wpIHtcclxuICAgIHZhciBxdWV1ZSA9IGVycm9yc1t2YWxpZGF0aW9uVG9rZW5dO1xyXG5cclxuICAgIGlmIChpc1ZhbGlkKSB7XHJcbiAgICAgIGlmIChxdWV1ZSkge1xyXG4gICAgICAgIGFycmF5UmVtb3ZlKHF1ZXVlLCBjb250cm9sKTtcclxuICAgICAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgaW52YWxpZENvdW50LS07XHJcbiAgICAgICAgICBpZiAoIWludmFsaWRDb3VudCkge1xyXG4gICAgICAgICAgICB0b2dnbGVWYWxpZENzcyhpc1ZhbGlkKTtcclxuICAgICAgICAgICAgZm9ybS4kdmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3JtLiRpbnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlcnJvcnNbdmFsaWRhdGlvblRva2VuXSA9IGZhbHNlO1xyXG4gICAgICAgICAgdG9nZ2xlVmFsaWRDc3ModHJ1ZSwgdmFsaWRhdGlvblRva2VuKTtcclxuICAgICAgICAgIHBhcmVudEZvcm0uJHNldFZhbGlkaXR5KHZhbGlkYXRpb25Ub2tlbiwgdHJ1ZSwgZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCFpbnZhbGlkQ291bnQpIHtcclxuICAgICAgICB0b2dnbGVWYWxpZENzcyhpc1ZhbGlkKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocXVldWUpIHtcclxuICAgICAgICBpZiAoaW5jbHVkZXMocXVldWUsIGNvbnRyb2wpKSByZXR1cm47XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZXJyb3JzW3ZhbGlkYXRpb25Ub2tlbl0gPSBxdWV1ZSA9IFtdO1xyXG4gICAgICAgIGludmFsaWRDb3VudCsrO1xyXG4gICAgICAgIHRvZ2dsZVZhbGlkQ3NzKGZhbHNlLCB2YWxpZGF0aW9uVG9rZW4pO1xyXG4gICAgICAgIHBhcmVudEZvcm0uJHNldFZhbGlkaXR5KHZhbGlkYXRpb25Ub2tlbiwgZmFsc2UsIGZvcm0pO1xyXG4gICAgICB9XHJcbiAgICAgIHF1ZXVlLnB1c2goY29udHJvbCk7XHJcblxyXG4gICAgICBmb3JtLiR2YWxpZCA9IGZhbHNlO1xyXG4gICAgICBmb3JtLiRpbnZhbGlkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlciMkc2V0RGlydHlcclxuICAgKiBAbWV0aG9kT2YgbmcuZGlyZWN0aXZlOmZvcm0uRm9ybUNvbnRyb2xsZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFNldHMgdGhlIGZvcm0gdG8gYSBkaXJ0eSBzdGF0ZS5cclxuICAgKlxyXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gYWRkIHRoZSAnbmctZGlydHknIGNsYXNzIGFuZCBzZXQgdGhlIGZvcm0gdG8gYSBkaXJ0eVxyXG4gICAqIHN0YXRlIChuZy1kaXJ0eSBjbGFzcykuIFRoaXMgbWV0aG9kIHdpbGwgYWxzbyBwcm9wYWdhdGUgdG8gcGFyZW50IGZvcm1zLlxyXG4gICAqL1xyXG4gIGZvcm0uJHNldERpcnR5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKFBSSVNUSU5FX0NMQVNTKS5hZGRDbGFzcyhESVJUWV9DTEFTUyk7XHJcbiAgICBmb3JtLiRkaXJ0eSA9IHRydWU7XHJcbiAgICBmb3JtLiRwcmlzdGluZSA9IGZhbHNlO1xyXG4gICAgcGFyZW50Rm9ybS4kc2V0RGlydHkoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlciMkc2V0UHJpc3RpbmVcclxuICAgKiBAbWV0aG9kT2YgbmcuZGlyZWN0aXZlOmZvcm0uRm9ybUNvbnRyb2xsZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIFNldHMgdGhlIGZvcm0gdG8gaXRzIHByaXN0aW5lIHN0YXRlLlxyXG4gICAqXHJcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByZW1vdmUgdGhlICduZy1kaXJ0eScgY2xhc3MgYW5kIHNldCB0aGUgZm9ybSB0byBpdHMgcHJpc3RpbmVcclxuICAgKiBzdGF0ZSAobmctcHJpc3RpbmUgY2xhc3MpLiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gcHJvcGFnYXRlIHRvIGFsbCB0aGUgY29udHJvbHMgY29udGFpbmVkXHJcbiAgICogaW4gdGhpcyBmb3JtLlxyXG4gICAqXHJcbiAgICogU2V0dGluZyBhIGZvcm0gYmFjayB0byBhIHByaXN0aW5lIHN0YXRlIGlzIG9mdGVuIHVzZWZ1bCB3aGVuIHdlIHdhbnQgdG8gJ3JldXNlJyBhIGZvcm0gYWZ0ZXJcclxuICAgKiBzYXZpbmcgb3IgcmVzZXR0aW5nIGl0LlxyXG4gICAqL1xyXG4gIGZvcm0uJHNldFByaXN0aW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgZWxlbWVudC5yZW1vdmVDbGFzcyhESVJUWV9DTEFTUykuYWRkQ2xhc3MoUFJJU1RJTkVfQ0xBU1MpO1xyXG4gICAgZm9ybS4kZGlydHkgPSBmYWxzZTtcclxuICAgIGZvcm0uJHByaXN0aW5lID0gdHJ1ZTtcclxuICAgIGZvckVhY2goY29udHJvbHMsIGZ1bmN0aW9uKGNvbnRyb2wpIHtcclxuICAgICAgY29udHJvbC4kc2V0UHJpc3RpbmUoKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdGb3JtXHJcbiAqIEByZXN0cmljdCBFQUNcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIE5lc3RhYmxlIGFsaWFzIG9mIHtAbGluayBuZy5kaXJlY3RpdmU6Zm9ybSBgZm9ybWB9IGRpcmVjdGl2ZS4gSFRNTFxyXG4gKiBkb2VzIG5vdCBhbGxvdyBuZXN0aW5nIG9mIGZvcm0gZWxlbWVudHMuIEl0IGlzIHVzZWZ1bCB0byBuZXN0IGZvcm1zLCBmb3IgZXhhbXBsZSBpZiB0aGUgdmFsaWRpdHkgb2YgYVxyXG4gKiBzdWItZ3JvdXAgb2YgY29udHJvbHMgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lfG5nRm9ybSBOYW1lIG9mIHRoZSBmb3JtLiBJZiBzcGVjaWZpZWQsIHRoZSBmb3JtIGNvbnRyb2xsZXIgd2lsbCBiZSBwdWJsaXNoZWQgaW50b1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZCBzY29wZSwgdW5kZXIgdGhpcyBuYW1lLlxyXG4gKlxyXG4gKi9cclxuXHJcbiAvKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6Zm9ybVxyXG4gKiBAcmVzdHJpY3QgRVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRGlyZWN0aXZlIHRoYXQgaW5zdGFudGlhdGVzXHJcbiAqIHtAbGluayBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlciBGb3JtQ29udHJvbGxlcn0uXHJcbiAqXHJcbiAqIElmIGBuYW1lYCBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkLCB0aGUgZm9ybSBjb250cm9sbGVyIGlzIHB1Ymxpc2hlZCBvbnRvIHRoZSBjdXJyZW50IHNjb3BlIHVuZGVyXHJcbiAqIHRoaXMgbmFtZS5cclxuICpcclxuICogIyBBbGlhczoge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0Zvcm0gYG5nRm9ybWB9XHJcbiAqXHJcbiAqIEluIGFuZ3VsYXIgZm9ybXMgY2FuIGJlIG5lc3RlZC4gVGhpcyBtZWFucyB0aGF0IHRoZSBvdXRlciBmb3JtIGlzIHZhbGlkIHdoZW4gYWxsIG9mIHRoZSBjaGlsZFxyXG4gKiBmb3JtcyBhcmUgdmFsaWQgYXMgd2VsbC4gSG93ZXZlciBicm93c2VycyBkbyBub3QgYWxsb3cgbmVzdGluZyBvZiBgPGZvcm0+YCBlbGVtZW50cywgZm9yIHRoaXNcclxuICogcmVhc29uIGFuZ3VsYXIgcHJvdmlkZXMge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0Zvcm0gYG5nRm9ybWB9IGFsaWFzXHJcbiAqIHdoaWNoIGJlaGF2ZXMgaWRlbnRpY2FsIHRvIGA8Zm9ybT5gIGJ1dCBhbGxvd3MgZm9ybSBuZXN0aW5nLlxyXG4gKlxyXG4gKlxyXG4gKiAjIENTUyBjbGFzc2VzXHJcbiAqICAtIGBuZy12YWxpZGAgSXMgc2V0IGlmIHRoZSBmb3JtIGlzIHZhbGlkLlxyXG4gKiAgLSBgbmctaW52YWxpZGAgSXMgc2V0IGlmIHRoZSBmb3JtIGlzIGludmFsaWQuXHJcbiAqICAtIGBuZy1wcmlzdGluZWAgSXMgc2V0IGlmIHRoZSBmb3JtIGlzIHByaXN0aW5lLlxyXG4gKiAgLSBgbmctZGlydHlgIElzIHNldCBpZiB0aGUgZm9ybSBpcyBkaXJ0eS5cclxuICpcclxuICpcclxuICogIyBTdWJtaXR0aW5nIGEgZm9ybSBhbmQgcHJldmVudGluZyBkZWZhdWx0IGFjdGlvblxyXG4gKlxyXG4gKiBTaW5jZSB0aGUgcm9sZSBvZiBmb3JtcyBpbiBjbGllbnQtc2lkZSBBbmd1bGFyIGFwcGxpY2F0aW9ucyBpcyBkaWZmZXJlbnQgdGhhbiBpbiBjbGFzc2ljYWxcclxuICogcm91bmR0cmlwIGFwcHMsIGl0IGlzIGRlc2lyYWJsZSBmb3IgdGhlIGJyb3dzZXIgbm90IHRvIHRyYW5zbGF0ZSB0aGUgZm9ybSBzdWJtaXNzaW9uIGludG8gYSBmdWxsXHJcbiAqIHBhZ2UgcmVsb2FkIHRoYXQgc2VuZHMgdGhlIGRhdGEgdG8gdGhlIHNlcnZlci4gSW5zdGVhZCBzb21lIGphdmFzY3JpcHQgbG9naWMgc2hvdWxkIGJlIHRyaWdnZXJlZFxyXG4gKiB0byBoYW5kbGUgdGhlIGZvcm0gc3VibWlzc2lvbiBpbiBhcHBsaWNhdGlvbiBzcGVjaWZpYyB3YXkuXHJcbiAqXHJcbiAqIEZvciB0aGlzIHJlYXNvbiwgQW5ndWxhciBwcmV2ZW50cyB0aGUgZGVmYXVsdCBhY3Rpb24gKGZvcm0gc3VibWlzc2lvbiB0byB0aGUgc2VydmVyKSB1bmxlc3MgdGhlXHJcbiAqIGA8Zm9ybT5gIGVsZW1lbnQgaGFzIGFuIGBhY3Rpb25gIGF0dHJpYnV0ZSBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqIFlvdSBjYW4gdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHR3byB3YXlzIHRvIHNwZWNpZnkgd2hhdCBqYXZhc2NyaXB0IG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHdoZW5cclxuICogYSBmb3JtIGlzIHN1Ym1pdHRlZDpcclxuICpcclxuICogLSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nU3VibWl0IG5nU3VibWl0fSBkaXJlY3RpdmUgb24gdGhlIGZvcm0gZWxlbWVudFxyXG4gKiAtIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfSBkaXJlY3RpdmUgb24gdGhlIGZpcnN0XHJcbiAgKiAgYnV0dG9uIG9yIGlucHV0IGZpZWxkIG9mIHR5cGUgc3VibWl0IChpbnB1dFt0eXBlPXN1Ym1pdF0pXHJcbiAqXHJcbiAqIFRvIHByZXZlbnQgZG91YmxlIGV4ZWN1dGlvbiBvZiB0aGUgaGFuZGxlciwgdXNlIG9ubHkgb25lIG9mIG5nU3VibWl0IG9yIG5nQ2xpY2sgZGlyZWN0aXZlcy4gVGhpc1xyXG4gKiBpcyBiZWNhdXNlIG9mIHRoZSBmb2xsb3dpbmcgZm9ybSBzdWJtaXNzaW9uIHJ1bGVzIGNvbWluZyBmcm9tIHRoZSBodG1sIHNwZWM6XHJcbiAqXHJcbiAqIC0gSWYgYSBmb3JtIGhhcyBvbmx5IG9uZSBpbnB1dCBmaWVsZCB0aGVuIGhpdHRpbmcgZW50ZXIgaW4gdGhpcyBmaWVsZCB0cmlnZ2VycyBmb3JtIHN1Ym1pdFxyXG4gKiAoYG5nU3VibWl0YClcclxuICogLSBpZiBhIGZvcm0gaGFzIGhhcyAyKyBpbnB1dCBmaWVsZHMgYW5kIG5vIGJ1dHRvbnMgb3IgaW5wdXRbdHlwZT1zdWJtaXRdIHRoZW4gaGl0dGluZyBlbnRlclxyXG4gKiBkb2Vzbid0IHRyaWdnZXIgc3VibWl0XHJcbiAqIC0gaWYgYSBmb3JtIGhhcyBvbmUgb3IgbW9yZSBpbnB1dCBmaWVsZHMgYW5kIG9uZSBvciBtb3JlIGJ1dHRvbnMgb3IgaW5wdXRbdHlwZT1zdWJtaXRdIHRoZW5cclxuICogaGl0dGluZyBlbnRlciBpbiBhbnkgb2YgdGhlIGlucHV0IGZpZWxkcyB3aWxsIHRyaWdnZXIgdGhlIGNsaWNrIGhhbmRsZXIgb24gdGhlICpmaXJzdCogYnV0dG9uIG9yXHJcbiAqIGlucHV0W3R5cGU9c3VibWl0XSAoYG5nQ2xpY2tgKSAqYW5kKiBhIHN1Ym1pdCBoYW5kbGVyIG9uIHRoZSBlbmNsb3NpbmcgZm9ybSAoYG5nU3VibWl0YClcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIE5hbWUgb2YgdGhlIGZvcm0uIElmIHNwZWNpZmllZCwgdGhlIGZvcm0gY29udHJvbGxlciB3aWxsIGJlIHB1Ymxpc2hlZCBpbnRvXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkIHNjb3BlLCB1bmRlciB0aGlzIG5hbWUuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAkc2NvcGUudXNlclR5cGUgPSAnZ3Vlc3QnO1xyXG4gICAgICAgICB9XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICB1c2VyVHlwZTogPGlucHV0IG5hbWU9XCJpbnB1dFwiIG5nLW1vZGVsPVwidXNlclR5cGVcIiByZXF1aXJlZD5cclxuICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLnJlcXVpcmVkXCI+UmVxdWlyZWQhPC9zcGFuPjxicj5cclxuICAgICAgICAgPHR0PnVzZXJUeXBlID0ge3t1c2VyVHlwZX19PC90dD48YnI+XHJcbiAgICAgICAgIDx0dD5teUZvcm0uaW5wdXQuJHZhbGlkID0ge3tteUZvcm0uaW5wdXQuJHZhbGlkfX08L3R0Pjxicj5cclxuICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kZXJyb3IgPSB7e215Rm9ybS5pbnB1dC4kZXJyb3J9fTwvdHQ+PGJyPlxyXG4gICAgICAgICA8dHQ+bXlGb3JtLiR2YWxpZCA9IHt7bXlGb3JtLiR2YWxpZH19PC90dD48YnI+XHJcbiAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLnJlcXVpcmVkID0ge3shIW15Rm9ybS4kZXJyb3IucmVxdWlyZWR9fTwvdHQ+PGJyPlxyXG4gICAgICAgIDwvZm9ybT5cclxuICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB0byBtb2RlbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygndXNlclR5cGUnKSkudG9FcXVhbCgnZ3Vlc3QnKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgZW1wdHknLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgaW5wdXQoJ3VzZXJUeXBlJykuZW50ZXIoJycpO1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygndXNlclR5cGUnKSkudG9FcXVhbCgnJyk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcbnZhciBmb3JtRGlyZWN0aXZlRmFjdG9yeSA9IGZ1bmN0aW9uKGlzTmdGb3JtKSB7XHJcbiAgcmV0dXJuIFsnJHRpbWVvdXQnLCBmdW5jdGlvbigkdGltZW91dCkge1xyXG4gICAgdmFyIGZvcm1EaXJlY3RpdmUgPSB7XHJcbiAgICAgIG5hbWU6ICdmb3JtJyxcclxuICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgY29udHJvbGxlcjogRm9ybUNvbnRyb2xsZXIsXHJcbiAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBwcmU6IGZ1bmN0aW9uKHNjb3BlLCBmb3JtRWxlbWVudCwgYXR0ciwgY29udHJvbGxlcikge1xyXG4gICAgICAgICAgICBpZiAoIWF0dHIuYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgdXNlIGpxIGV2ZW50cyBiZWNhdXNlIGlmIGEgZm9ybSBpcyBkZXN0cm95ZWQgZHVyaW5nIHN1Ym1pc3Npb24gdGhlIGRlZmF1bHRcclxuICAgICAgICAgICAgICAvLyBhY3Rpb24gaXMgbm90IHByZXZlbnRlZC4gc2VlICMxMjM4XHJcbiAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAvLyBJRSA5IGlzIG5vdCBhZmZlY3RlZCBiZWNhdXNlIGl0IGRvZXNuJ3QgZmlyZSBhIHN1Ym1pdCBldmVudCBhbmQgdHJ5IHRvIGRvIGEgZnVsbFxyXG4gICAgICAgICAgICAgIC8vIHBhZ2UgcmVsb2FkIGlmIHRoZSBmb3JtIHdhcyBkZXN0cm95ZWQgYnkgc3VibWlzc2lvbiBvZiB0aGUgZm9ybSB2aWEgYSBjbGljayBoYW5kbGVyXHJcbiAgICAgICAgICAgICAgLy8gb24gYSBidXR0b24gaW4gdGhlIGZvcm0uIExvb2tzIGxpa2UgYW4gSUU5IHNwZWNpZmljIGJ1Zy5cclxuICAgICAgICAgICAgICB2YXIgcHJldmVudERlZmF1bHRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICA/IGV2ZW50LnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICAgICAgICAgICAgOiBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlOyAvLyBJRVxyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXJGbihmb3JtRWxlbWVudFswXSwgJ3N1Ym1pdCcsIHByZXZlbnREZWZhdWx0TGlzdGVuZXIpO1xyXG5cclxuICAgICAgICAgICAgICAvLyB1bnJlZ2lzdGVyIHRoZSBwcmV2ZW50RGVmYXVsdCBsaXN0ZW5lciBzbyB0aGF0IHdlIGRvbid0IG5vdCBsZWFrIG1lbW9yeSBidXQgaW4gYVxyXG4gICAgICAgICAgICAgIC8vIHdheSB0aGF0IHdpbGwgYWNoaWV2ZSB0aGUgcHJldmVudGlvbiBvZiB0aGUgZGVmYXVsdCBhY3Rpb24uXHJcbiAgICAgICAgICAgICAgZm9ybUVsZW1lbnQub24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lckZuKGZvcm1FbGVtZW50WzBdLCAnc3VibWl0JywgcHJldmVudERlZmF1bHRMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICB9LCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRGb3JtQ3RybCA9IGZvcm1FbGVtZW50LnBhcmVudCgpLmNvbnRyb2xsZXIoJ2Zvcm0nKSxcclxuICAgICAgICAgICAgICAgIGFsaWFzID0gYXR0ci5uYW1lIHx8IGF0dHIubmdGb3JtO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFsaWFzKSB7XHJcbiAgICAgICAgICAgICAgc2V0dGVyKHNjb3BlLCBhbGlhcywgY29udHJvbGxlciwgYWxpYXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRGb3JtQ3RybCkge1xyXG4gICAgICAgICAgICAgIGZvcm1FbGVtZW50Lm9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Rm9ybUN0cmwuJHJlbW92ZUNvbnRyb2woY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxpYXMpIHtcclxuICAgICAgICAgICAgICAgICAgc2V0dGVyKHNjb3BlLCBhbGlhcywgdW5kZWZpbmVkLCBhbGlhcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHRlbmQoY29udHJvbGxlciwgbnVsbEZvcm1DdHJsKTsgLy9zdG9wIHByb3BhZ2F0aW5nIGNoaWxkIGRlc3RydWN0aW9uIGhhbmRsZXJzIHVwd2FyZHNcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGlzTmdGb3JtID8gZXh0ZW5kKGNvcHkoZm9ybURpcmVjdGl2ZSksIHtyZXN0cmljdDogJ0VBQyd9KSA6IGZvcm1EaXJlY3RpdmU7XHJcbiAgfV07XHJcbn07XHJcblxyXG52YXIgZm9ybURpcmVjdGl2ZSA9IGZvcm1EaXJlY3RpdmVGYWN0b3J5KCk7XHJcbnZhciBuZ0Zvcm1EaXJlY3RpdmUgPSBmb3JtRGlyZWN0aXZlRmFjdG9yeSh0cnVlKTtcclxuXHJcbnZhciBVUkxfUkVHRVhQID0gL14oZnRwfGh0dHB8aHR0cHMpOlxcL1xcLyhcXHcrOnswLDF9XFx3KkApPyhcXFMrKSg6WzAtOV0rKT8oXFwvfFxcLyhbXFx3IyE6Lj8rPSYlQCFcXC1cXC9dKSk/JC87XHJcbnZhciBFTUFJTF9SRUdFWFAgPSAvXltBLVphLXowLTkuXyUrLV0rQFtBLVphLXowLTkuLV0rXFwuW0EtWmEtel17Miw2fSQvO1xyXG52YXIgTlVNQkVSX1JFR0VYUCA9IC9eXFxzKihcXC18XFwrKT8oXFxkK3woXFxkKihcXC5cXGQqKSkpXFxzKiQvO1xyXG5cclxudmFyIGlucHV0VHlwZSA9IHtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5nZG9jIGlucHV0VHlwZVxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTppbnB1dC50ZXh0XHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBTdGFuZGFyZCBIVE1MIHRleHQgaW5wdXQgd2l0aCBhbmd1bGFyIGRhdGEgYmluZGluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZ01vZGVsIEFzc2lnbmFibGUgYW5ndWxhciBleHByZXNzaW9uIHRvIGRhdGEtYmluZCB0by5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgUHJvcGVydHkgbmFtZSBvZiB0aGUgZm9ybSB1bmRlciB3aGljaCB0aGUgY29udHJvbCBpcyBwdWJsaXNoZWQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSByZXF1aXJlZCBBZGRzIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIG5vdCBlbnRlcmVkLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdSZXF1aXJlZCBBZGRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGFuZCBgcmVxdWlyZWRgIHZhbGlkYXRpb24gY29uc3RyYWludCB0b1xyXG4gICAqICAgIHRoZSBlbGVtZW50IHdoZW4gdGhlIG5nUmVxdWlyZWQgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gVXNlIGBuZ1JlcXVpcmVkYCBpbnN0ZWFkIG9mXHJcbiAgICogICAgYHJlcXVpcmVkYCB3aGVuIHlvdSB3YW50IHRvIGRhdGEtYmluZCB0byB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBuZ01pbmxlbmd0aCBTZXRzIGBtaW5sZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBzaG9ydGVyIHRoYW5cclxuICAgKiAgICBtaW5sZW5ndGguXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBuZ01heGxlbmd0aCBTZXRzIGBtYXhsZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBsb25nZXIgdGhhblxyXG4gICAqICAgIG1heGxlbmd0aC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nUGF0dGVybiBTZXRzIGBwYXR0ZXJuYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlXHJcbiAgICogICAgUmVnRXhwIHBhdHRlcm4gZXhwcmVzc2lvbi4gRXhwZWN0ZWQgdmFsdWUgaXMgYC9yZWdleHAvYCBmb3IgaW5saW5lIHBhdHRlcm5zIG9yIGByZWdleHBgIGZvclxyXG4gICAqICAgIHBhdHRlcm5zIGRlZmluZWQgYXMgc2NvcGUgZXhwcmVzc2lvbnMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ0NoYW5nZSBBbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBpbnB1dCBjaGFuZ2VzIGR1ZSB0byB1c2VyXHJcbiAgICogICAgaW50ZXJhY3Rpb24gd2l0aCB0aGUgaW5wdXQgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbbmdUcmltPXRydWVdIElmIHNldCB0byBmYWxzZSBBbmd1bGFyIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgdHJpbW1pbmcgdGhlXHJcbiAgICogICAgaW5wdXQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAgICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAgICRzY29wZS50ZXh0ID0gJ2d1ZXN0JztcclxuICAgICAgICAgICAgICRzY29wZS53b3JkID0gL15cXHMqXFx3KlxccyokLztcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCIgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICAgICBTaW5nbGUgd29yZDogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImlucHV0XCIgbmctbW9kZWw9XCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nLXBhdHRlcm49XCJ3b3JkXCIgcmVxdWlyZWQgbmctdHJpbT1cImZhbHNlXCI+XHJcbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLnJlcXVpcmVkXCI+XHJcbiAgICAgICAgICAgICBSZXF1aXJlZCE8L3NwYW4+XHJcbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLnBhdHRlcm5cIj5cclxuICAgICAgICAgICAgIFNpbmdsZSB3b3JkIG9ubHkhPC9zcGFuPlxyXG5cclxuICAgICAgICAgICA8dHQ+dGV4dCA9IHt7dGV4dH19PC90dD48YnIvPlxyXG4gICAgICAgICAgIDx0dD5teUZvcm0uaW5wdXQuJHZhbGlkID0ge3tteUZvcm0uaW5wdXQuJHZhbGlkfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kZXJyb3IgPSB7e215Rm9ybS5pbnB1dC4kZXJyb3J9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICA8dHQ+bXlGb3JtLiR2YWxpZCA9IHt7bXlGb3JtLiR2YWxpZH19PC90dD48YnIvPlxyXG4gICAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLnJlcXVpcmVkID0ge3shIW15Rm9ybS4kZXJyb3IucmVxdWlyZWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB0byBtb2RlbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndGV4dCcpKS50b0VxdWFsKCdndWVzdCcpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgZW1wdHknLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaW5wdXQoJ3RleHQnKS5lbnRlcignJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd0ZXh0JykpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBiZSBpbnZhbGlkIGlmIG11bHRpIHdvcmQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaW5wdXQoJ3RleHQnKS5lbnRlcignaGVsbG8gd29ybGQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGl0KCdzaG91bGQgbm90IGJlIHRyaW1tZWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaW5wdXQoJ3RleHQnKS5lbnRlcigndW50cmltbWVkICcpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndGV4dCcpKS50b0VxdWFsKCd1bnRyaW1tZWQgJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ3RydWUnKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICAgICA8L2RvYzpleGFtcGxlPlxyXG4gICAqL1xyXG4gICd0ZXh0JzogdGV4dElucHV0VHlwZSxcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBpbnB1dFR5cGVcclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6aW5wdXQubnVtYmVyXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBUZXh0IGlucHV0IHdpdGggbnVtYmVyIHZhbGlkYXRpb24gYW5kIHRyYW5zZm9ybWF0aW9uLiBTZXRzIHRoZSBgbnVtYmVyYCB2YWxpZGF0aW9uXHJcbiAgICogZXJyb3IgaWYgbm90IGEgdmFsaWQgbnVtYmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5nTW9kZWwgQXNzaWduYWJsZSBhbmd1bGFyIGV4cHJlc3Npb24gdG8gZGF0YS1iaW5kIHRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBmb3JtIHVuZGVyIHdoaWNoIHRoZSBjb250cm9sIGlzIHB1Ymxpc2hlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG1pbiBTZXRzIHRoZSBgbWluYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgZW50ZXJlZCBpcyBsZXNzIHRoYW4gYG1pbmAuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBtYXggU2V0cyB0aGUgYG1heGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGVudGVyZWQgaXMgZ3JlYXRlciB0aGFuIGBtYXhgLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gcmVxdWlyZWQgU2V0cyBgcmVxdWlyZWRgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBub3QgZW50ZXJlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nUmVxdWlyZWQgQWRkcyBgcmVxdWlyZWRgIGF0dHJpYnV0ZSBhbmQgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGNvbnN0cmFpbnQgdG9cclxuICAgKiAgICB0aGUgZWxlbWVudCB3aGVuIHRoZSBuZ1JlcXVpcmVkIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRydWUuIFVzZSBgbmdSZXF1aXJlZGAgaW5zdGVhZCBvZlxyXG4gICAqICAgIGByZXF1aXJlZGAgd2hlbiB5b3Ugd2FudCB0byBkYXRhLWJpbmQgdG8gdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNaW5sZW5ndGggU2V0cyBgbWlubGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgc2hvcnRlciB0aGFuXHJcbiAgICogICAgbWlubGVuZ3RoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNYXhsZW5ndGggU2V0cyBgbWF4bGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbG9uZ2VyIHRoYW5cclxuICAgKiAgICBtYXhsZW5ndGguXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ1BhdHRlcm4gU2V0cyBgcGF0dGVybmAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZVxyXG4gICAqICAgIFJlZ0V4cCBwYXR0ZXJuIGV4cHJlc3Npb24uIEV4cGVjdGVkIHZhbHVlIGlzIGAvcmVnZXhwL2AgZm9yIGlubGluZSBwYXR0ZXJucyBvciBgcmVnZXhwYCBmb3JcclxuICAgKiAgICBwYXR0ZXJucyBkZWZpbmVkIGFzIHNjb3BlIGV4cHJlc3Npb25zLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdDaGFuZ2UgQW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaW5wdXQgY2hhbmdlcyBkdWUgdG8gdXNlclxyXG4gICAqICAgIGludGVyYWN0aW9uIHdpdGggdGhlIGlucHV0IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAgICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAgICRzY29wZS52YWx1ZSA9IDEyO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICAgIE51bWJlcjogPGlucHV0IHR5cGU9XCJudW1iZXJcIiBuYW1lPVwiaW5wdXRcIiBuZy1tb2RlbD1cInZhbHVlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaW49XCIwXCIgbWF4PVwiOTlcIiByZXF1aXJlZD5cclxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS5pbnB1dC4kZXJyb3IucmVxdWlyZWRcIj5cclxuICAgICAgICAgICAgIFJlcXVpcmVkITwvc3Bhbj5cclxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS5pbnB1dC4kZXJyb3IubnVtYmVyXCI+XHJcbiAgICAgICAgICAgICBOb3QgdmFsaWQgbnVtYmVyITwvc3Bhbj5cclxuICAgICAgICAgICA8dHQ+dmFsdWUgPSB7e3ZhbHVlfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kdmFsaWQgPSB7e215Rm9ybS5pbnB1dC4kdmFsaWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiRlcnJvciA9IHt7bXlGb3JtLmlucHV0LiRlcnJvcn19PC90dD48YnIvPlxyXG4gICAgICAgICAgIDx0dD5teUZvcm0uJHZhbGlkID0ge3tteUZvcm0uJHZhbGlkfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnIvPlxyXG4gICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHRvIG1vZGVsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ZhbHVlJykpLnRvRXF1YWwoJzEyJyk7XHJcbiAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBiZSBpbnZhbGlkIGlmIGVtcHR5JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgaW5wdXQoJ3ZhbHVlJykuZW50ZXIoJycpO1xyXG4gICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd2YWx1ZScpKS50b0VxdWFsKCcnKTtcclxuICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBiZSBpbnZhbGlkIGlmIG92ZXIgbWF4JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgaW5wdXQoJ3ZhbHVlJykuZW50ZXIoJzEyMycpO1xyXG4gICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd2YWx1ZScpKS50b0VxdWFsKCcnKTtcclxuICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAgICovXHJcbiAgJ251bWJlcic6IG51bWJlcklucHV0VHlwZSxcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBpbnB1dFR5cGVcclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6aW5wdXQudXJsXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBUZXh0IGlucHV0IHdpdGggVVJMIHZhbGlkYXRpb24uIFNldHMgdGhlIGB1cmxgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSBjb250ZW50IGlzIG5vdCBhXHJcbiAgICogdmFsaWQgVVJMLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5nTW9kZWwgQXNzaWduYWJsZSBhbmd1bGFyIGV4cHJlc3Npb24gdG8gZGF0YS1iaW5kIHRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBmb3JtIHVuZGVyIHdoaWNoIHRoZSBjb250cm9sIGlzIHB1Ymxpc2hlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHJlcXVpcmVkIFNldHMgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbm90IGVudGVyZWQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ1JlcXVpcmVkIEFkZHMgYHJlcXVpcmVkYCBhdHRyaWJ1dGUgYW5kIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBjb25zdHJhaW50IHRvXHJcbiAgICogICAgdGhlIGVsZW1lbnQgd2hlbiB0aGUgbmdSZXF1aXJlZCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlLiBVc2UgYG5nUmVxdWlyZWRgIGluc3RlYWQgb2ZcclxuICAgKiAgICBgcmVxdWlyZWRgIHdoZW4geW91IHdhbnQgdG8gZGF0YS1iaW5kIHRvIHRoZSBgcmVxdWlyZWRgIGF0dHJpYnV0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IG5nTWlubGVuZ3RoIFNldHMgYG1pbmxlbmd0aGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIHNob3J0ZXIgdGhhblxyXG4gICAqICAgIG1pbmxlbmd0aC5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IG5nTWF4bGVuZ3RoIFNldHMgYG1heGxlbmd0aGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIGxvbmdlciB0aGFuXHJcbiAgICogICAgbWF4bGVuZ3RoLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdQYXR0ZXJuIFNldHMgYHBhdHRlcm5gIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGVcclxuICAgKiAgICBSZWdFeHAgcGF0dGVybiBleHByZXNzaW9uLiBFeHBlY3RlZCB2YWx1ZSBpcyBgL3JlZ2V4cC9gIGZvciBpbmxpbmUgcGF0dGVybnMgb3IgYHJlZ2V4cGAgZm9yXHJcbiAgICogICAgcGF0dGVybnMgZGVmaW5lZCBhcyBzY29wZSBleHByZXNzaW9ucy5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nQ2hhbmdlIEFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZCB3aGVuIGlucHV0IGNoYW5nZXMgZHVlIHRvIHVzZXJcclxuICAgKiAgICBpbnRlcmFjdGlvbiB3aXRoIHRoZSBpbnB1dCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgICAgPGRvYzpleGFtcGxlPlxyXG4gICAgICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAgICAkc2NvcGUudGV4dCA9ICdodHRwOi8vZ29vZ2xlLmNvbSc7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICA8L3NjcmlwdD5cclxuICAgICAgICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiIG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgICAgVVJMOiA8aW5wdXQgdHlwZT1cInVybFwiIG5hbWU9XCJpbnB1dFwiIG5nLW1vZGVsPVwidGV4dFwiIHJlcXVpcmVkPlxyXG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmlucHV0LiRlcnJvci5yZXF1aXJlZFwiPlxyXG4gICAgICAgICAgICAgUmVxdWlyZWQhPC9zcGFuPlxyXG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmlucHV0LiRlcnJvci51cmxcIj5cclxuICAgICAgICAgICAgIE5vdCB2YWxpZCB1cmwhPC9zcGFuPlxyXG4gICAgICAgICAgIDx0dD50ZXh0ID0ge3t0ZXh0fX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kdmFsaWQgPSB7e215Rm9ybS5pbnB1dC4kdmFsaWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiRlcnJvciA9IHt7bXlGb3JtLmlucHV0LiRlcnJvcn19PC90dD48YnIvPlxyXG4gICAgICAgICAgIDx0dD5teUZvcm0uJHZhbGlkID0ge3tteUZvcm0uJHZhbGlkfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnIvPlxyXG4gICAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLnVybCA9IHt7ISFteUZvcm0uJGVycm9yLnVybH19PC90dD48YnIvPlxyXG4gICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHRvIG1vZGVsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd0ZXh0JykpLnRvRXF1YWwoJ2h0dHA6Ly9nb29nbGUuY29tJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ3RydWUnKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBlbXB0eScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpbnB1dCgndGV4dCcpLmVudGVyKCcnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3RleHQnKSkudG9FcXVhbCgnJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgbm90IHVybCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpbnB1dCgndGV4dCcpLmVudGVyKCd4eHgnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICAgICA8L2RvYzpleGFtcGxlPlxyXG4gICAqL1xyXG4gICd1cmwnOiB1cmxJbnB1dFR5cGUsXHJcblxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgaW5wdXRUeXBlXHJcbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOmlucHV0LmVtYWlsXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBUZXh0IGlucHV0IHdpdGggZW1haWwgdmFsaWRhdGlvbi4gU2V0cyB0aGUgYGVtYWlsYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiBub3QgYSB2YWxpZCBlbWFpbFxyXG4gICAqIGFkZHJlc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmdNb2RlbCBBc3NpZ25hYmxlIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBkYXRhLWJpbmQgdG8uXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFByb3BlcnR5IG5hbWUgb2YgdGhlIGZvcm0gdW5kZXIgd2hpY2ggdGhlIGNvbnRyb2wgaXMgcHVibGlzaGVkLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gcmVxdWlyZWQgU2V0cyBgcmVxdWlyZWRgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBub3QgZW50ZXJlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nUmVxdWlyZWQgQWRkcyBgcmVxdWlyZWRgIGF0dHJpYnV0ZSBhbmQgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGNvbnN0cmFpbnQgdG9cclxuICAgKiAgICB0aGUgZWxlbWVudCB3aGVuIHRoZSBuZ1JlcXVpcmVkIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRydWUuIFVzZSBgbmdSZXF1aXJlZGAgaW5zdGVhZCBvZlxyXG4gICAqICAgIGByZXF1aXJlZGAgd2hlbiB5b3Ugd2FudCB0byBkYXRhLWJpbmQgdG8gdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNaW5sZW5ndGggU2V0cyBgbWlubGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgc2hvcnRlciB0aGFuXHJcbiAgICogICAgbWlubGVuZ3RoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNYXhsZW5ndGggU2V0cyBgbWF4bGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbG9uZ2VyIHRoYW5cclxuICAgKiAgICBtYXhsZW5ndGguXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ1BhdHRlcm4gU2V0cyBgcGF0dGVybmAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZVxyXG4gICAqICAgIFJlZ0V4cCBwYXR0ZXJuIGV4cHJlc3Npb24uIEV4cGVjdGVkIHZhbHVlIGlzIGAvcmVnZXhwL2AgZm9yIGlubGluZSBwYXR0ZXJucyBvciBgcmVnZXhwYCBmb3JcclxuICAgKiAgICBwYXR0ZXJucyBkZWZpbmVkIGFzIHNjb3BlIGV4cHJlc3Npb25zLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdDaGFuZ2UgQW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaW5wdXQgY2hhbmdlcyBkdWUgdG8gdXNlclxyXG4gICAqICAgIGludGVyYWN0aW9uIHdpdGggdGhlIGlucHV0IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAgICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAgICRzY29wZS50ZXh0ID0gJ21lQGV4YW1wbGUuY29tJztcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICAgICAgRW1haWw6IDxpbnB1dCB0eXBlPVwiZW1haWxcIiBuYW1lPVwiaW5wdXRcIiBuZy1tb2RlbD1cInRleHRcIiByZXF1aXJlZD5cclxuICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmlucHV0LiRlcnJvci5yZXF1aXJlZFwiPlxyXG4gICAgICAgICAgICAgICBSZXF1aXJlZCE8L3NwYW4+XHJcbiAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS5pbnB1dC4kZXJyb3IuZW1haWxcIj5cclxuICAgICAgICAgICAgICAgTm90IHZhbGlkIGVtYWlsITwvc3Bhbj5cclxuICAgICAgICAgICAgIDx0dD50ZXh0ID0ge3t0ZXh0fX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiR2YWxpZCA9IHt7bXlGb3JtLmlucHV0LiR2YWxpZH19PC90dD48YnIvPlxyXG4gICAgICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kZXJyb3IgPSB7e215Rm9ybS5pbnB1dC4kZXJyb3J9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgICAgIDx0dD5teUZvcm0uJHZhbGlkID0ge3tteUZvcm0uJHZhbGlkfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgICA8dHQ+bXlGb3JtLiRlcnJvci5yZXF1aXJlZCA9IHt7ISFteUZvcm0uJGVycm9yLnJlcXVpcmVkfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgICA8dHQ+bXlGb3JtLiRlcnJvci5lbWFpbCA9IHt7ISFteUZvcm0uJGVycm9yLmVtYWlsfX08L3R0Pjxici8+XHJcbiAgICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHRvIG1vZGVsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd0ZXh0JykpLnRvRXF1YWwoJ21lQGV4YW1wbGUuY29tJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ3RydWUnKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBlbXB0eScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpbnB1dCgndGV4dCcpLmVudGVyKCcnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3RleHQnKSkudG9FcXVhbCgnJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgbm90IGVtYWlsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlucHV0KCd0ZXh0JykuZW50ZXIoJ3h4eCcpO1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAgICovXHJcbiAgJ2VtYWlsJzogZW1haWxJbnB1dFR5cGUsXHJcblxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgaW5wdXRUeXBlXHJcbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOmlucHV0LnJhZGlvXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBIVE1MIHJhZGlvIGJ1dHRvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZ01vZGVsIEFzc2lnbmFibGUgYW5ndWxhciBleHByZXNzaW9uIHRvIGRhdGEtYmluZCB0by5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHdoaWNoIHRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBzZXQgd2hlbiBzZWxlY3RlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgUHJvcGVydHkgbmFtZSBvZiB0aGUgZm9ybSB1bmRlciB3aGljaCB0aGUgY29udHJvbCBpcyBwdWJsaXNoZWQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ0NoYW5nZSBBbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBpbnB1dCBjaGFuZ2VzIGR1ZSB0byB1c2VyXHJcbiAgICogICAgaW50ZXJhY3Rpb24gd2l0aCB0aGUgaW5wdXQgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICAgJHNjb3BlLmNvbG9yID0gJ2JsdWUnO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuZy1tb2RlbD1cImNvbG9yXCIgdmFsdWU9XCJyZWRcIj4gIFJlZCA8YnIvPlxyXG4gICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuZy1tb2RlbD1cImNvbG9yXCIgdmFsdWU9XCJncmVlblwiPiBHcmVlbiA8YnIvPlxyXG4gICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuZy1tb2RlbD1cImNvbG9yXCIgdmFsdWU9XCJibHVlXCI+IEJsdWUgPGJyLz5cclxuICAgICAgICAgICA8dHQ+Y29sb3IgPSB7e2NvbG9yfX08L3R0Pjxici8+XHJcbiAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgICBpdCgnc2hvdWxkIGNoYW5nZSBzdGF0ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnY29sb3InKSkudG9FcXVhbCgnYmx1ZScpO1xyXG5cclxuICAgICAgICAgICAgaW5wdXQoJ2NvbG9yJykuc2VsZWN0KCdyZWQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2NvbG9yJykpLnRvRXF1YWwoJ3JlZCcpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAgICovXHJcbiAgJ3JhZGlvJzogcmFkaW9JbnB1dFR5cGUsXHJcblxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgaW5wdXRUeXBlXHJcbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOmlucHV0LmNoZWNrYm94XHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBIVE1MIGNoZWNrYm94LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5nTW9kZWwgQXNzaWduYWJsZSBhbmd1bGFyIGV4cHJlc3Npb24gdG8gZGF0YS1iaW5kIHRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBmb3JtIHVuZGVyIHdoaWNoIHRoZSBjb250cm9sIGlzIHB1Ymxpc2hlZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nVHJ1ZVZhbHVlIFRoZSB2YWx1ZSB0byB3aGljaCB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgc2V0IHdoZW4gc2VsZWN0ZWQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ0ZhbHNlVmFsdWUgVGhlIHZhbHVlIHRvIHdoaWNoIHRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBzZXQgd2hlbiBub3Qgc2VsZWN0ZWQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ0NoYW5nZSBBbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBpbnB1dCBjaGFuZ2VzIGR1ZSB0byB1c2VyXHJcbiAgICogICAgaW50ZXJhY3Rpb24gd2l0aCB0aGUgaW5wdXQgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICAgJHNjb3BlLnZhbHVlMSA9IHRydWU7XHJcbiAgICAgICAgICAgICAkc2NvcGUudmFsdWUyID0gJ1lFUydcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCIgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICAgICBWYWx1ZTE6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cInZhbHVlMVwiPiA8YnIvPlxyXG4gICAgICAgICAgIFZhbHVlMjogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwidmFsdWUyXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZy10cnVlLXZhbHVlPVwiWUVTXCIgbmctZmFsc2UtdmFsdWU9XCJOT1wiPiA8YnIvPlxyXG4gICAgICAgICAgIDx0dD52YWx1ZTEgPSB7e3ZhbHVlMX19PC90dD48YnIvPlxyXG4gICAgICAgICAgIDx0dD52YWx1ZTIgPSB7e3ZhbHVlMn19PC90dD48YnIvPlxyXG4gICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgICAgaXQoJ3Nob3VsZCBjaGFuZ2Ugc3RhdGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ZhbHVlMScpKS50b0VxdWFsKCd0cnVlJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd2YWx1ZTInKSkudG9FcXVhbCgnWUVTJyk7XHJcblxyXG4gICAgICAgICAgICBpbnB1dCgndmFsdWUxJykuY2hlY2soKTtcclxuICAgICAgICAgICAgaW5wdXQoJ3ZhbHVlMicpLmNoZWNrKCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd2YWx1ZTEnKSkudG9FcXVhbCgnZmFsc2UnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ZhbHVlMicpKS50b0VxdWFsKCdOTycpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAgICovXHJcbiAgJ2NoZWNrYm94JzogY2hlY2tib3hJbnB1dFR5cGUsXHJcblxyXG4gICdoaWRkZW4nOiBub29wLFxyXG4gICdidXR0b24nOiBub29wLFxyXG4gICdzdWJtaXQnOiBub29wLFxyXG4gICdyZXNldCc6IG5vb3BcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gdGV4dElucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHNuaWZmZXIsICRicm93c2VyKSB7XHJcblxyXG4gIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZhbHVlID0gZWxlbWVudC52YWwoKTtcclxuXHJcbiAgICAvLyBCeSBkZWZhdWx0IHdlIHdpbGwgdHJpbSB0aGUgdmFsdWVcclxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUgbmctdHJpbSBleGlzdHMgd2Ugd2lsbCBhdm9pZCB0cmltbWluZ1xyXG4gICAgLy8gZS5nLiA8aW5wdXQgbmctbW9kZWw9XCJmb29cIiBuZy10cmltPVwiZmFsc2VcIj5cclxuICAgIGlmICh0b0Jvb2xlYW4oYXR0ci5uZ1RyaW0gfHwgJ1QnKSkge1xyXG4gICAgICB2YWx1ZSA9IHRyaW0odmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjdHJsLiR2aWV3VmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICBjdHJsLiRzZXRWaWV3VmFsdWUodmFsdWUpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBpZiB0aGUgYnJvd3NlciBkb2VzIHN1cHBvcnQgXCJpbnB1dFwiIGV2ZW50LCB3ZSBhcmUgZmluZSAtIGV4Y2VwdCBvbiBJRTkgd2hpY2ggZG9lc24ndCBmaXJlIHRoZVxyXG4gIC8vIGlucHV0IGV2ZW50IG9uIGJhY2tzcGFjZSwgZGVsZXRlIG9yIGN1dFxyXG4gIGlmICgkc25pZmZlci5oYXNFdmVudCgnaW5wdXQnKSkge1xyXG4gICAgZWxlbWVudC5vbignaW5wdXQnLCBsaXN0ZW5lcik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhciB0aW1lb3V0O1xyXG5cclxuICAgIHZhciBkZWZlckxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGltZW91dCkge1xyXG4gICAgICAgIHRpbWVvdXQgPSAkYnJvd3Nlci5kZWZlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBlbGVtZW50Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdmFyIGtleSA9IGV2ZW50LmtleUNvZGU7XHJcblxyXG4gICAgICAvLyBpZ25vcmVcclxuICAgICAgLy8gICAgY29tbWFuZCAgICAgICAgICAgIG1vZGlmaWVycyAgICAgICAgICAgICAgICAgICBhcnJvd3NcclxuICAgICAgaWYgKGtleSA9PT0gOTEgfHwgKDE1IDwga2V5ICYmIGtleSA8IDE5KSB8fCAoMzcgPD0ga2V5ICYmIGtleSA8PSA0MCkpIHJldHVybjtcclxuXHJcbiAgICAgIGRlZmVyTGlzdGVuZXIoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGlmIHVzZXIgcGFzdGUgaW50byBpbnB1dCB1c2luZyBtb3VzZSwgd2UgbmVlZCBcImNoYW5nZVwiIGV2ZW50IHRvIGNhdGNoIGl0XHJcbiAgICBlbGVtZW50Lm9uKCdjaGFuZ2UnLCBsaXN0ZW5lcik7XHJcblxyXG4gICAgLy8gaWYgdXNlciBtb2RpZmllcyBpbnB1dCB2YWx1ZSB1c2luZyBjb250ZXh0IG1lbnUgaW4gSUUsIHdlIG5lZWQgXCJwYXN0ZVwiIGFuZCBcImN1dFwiIGV2ZW50cyB0byBjYXRjaCBpdFxyXG4gICAgaWYgKCRzbmlmZmVyLmhhc0V2ZW50KCdwYXN0ZScpKSB7XHJcbiAgICAgIGVsZW1lbnQub24oJ3Bhc3RlIGN1dCcsIGRlZmVyTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIGN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZWxlbWVudC52YWwoaXNFbXB0eShjdHJsLiR2aWV3VmFsdWUpID8gJycgOiBjdHJsLiR2aWV3VmFsdWUpO1xyXG4gIH07XHJcblxyXG4gIC8vIHBhdHRlcm4gdmFsaWRhdG9yXHJcbiAgdmFyIHBhdHRlcm4gPSBhdHRyLm5nUGF0dGVybixcclxuICAgICAgcGF0dGVyblZhbGlkYXRvcixcclxuICAgICAgbWF0Y2g7XHJcblxyXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKHJlZ2V4cCwgdmFsdWUpIHtcclxuICAgIGlmIChpc0VtcHR5KHZhbHVlKSB8fCByZWdleHAudGVzdCh2YWx1ZSkpIHtcclxuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ3BhdHRlcm4nLCB0cnVlKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ3BhdHRlcm4nLCBmYWxzZSk7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgaWYgKHBhdHRlcm4pIHtcclxuICAgIG1hdGNoID0gcGF0dGVybi5tYXRjaCgvXlxcLyguKilcXC8oW2dpbV0qKSQvKTtcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChtYXRjaFsxXSwgbWF0Y2hbMl0pO1xyXG4gICAgICBwYXR0ZXJuVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsaWRhdGUocGF0dGVybiwgdmFsdWUpXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXR0ZXJuVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgcGF0dGVybk9iaiA9IHNjb3BlLiRldmFsKHBhdHRlcm4pO1xyXG5cclxuICAgICAgICBpZiAoIXBhdHRlcm5PYmogfHwgIXBhdHRlcm5PYmoudGVzdCkge1xyXG4gICAgICAgICAgdGhyb3cgbWluRXJyKCduZ1BhdHRlcm4nKSgnbm9yZWdleHAnLFxyXG4gICAgICAgICAgICAnRXhwZWN0ZWQgezB9IHRvIGJlIGEgUmVnRXhwIGJ1dCB3YXMgezF9LiBFbGVtZW50OiB7Mn0nLCBwYXR0ZXJuLFxyXG4gICAgICAgICAgICBwYXR0ZXJuT2JqLCBzdGFydGluZ1RhZyhlbGVtZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwYXR0ZXJuT2JqLCB2YWx1ZSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKHBhdHRlcm5WYWxpZGF0b3IpO1xyXG4gICAgY3RybC4kcGFyc2Vycy5wdXNoKHBhdHRlcm5WYWxpZGF0b3IpO1xyXG4gIH1cclxuXHJcbiAgLy8gbWluIGxlbmd0aCB2YWxpZGF0b3JcclxuICBpZiAoYXR0ci5uZ01pbmxlbmd0aCkge1xyXG4gICAgdmFyIG1pbmxlbmd0aCA9IGludChhdHRyLm5nTWlubGVuZ3RoKTtcclxuICAgIHZhciBtaW5MZW5ndGhWYWxpZGF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBpZiAoIWlzRW1wdHkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA8IG1pbmxlbmd0aCkge1xyXG4gICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdtaW5sZW5ndGgnLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbWlubGVuZ3RoJywgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGN0cmwuJHBhcnNlcnMucHVzaChtaW5MZW5ndGhWYWxpZGF0b3IpO1xyXG4gICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKG1pbkxlbmd0aFZhbGlkYXRvcik7XHJcbiAgfVxyXG5cclxuICAvLyBtYXggbGVuZ3RoIHZhbGlkYXRvclxyXG4gIGlmIChhdHRyLm5nTWF4bGVuZ3RoKSB7XHJcbiAgICB2YXIgbWF4bGVuZ3RoID0gaW50KGF0dHIubmdNYXhsZW5ndGgpO1xyXG4gICAgdmFyIG1heExlbmd0aFZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmICghaXNFbXB0eSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gbWF4bGVuZ3RoKSB7XHJcbiAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ21heGxlbmd0aCcsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdtYXhsZW5ndGgnLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY3RybC4kcGFyc2Vycy5wdXNoKG1heExlbmd0aFZhbGlkYXRvcik7XHJcbiAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2gobWF4TGVuZ3RoVmFsaWRhdG9yKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51bWJlcklucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHNuaWZmZXIsICRicm93c2VyKSB7XHJcbiAgdGV4dElucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHNuaWZmZXIsICRicm93c2VyKTtcclxuXHJcbiAgY3RybC4kcGFyc2Vycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICB2YXIgZW1wdHkgPSBpc0VtcHR5KHZhbHVlKTtcclxuICAgIGlmIChlbXB0eSB8fCBOVU1CRVJfUkVHRVhQLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdudW1iZXInLCB0cnVlKTtcclxuICAgICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiAoZW1wdHkgPyB2YWx1ZSA6IHBhcnNlRmxvYXQodmFsdWUpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdudW1iZXInLCBmYWxzZSk7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGN0cmwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzRW1wdHkodmFsdWUpID8gJycgOiAnJyArIHZhbHVlO1xyXG4gIH0pO1xyXG5cclxuICBpZiAoYXR0ci5taW4pIHtcclxuICAgIHZhciBtaW4gPSBwYXJzZUZsb2F0KGF0dHIubWluKTtcclxuICAgIHZhciBtaW5WYWxpZGF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBpZiAoIWlzRW1wdHkodmFsdWUpICYmIHZhbHVlIDwgbWluKSB7XHJcbiAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ21pbicsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdtaW4nLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY3RybC4kcGFyc2Vycy5wdXNoKG1pblZhbGlkYXRvcik7XHJcbiAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2gobWluVmFsaWRhdG9yKTtcclxuICB9XHJcblxyXG4gIGlmIChhdHRyLm1heCkge1xyXG4gICAgdmFyIG1heCA9IHBhcnNlRmxvYXQoYXR0ci5tYXgpO1xyXG4gICAgdmFyIG1heFZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGlmICghaXNFbXB0eSh2YWx1ZSkgJiYgdmFsdWUgPiBtYXgpIHtcclxuICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbWF4JywgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ21heCcsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjdHJsLiRwYXJzZXJzLnB1c2gobWF4VmFsaWRhdG9yKTtcclxuICAgIGN0cmwuJGZvcm1hdHRlcnMucHVzaChtYXhWYWxpZGF0b3IpO1xyXG4gIH1cclxuXHJcbiAgY3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcblxyXG4gICAgaWYgKGlzRW1wdHkodmFsdWUpIHx8IGlzTnVtYmVyKHZhbHVlKSkge1xyXG4gICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbnVtYmVyJywgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdudW1iZXInLCBmYWxzZSk7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVybElucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHNuaWZmZXIsICRicm93c2VyKSB7XHJcbiAgdGV4dElucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHNuaWZmZXIsICRicm93c2VyKTtcclxuXHJcbiAgdmFyIHVybFZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNFbXB0eSh2YWx1ZSkgfHwgVVJMX1JFR0VYUC50ZXN0KHZhbHVlKSkge1xyXG4gICAgICBjdHJsLiRzZXRWYWxpZGl0eSgndXJsJywgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCd1cmwnLCBmYWxzZSk7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY3RybC4kZm9ybWF0dGVycy5wdXNoKHVybFZhbGlkYXRvcik7XHJcbiAgY3RybC4kcGFyc2Vycy5wdXNoKHVybFZhbGlkYXRvcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVtYWlsSW5wdXRUeXBlKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsLCAkc25pZmZlciwgJGJyb3dzZXIpIHtcclxuICB0ZXh0SW5wdXRUeXBlKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsLCAkc25pZmZlciwgJGJyb3dzZXIpO1xyXG5cclxuICB2YXIgZW1haWxWYWxpZGF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgaWYgKGlzRW1wdHkodmFsdWUpIHx8IEVNQUlMX1JFR0VYUC50ZXN0KHZhbHVlKSkge1xyXG4gICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnZW1haWwnLCB0cnVlKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ2VtYWlsJywgZmFsc2UpO1xyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGN0cmwuJGZvcm1hdHRlcnMucHVzaChlbWFpbFZhbGlkYXRvcik7XHJcbiAgY3RybC4kcGFyc2Vycy5wdXNoKGVtYWlsVmFsaWRhdG9yKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFkaW9JbnB1dFR5cGUoc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwpIHtcclxuICAvLyBtYWtlIHRoZSBuYW1lIHVuaXF1ZSwgaWYgbm90IGRlZmluZWRcclxuICBpZiAoaXNVbmRlZmluZWQoYXR0ci5uYW1lKSkge1xyXG4gICAgZWxlbWVudC5hdHRyKCduYW1lJywgbmV4dFVpZCgpKTtcclxuICB9XHJcblxyXG4gIGVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoZWxlbWVudFswXS5jaGVja2VkKSB7XHJcbiAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICBjdHJsLiRzZXRWaWV3VmFsdWUoYXR0ci52YWx1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBjdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XHJcbiAgICBlbGVtZW50WzBdLmNoZWNrZWQgPSAodmFsdWUgPT0gY3RybC4kdmlld1ZhbHVlKTtcclxuICB9O1xyXG5cclxuICBhdHRyLiRvYnNlcnZlKCd2YWx1ZScsIGN0cmwuJHJlbmRlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrYm94SW5wdXRUeXBlKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsKSB7XHJcbiAgdmFyIHRydWVWYWx1ZSA9IGF0dHIubmdUcnVlVmFsdWUsXHJcbiAgICAgIGZhbHNlVmFsdWUgPSBhdHRyLm5nRmFsc2VWYWx1ZTtcclxuXHJcbiAgaWYgKCFpc1N0cmluZyh0cnVlVmFsdWUpKSB0cnVlVmFsdWUgPSB0cnVlO1xyXG4gIGlmICghaXNTdHJpbmcoZmFsc2VWYWx1ZSkpIGZhbHNlVmFsdWUgPSBmYWxzZTtcclxuXHJcbiAgZWxlbWVudC5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcclxuICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgY3RybC4kc2V0Vmlld1ZhbHVlKGVsZW1lbnRbMF0uY2hlY2tlZCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgY3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICBlbGVtZW50WzBdLmNoZWNrZWQgPSBjdHJsLiR2aWV3VmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgY3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWVWYWx1ZTtcclxuICB9KTtcclxuXHJcbiAgY3RybC4kcGFyc2Vycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPyB0cnVlVmFsdWUgOiBmYWxzZVZhbHVlO1xyXG4gIH0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOnRleHRhcmVhXHJcbiAqIEByZXN0cmljdCBFXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBIVE1MIHRleHRhcmVhIGVsZW1lbnQgY29udHJvbCB3aXRoIGFuZ3VsYXIgZGF0YS1iaW5kaW5nLiBUaGUgZGF0YS1iaW5kaW5nIGFuZCB2YWxpZGF0aW9uXHJcbiAqIHByb3BlcnRpZXMgb2YgdGhpcyBlbGVtZW50IGFyZSBleGFjdGx5IHRoZSBzYW1lIGFzIHRob3NlIG9mIHRoZVxyXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOmlucHV0IGlucHV0IGVsZW1lbnR9LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmdNb2RlbCBBc3NpZ25hYmxlIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBkYXRhLWJpbmQgdG8uXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBmb3JtIHVuZGVyIHdoaWNoIHRoZSBjb250cm9sIGlzIHB1Ymxpc2hlZC5cclxuICogQHBhcmFtIHtzdHJpbmc9fSByZXF1aXJlZCBTZXRzIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIG5vdCBlbnRlcmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5nUmVxdWlyZWQgQWRkcyBgcmVxdWlyZWRgIGF0dHJpYnV0ZSBhbmQgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGNvbnN0cmFpbnQgdG9cclxuICogICAgdGhlIGVsZW1lbnQgd2hlbiB0aGUgbmdSZXF1aXJlZCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlLiBVc2UgYG5nUmVxdWlyZWRgIGluc3RlYWQgb2ZcclxuICogICAgYHJlcXVpcmVkYCB3aGVuIHlvdSB3YW50IHRvIGRhdGEtYmluZCB0byB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNaW5sZW5ndGggU2V0cyBgbWlubGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgc2hvcnRlciB0aGFuXHJcbiAqICAgIG1pbmxlbmd0aC5cclxuICogQHBhcmFtIHtudW1iZXI9fSBuZ01heGxlbmd0aCBTZXRzIGBtYXhsZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBsb25nZXIgdGhhblxyXG4gKiAgICBtYXhsZW5ndGguXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmdQYXR0ZXJuIFNldHMgYHBhdHRlcm5gIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGVcclxuICogICAgUmVnRXhwIHBhdHRlcm4gZXhwcmVzc2lvbi4gRXhwZWN0ZWQgdmFsdWUgaXMgYC9yZWdleHAvYCBmb3IgaW5saW5lIHBhdHRlcm5zIG9yIGByZWdleHBgIGZvclxyXG4gKiAgICBwYXR0ZXJucyBkZWZpbmVkIGFzIHNjb3BlIGV4cHJlc3Npb25zLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5nQ2hhbmdlIEFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZCB3aGVuIGlucHV0IGNoYW5nZXMgZHVlIHRvIHVzZXJcclxuICogICAgaW50ZXJhY3Rpb24gd2l0aCB0aGUgaW5wdXQgZWxlbWVudC5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOmlucHV0XHJcbiAqIEByZXN0cmljdCBFXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBIVE1MIGlucHV0IGVsZW1lbnQgY29udHJvbCB3aXRoIGFuZ3VsYXIgZGF0YS1iaW5kaW5nLiBJbnB1dCBjb250cm9sIGZvbGxvd3MgSFRNTDUgaW5wdXQgdHlwZXNcclxuICogYW5kIHBvbHlmaWxscyB0aGUgSFRNTDUgdmFsaWRhdGlvbiBiZWhhdmlvciBmb3Igb2xkZXIgYnJvd3NlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZ01vZGVsIEFzc2lnbmFibGUgYW5ndWxhciBleHByZXNzaW9uIHRvIGRhdGEtYmluZCB0by5cclxuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFByb3BlcnR5IG5hbWUgb2YgdGhlIGZvcm0gdW5kZXIgd2hpY2ggdGhlIGNvbnRyb2wgaXMgcHVibGlzaGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IHJlcXVpcmVkIFNldHMgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbm90IGVudGVyZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG5nUmVxdWlyZWQgU2V0cyBgcmVxdWlyZWRgIGF0dHJpYnV0ZSBpZiBzZXQgdG8gdHJ1ZVxyXG4gKiBAcGFyYW0ge251bWJlcj19IG5nTWlubGVuZ3RoIFNldHMgYG1pbmxlbmd0aGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIHNob3J0ZXIgdGhhblxyXG4gKiAgICBtaW5sZW5ndGguXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNYXhsZW5ndGggU2V0cyBgbWF4bGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbG9uZ2VyIHRoYW5cclxuICogICAgbWF4bGVuZ3RoLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5nUGF0dGVybiBTZXRzIGBwYXR0ZXJuYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlXHJcbiAqICAgIFJlZ0V4cCBwYXR0ZXJuIGV4cHJlc3Npb24uIEV4cGVjdGVkIHZhbHVlIGlzIGAvcmVnZXhwL2AgZm9yIGlubGluZSBwYXR0ZXJucyBvciBgcmVnZXhwYCBmb3JcclxuICogICAgcGF0dGVybnMgZGVmaW5lZCBhcyBzY29wZSBleHByZXNzaW9ucy5cclxuICogQHBhcmFtIHtzdHJpbmc9fSBuZ0NoYW5nZSBBbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBpbnB1dCBjaGFuZ2VzIGR1ZSB0byB1c2VyXHJcbiAqICAgIGludGVyYWN0aW9uIHdpdGggdGhlIGlucHV0IGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAkc2NvcGUudXNlciA9IHtuYW1lOiAnZ3Vlc3QnLCBsYXN0OiAndmlzaXRvcid9O1xyXG4gICAgICAgICB9XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiPlxyXG4gICAgICAgICAgIFVzZXIgbmFtZTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cInVzZXJOYW1lXCIgbmctbW9kZWw9XCJ1c2VyLm5hbWVcIiByZXF1aXJlZD5cclxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS51c2VyTmFtZS4kZXJyb3IucmVxdWlyZWRcIj5cclxuICAgICAgICAgICAgIFJlcXVpcmVkITwvc3Bhbj48YnI+XHJcbiAgICAgICAgICAgTGFzdCBuYW1lOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibGFzdE5hbWVcIiBuZy1tb2RlbD1cInVzZXIubGFzdFwiXHJcbiAgICAgICAgICAgICBuZy1taW5sZW5ndGg9XCIzXCIgbmctbWF4bGVuZ3RoPVwiMTBcIj5cclxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS5sYXN0TmFtZS4kZXJyb3IubWlubGVuZ3RoXCI+XHJcbiAgICAgICAgICAgICBUb28gc2hvcnQhPC9zcGFuPlxyXG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmxhc3ROYW1lLiRlcnJvci5tYXhsZW5ndGhcIj5cclxuICAgICAgICAgICAgIFRvbyBsb25nITwvc3Bhbj48YnI+XHJcbiAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgPGhyPlxyXG4gICAgICAgICA8dHQ+dXNlciA9IHt7dXNlcn19PC90dD48YnIvPlxyXG4gICAgICAgICA8dHQ+bXlGb3JtLnVzZXJOYW1lLiR2YWxpZCA9IHt7bXlGb3JtLnVzZXJOYW1lLiR2YWxpZH19PC90dD48YnI+XHJcbiAgICAgICAgIDx0dD5teUZvcm0udXNlck5hbWUuJGVycm9yID0ge3tteUZvcm0udXNlck5hbWUuJGVycm9yfX08L3R0Pjxicj5cclxuICAgICAgICAgPHR0Pm15Rm9ybS5sYXN0TmFtZS4kdmFsaWQgPSB7e215Rm9ybS5sYXN0TmFtZS4kdmFsaWR9fTwvdHQ+PGJyPlxyXG4gICAgICAgICA8dHQ+bXlGb3JtLmxhc3ROYW1lLiRlcnJvciA9IHt7bXlGb3JtLmxhc3ROYW1lLiRlcnJvcn19PC90dD48YnI+XHJcbiAgICAgICAgIDx0dD5teUZvcm0uJHZhbGlkID0ge3tteUZvcm0uJHZhbGlkfX08L3R0Pjxicj5cclxuICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnI+XHJcbiAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLm1pbmxlbmd0aCA9IHt7ISFteUZvcm0uJGVycm9yLm1pbmxlbmd0aH19PC90dD48YnI+XHJcbiAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLm1heGxlbmd0aCA9IHt7ISFteUZvcm0uJGVycm9yLm1heGxlbmd0aH19PC90dD48YnI+XHJcbiAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB0byBtb2RlbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3VzZXInKSkudG9FcXVhbCgne1wibmFtZVwiOlwiZ3Vlc3RcIixcImxhc3RcIjpcInZpc2l0b3JcIn0nKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0udXNlck5hbWUuJHZhbGlkJykpLnRvRXF1YWwoJ3RydWUnKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uJHZhbGlkJykpLnRvRXF1YWwoJ3RydWUnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBiZSBpbnZhbGlkIGlmIGVtcHR5IHdoZW4gcmVxdWlyZWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlucHV0KCd1c2VyLm5hbWUnKS5lbnRlcignJyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygndXNlcicpKS50b0VxdWFsKCd7XCJsYXN0XCI6XCJ2aXNpdG9yXCJ9Jyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLnVzZXJOYW1lLiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3Nob3VsZCBiZSB2YWxpZCBpZiBlbXB0eSB3aGVuIG1pbiBsZW5ndGggaXMgc2V0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpbnB1dCgndXNlci5sYXN0JykuZW50ZXIoJycpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3VzZXInKSkudG9FcXVhbCgne1wibmFtZVwiOlwiZ3Vlc3RcIixcImxhc3RcIjpcIlwifScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5sYXN0TmFtZS4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgbGVzcyB0aGFuIHJlcXVpcmVkIG1pbiBsZW5ndGgnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlucHV0KCd1c2VyLmxhc3QnKS5lbnRlcigneHgnKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd1c2VyJykpLnRvRXF1YWwoJ3tcIm5hbWVcIjpcImd1ZXN0XCJ9Jyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmxhc3ROYW1lLiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5sYXN0TmFtZS4kZXJyb3InKSkudG9NYXRjaCgvbWlubGVuZ3RoLyk7XHJcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgbG9uZ2VyIHRoYW4gbWF4IGxlbmd0aCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaW5wdXQoJ3VzZXIubGFzdCcpLmVudGVyKCdzb21lIHJpZGljdWxvdXNseSBsb25nIG5hbWUnKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd1c2VyJykpXHJcbiAgICAgICAgICAgIC50b0VxdWFsKCd7XCJuYW1lXCI6XCJndWVzdFwifScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5sYXN0TmFtZS4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0ubGFzdE5hbWUuJGVycm9yJykpLnRvTWF0Y2goL21heGxlbmd0aC8pO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgICA8L2RvYzpleGFtcGxlPlxyXG4gKi9cclxudmFyIGlucHV0RGlyZWN0aXZlID0gWyckYnJvd3NlcicsICckc25pZmZlcicsIGZ1bmN0aW9uKCRicm93c2VyLCAkc25pZmZlcikge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgcmVxdWlyZTogJz9uZ01vZGVsJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsKSB7XHJcbiAgICAgIGlmIChjdHJsKSB7XHJcbiAgICAgICAgKGlucHV0VHlwZVtsb3dlcmNhc2UoYXR0ci50eXBlKV0gfHwgaW5wdXRUeXBlLnRleHQpKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsLCAkc25pZmZlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGJyb3dzZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufV07XHJcblxyXG52YXIgVkFMSURfQ0xBU1MgPSAnbmctdmFsaWQnLFxyXG4gICAgSU5WQUxJRF9DTEFTUyA9ICduZy1pbnZhbGlkJyxcclxuICAgIFBSSVNUSU5FX0NMQVNTID0gJ25nLXByaXN0aW5lJyxcclxuICAgIERJUlRZX0NMQVNTID0gJ25nLWRpcnR5JztcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2Mgb2JqZWN0XHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAkdmlld1ZhbHVlIEFjdHVhbCBzdHJpbmcgdmFsdWUgaW4gdGhlIHZpZXcuXHJcbiAqIEBwcm9wZXJ0eSB7Kn0gJG1vZGVsVmFsdWUgVGhlIHZhbHVlIGluIHRoZSBtb2RlbCwgdGhhdCB0aGUgY29udHJvbCBpcyBib3VuZCB0by5cclxuICogQHByb3BlcnR5IHtBcnJheS48RnVuY3Rpb24+fSAkcGFyc2VycyBBcnJheSBvZiBmdW5jdGlvbnMgdG8gZXhlY3V0ZSwgYXMgYSBwaXBlbGluZSwgd2hlbmV2ZXJcclxuICAgICAgIHRoZSBjb250cm9sIHJlYWRzIHZhbHVlIGZyb20gdGhlIERPTS4gIEVhY2ggZnVuY3Rpb24gaXMgY2FsbGVkLCBpbiB0dXJuLCBwYXNzaW5nIHRoZSB2YWx1ZVxyXG4gICAgICAgdGhyb3VnaCB0byB0aGUgbmV4dC4gVXNlZCB0byBzYW5pdGl6ZSAvIGNvbnZlcnQgdGhlIHZhbHVlIGFzIHdlbGwgYXMgdmFsaWRhdGlvbi5cclxuICAgICAgIEZvciB2YWxpZGF0aW9uLCB0aGUgcGFyc2VycyBzaG91bGQgdXBkYXRlIHRoZSB2YWxpZGl0eSBzdGF0ZSB1c2luZ1xyXG4gICAgICAge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyIyRzZXRWYWxpZGl0eSAkc2V0VmFsaWRpdHkoKX0sXHJcbiAgICAgICBhbmQgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBpbnZhbGlkIHZhbHVlcy5cclxuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEZ1bmN0aW9uPn0gJGZvcm1hdHRlcnMgQXJyYXkgb2YgZnVuY3Rpb25zIHRvIGV4ZWN1dGUsIGFzIGEgcGlwZWxpbmUsIHdoZW5ldmVyXHJcbiAgICAgICB0aGUgbW9kZWwgdmFsdWUgY2hhbmdlcy4gRWFjaCBmdW5jdGlvbiBpcyBjYWxsZWQsIGluIHR1cm4sIHBhc3NpbmcgdGhlIHZhbHVlIHRocm91Z2ggdG8gdGhlXHJcbiAgICAgICBuZXh0LiBVc2VkIHRvIGZvcm1hdCAvIGNvbnZlcnQgdmFsdWVzIGZvciBkaXNwbGF5IGluIHRoZSBjb250cm9sIGFuZCB2YWxpZGF0aW9uLlxyXG4gKiAgICAgIDxwcmU+XHJcbiAqICAgICAgZnVuY3Rpb24gZm9ybWF0dGVyKHZhbHVlKSB7XHJcbiAqICAgICAgICBpZiAodmFsdWUpIHtcclxuICogICAgICAgICAgcmV0dXJuIHZhbHVlLnRvVXBwZXJDYXNlKCk7XHJcbiAqICAgICAgICB9XHJcbiAqICAgICAgfVxyXG4gKiAgICAgIG5nTW9kZWwuJGZvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xyXG4gKiAgICAgIDwvcHJlPlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gJGVycm9yIEFuIG9iamVjdCBoYXNoIHdpdGggYWxsIGVycm9ycyBhcyBrZXlzLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICRwcmlzdGluZSBUcnVlIGlmIHVzZXIgaGFzIG5vdCBpbnRlcmFjdGVkIHdpdGggdGhlIGNvbnRyb2wgeWV0LlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICRkaXJ0eSBUcnVlIGlmIHVzZXIgaGFzIGFscmVhZHkgaW50ZXJhY3RlZCB3aXRoIHRoZSBjb250cm9sLlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICR2YWxpZCBUcnVlIGlmIHRoZXJlIGlzIG5vIGVycm9yLlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICRpbnZhbGlkIFRydWUgaWYgYXQgbGVhc3Qgb25lIGVycm9yIG9uIHRoZSBjb250cm9sLlxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogYE5nTW9kZWxDb250cm9sbGVyYCBwcm92aWRlcyBBUEkgZm9yIHRoZSBgbmctbW9kZWxgIGRpcmVjdGl2ZS4gVGhlIGNvbnRyb2xsZXIgY29udGFpbnNcclxuICogc2VydmljZXMgZm9yIGRhdGEtYmluZGluZywgdmFsaWRhdGlvbiwgQ1NTIHVwZGF0ZSwgdmFsdWUgZm9ybWF0dGluZyBhbmQgcGFyc2luZy4gSXRcclxuICogc3BlY2lmaWNhbGx5IGRvZXMgbm90IGNvbnRhaW4gYW55IGxvZ2ljIHdoaWNoIGRlYWxzIHdpdGggRE9NIHJlbmRlcmluZyBvciBsaXN0ZW5pbmcgdG9cclxuICogRE9NIGV2ZW50cy4gVGhlIGBOZ01vZGVsQ29udHJvbGxlcmAgaXMgbWVhbnQgdG8gYmUgZXh0ZW5kZWQgYnkgb3RoZXIgZGlyZWN0aXZlcyB3aGVyZSwgdGhlXHJcbiAqIGRpcmVjdGl2ZSBwcm92aWRlcyBET00gbWFuaXB1bGF0aW9uIGFuZCB0aGUgYE5nTW9kZWxDb250cm9sbGVyYCBwcm92aWRlcyB0aGUgZGF0YS1iaW5kaW5nLlxyXG4gKiBOb3RlIHRoYXQgeW91IGNhbm5vdCB1c2UgYE5nTW9kZWxDb250cm9sbGVyYCBpbiBhIGRpcmVjdGl2ZSB3aXRoIGFuIGlzb2xhdGVkIHNjb3BlLFxyXG4gKiBhcywgaW4gdGhhdCBjYXNlLCB0aGUgYG5nLW1vZGVsYCB2YWx1ZSBnZXRzIHB1dCBpbnRvIHRoZSBpc29sYXRlZCBzY29wZSBhbmQgZG9lcyBub3QgZ2V0XHJcbiAqIHByb3BvZ2F0ZWQgdG8gdGhlIHBhcmVudCBzY29wZS5cclxuICpcclxuICpcclxuICogVGhpcyBleGFtcGxlIHNob3dzIGhvdyB0byB1c2UgYE5nTW9kZWxDb250cm9sbGVyYCB3aXRoIGEgY3VzdG9tIGNvbnRyb2wgdG8gYWNoaWV2ZVxyXG4gKiBkYXRhLWJpbmRpbmcuIE5vdGljZSBob3cgZGlmZmVyZW50IGRpcmVjdGl2ZXMgKGBjb250ZW50ZWRpdGFibGVgLCBgbmctbW9kZWxgLCBhbmQgYHJlcXVpcmVkYClcclxuICogY29sbGFib3JhdGUgdG9nZXRoZXIgdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCByZXN1bHQuXHJcbiAqXHJcbiAqIDxleGFtcGxlIG1vZHVsZT1cImN1c3RvbUNvbnRyb2xcIj5cclxuICAgIDxmaWxlIG5hbWU9XCJzdHlsZS5jc3NcIj5cclxuICAgICAgW2NvbnRlbnRlZGl0YWJsZV0ge1xyXG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xyXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xyXG4gICAgICAgIG1pbi1oZWlnaHQ6IDIwcHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5uZy1pbnZhbGlkIHtcclxuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCByZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XHJcbiAgICAgIGFuZ3VsYXIubW9kdWxlKCdjdXN0b21Db250cm9sJywgW10pLlxyXG4gICAgICAgIGRpcmVjdGl2ZSgnY29udGVudGVkaXRhYmxlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXN0cmljdDogJ0EnLCAvLyBvbmx5IGFjdGl2YXRlIG9uIGVsZW1lbnQgYXR0cmlidXRlXHJcbiAgICAgICAgICAgIHJlcXVpcmU6ICc/bmdNb2RlbCcsIC8vIGdldCBhIGhvbGQgb2YgTmdNb2RlbENvbnRyb2xsZXJcclxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XHJcbiAgICAgICAgICAgICAgaWYoIW5nTW9kZWwpIHJldHVybjsgLy8gZG8gbm90aGluZyBpZiBubyBuZy1tb2RlbFxyXG5cclxuICAgICAgICAgICAgICAvLyBTcGVjaWZ5IGhvdyBVSSBzaG91bGQgYmUgdXBkYXRlZFxyXG4gICAgICAgICAgICAgIG5nTW9kZWwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5odG1sKG5nTW9kZWwuJHZpZXdWYWx1ZSB8fCAnJyk7XHJcbiAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBjaGFuZ2UgZXZlbnRzIHRvIGVuYWJsZSBiaW5kaW5nXHJcbiAgICAgICAgICAgICAgZWxlbWVudC5vbignYmx1ciBrZXl1cCBjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlLiRhcHBseShyZWFkKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICByZWFkKCk7IC8vIGluaXRpYWxpemVcclxuXHJcbiAgICAgICAgICAgICAgLy8gV3JpdGUgZGF0YSB0byB0aGUgbW9kZWxcclxuICAgICAgICAgICAgICBmdW5jdGlvbiByZWFkKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBlbGVtZW50Lmh0bWwoKTtcclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gd2UgY2xlYXIgdGhlIGNvbnRlbnQgZWRpdGFibGUgdGhlIGJyb3dzZXIgbGVhdmVzIGEgPGJyPiBiZWhpbmRcclxuICAgICAgICAgICAgICAgIC8vIElmIHN0cmlwLWJyIGF0dHJpYnV0ZSBpcyBwcm92aWRlZCB0aGVuIHdlIHN0cmlwIHRoaXMgb3V0XHJcbiAgICAgICAgICAgICAgICBpZiggYXR0cnMuc3RyaXBCciAmJiBodG1sID09ICc8YnI+JyApIHtcclxuICAgICAgICAgICAgICAgICAgaHRtbCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKGh0bWwpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cclxuICAgICAgIDxkaXYgY29udGVudGVkaXRhYmxlXHJcbiAgICAgICAgICAgIG5hbWU9XCJteVdpZGdldFwiIG5nLW1vZGVsPVwidXNlckNvbnRlbnRcIlxyXG4gICAgICAgICAgICBzdHJpcC1icj1cInRydWVcIlxyXG4gICAgICAgICAgICByZXF1aXJlZD5DaGFuZ2UgbWUhPC9kaXY+XHJcbiAgICAgICAgPHNwYW4gbmctc2hvdz1cIm15Rm9ybS5teVdpZGdldC4kZXJyb3IucmVxdWlyZWRcIj5SZXF1aXJlZCE8L3NwYW4+XHJcbiAgICAgICA8aHI+XHJcbiAgICAgICA8dGV4dGFyZWEgbmctbW9kZWw9XCJ1c2VyQ29udGVudFwiPjwvdGV4dGFyZWE+XHJcbiAgICAgIDwvZm9ybT5cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxyXG4gICAgICBpdCgnc2hvdWxkIGRhdGEtYmluZCBhbmQgYmVjb21lIGludmFsaWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgY29udGVudEVkaXRhYmxlID0gZWxlbWVudCgnW2NvbnRlbnRlZGl0YWJsZV0nKTtcclxuXHJcbiAgICAgICAgZXhwZWN0KGNvbnRlbnRFZGl0YWJsZS50ZXh0KCkpLnRvRXF1YWwoJ0NoYW5nZSBtZSEnKTtcclxuICAgICAgICBpbnB1dCgndXNlckNvbnRlbnQnKS5lbnRlcignJyk7XHJcbiAgICAgICAgZXhwZWN0KGNvbnRlbnRFZGl0YWJsZS50ZXh0KCkpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgIGV4cGVjdChjb250ZW50RWRpdGFibGUucHJvcCgnY2xhc3NOYW1lJykpLnRvTWF0Y2goL25nLWludmFsaWQtcmVxdWlyZWQvKTtcclxuICAgICAgfSk7XHJcbiAgICA8L2ZpbGU+XHJcbiAqIDwvZXhhbXBsZT5cclxuICpcclxuICovXHJcbnZhciBOZ01vZGVsQ29udHJvbGxlciA9IFsnJHNjb3BlJywgJyRleGNlcHRpb25IYW5kbGVyJywgJyRhdHRycycsICckZWxlbWVudCcsICckcGFyc2UnLFxyXG4gICAgZnVuY3Rpb24oJHNjb3BlLCAkZXhjZXB0aW9uSGFuZGxlciwgJGF0dHIsICRlbGVtZW50LCAkcGFyc2UpIHtcclxuICB0aGlzLiR2aWV3VmFsdWUgPSBOdW1iZXIuTmFOO1xyXG4gIHRoaXMuJG1vZGVsVmFsdWUgPSBOdW1iZXIuTmFOO1xyXG4gIHRoaXMuJHBhcnNlcnMgPSBbXTtcclxuICB0aGlzLiRmb3JtYXR0ZXJzID0gW107XHJcbiAgdGhpcy4kdmlld0NoYW5nZUxpc3RlbmVycyA9IFtdO1xyXG4gIHRoaXMuJHByaXN0aW5lID0gdHJ1ZTtcclxuICB0aGlzLiRkaXJ0eSA9IGZhbHNlO1xyXG4gIHRoaXMuJHZhbGlkID0gdHJ1ZTtcclxuICB0aGlzLiRpbnZhbGlkID0gZmFsc2U7XHJcbiAgdGhpcy4kbmFtZSA9ICRhdHRyLm5hbWU7XHJcblxyXG4gIHZhciBuZ01vZGVsR2V0ID0gJHBhcnNlKCRhdHRyLm5nTW9kZWwpLFxyXG4gICAgICBuZ01vZGVsU2V0ID0gbmdNb2RlbEdldC5hc3NpZ247XHJcblxyXG4gIGlmICghbmdNb2RlbFNldCkge1xyXG4gICAgdGhyb3cgbWluRXJyKCduZ01vZGVsJykoJ25vbmFzc2lnbicsIFwiRXhwcmVzc2lvbiAnezB9JyBpcyBub24tYXNzaWduYWJsZS4gRWxlbWVudDogezF9XCIsXHJcbiAgICAgICAgJGF0dHIubmdNb2RlbCwgc3RhcnRpbmdUYWcoJGVsZW1lbnQpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyIyRyZW5kZXJcclxuICAgKiBAbWV0aG9kT2YgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIENhbGxlZCB3aGVuIHRoZSB2aWV3IG5lZWRzIHRvIGJlIHVwZGF0ZWQuIEl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIHVzZXIgb2YgdGhlIG5nLW1vZGVsXHJcbiAgICogZGlyZWN0aXZlIHdpbGwgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxyXG4gICAqL1xyXG4gIHRoaXMuJHJlbmRlciA9IG5vb3A7XHJcblxyXG4gIHZhciBwYXJlbnRGb3JtID0gJGVsZW1lbnQuaW5oZXJpdGVkRGF0YSgnJGZvcm1Db250cm9sbGVyJykgfHwgbnVsbEZvcm1DdHJsLFxyXG4gICAgICBpbnZhbGlkQ291bnQgPSAwLCAvLyB1c2VkIHRvIGVhc2lseSBkZXRlcm1pbmUgaWYgd2UgYXJlIHZhbGlkXHJcbiAgICAgICRlcnJvciA9IHRoaXMuJGVycm9yID0ge307IC8vIGtlZXAgaW52YWxpZCBrZXlzIGhlcmVcclxuXHJcblxyXG4gIC8vIFNldHVwIGluaXRpYWwgc3RhdGUgb2YgdGhlIGNvbnRyb2xcclxuICAkZWxlbWVudC5hZGRDbGFzcyhQUklTVElORV9DTEFTUyk7XHJcbiAgdG9nZ2xlVmFsaWRDc3ModHJ1ZSk7XHJcblxyXG4gIC8vIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgZWFzeSB0b2dnbGluZyBvZiBjbGFzc2VzXHJcbiAgZnVuY3Rpb24gdG9nZ2xlVmFsaWRDc3MoaXNWYWxpZCwgdmFsaWRhdGlvbkVycm9yS2V5KSB7XHJcbiAgICB2YWxpZGF0aW9uRXJyb3JLZXkgPSB2YWxpZGF0aW9uRXJyb3JLZXkgPyAnLScgKyBzbmFrZV9jYXNlKHZhbGlkYXRpb25FcnJvcktleSwgJy0nKSA6ICcnO1xyXG4gICAgJGVsZW1lbnQuXHJcbiAgICAgIHJlbW92ZUNsYXNzKChpc1ZhbGlkID8gSU5WQUxJRF9DTEFTUyA6IFZBTElEX0NMQVNTKSArIHZhbGlkYXRpb25FcnJvcktleSkuXHJcbiAgICAgIGFkZENsYXNzKChpc1ZhbGlkID8gVkFMSURfQ0xBU1MgOiBJTlZBTElEX0NMQVNTKSArIHZhbGlkYXRpb25FcnJvcktleSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdNb2RlbC5OZ01vZGVsQ29udHJvbGxlciMkc2V0VmFsaWRpdHlcclxuICAgKiBAbWV0aG9kT2YgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXJcclxuICAgKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIENoYW5nZSB0aGUgdmFsaWRpdHkgc3RhdGUsIGFuZCBub3RpZmllcyB0aGUgZm9ybSB3aGVuIHRoZSBjb250cm9sIGNoYW5nZXMgdmFsaWRpdHkuIChpLmUuIGl0XHJcbiAgICogZG9lcyBub3Qgbm90aWZ5IGZvcm0gaWYgZ2l2ZW4gdmFsaWRhdG9yIGlzIGFscmVhZHkgbWFya2VkIGFzIGludmFsaWQpLlxyXG4gICAqXHJcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBieSB2YWxpZGF0b3JzIC0gaS5lLiB0aGUgcGFyc2VyIG9yIGZvcm1hdHRlciBmdW5jdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdGlvbkVycm9yS2V5IE5hbWUgb2YgdGhlIHZhbGlkYXRvci4gdGhlIGB2YWxpZGF0aW9uRXJyb3JLZXlgIHdpbGwgYXNzaWduXHJcbiAgICogICAgICAgIHRvIGAkZXJyb3JbdmFsaWRhdGlvbkVycm9yS2V5XT1pc1ZhbGlkYCBzbyB0aGF0IGl0IGlzIGF2YWlsYWJsZSBmb3IgZGF0YS1iaW5kaW5nLlxyXG4gICAqICAgICAgICBUaGUgYHZhbGlkYXRpb25FcnJvcktleWAgc2hvdWxkIGJlIGluIGNhbWVsQ2FzZSBhbmQgd2lsbCBnZXQgY29udmVydGVkIGludG8gZGFzaC1jYXNlXHJcbiAgICogICAgICAgIGZvciBjbGFzcyBuYW1lLiBFeGFtcGxlOiBgbXlFcnJvcmAgd2lsbCByZXN1bHQgaW4gYG5nLXZhbGlkLW15LWVycm9yYCBhbmQgYG5nLWludmFsaWQtbXktZXJyb3JgXHJcbiAgICogICAgICAgIGNsYXNzIGFuZCBjYW4gYmUgYm91bmQgdG8gYXMgIGB7e3NvbWVGb3JtLnNvbWVDb250cm9sLiRlcnJvci5teUVycm9yfX1gIC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWQgV2hldGhlciB0aGUgY3VycmVudCBzdGF0ZSBpcyB2YWxpZCAodHJ1ZSkgb3IgaW52YWxpZCAoZmFsc2UpLlxyXG4gICAqL1xyXG4gIHRoaXMuJHNldFZhbGlkaXR5ID0gZnVuY3Rpb24odmFsaWRhdGlvbkVycm9yS2V5LCBpc1ZhbGlkKSB7XHJcbiAgICBpZiAoJGVycm9yW3ZhbGlkYXRpb25FcnJvcktleV0gPT09ICFpc1ZhbGlkKSByZXR1cm47XHJcblxyXG4gICAgaWYgKGlzVmFsaWQpIHtcclxuICAgICAgaWYgKCRlcnJvclt2YWxpZGF0aW9uRXJyb3JLZXldKSBpbnZhbGlkQ291bnQtLTtcclxuICAgICAgaWYgKCFpbnZhbGlkQ291bnQpIHtcclxuICAgICAgICB0b2dnbGVWYWxpZENzcyh0cnVlKTtcclxuICAgICAgICB0aGlzLiR2YWxpZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy4kaW52YWxpZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0b2dnbGVWYWxpZENzcyhmYWxzZSk7XHJcbiAgICAgIHRoaXMuJGludmFsaWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLiR2YWxpZCA9IGZhbHNlO1xyXG4gICAgICBpbnZhbGlkQ291bnQrKztcclxuICAgIH1cclxuXHJcbiAgICAkZXJyb3JbdmFsaWRhdGlvbkVycm9yS2V5XSA9ICFpc1ZhbGlkO1xyXG4gICAgdG9nZ2xlVmFsaWRDc3MoaXNWYWxpZCwgdmFsaWRhdGlvbkVycm9yS2V5KTtcclxuXHJcbiAgICBwYXJlbnRGb3JtLiRzZXRWYWxpZGl0eSh2YWxpZGF0aW9uRXJyb3JLZXksIGlzVmFsaWQsIHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxyXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyIyRzZXRQcmlzdGluZVxyXG4gICAqIEBtZXRob2RPZiBuZy5kaXJlY3RpdmU6bmdNb2RlbC5OZ01vZGVsQ29udHJvbGxlclxyXG4gICAqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogU2V0cyB0aGUgY29udHJvbCB0byBpdHMgcHJpc3RpbmUgc3RhdGUuXHJcbiAgICpcclxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIHJlbW92ZSB0aGUgJ25nLWRpcnR5JyBjbGFzcyBhbmQgc2V0IHRoZSBjb250cm9sIHRvIGl0cyBwcmlzdGluZVxyXG4gICAqIHN0YXRlIChuZy1wcmlzdGluZSBjbGFzcykuXHJcbiAgICovXHJcbiAgdGhpcy4kc2V0UHJpc3RpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLiRkaXJ0eSA9IGZhbHNlO1xyXG4gICAgdGhpcy4kcHJpc3RpbmUgPSB0cnVlO1xyXG4gICAgJGVsZW1lbnQucmVtb3ZlQ2xhc3MoRElSVFlfQ0xBU1MpLmFkZENsYXNzKFBSSVNUSU5FX0NMQVNTKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAbmdkb2MgZnVuY3Rpb25cclxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdNb2RlbC5OZ01vZGVsQ29udHJvbGxlciMkc2V0Vmlld1ZhbHVlXHJcbiAgICogQG1ldGhvZE9mIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyXHJcbiAgICpcclxuICAgKiBAZGVzY3JpcHRpb25cclxuICAgKiBSZWFkIGEgdmFsdWUgZnJvbSB2aWV3LlxyXG4gICAqXHJcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBmcm9tIHdpdGhpbiBhIERPTSBldmVudCBoYW5kbGVyLlxyXG4gICAqIEZvciBleGFtcGxlIHtAbGluayBuZy5kaXJlY3RpdmU6aW5wdXQgaW5wdXR9IG9yXHJcbiAgICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpzZWxlY3Qgc2VsZWN0fSBkaXJlY3RpdmVzIGNhbGwgaXQuXHJcbiAgICpcclxuICAgKiBJdCBpbnRlcm5hbGx5IGNhbGxzIGFsbCBgJHBhcnNlcnNgIChpbmNsdWRpbmcgdmFsaWRhdG9ycykgYW5kIHVwZGF0ZXMgdGhlIGAkbW9kZWxWYWx1ZWAgYW5kIHRoZSBhY3R1YWwgbW9kZWwgcGF0aC5cclxuICAgKiBMYXN0bHkgaXQgY2FsbHMgYWxsIHJlZ2lzdGVyZWQgY2hhbmdlIGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSBmcm9tIHRoZSB2aWV3LlxyXG4gICAqL1xyXG4gIHRoaXMuJHNldFZpZXdWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICB0aGlzLiR2aWV3VmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICAvLyBjaGFuZ2UgdG8gZGlydHlcclxuICAgIGlmICh0aGlzLiRwcmlzdGluZSkge1xyXG4gICAgICB0aGlzLiRkaXJ0eSA9IHRydWU7XHJcbiAgICAgIHRoaXMuJHByaXN0aW5lID0gZmFsc2U7XHJcbiAgICAgICRlbGVtZW50LnJlbW92ZUNsYXNzKFBSSVNUSU5FX0NMQVNTKS5hZGRDbGFzcyhESVJUWV9DTEFTUyk7XHJcbiAgICAgIHBhcmVudEZvcm0uJHNldERpcnR5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yRWFjaCh0aGlzLiRwYXJzZXJzLCBmdW5jdGlvbihmbikge1xyXG4gICAgICB2YWx1ZSA9IGZuKHZhbHVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLiRtb2RlbFZhbHVlICE9PSB2YWx1ZSkge1xyXG4gICAgICB0aGlzLiRtb2RlbFZhbHVlID0gdmFsdWU7XHJcbiAgICAgIG5nTW9kZWxTZXQoJHNjb3BlLCB2YWx1ZSk7XHJcbiAgICAgIGZvckVhY2godGhpcy4kdmlld0NoYW5nZUxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgICAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBtb2RlbCAtPiB2YWx1ZVxyXG4gIHZhciBjdHJsID0gdGhpcztcclxuXHJcbiAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiBuZ01vZGVsV2F0Y2goKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBuZ01vZGVsR2V0KCRzY29wZSk7XHJcblxyXG4gICAgLy8gaWYgc2NvcGUgbW9kZWwgdmFsdWUgYW5kIG5nTW9kZWwgdmFsdWUgYXJlIG91dCBvZiBzeW5jXHJcbiAgICBpZiAoY3RybC4kbW9kZWxWYWx1ZSAhPT0gdmFsdWUpIHtcclxuXHJcbiAgICAgIHZhciBmb3JtYXR0ZXJzID0gY3RybC4kZm9ybWF0dGVycyxcclxuICAgICAgICAgIGlkeCA9IGZvcm1hdHRlcnMubGVuZ3RoO1xyXG5cclxuICAgICAgY3RybC4kbW9kZWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICB3aGlsZShpZHgtLSkge1xyXG4gICAgICAgIHZhbHVlID0gZm9ybWF0dGVyc1tpZHhdKHZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGN0cmwuJHZpZXdWYWx1ZSAhPT0gdmFsdWUpIHtcclxuICAgICAgICBjdHJsLiR2aWV3VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBjdHJsLiRyZW5kZXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XTtcclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdNb2RlbFxyXG4gKlxyXG4gKiBAZWxlbWVudCBpbnB1dFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogSXMgYSBkaXJlY3RpdmUgdGhhdCB0ZWxscyBBbmd1bGFyIHRvIGRvIHR3by13YXkgZGF0YSBiaW5kaW5nLiBJdCB3b3JrcyB0b2dldGhlciB3aXRoIGBpbnB1dGAsXHJcbiAqIGBzZWxlY3RgLCBgdGV4dGFyZWFgIGFuZCBldmVuIGN1c3RvbSBmb3JtIGNvbnRyb2xzIHRoYXQgdXNlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdNb2RlbC5OZ01vZGVsQ29udHJvbGxlclxyXG4gKiBOZ01vZGVsQ29udHJvbGxlcn0gZXhwb3NlZCBieSB0aGlzIGRpcmVjdGl2ZS5cclxuICpcclxuICogYG5nTW9kZWxgIGlzIHJlc3BvbnNpYmxlIGZvcjpcclxuICpcclxuICogLSBiaW5kaW5nIHRoZSB2aWV3IGludG8gdGhlIG1vZGVsLCB3aGljaCBvdGhlciBkaXJlY3RpdmVzIHN1Y2ggYXMgYGlucHV0YCwgYHRleHRhcmVhYCBvciBgc2VsZWN0YFxyXG4gKiAgIHJlcXVpcmUsXHJcbiAqIC0gcHJvdmlkaW5nIHZhbGlkYXRpb24gYmVoYXZpb3IgKGkuZS4gcmVxdWlyZWQsIG51bWJlciwgZW1haWwsIHVybCksXHJcbiAqIC0ga2VlcGluZyBzdGF0ZSBvZiB0aGUgY29udHJvbCAodmFsaWQvaW52YWxpZCwgZGlydHkvcHJpc3RpbmUsIHZhbGlkYXRpb24gZXJyb3JzKSxcclxuICogLSBzZXR0aW5nIHJlbGF0ZWQgY3NzIGNsYXNzIG9udG8gdGhlIGVsZW1lbnQgKGBuZy12YWxpZGAsIGBuZy1pbnZhbGlkYCwgYG5nLWRpcnR5YCwgYG5nLXByaXN0aW5lYCksXHJcbiAqIC0gcmVnaXN0ZXIgdGhlIGNvbnRyb2wgd2l0aCBwYXJlbnQge0BsaW5rIG5nLmRpcmVjdGl2ZTpmb3JtIGZvcm19LlxyXG4gKlxyXG4gKiBOb3RlOiBgbmdNb2RlbGAgd2lsbCB0cnkgdG8gYmluZCB0byB0aGUgcHJvcGVydHkgZ2l2ZW4gYnkgZXZhbHVhdGluZyB0aGUgZXhwcmVzc2lvbiBvbiB0aGVcclxuICogY3VycmVudCBzY29wZS4gSWYgdGhlIHByb3BlcnR5IGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBvbiB0aGlzIHNjb3BlLCBpdCB3aWxsIGJlIGNyZWF0ZWRcclxuICogaW1wbGljaXRseSBhbmQgYWRkZWQgdG8gdGhlIHNjb3BlLlxyXG4gKlxyXG4gKiBGb3IgYmFzaWMgZXhhbXBsZXMsIGhvdyB0byB1c2UgYG5nTW9kZWxgLCBzZWU6XHJcbiAqXHJcbiAqICAtIHtAbGluayBuZy5kaXJlY3RpdmU6aW5wdXQgaW5wdXR9XHJcbiAqICAgIC0ge0BsaW5rIG5nLmRpcmVjdGl2ZTppbnB1dC50ZXh0IHRleHR9XHJcbiAqICAgIC0ge0BsaW5rIG5nLmRpcmVjdGl2ZTppbnB1dC5jaGVja2JveCBjaGVja2JveH1cclxuICogICAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOmlucHV0LnJhZGlvIHJhZGlvfVxyXG4gKiAgICAtIHtAbGluayBuZy5kaXJlY3RpdmU6aW5wdXQubnVtYmVyIG51bWJlcn1cclxuICogICAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOmlucHV0LmVtYWlsIGVtYWlsfVxyXG4gKiAgICAtIHtAbGluayBuZy5kaXJlY3RpdmU6aW5wdXQudXJsIHVybH1cclxuICogIC0ge0BsaW5rIG5nLmRpcmVjdGl2ZTpzZWxlY3Qgc2VsZWN0fVxyXG4gKiAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOnRleHRhcmVhIHRleHRhcmVhfVxyXG4gKlxyXG4gKi9cclxudmFyIG5nTW9kZWxEaXJlY3RpdmUgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVxdWlyZTogWyduZ01vZGVsJywgJ14/Zm9ybSddLFxyXG4gICAgY29udHJvbGxlcjogTmdNb2RlbENvbnRyb2xsZXIsXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybHMpIHtcclxuICAgICAgLy8gbm90aWZ5IG90aGVycywgZXNwZWNpYWxseSBwYXJlbnQgZm9ybXNcclxuXHJcbiAgICAgIHZhciBtb2RlbEN0cmwgPSBjdHJsc1swXSxcclxuICAgICAgICAgIGZvcm1DdHJsID0gY3RybHNbMV0gfHwgbnVsbEZvcm1DdHJsO1xyXG5cclxuICAgICAgZm9ybUN0cmwuJGFkZENvbnRyb2wobW9kZWxDdHJsKTtcclxuXHJcbiAgICAgIGVsZW1lbnQub24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZm9ybUN0cmwuJHJlbW92ZUNvbnRyb2wobW9kZWxDdHJsKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdDaGFuZ2VcclxuICogQHJlc3RyaWN0IEVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEV2YWx1YXRlIGdpdmVuIGV4cHJlc3Npb24gd2hlbiB1c2VyIGNoYW5nZXMgdGhlIGlucHV0LlxyXG4gKiBUaGUgZXhwcmVzc2lvbiBpcyBub3QgZXZhbHVhdGVkIHdoZW4gdGhlIHZhbHVlIGNoYW5nZSBpcyBjb21pbmcgZnJvbSB0aGUgbW9kZWwuXHJcbiAqXHJcbiAqIE5vdGUsIHRoaXMgZGlyZWN0aXZlIHJlcXVpcmVzIGBuZ01vZGVsYCB0byBiZSBwcmVzZW50LlxyXG4gKlxyXG4gKiBAZWxlbWVudCBpbnB1dFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiA8ZG9jOmV4YW1wbGU+XHJcbiAqICAgPGRvYzpzb3VyY2U+XHJcbiAqICAgICA8c2NyaXB0PlxyXG4gKiAgICAgICBmdW5jdGlvbiBDb250cm9sbGVyKCRzY29wZSkge1xyXG4gKiAgICAgICAgICRzY29wZS5jb3VudGVyID0gMDtcclxuICogICAgICAgICAkc2NvcGUuY2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgICAgICAkc2NvcGUuY291bnRlcisrO1xyXG4gKiAgICAgICAgIH07XHJcbiAqICAgICAgIH1cclxuICogICAgIDwvc2NyaXB0PlxyXG4gKiAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ29udHJvbGxlclwiPlxyXG4gKiAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJjb25maXJtZWRcIiBuZy1jaGFuZ2U9XCJjaGFuZ2UoKVwiIGlkPVwibmctY2hhbmdlLWV4YW1wbGUxXCIgLz5cclxuICogICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwiY29uZmlybWVkXCIgaWQ9XCJuZy1jaGFuZ2UtZXhhbXBsZTJcIiAvPlxyXG4gKiAgICAgICA8bGFiZWwgZm9yPVwibmctY2hhbmdlLWV4YW1wbGUyXCI+Q29uZmlybWVkPC9sYWJlbD48YnIgLz5cclxuICogICAgICAgZGVidWcgPSB7e2NvbmZpcm1lZH19PGJyIC8+XHJcbiAqICAgICAgIGNvdW50ZXIgPSB7e2NvdW50ZXJ9fVxyXG4gKiAgICAgPC9kaXY+XHJcbiAqICAgPC9kb2M6c291cmNlPlxyXG4gKiAgIDxkb2M6c2NlbmFyaW8+XHJcbiAqICAgICBpdCgnc2hvdWxkIGV2YWx1YXRlIHRoZSBleHByZXNzaW9uIGlmIGNoYW5naW5nIGZyb20gdmlldycsIGZ1bmN0aW9uKCkge1xyXG4gKiAgICAgICBleHBlY3QoYmluZGluZygnY291bnRlcicpKS50b0VxdWFsKCcwJyk7XHJcbiAqICAgICAgIGVsZW1lbnQoJyNuZy1jaGFuZ2UtZXhhbXBsZTEnKS5jbGljaygpO1xyXG4gKiAgICAgICBleHBlY3QoYmluZGluZygnY291bnRlcicpKS50b0VxdWFsKCcxJyk7XHJcbiAqICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb25maXJtZWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gKiAgICAgfSk7XHJcbiAqXHJcbiAqICAgICBpdCgnc2hvdWxkIG5vdCBldmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiBpZiBjaGFuZ2luZyBmcm9tIG1vZGVsJywgZnVuY3Rpb24oKSB7XHJcbiAqICAgICAgIGVsZW1lbnQoJyNuZy1jaGFuZ2UtZXhhbXBsZTInKS5jbGljaygpO1xyXG4gKiAgICAgICBleHBlY3QoYmluZGluZygnY291bnRlcicpKS50b0VxdWFsKCcwJyk7XHJcbiAqICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb25maXJtZWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gKiAgICAgfSk7XHJcbiAqICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAqIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdDaGFuZ2VEaXJlY3RpdmUgPSB2YWx1ZUZuKHtcclxuICByZXF1aXJlOiAnbmdNb2RlbCcsXHJcbiAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwpIHtcclxuICAgIGN0cmwuJHZpZXdDaGFuZ2VMaXN0ZW5lcnMucHVzaChmdW5jdGlvbigpIHtcclxuICAgICAgc2NvcGUuJGV2YWwoYXR0ci5uZ0NoYW5nZSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn0pO1xyXG5cclxuXHJcbnZhciByZXF1aXJlZERpcmVjdGl2ZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZXF1aXJlOiAnP25nTW9kZWwnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0ciwgY3RybCkge1xyXG4gICAgICBpZiAoIWN0cmwpIHJldHVybjtcclxuICAgICAgYXR0ci5yZXF1aXJlZCA9IHRydWU7IC8vIGZvcmNlIHRydXRoeSBpbiBjYXNlIHdlIGFyZSBvbiBub24gaW5wdXQgZWxlbWVudFxyXG5cclxuICAgICAgdmFyIHZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGF0dHIucmVxdWlyZWQgJiYgKGlzRW1wdHkodmFsdWUpIHx8IHZhbHVlID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdyZXF1aXJlZCcsIGZhbHNlKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ3JlcXVpcmVkJywgdHJ1ZSk7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKHZhbGlkYXRvcik7XHJcbiAgICAgIGN0cmwuJHBhcnNlcnMudW5zaGlmdCh2YWxpZGF0b3IpO1xyXG5cclxuICAgICAgYXR0ci4kb2JzZXJ2ZSgncmVxdWlyZWQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YWxpZGF0b3IoY3RybC4kdmlld1ZhbHVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdMaXN0XHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUZXh0IGlucHV0IHRoYXQgY29udmVydHMgYmV0d2VlbiBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICpcclxuICogQGVsZW1lbnQgaW5wdXRcclxuICogQHBhcmFtIHtzdHJpbmc9fSBuZ0xpc3Qgb3B0aW9uYWwgZGVsaW1pdGVyIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gc3BsaXQgdGhlIHZhbHVlLiBJZlxyXG4gKiAgIHNwZWNpZmllZCBpbiBmb3JtIGAvc29tZXRoaW5nL2AgdGhlbiB0aGUgdmFsdWUgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICA8c2NyaXB0PlxyXG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgICRzY29wZS5uYW1lcyA9IFsnaWdvcicsICdtaXNrbycsICd2b2p0YSddO1xyXG4gICAgICAgICB9XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICBMaXN0OiA8aW5wdXQgbmFtZT1cIm5hbWVzSW5wdXRcIiBuZy1tb2RlbD1cIm5hbWVzXCIgbmctbGlzdCByZXF1aXJlZD5cclxuICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0ubmFtZXNJbnB1dC4kZXJyb3IucmVxdWlyZWRcIj5cclxuICAgICAgICAgICBSZXF1aXJlZCE8L3NwYW4+XHJcbiAgICAgICAgIDxicj5cclxuICAgICAgICAgPHR0Pm5hbWVzID0ge3tuYW1lc319PC90dD48YnIvPlxyXG4gICAgICAgICA8dHQ+bXlGb3JtLm5hbWVzSW5wdXQuJHZhbGlkID0ge3tteUZvcm0ubmFtZXNJbnB1dC4kdmFsaWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICAgPHR0Pm15Rm9ybS5uYW1lc0lucHV0LiRlcnJvciA9IHt7bXlGb3JtLm5hbWVzSW5wdXQuJGVycm9yfX08L3R0Pjxici8+XHJcbiAgICAgICAgIDx0dD5teUZvcm0uJHZhbGlkID0ge3tteUZvcm0uJHZhbGlkfX08L3R0Pjxici8+XHJcbiAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLnJlcXVpcmVkID0ge3shIW15Rm9ybS4kZXJyb3IucmVxdWlyZWR9fTwvdHQ+PGJyLz5cclxuICAgICAgICA8L2Zvcm0+XHJcbiAgICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgdG8gbW9kZWwnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCduYW1lcycpKS50b0VxdWFsKCdbXCJpZ29yXCIsXCJtaXNrb1wiLFwidm9qdGFcIl0nKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0ubmFtZXNJbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJ3NwYW4uZXJyb3InKS5jc3MoJ2Rpc3BsYXknKSkudG9CZSgnbm9uZScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgZW1wdHknLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlucHV0KCduYW1lcycpLmVudGVyKCcnKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCduYW1lcycpKS50b0VxdWFsKCdbXScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5uYW1lc0lucHV0LiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJ3NwYW4uZXJyb3InKS5jc3MoJ2Rpc3BsYXknKSkubm90KCkudG9CZSgnbm9uZScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdMaXN0RGlyZWN0aXZlID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsKSB7XHJcbiAgICAgIHZhciBtYXRjaCA9IC9cXC8oLiopXFwvLy5leGVjKGF0dHIubmdMaXN0KSxcclxuICAgICAgICAgIHNlcGFyYXRvciA9IG1hdGNoICYmIG5ldyBSZWdFeHAobWF0Y2hbMV0pIHx8IGF0dHIubmdMaXN0IHx8ICcsJztcclxuXHJcbiAgICAgIHZhciBwYXJzZSA9IGZ1bmN0aW9uKHZpZXdWYWx1ZSkge1xyXG4gICAgICAgIHZhciBsaXN0ID0gW107XHJcblxyXG4gICAgICAgIGlmICh2aWV3VmFsdWUpIHtcclxuICAgICAgICAgIGZvckVhY2godmlld1ZhbHVlLnNwbGl0KHNlcGFyYXRvciksIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgbGlzdC5wdXNoKHRyaW0odmFsdWUpKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjdHJsLiRwYXJzZXJzLnB1c2gocGFyc2UpO1xyXG4gICAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5qb2luKCcsICcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcblxyXG52YXIgQ09OU1RBTlRfVkFMVUVfUkVHRVhQID0gL14odHJ1ZXxmYWxzZXxcXGQrKSQvO1xyXG5cclxudmFyIG5nVmFsdWVEaXJlY3RpdmUgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcHJpb3JpdHk6IDEwMCxcclxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRwbCwgdHBsQXR0cikge1xyXG4gICAgICBpZiAoQ09OU1RBTlRfVkFMVUVfUkVHRVhQLnRlc3QodHBsQXR0ci5uZ1ZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxtLCBhdHRyKSB7XHJcbiAgICAgICAgICBhdHRyLiRzZXQoJ3ZhbHVlJywgc2NvcGUuJGV2YWwoYXR0ci5uZ1ZhbHVlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cikge1xyXG4gICAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHIubmdWYWx1ZSwgZnVuY3Rpb24gdmFsdWVXYXRjaEFjdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBhdHRyLiRzZXQoJ3ZhbHVlJywgdmFsdWUpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdCaW5kXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgYG5nQmluZGAgYXR0cmlidXRlIHRlbGxzIEFuZ3VsYXIgdG8gcmVwbGFjZSB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBzcGVjaWZpZWQgSFRNTCBlbGVtZW50XHJcbiAqIHdpdGggdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gZXhwcmVzc2lvbiwgYW5kIHRvIHVwZGF0ZSB0aGUgdGV4dCBjb250ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoYXRcclxuICogZXhwcmVzc2lvbiBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBUeXBpY2FsbHksIHlvdSBkb24ndCB1c2UgYG5nQmluZGAgZGlyZWN0bHksIGJ1dCBpbnN0ZWFkIHlvdSB1c2UgdGhlIGRvdWJsZSBjdXJseSBtYXJrdXAgbGlrZVxyXG4gKiBge3sgZXhwcmVzc2lvbiB9fWAgd2hpY2ggaXMgc2ltaWxhciBidXQgbGVzcyB2ZXJib3NlLlxyXG4gKlxyXG4gKiBJdCBpcyBwcmVmZXJyYWJsZSB0byB1c2UgYG5nQmluZGAgaW5zdGVhZCBvZiBge3sgZXhwcmVzc2lvbiB9fWAgd2hlbiBhIHRlbXBsYXRlIGlzIG1vbWVudGFyaWx5IFxyXG4gKiBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgaW4gaXRzIHJhdyBzdGF0ZSBiZWZvcmUgQW5ndWxhciBjb21waWxlcyBpdC4gU2luY2UgYG5nQmluZGAgaXMgYW4gXHJcbiAqIGVsZW1lbnQgYXR0cmlidXRlLCBpdCBtYWtlcyB0aGUgYmluZGluZ3MgaW52aXNpYmxlIHRvIHRoZSB1c2VyIHdoaWxlIHRoZSBwYWdlIGlzIGxvYWRpbmcuXHJcbiAqXHJcbiAqIEFuIGFsdGVybmF0aXZlIHNvbHV0aW9uIHRvIHRoaXMgcHJvYmxlbSB3b3VsZCBiZSB1c2luZyB0aGVcclxuICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0Nsb2FrIG5nQ2xvYWt9IGRpcmVjdGl2ZS5cclxuICpcclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdCaW5kIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBFbnRlciBhIG5hbWUgaW4gdGhlIExpdmUgUHJldmlldyB0ZXh0IGJveDsgdGhlIGdyZWV0aW5nIGJlbG93IHRoZSB0ZXh0IGJveCBjaGFuZ2VzIGluc3RhbnRseS5cclxuICAgPGRvYzpleGFtcGxlPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAkc2NvcGUubmFtZSA9ICdXaGlybGVkJztcclxuICAgICAgICAgfVxyXG4gICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICAgIEVudGVyIG5hbWU6IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwibmFtZVwiPjxicj5cclxuICAgICAgICAgSGVsbG8gPHNwYW4gbmctYmluZD1cIm5hbWVcIj48L3NwYW4+IVxyXG4gICAgICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLWJpbmQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmJpbmRpbmcoJ25hbWUnKSkudG9CZSgnV2hpcmxlZCcpO1xyXG4gICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5pbnB1dCgnbmFtZScpLmVudGVyKCd3b3JsZCcpO1xyXG4gICAgICAgICBleHBlY3QodXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuYmluZGluZygnbmFtZScpKS50b0JlKCd3b3JsZCcpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdCaW5kRGlyZWN0aXZlID0gbmdEaXJlY3RpdmUoZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICBlbGVtZW50LmFkZENsYXNzKCduZy1iaW5kaW5nJykuZGF0YSgnJGJpbmRpbmcnLCBhdHRyLm5nQmluZCk7XHJcbiAgc2NvcGUuJHdhdGNoKGF0dHIubmdCaW5kLCBmdW5jdGlvbiBuZ0JpbmRXYXRjaEFjdGlvbih2YWx1ZSkge1xyXG4gICAgZWxlbWVudC50ZXh0KHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWUpO1xyXG4gIH0pO1xyXG59KTtcclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdCaW5kVGVtcGxhdGVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgbmdCaW5kVGVtcGxhdGVgIGRpcmVjdGl2ZSBzcGVjaWZpZXMgdGhhdCB0aGUgZWxlbWVudFxyXG4gKiB0ZXh0IGNvbnRlbnQgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggdGhlIGludGVycG9sYXRpb24gb2YgdGhlIHRlbXBsYXRlXHJcbiAqIGluIHRoZSBgbmdCaW5kVGVtcGxhdGVgIGF0dHJpYnV0ZS5cclxuICogVW5saWtlIGBuZ0JpbmRgLCB0aGUgYG5nQmluZFRlbXBsYXRlYCBjYW4gY29udGFpbiBtdWx0aXBsZSBge3tgIGB9fWBcclxuICogZXhwcmVzc2lvbnMuIFRoaXMgZGlyZWN0aXZlIGlzIG5lZWRlZCBzaW5jZSBzb21lIEhUTUwgZWxlbWVudHNcclxuICogKHN1Y2ggYXMgVElUTEUgYW5kIE9QVElPTikgY2Fubm90IGNvbnRhaW4gU1BBTiBlbGVtZW50cy5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZ0JpbmRUZW1wbGF0ZSB0ZW1wbGF0ZSBvZiBmb3JtXHJcbiAqICAgPHR0Pnt7PC90dD4gPHR0PmV4cHJlc3Npb248L3R0PiA8dHQ+fX08L3R0PiB0byBldmFsLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBUcnkgaXQgaGVyZTogZW50ZXIgdGV4dCBpbiB0ZXh0IGJveCBhbmQgd2F0Y2ggdGhlIGdyZWV0aW5nIGNoYW5nZS5cclxuICAgPGRvYzpleGFtcGxlPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAgICAkc2NvcGUuc2FsdXRhdGlvbiA9ICdIZWxsbyc7XHJcbiAgICAgICAgICAgJHNjb3BlLm5hbWUgPSAnV29ybGQnO1xyXG4gICAgICAgICB9XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICBTYWx1dGF0aW9uOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInNhbHV0YXRpb25cIj48YnI+XHJcbiAgICAgICAgTmFtZTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJuYW1lXCI+PGJyPlxyXG4gICAgICAgIDxwcmUgbmctYmluZC10ZW1wbGF0ZT1cInt7c2FsdXRhdGlvbn19IHt7bmFtZX19IVwiPjwvcHJlPlxyXG4gICAgICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLWJpbmQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmJpbmRpbmcoJ3NhbHV0YXRpb24nKSkuXHJcbiAgICAgICAgICAgdG9CZSgnSGVsbG8nKTtcclxuICAgICAgICAgZXhwZWN0KHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmJpbmRpbmcoJ25hbWUnKSkuXHJcbiAgICAgICAgICAgdG9CZSgnV29ybGQnKTtcclxuICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuaW5wdXQoJ3NhbHV0YXRpb24nKS5lbnRlcignR3JlZXRpbmdzJyk7XHJcbiAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCduYW1lJykuZW50ZXIoJ3VzZXInKTtcclxuICAgICAgICAgZXhwZWN0KHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmJpbmRpbmcoJ3NhbHV0YXRpb24nKSkuXHJcbiAgICAgICAgICAgdG9CZSgnR3JlZXRpbmdzJyk7XHJcbiAgICAgICAgIGV4cGVjdCh1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5iaW5kaW5nKCduYW1lJykpLlxyXG4gICAgICAgICAgIHRvQmUoJ3VzZXInKTtcclxuICAgICAgIH0pO1xyXG4gICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICA8L2RvYzpleGFtcGxlPlxyXG4gKi9cclxudmFyIG5nQmluZFRlbXBsYXRlRGlyZWN0aXZlID0gWyckaW50ZXJwb2xhdGUnLCBmdW5jdGlvbigkaW50ZXJwb2xhdGUpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICAgIC8vIFRPRE86IG1vdmUgdGhpcyB0byBzY2VuYXJpbyBydW5uZXJcclxuICAgIHZhciBpbnRlcnBvbGF0ZUZuID0gJGludGVycG9sYXRlKGVsZW1lbnQuYXR0cihhdHRyLiRhdHRyLm5nQmluZFRlbXBsYXRlKSk7XHJcbiAgICBlbGVtZW50LmFkZENsYXNzKCduZy1iaW5kaW5nJykuZGF0YSgnJGJpbmRpbmcnLCBpbnRlcnBvbGF0ZUZuKTtcclxuICAgIGF0dHIuJG9ic2VydmUoJ25nQmluZFRlbXBsYXRlJywgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgZWxlbWVudC50ZXh0KHZhbHVlKTtcclxuICAgIH0pO1xyXG4gIH1cclxufV07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQmluZEh0bWxcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENyZWF0ZXMgYSBiaW5kaW5nIHRoYXQgd2lsbCBpbm5lckhUTUwgdGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIHRoZSBgZXhwcmVzc2lvbmAgaW50byB0aGUgY3VycmVudFxyXG4gKiBlbGVtZW50IGluIGEgc2VjdXJlIHdheS4gIEJ5IGRlZmF1bHQsIHRoZSBpbm5lckhUTUwtZWQgY29udGVudCB3aWxsIGJlIHNhbml0aXplZCB1c2luZyB0aGUge0BsaW5rXHJcbiAqIG5nU2FuaXRpemUuJHNhbml0aXplICRzYW5pdGl6ZX0gc2VydmljZS4gIFRvIHV0aWxpemUgdGhpcyBmdW5jdGlvbmFsaXR5LCBlbnN1cmUgdGhhdCBgJHNhbml0aXplYFxyXG4gKiBpcyBhdmFpbGFibGUsIGZvciBleGFtcGxlLCBieSBpbmNsdWRpbmcge0BsaW5rIG5nU2FuaXRpemV9IGluIHlvdXIgbW9kdWxlJ3MgZGVwZW5kZW5jaWVzIChub3QgaW5cclxuICogY29yZSBBbmd1bGFyLikgIFlvdSBtYXkgYWxzbyBieXBhc3Mgc2FuaXRpemF0aW9uIGZvciB2YWx1ZXMgeW91IGtub3cgYXJlIHNhZmUuIFRvIGRvIHNvLCBiaW5kIHRvXHJcbiAqIGFuIGV4cGxpY2l0bHkgdHJ1c3RlZCB2YWx1ZSB2aWEge0BsaW5rIG5nLiRzY2UjdHJ1c3RBc0h0bWwgJHNjZS50cnVzdEFzSHRtbH0uICBTZWUgdGhlIGV4YW1wbGVcclxuICogdW5kZXIge0BsaW5rIG5nLiRzY2UjRXhhbXBsZSBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyAoU0NFKX0uXHJcbiAqXHJcbiAqIE5vdGU6IElmIGEgYCRzYW5pdGl6ZWAgc2VydmljZSBpcyB1bmF2YWlsYWJsZSBhbmQgdGhlIGJvdW5kIHZhbHVlIGlzbid0IGV4cGxpY2l0bHkgdHJ1c3RlZCwgeW91XHJcbiAqIHdpbGwgaGF2ZSBhbiBleGNlcHRpb24gKGluc3RlYWQgb2YgYW4gZXhwbG9pdC4pXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQmluZEh0bWwge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUuXHJcbiAqL1xyXG52YXIgbmdCaW5kSHRtbERpcmVjdGl2ZSA9IFsnJHNjZScsIGZ1bmN0aW9uKCRzY2UpIHtcclxuICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ25nLWJpbmRpbmcnKS5kYXRhKCckYmluZGluZycsIGF0dHIubmdCaW5kSHRtbCk7XHJcbiAgICBzY29wZS4kd2F0Y2goYXR0ci5uZ0JpbmRIdG1sLCBmdW5jdGlvbiBuZ0JpbmRIdG1sV2F0Y2hBY3Rpb24odmFsdWUpIHtcclxuICAgICAgZWxlbWVudC5odG1sKCRzY2UuZ2V0VHJ1c3RlZEh0bWwodmFsdWUpIHx8ICcnKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1dO1xyXG5cclxuZnVuY3Rpb24gY2xhc3NEaXJlY3RpdmUobmFtZSwgc2VsZWN0b3IpIHtcclxuICBuYW1lID0gJ25nQ2xhc3MnICsgbmFtZTtcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXN0cmljdDogJ0FDJyxcclxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICAgICAgICB2YXIgb2xkVmFsID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBzY29wZS4kd2F0Y2goYXR0cltuYW1lXSwgbmdDbGFzc1dhdGNoQWN0aW9uLCB0cnVlKTtcclxuXHJcbiAgICAgICAgYXR0ci4kb2JzZXJ2ZSgnY2xhc3MnLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgbmdDbGFzc1dhdGNoQWN0aW9uKHNjb3BlLiRldmFsKGF0dHJbbmFtZV0pKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIGlmIChuYW1lICE9PSAnbmdDbGFzcycpIHtcclxuICAgICAgICAgIHNjb3BlLiR3YXRjaCgnJGluZGV4JywgZnVuY3Rpb24oJGluZGV4LCBvbGQkaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIG1vZCA9ICRpbmRleCAmIDE7XHJcbiAgICAgICAgICAgIGlmIChtb2QgIT09IG9sZCRpbmRleCAmIDEpIHtcclxuICAgICAgICAgICAgICBpZiAobW9kID09PSBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3Moc2NvcGUuJGV2YWwoYXR0cltuYW1lXSkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhzY29wZS4kZXZhbChhdHRyW25hbWVdKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBuZ0NsYXNzV2F0Y2hBY3Rpb24obmV3VmFsKSB7XHJcbiAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IHRydWUgfHwgc2NvcGUuJGluZGV4ICUgMiA9PT0gc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKG9sZFZhbCAmJiAhZXF1YWxzKG5ld1ZhbCxvbGRWYWwpKSB7XHJcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Mob2xkVmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRDbGFzcyhuZXdWYWwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgb2xkVmFsID0gY29weShuZXdWYWwpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzVmFsKSB7XHJcbiAgICAgICAgICBhdHRyLiRyZW1vdmVDbGFzcyhmbGF0dGVuQ2xhc3NlcyhjbGFzc1ZhbCkpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZENsYXNzKGNsYXNzVmFsKSB7XHJcbiAgICAgICAgICBhdHRyLiRhZGRDbGFzcyhmbGF0dGVuQ2xhc3NlcyhjbGFzc1ZhbCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZmxhdHRlbkNsYXNzZXMoY2xhc3NWYWwpIHtcclxuICAgICAgICAgIGlmKGlzQXJyYXkoY2xhc3NWYWwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc1ZhbC5qb2luKCcgJyk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGNsYXNzVmFsKSkge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFtdLCBpID0gMDtcclxuICAgICAgICAgICAgZm9yRWFjaChjbGFzc1ZhbCwgZnVuY3Rpb24odiwgaykge1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goayk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBjbGFzc1ZhbDtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0NsYXNzXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgYG5nQ2xhc3NgIGFsbG93cyB5b3UgdG8gc2V0IENTUyBjbGFzc2VzIG9uIEhUTUwgYW4gZWxlbWVudCwgZHluYW1pY2FsbHksIGJ5IGRhdGFiaW5kaW5nXHJcbiAqIGFuIGV4cHJlc3Npb24gdGhhdCByZXByZXNlbnRzIGFsbCBjbGFzc2VzIHRvIGJlIGFkZGVkLlxyXG4gKlxyXG4gKiBUaGUgZGlyZWN0aXZlIHdvbid0IGFkZCBkdXBsaWNhdGUgY2xhc3NlcyBpZiBhIHBhcnRpY3VsYXIgY2xhc3Mgd2FzIGFscmVhZHkgc2V0LlxyXG4gKlxyXG4gKiBXaGVuIHRoZSBleHByZXNzaW9uIGNoYW5nZXMsIHRoZSBwcmV2aW91c2x5IGFkZGVkIGNsYXNzZXMgYXJlIHJlbW92ZWQgYW5kIG9ubHkgdGhlbiB0aGVcclxuICogbmV3IGNsYXNzZXMgYXJlIGFkZGVkLlxyXG4gKlxyXG4gKiBAYW5pbWF0aW9uc1xyXG4gKiBhZGQgLSBoYXBwZW5zIGp1c3QgYmVmb3JlIHRoZSBjbGFzcyBpcyBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XHJcbiAqIHJlbW92ZSAtIGhhcHBlbnMganVzdCBiZWZvcmUgdGhlIGNsYXNzIGlzIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudFxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0NsYXNzIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWwuIFRoZSByZXN1bHRcclxuICogICBvZiB0aGUgZXZhbHVhdGlvbiBjYW4gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHNwYWNlIGRlbGltaXRlZCBjbGFzc1xyXG4gKiAgIG5hbWVzLCBhbiBhcnJheSwgb3IgYSBtYXAgb2YgY2xhc3MgbmFtZXMgdG8gYm9vbGVhbiB2YWx1ZXMuIEluIHRoZSBjYXNlIG9mIGEgbWFwLCB0aGVcclxuICogICBuYW1lcyBvZiB0aGUgcHJvcGVydGllcyB3aG9zZSB2YWx1ZXMgYXJlIHRydXRoeSB3aWxsIGJlIGFkZGVkIGFzIGNzcyBjbGFzc2VzIHRvIHRoZVxyXG4gKiAgIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBleGFtcGxlIEV4YW1wbGUgdGhhdCBkZW1vc3RyYXRlcyBiYXNpYyBiaW5kaW5ncyB2aWEgbmdDbGFzcyBkaXJlY3RpdmUuXHJcbiAgIDxleGFtcGxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICAgICA8cCBuZy1jbGFzcz1cIntzdHJpa2U6IHN0cmlrZSwgYm9sZDogYm9sZCwgcmVkOiByZWR9XCI+TWFwIFN5bnRheCBFeGFtcGxlPC9wPlxyXG4gICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwiYm9sZFwiPiBib2xkXHJcbiAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJzdHJpa2VcIj4gc3RyaWtlXHJcbiAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJyZWRcIj4gcmVkXHJcbiAgICAgICA8aHI+XHJcbiAgICAgICA8cCBuZy1jbGFzcz1cInN0eWxlXCI+VXNpbmcgU3RyaW5nIFN5bnRheDwvcD5cclxuICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwic3R5bGVcIiBwbGFjZWhvbGRlcj1cIlR5cGU6IGJvbGQgc3RyaWtlIHJlZFwiPlxyXG4gICAgICAgPGhyPlxyXG4gICAgICAgPHAgbmctY2xhc3M9XCJbc3R5bGUxLCBzdHlsZTIsIHN0eWxlM11cIj5Vc2luZyBBcnJheSBTeW50YXg8L3A+XHJcbiAgICAgICA8aW5wdXQgbmctbW9kZWw9XCJzdHlsZTFcIiBwbGFjZWhvbGRlcj1cIlR5cGU6IGJvbGRcIj48YnI+XHJcbiAgICAgICA8aW5wdXQgbmctbW9kZWw9XCJzdHlsZTJcIiBwbGFjZWhvbGRlcj1cIlR5cGU6IHN0cmlrZVwiPjxicj5cclxuICAgICAgIDxpbnB1dCBuZy1tb2RlbD1cInN0eWxlM1wiIHBsYWNlaG9sZGVyPVwiVHlwZTogcmVkXCI+PGJyPlxyXG4gICAgIDwvZmlsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwic3R5bGUuY3NzXCI+XHJcbiAgICAgICAuc3RyaWtlIHtcclxuICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7XHJcbiAgICAgICB9XHJcbiAgICAgICAuYm9sZCB7XHJcbiAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbiAgICAgICB9XHJcbiAgICAgICAucmVkIHtcclxuICAgICAgICAgICBjb2xvcjogcmVkO1xyXG4gICAgICAgfVxyXG4gICAgIDwvZmlsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cclxuICAgICAgIGl0KCdzaG91bGQgbGV0IHlvdSB0b2dnbGUgdGhlIGNsYXNzJywgZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgcDpmaXJzdCcpLnByb3AoJ2NsYXNzTmFtZScpKS5ub3QoKS50b01hdGNoKC9ib2xkLyk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBwOmZpcnN0JykucHJvcCgnY2xhc3NOYW1lJykpLm5vdCgpLnRvTWF0Y2goL3JlZC8pO1xyXG5cclxuICAgICAgICAgaW5wdXQoJ2JvbGQnKS5jaGVjaygpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgcDpmaXJzdCcpLnByb3AoJ2NsYXNzTmFtZScpKS50b01hdGNoKC9ib2xkLyk7XHJcblxyXG4gICAgICAgICBpbnB1dCgncmVkJykuY2hlY2soKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHA6Zmlyc3QnKS5wcm9wKCdjbGFzc05hbWUnKSkudG9NYXRjaCgvcmVkLyk7XHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgICBpdCgnc2hvdWxkIGxldCB5b3UgdG9nZ2xlIHN0cmluZyBleGFtcGxlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBwOm50aC1vZi10eXBlKDIpJykucHJvcCgnY2xhc3NOYW1lJykpLnRvQmUoJycpO1xyXG4gICAgICAgICBpbnB1dCgnc3R5bGUnKS5lbnRlcigncmVkJyk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBwOm50aC1vZi10eXBlKDIpJykucHJvcCgnY2xhc3NOYW1lJykpLnRvQmUoJ3JlZCcpO1xyXG4gICAgICAgfSk7XHJcblxyXG4gICAgICAgaXQoJ2FycmF5IGV4YW1wbGUgc2hvdWxkIGhhdmUgMyBjbGFzc2VzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBwOmxhc3QnKS5wcm9wKCdjbGFzc05hbWUnKSkudG9CZSgnJyk7XHJcbiAgICAgICAgIGlucHV0KCdzdHlsZTEnKS5lbnRlcignYm9sZCcpO1xyXG4gICAgICAgICBpbnB1dCgnc3R5bGUyJykuZW50ZXIoJ3N0cmlrZScpO1xyXG4gICAgICAgICBpbnB1dCgnc3R5bGUzJykuZW50ZXIoJ3JlZCcpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgcDpsYXN0JykucHJvcCgnY2xhc3NOYW1lJykpLnRvQmUoJ2JvbGQgc3RyaWtlIHJlZCcpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9maWxlPlxyXG4gICA8L2V4YW1wbGU+XHJcblxyXG4gICAjIyBBbmltYXRpb25zXHJcblxyXG4gICBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIHBlcmZvcm0gYW5pbWF0aW9ucyB1c2luZyBuZ0NsYXNzLlxyXG5cclxuICAgPGV4YW1wbGUgYW5pbWF0aW9ucz1cInRydWVcIj5cclxuICAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwic2V0XCIgbmctY2xpY2s9XCJteVZhcj0nbXktY2xhc3MnXCI+XHJcbiAgICAgIDxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCJjbGVhclwiIG5nLWNsaWNrPVwibXlWYXI9JydcIj5cclxuICAgICAgPGJyPlxyXG4gICAgICA8c3BhbiBuZy1jbGFzcz1cIm15VmFyXCI+U2FtcGxlIFRleHQ8L3NwYW4+XHJcbiAgICAgPC9maWxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJzdHlsZS5jc3NcIj5cclxuICAgICAgIC5teS1jbGFzcy1hZGQsIC5teS1jbGFzcy1yZW1vdmUge1xyXG4gICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuICAgICAgICAgLW1vei10cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XHJcbiAgICAgICAgIC1vLXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuICAgICAgICAgdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIC5teS1jbGFzcyxcclxuICAgICAgIC5teS1jbGFzcy1hZGQubXktY2xhc3MtYWRkLWFjdGl2ZSB7XHJcbiAgICAgICAgIGNvbG9yOiByZWQ7XHJcbiAgICAgICAgIGZvbnQtc2l6ZTozZW07XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgLm15LWNsYXNzLXJlbW92ZS5teS1jbGFzcy1yZW1vdmUtYWN0aXZlIHtcclxuICAgICAgICAgZm9udC1zaXplOjEuMGVtO1xyXG4gICAgICAgICBjb2xvcjpibGFjaztcclxuICAgICAgIH1cclxuICAgICA8L2ZpbGU+XHJcbiAgICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLWNsYXNzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBzcGFuJykucHJvcCgnY2xhc3NOYW1lJykpLm5vdCgpLlxyXG4gICAgICAgICAgIHRvTWF0Y2goL215LWNsYXNzLyk7XHJcblxyXG4gICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5lbGVtZW50KCc6YnV0dG9uOmZpcnN0JykuY2xpY2soKTtcclxuXHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBzcGFuJykucHJvcCgnY2xhc3NOYW1lJykpLlxyXG4gICAgICAgICAgIHRvTWF0Y2goL215LWNsYXNzLyk7XHJcblxyXG4gICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5lbGVtZW50KCc6YnV0dG9uOmxhc3QnKS5jbGljaygpO1xyXG5cclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHNwYW4nKS5wcm9wKCdjbGFzc05hbWUnKSkubm90KCkuXHJcbiAgICAgICAgICAgdG9NYXRjaCgvbXktY2xhc3MvKTtcclxuICAgICAgIH0pO1xyXG4gICAgIDwvZmlsZT5cclxuICAgPC9leGFtcGxlPlxyXG5cclxuXHJcbiAgICMjIG5nQ2xhc3MgYW5kIHByZS1leGlzdGluZyBDU1MzIFRyYW5zaXRpb25zL0FuaW1hdGlvbnNcclxuICAgVGhlIG5nQ2xhc3MgZGlyZWN0aXZlIHN0aWxsIHN1cHBvcnRzIENTUzMgVHJhbnNpdGlvbnMvQW5pbWF0aW9ucyBldmVuIGlmIHRoZXkgZG8gbm90IGZvbGxvdyB0aGUgbmdBbmltYXRlIENTUyBuYW1pbmcgc3RydWN0dXJlLlxyXG4gICBUaGVyZWZvcmUsIGlmIGFueSBDU1MzIFRyYW5zaXRpb24vQW5pbWF0aW9uIHN0eWxlcyAob3V0c2lkZSBvZiBuZ0FuaW1hdGUpIGFyZSBzZXQgb24gdGhlIGVsZW1lbnQsIHRoZW4sIGlmIGEgbmdDbGFzcyBhbmltYXRpb25cclxuICAgaXMgdHJpZ2dlcmVkLCB0aGUgbmdDbGFzcyBhbmltYXRpb24gd2lsbCBiZSBza2lwcGVkIHNvIHRoYXQgbmdBbmltYXRlIGNhbiBhbGxvdyBmb3IgdGhlIHByZS1leGlzdGluZyB0cmFuc2l0aW9uIG9yIGFuaW1hdGlvbiB0b1xyXG4gICB0YWtlIG92ZXIuIFRoaXMgcmVzdHJpY3Rpb24gYWxsb3dzIGZvciBuZ0NsYXNzIHRvIHN0aWxsIHdvcmsgd2l0aCBzdGFuZGFyZCBDU1MzIFRyYW5zaXRpb25zL0FuaW1hdGlvbnMgdGhhdCBhcmUgZGVmaW5lZFxyXG4gICBvdXRzaWRlIG9mIG5nQW5pbWF0ZS5cclxuICovXHJcbnZhciBuZ0NsYXNzRGlyZWN0aXZlID0gY2xhc3NEaXJlY3RpdmUoJycsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQ2xhc3NPZGRcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgbmdDbGFzc09kZGAgYW5kIGBuZ0NsYXNzRXZlbmAgZGlyZWN0aXZlcyB3b3JrIGV4YWN0bHkgYXNcclxuICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsYXNzIG5nQ2xhc3N9LCBleGNlcHQgaXQgd29ya3MgaW5cclxuICogY29uanVuY3Rpb24gd2l0aCBgbmdSZXBlYXRgIGFuZCB0YWtlcyBhZmZlY3Qgb25seSBvbiBvZGQgKGV2ZW4pIHJvd3MuXHJcbiAqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIGNhbiBiZSBhcHBsaWVkIG9ubHkgd2l0aGluIGEgc2NvcGUgb2YgYW5cclxuICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1JlcGVhdCBuZ1JlcGVhdH0uXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQ2xhc3NPZGQge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbC4gVGhlIHJlc3VsdFxyXG4gKiAgIG9mIHRoZSBldmFsdWF0aW9uIGNhbiBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgc3BhY2UgZGVsaW1pdGVkIGNsYXNzIG5hbWVzIG9yIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZXhhbXBsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgICAgIDxvbCBuZy1pbml0PVwibmFtZXM9WydKb2huJywgJ01hcnknLCAnQ2F0ZScsICdTdXonXVwiPlxyXG4gICAgICAgICAgPGxpIG5nLXJlcGVhdD1cIm5hbWUgaW4gbmFtZXNcIj5cclxuICAgICAgICAgICA8c3BhbiBuZy1jbGFzcy1vZGQ9XCInb2RkJ1wiIG5nLWNsYXNzLWV2ZW49XCInZXZlbidcIj5cclxuICAgICAgICAgICAgIHt7bmFtZX19XHJcbiAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICA8L29sPlxyXG4gICAgIDwvZmlsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwic3R5bGUuY3NzXCI+XHJcbiAgICAgICAub2RkIHtcclxuICAgICAgICAgY29sb3I6IHJlZDtcclxuICAgICAgIH1cclxuICAgICAgIC5ldmVuIHtcclxuICAgICAgICAgY29sb3I6IGJsdWU7XHJcbiAgICAgICB9XHJcbiAgICAgPC9maWxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBuZy1jbGFzcy1vZGQgYW5kIG5nLWNsYXNzLWV2ZW4nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIGxpOmZpcnN0IHNwYW4nKS5wcm9wKCdjbGFzc05hbWUnKSkuXHJcbiAgICAgICAgICAgdG9NYXRjaCgvb2RkLyk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBsaTpsYXN0IHNwYW4nKS5wcm9wKCdjbGFzc05hbWUnKSkuXHJcbiAgICAgICAgICAgdG9NYXRjaCgvZXZlbi8pO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9maWxlPlxyXG4gICA8L2V4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdDbGFzc09kZERpcmVjdGl2ZSA9IGNsYXNzRGlyZWN0aXZlKCdPZGQnLCAwKTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0NsYXNzRXZlblxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ0NsYXNzT2RkYCBhbmQgYG5nQ2xhc3NFdmVuYCBkaXJlY3RpdmVzIHdvcmsgZXhhY3RseSBhc1xyXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xhc3MgbmdDbGFzc30sIGV4Y2VwdCBpdCB3b3JrcyBpblxyXG4gKiBjb25qdW5jdGlvbiB3aXRoIGBuZ1JlcGVhdGAgYW5kIHRha2VzIGFmZmVjdCBvbmx5IG9uIG9kZCAoZXZlbikgcm93cy5cclxuICpcclxuICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIGFwcGxpZWQgb25seSB3aXRoaW4gYSBzY29wZSBvZiBhblxyXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nUmVwZWF0IG5nUmVwZWF0fS5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdDbGFzc0V2ZW4ge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbC4gVGhlXHJcbiAqICAgcmVzdWx0IG9mIHRoZSBldmFsdWF0aW9uIGNhbiBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgc3BhY2UgZGVsaW1pdGVkIGNsYXNzIG5hbWVzIG9yIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZXhhbXBsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxyXG4gICAgICAgIDxvbCBuZy1pbml0PVwibmFtZXM9WydKb2huJywgJ01hcnknLCAnQ2F0ZScsICdTdXonXVwiPlxyXG4gICAgICAgICAgPGxpIG5nLXJlcGVhdD1cIm5hbWUgaW4gbmFtZXNcIj5cclxuICAgICAgICAgICA8c3BhbiBuZy1jbGFzcy1vZGQ9XCInb2RkJ1wiIG5nLWNsYXNzLWV2ZW49XCInZXZlbidcIj5cclxuICAgICAgICAgICAgIHt7bmFtZX19ICZuYnNwOyAmbmJzcDsgJm5ic3A7XHJcbiAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICA8L29sPlxyXG4gICAgIDwvZmlsZT5cclxuICAgICA8ZmlsZSBuYW1lPVwic3R5bGUuY3NzXCI+XHJcbiAgICAgICAub2RkIHtcclxuICAgICAgICAgY29sb3I6IHJlZDtcclxuICAgICAgIH1cclxuICAgICAgIC5ldmVuIHtcclxuICAgICAgICAgY29sb3I6IGJsdWU7XHJcbiAgICAgICB9XHJcbiAgICAgPC9maWxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBuZy1jbGFzcy1vZGQgYW5kIG5nLWNsYXNzLWV2ZW4nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIGxpOmZpcnN0IHNwYW4nKS5wcm9wKCdjbGFzc05hbWUnKSkuXHJcbiAgICAgICAgICAgdG9NYXRjaCgvb2RkLyk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBsaTpsYXN0IHNwYW4nKS5wcm9wKCdjbGFzc05hbWUnKSkuXHJcbiAgICAgICAgICAgdG9NYXRjaCgvZXZlbi8pO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9maWxlPlxyXG4gICA8L2V4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdDbGFzc0V2ZW5EaXJlY3RpdmUgPSBjbGFzc0RpcmVjdGl2ZSgnRXZlbicsIDEpO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQ2xvYWtcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgbmdDbG9ha2AgZGlyZWN0aXZlIGlzIHVzZWQgdG8gcHJldmVudCB0aGUgQW5ndWxhciBodG1sIHRlbXBsYXRlIGZyb20gYmVpbmcgYnJpZWZseVxyXG4gKiBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgaW4gaXRzIHJhdyAodW5jb21waWxlZCkgZm9ybSB3aGlsZSB5b3VyIGFwcGxpY2F0aW9uIGlzIGxvYWRpbmcuIFVzZSB0aGlzXHJcbiAqIGRpcmVjdGl2ZSB0byBhdm9pZCB0aGUgdW5kZXNpcmFibGUgZmxpY2tlciBlZmZlY3QgY2F1c2VkIGJ5IHRoZSBodG1sIHRlbXBsYXRlIGRpc3BsYXkuXHJcbiAqXHJcbiAqIFRoZSBkaXJlY3RpdmUgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQsIGJ1dCB0eXBpY2FsbHkgYSBmaW5lLWdyYWluZWQgYXBwbGljYXRpb24gaXNcclxuICogcHJlZmVycmVkIGluIG9yZGVyIHRvIGJlbmVmaXQgZnJvbSBwcm9ncmVzc2l2ZSByZW5kZXJpbmcgb2YgdGhlIGJyb3dzZXIgdmlldy5cclxuICpcclxuICogYG5nQ2xvYWtgIHdvcmtzIGluIGNvb3BlcmF0aW9uIHdpdGggYSBjc3MgcnVsZSB0aGF0IGlzIGVtYmVkZGVkIHdpdGhpbiBgYW5ndWxhci5qc2AgYW5kXHJcbiAqICBgYW5ndWxhci5taW4uanNgIGZpbGVzLiBGb2xsb3dpbmcgaXMgdGhlIGNzcyBydWxlOlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiBbbmdcXDpjbG9ha10sIFtuZy1jbG9ha10sIFtkYXRhLW5nLWNsb2FrXSwgW3gtbmctY2xvYWtdLCAubmctY2xvYWssIC54LW5nLWNsb2FrIHtcclxuICogICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XHJcbiAqIH1cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIFdoZW4gdGhpcyBjc3MgcnVsZSBpcyBsb2FkZWQgYnkgdGhlIGJyb3dzZXIsIGFsbCBodG1sIGVsZW1lbnRzIChpbmNsdWRpbmcgdGhlaXIgY2hpbGRyZW4pIHRoYXRcclxuICogYXJlIHRhZ2dlZCB3aXRoIHRoZSBgbmctY2xvYWtgIGRpcmVjdGl2ZSBhcmUgaGlkZGVuLiBXaGVuIEFuZ3VsYXIgY29tZXMgYWNyb3NzIHRoaXMgZGlyZWN0aXZlXHJcbiAqIGR1cmluZyB0aGUgY29tcGlsYXRpb24gb2YgdGhlIHRlbXBsYXRlIGl0IGRlbGV0ZXMgdGhlIGBuZ0Nsb2FrYCBlbGVtZW50IGF0dHJpYnV0ZSwgd2hpY2hcclxuICogbWFrZXMgdGhlIGNvbXBpbGVkIGVsZW1lbnQgdmlzaWJsZS5cclxuICpcclxuICogRm9yIHRoZSBiZXN0IHJlc3VsdCwgYGFuZ3VsYXIuanNgIHNjcmlwdCBtdXN0IGJlIGxvYWRlZCBpbiB0aGUgaGVhZCBzZWN0aW9uIG9mIHRoZSBodG1sIGZpbGU7XHJcbiAqIGFsdGVybmF0aXZlbHksIHRoZSBjc3MgcnVsZSAoYWJvdmUpIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIGV4dGVybmFsIHN0eWxlc2hlZXQgb2YgdGhlXHJcbiAqIGFwcGxpY2F0aW9uLlxyXG4gKlxyXG4gKiBMZWdhY3kgYnJvd3NlcnMsIGxpa2UgSUU3LCBkbyBub3QgcHJvdmlkZSBhdHRyaWJ1dGUgc2VsZWN0b3Igc3VwcG9ydCAoYWRkZWQgaW4gQ1NTIDIuMSkgc28gdGhleVxyXG4gKiBjYW5ub3QgbWF0Y2ggdGhlIGBbbmdcXDpjbG9ha11gIHNlbGVjdG9yLiBUbyB3b3JrIGFyb3VuZCB0aGlzIGxpbWl0YXRpb24sIHlvdSBtdXN0IGFkZCB0aGUgY3NzXHJcbiAqIGNsYXNzIGBuZ0Nsb2FrYCBpbiBhZGRpdGlvbiB0byBgbmdDbG9ha2AgZGlyZWN0aXZlIGFzIHNob3duIGluIHRoZSBleGFtcGxlIGJlbG93LlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICpcclxuICogQGV4YW1wbGVcclxuICAgPGRvYzpleGFtcGxlPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICAgIDxkaXYgaWQ9XCJ0ZW1wbGF0ZTFcIiBuZy1jbG9haz57eyAnaGVsbG8nIH19PC9kaXY+XHJcbiAgICAgICAgPGRpdiBpZD1cInRlbXBsYXRlMlwiIG5nLWNsb2FrIGNsYXNzPVwibmctY2xvYWtcIj57eyAnaGVsbG8gSUU3JyB9fTwvZGl2PlxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgaXQoJ3Nob3VsZCByZW1vdmUgdGhlIHRlbXBsYXRlIGRpcmVjdGl2ZSBhbmQgY3NzIGNsYXNzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAjdGVtcGxhdGUxJykuYXR0cignbmctY2xvYWsnKSkuXHJcbiAgICAgICAgICAgbm90KCkudG9CZURlZmluZWQoKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlICN0ZW1wbGF0ZTInKS5hdHRyKCduZy1jbG9haycpKS5cclxuICAgICAgICAgICBub3QoKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqXHJcbiAqL1xyXG52YXIgbmdDbG9ha0RpcmVjdGl2ZSA9IG5nRGlyZWN0aXZlKHtcclxuICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XHJcbiAgICBhdHRyLiRzZXQoJ25nQ2xvYWsnLCB1bmRlZmluZWQpO1xyXG4gICAgZWxlbWVudC5yZW1vdmVDbGFzcygnbmctY2xvYWsnKTtcclxuICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQ29udHJvbGxlclxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ0NvbnRyb2xsZXJgIGRpcmVjdGl2ZSBhc3NpZ25zIGJlaGF2aW9yIHRvIGEgc2NvcGUuIFRoaXMgaXMgYSBrZXkgYXNwZWN0IG9mIGhvdyBhbmd1bGFyXHJcbiAqIHN1cHBvcnRzIHRoZSBwcmluY2lwbGVzIGJlaGluZCB0aGUgTW9kZWwtVmlldy1Db250cm9sbGVyIGRlc2lnbiBwYXR0ZXJuLlxyXG4gKlxyXG4gKiBNVkMgY29tcG9uZW50cyBpbiBhbmd1bGFyOlxyXG4gKlxyXG4gKiAqIE1vZGVsIMOi4oKs4oCdIFRoZSBNb2RlbCBpcyBkYXRhIGluIHNjb3BlIHByb3BlcnRpZXM7IHNjb3BlcyBhcmUgYXR0YWNoZWQgdG8gdGhlIERPTS5cclxuICogKiBWaWV3IMOi4oKs4oCdIFRoZSB0ZW1wbGF0ZSAoSFRNTCB3aXRoIGRhdGEgYmluZGluZ3MpIGlzIHJlbmRlcmVkIGludG8gdGhlIFZpZXcuXHJcbiAqICogQ29udHJvbGxlciDDouKCrOKAnSBUaGUgYG5nQ29udHJvbGxlcmAgZGlyZWN0aXZlIHNwZWNpZmllcyBhIENvbnRyb2xsZXIgY2xhc3M7IHRoZSBjbGFzcyBoYXNcclxuICogICBtZXRob2RzIHRoYXQgdHlwaWNhbGx5IGV4cHJlc3MgdGhlIGJ1c2luZXNzIGxvZ2ljIGJlaGluZCB0aGUgYXBwbGljYXRpb24uXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBhbiBhbHRlcm5hdGl2ZSB3YXkgdG8gZGVmaW5lIGNvbnRyb2xsZXJzIGlzIHZpYSB0aGUge0BsaW5rIG5nUm91dGUuJHJvdXRlICRyb3V0ZX0gc2VydmljZS5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBzY29wZVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQ29udHJvbGxlciBOYW1lIG9mIGEgZ2xvYmFsbHkgYWNjZXNzaWJsZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBvciBhblxyXG4gKiAgICAge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0gdGhhdCBvbiB0aGUgY3VycmVudCBzY29wZSBldmFsdWF0ZXMgdG8gYVxyXG4gKiAgICAgY29uc3RydWN0b3IgZnVuY3Rpb24uIFRoZSBjb250cm9sbGVyIGluc3RhbmNlIGNhbiBmdXJ0aGVyIGJlIHB1Ymxpc2hlZCBpbnRvIHRoZSBzY29wZVxyXG4gKiAgICAgYnkgYWRkaW5nIGBhcyBsb2NhbE5hbWVgIHRoZSBjb250cm9sbGVyIG5hbWUgYXR0cmlidXRlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBIZXJlIGlzIGEgc2ltcGxlIGZvcm0gZm9yIGVkaXRpbmcgdXNlciBjb250YWN0IGluZm9ybWF0aW9uLiBBZGRpbmcsIHJlbW92aW5nLCBjbGVhcmluZywgYW5kXHJcbiAqIGdyZWV0aW5nIGFyZSBtZXRob2RzIGRlY2xhcmVkIG9uIHRoZSBjb250cm9sbGVyIChzZWUgc291cmNlIHRhYikuIFRoZXNlIG1ldGhvZHMgY2FuXHJcbiAqIGVhc2lseSBiZSBjYWxsZWQgZnJvbSB0aGUgYW5ndWxhciBtYXJrdXAuIE5vdGljZSB0aGF0IHRoZSBzY29wZSBiZWNvbWVzIHRoZSBgdGhpc2AgZm9yIHRoZVxyXG4gKiBjb250cm9sbGVyJ3MgaW5zdGFuY2UuIFRoaXMgYWxsb3dzIGZvciBlYXN5IGFjY2VzcyB0byB0aGUgdmlldyBkYXRhIGZyb20gdGhlIGNvbnRyb2xsZXIuIEFsc29cclxuICogbm90aWNlIHRoYXQgYW55IGNoYW5nZXMgdG8gdGhlIGRhdGEgYXJlIGF1dG9tYXRpY2FsbHkgcmVmbGVjdGVkIGluIHRoZSBWaWV3IHdpdGhvdXQgdGhlIG5lZWRcclxuICogZm9yIGEgbWFudWFsIHVwZGF0ZS4gVGhlIGV4YW1wbGUgaXMgaW5jbHVkZWQgaW4gdHdvIGRpZmZlcmVudCBkZWNsYXJhdGlvbiBzdHlsZXMgYmFzZWQgb25cclxuICogeW91ciBzdHlsZSBwcmVmZXJlbmNlcy5cclxuICAgPGRvYzpleGFtcGxlPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICA8c2NyaXB0PlxyXG4gICAgICAgIGZ1bmN0aW9uIFNldHRpbmdzQ29udHJvbGxlcjEoKSB7XHJcbiAgICAgICAgICB0aGlzLm5hbWUgPSBcIkpvaG4gU21pdGhcIjtcclxuICAgICAgICAgIHRoaXMuY29udGFjdHMgPSBbXHJcbiAgICAgICAgICAgIHt0eXBlOiAncGhvbmUnLCB2YWx1ZTogJzQwOCA1NTUgMTIxMid9LFxyXG4gICAgICAgICAgICB7dHlwZTogJ2VtYWlsJywgdmFsdWU6ICdqb2huLnNtaXRoQGV4YW1wbGUub3JnJ30gXTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIFNldHRpbmdzQ29udHJvbGxlcjEucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBhbGVydCh0aGlzLm5hbWUpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFNldHRpbmdzQ29udHJvbGxlcjEucHJvdG90eXBlLmFkZENvbnRhY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHRoaXMuY29udGFjdHMucHVzaCh7dHlwZTogJ2VtYWlsJywgdmFsdWU6ICd5b3VybmFtZUBleGFtcGxlLm9yZyd9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBTZXR0aW5nc0NvbnRyb2xsZXIxLnByb3RvdHlwZS5yZW1vdmVDb250YWN0ID0gZnVuY3Rpb24oY29udGFjdFRvUmVtb3ZlKSB7XHJcbiAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29udGFjdHMuaW5kZXhPZihjb250YWN0VG9SZW1vdmUpO1xyXG4gICAgICAgICAgdGhpcy5jb250YWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIFNldHRpbmdzQ29udHJvbGxlcjEucHJvdG90eXBlLmNsZWFyQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3QpIHtcclxuICAgICAgICAgIGNvbnRhY3QudHlwZSA9ICdwaG9uZSc7XHJcbiAgICAgICAgICBjb250YWN0LnZhbHVlID0gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgIDxkaXYgaWQ9XCJjdHJsLWFzLWV4bXBsXCIgbmctY29udHJvbGxlcj1cIlNldHRpbmdzQ29udHJvbGxlcjEgYXMgc2V0dGluZ3NcIj5cclxuICAgICAgICBOYW1lOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInNldHRpbmdzLm5hbWVcIi8+XHJcbiAgICAgICAgWyA8YSBocmVmPVwiXCIgbmctY2xpY2s9XCJzZXR0aW5ncy5ncmVldCgpXCI+Z3JlZXQ8L2E+IF08YnIvPlxyXG4gICAgICAgIENvbnRhY3Q6XHJcbiAgICAgICAgPHVsPlxyXG4gICAgICAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gc2V0dGluZ3MuY29udGFjdHNcIj5cclxuICAgICAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cImNvbnRhY3QudHlwZVwiPlxyXG4gICAgICAgICAgICAgICA8b3B0aW9uPnBob25lPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgIDxvcHRpb24+ZW1haWw8L29wdGlvbj5cclxuICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwiY29udGFjdC52YWx1ZVwiLz5cclxuICAgICAgICAgICAgWyA8YSBocmVmPVwiXCIgbmctY2xpY2s9XCJzZXR0aW5ncy5jbGVhckNvbnRhY3QoY29udGFjdClcIj5jbGVhcjwvYT5cclxuICAgICAgICAgICAgfCA8YSBocmVmPVwiXCIgbmctY2xpY2s9XCJzZXR0aW5ncy5yZW1vdmVDb250YWN0KGNvbnRhY3QpXCI+WDwvYT4gXVxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDxsaT5bIDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cInNldHRpbmdzLmFkZENvbnRhY3QoKVwiPmFkZDwvYT4gXTwvbGk+XHJcbiAgICAgICA8L3VsPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgPGRvYzpzY2VuYXJpbz5cclxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgY29udHJvbGxlciBhcycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnI2N0cmwtYXMtZXhtcGw+OmlucHV0JykudmFsKCkpLnRvQmUoJ0pvaG4gU21pdGgnKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNjdHJsLWFzLWV4bXBsIGxpOm50aC1jaGlsZCgxKSBpbnB1dCcpLnZhbCgpKVxyXG4gICAgICAgICAgIC50b0JlKCc0MDggNTU1IDEyMTInKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNjdHJsLWFzLWV4bXBsIGxpOm50aC1jaGlsZCgyKSBpbnB1dCcpLnZhbCgpKVxyXG4gICAgICAgICAgIC50b0JlKCdqb2huLnNtaXRoQGV4YW1wbGUub3JnJyk7XHJcblxyXG4gICAgICAgICBlbGVtZW50KCcjY3RybC1hcy1leG1wbCBsaTpmaXJzdCBhOmNvbnRhaW5zKFwiY2xlYXJcIiknKS5jbGljaygpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnI2N0cmwtYXMtZXhtcGwgbGk6Zmlyc3QgaW5wdXQnKS52YWwoKSkudG9CZSgnJyk7XHJcblxyXG4gICAgICAgICBlbGVtZW50KCcjY3RybC1hcy1leG1wbCBsaTpsYXN0IGE6Y29udGFpbnMoXCJhZGRcIiknKS5jbGljaygpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnI2N0cmwtYXMtZXhtcGwgbGk6bnRoLWNoaWxkKDMpIGlucHV0JykudmFsKCkpXHJcbiAgICAgICAgICAgLnRvQmUoJ3lvdXJuYW1lQGV4YW1wbGUub3JnJyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgPHNjcmlwdD5cclxuICAgICAgICBmdW5jdGlvbiBTZXR0aW5nc0NvbnRyb2xsZXIyKCRzY29wZSkge1xyXG4gICAgICAgICAgJHNjb3BlLm5hbWUgPSBcIkpvaG4gU21pdGhcIjtcclxuICAgICAgICAgICRzY29wZS5jb250YWN0cyA9IFtcclxuICAgICAgICAgICAge3R5cGU6J3Bob25lJywgdmFsdWU6JzQwOCA1NTUgMTIxMid9LFxyXG4gICAgICAgICAgICB7dHlwZTonZW1haWwnLCB2YWx1ZTonam9obi5zbWl0aEBleGFtcGxlLm9yZyd9IF07XHJcblxyXG4gICAgICAgICAgJHNjb3BlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgYWxlcnQodGhpcy5uYW1lKTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgJHNjb3BlLmFkZENvbnRhY3QgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICB0aGlzLmNvbnRhY3RzLnB1c2goe3R5cGU6J2VtYWlsJywgdmFsdWU6J3lvdXJuYW1lQGV4YW1wbGUub3JnJ30pO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAkc2NvcGUucmVtb3ZlQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3RUb1JlbW92ZSkge1xyXG4gICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29udGFjdHMuaW5kZXhPZihjb250YWN0VG9SZW1vdmUpO1xyXG4gICAgICAgICAgIHRoaXMuY29udGFjdHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgJHNjb3BlLmNsZWFyQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3QpIHtcclxuICAgICAgICAgICBjb250YWN0LnR5cGUgPSAncGhvbmUnO1xyXG4gICAgICAgICAgIGNvbnRhY3QudmFsdWUgPSAnJztcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICA8L3NjcmlwdD5cclxuICAgICAgPGRpdiBpZD1cImN0cmwtZXhtcGxcIiBuZy1jb250cm9sbGVyPVwiU2V0dGluZ3NDb250cm9sbGVyMlwiPlxyXG4gICAgICAgIE5hbWU6IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwibmFtZVwiLz5cclxuICAgICAgICBbIDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cImdyZWV0KClcIj5ncmVldDwvYT4gXTxici8+XHJcbiAgICAgICAgQ29udGFjdDpcclxuICAgICAgICA8dWw+XHJcbiAgICAgICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxyXG4gICAgICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwiY29udGFjdC50eXBlXCI+XHJcbiAgICAgICAgICAgICAgIDxvcHRpb24+cGhvbmU8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgPG9wdGlvbj5lbWFpbDwvb3B0aW9uPlxyXG4gICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJjb250YWN0LnZhbHVlXCIvPlxyXG4gICAgICAgICAgICBbIDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cImNsZWFyQ29udGFjdChjb250YWN0KVwiPmNsZWFyPC9hPlxyXG4gICAgICAgICAgICB8IDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cInJlbW92ZUNvbnRhY3QoY29udGFjdClcIj5YPC9hPiBdXHJcbiAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgPGxpPlsgPGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwiYWRkQ29udGFjdCgpXCI+YWRkPC9hPiBdPC9saT5cclxuICAgICAgIDwvdWw+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBjb250cm9sbGVyJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1leG1wbD46aW5wdXQnKS52YWwoKSkudG9CZSgnSm9obiBTbWl0aCcpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnI2N0cmwtZXhtcGwgbGk6bnRoLWNoaWxkKDEpIGlucHV0JykudmFsKCkpXHJcbiAgICAgICAgICAgLnRvQmUoJzQwOCA1NTUgMTIxMicpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnI2N0cmwtZXhtcGwgbGk6bnRoLWNoaWxkKDIpIGlucHV0JykudmFsKCkpXHJcbiAgICAgICAgICAgLnRvQmUoJ2pvaG4uc21pdGhAZXhhbXBsZS5vcmcnKTtcclxuXHJcbiAgICAgICAgIGVsZW1lbnQoJyNjdHJsLWV4bXBsIGxpOmZpcnN0IGE6Y29udGFpbnMoXCJjbGVhclwiKScpLmNsaWNrKCk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1leG1wbCBsaTpmaXJzdCBpbnB1dCcpLnZhbCgpKS50b0JlKCcnKTtcclxuXHJcbiAgICAgICAgIGVsZW1lbnQoJyNjdHJsLWV4bXBsIGxpOmxhc3QgYTpjb250YWlucyhcImFkZFwiKScpLmNsaWNrKCk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1leG1wbCBsaTpudGgtY2hpbGQoMykgaW5wdXQnKS52YWwoKSlcclxuICAgICAgICAgICAudG9CZSgneW91cm5hbWVAZXhhbXBsZS5vcmcnKTtcclxuICAgICAgIH0pO1xyXG4gICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICA8L2RvYzpleGFtcGxlPlxyXG5cclxuICovXHJcbnZhciBuZ0NvbnRyb2xsZXJEaXJlY3RpdmUgPSBbZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHNjb3BlOiB0cnVlLFxyXG4gICAgY29udHJvbGxlcjogJ0AnXHJcbiAgfTtcclxufV07XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdDc3BcclxuICogQHByaW9yaXR5IDEwMDBcclxuICpcclxuICogQGVsZW1lbnQgaHRtbFxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogRW5hYmxlcyBbQ1NQIChDb250ZW50IFNlY3VyaXR5IFBvbGljeSldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NlY3VyaXR5L0NTUCkgc3VwcG9ydC5cclxuICogXHJcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gZGV2ZWxvcGluZyB0aGluZ3MgbGlrZSBHb29nbGUgQ2hyb21lIEV4dGVuc2lvbnMuXHJcbiAqIFxyXG4gKiBDU1AgZm9yYmlkcyBhcHBzIHRvIHVzZSBgZXZhbGAgb3IgYEZ1bmN0aW9uKHN0cmluZylgIGdlbmVyYXRlZCBmdW5jdGlvbnMgKGFtb25nIG90aGVyIHRoaW5ncykuXHJcbiAqIEZvciB1cyB0byBiZSBjb21wYXRpYmxlLCB3ZSBqdXN0IG5lZWQgdG8gaW1wbGVtZW50IHRoZSBcImdldHRlckZuXCIgaW4gJHBhcnNlIHdpdGhvdXQgdmlvbGF0aW5nXHJcbiAqIGFueSBvZiB0aGVzZSByZXN0cmljdGlvbnMuXHJcbiAqIFxyXG4gKiBBbmd1bGFySlMgdXNlcyBgRnVuY3Rpb24oc3RyaW5nKWAgZ2VuZXJhdGVkIGZ1bmN0aW9ucyBhcyBhIHNwZWVkIG9wdGltaXphdGlvbi4gQnkgYXBwbHlpbmcgYG5nQ3NwYFxyXG4gKiBpdCBpcyBiZSBwb3NzaWJsZSB0byBvcHQgaW50byB0aGUgQ1NQIGNvbXBhdGlibGUgbW9kZS4gV2hlbiB0aGlzIG1vZGUgaXMgb24gQW5ndWxhckpTIHdpbGxcclxuICogZXZhbHVhdGUgYWxsIGV4cHJlc3Npb25zIHVwIHRvIDMwJSBzbG93ZXIgdGhhbiBpbiBub24tQ1NQIG1vZGUsIGJ1dCBubyBzZWN1cml0eSB2aW9sYXRpb25zIHdpbGxcclxuICogYmUgcmFpc2VkLlxyXG4gKiBcclxuICogSW4gb3JkZXIgdG8gdXNlIHRoaXMgZmVhdHVyZSBwdXQgYG5nQ3NwYCBkaXJlY3RpdmUgb24gdGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgYXBwbGljYXRpb24uXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBUaGlzIGV4YW1wbGUgc2hvd3MgaG93IHRvIGFwcGx5IHRoZSBgbmdDc3BgIGRpcmVjdGl2ZSB0byB0aGUgYGh0bWxgIHRhZy5cclxuICAgPHByZT5cclxuICAgICA8IWRvY3R5cGUgaHRtbD5cclxuICAgICA8aHRtbCBuZy1hcHAgbmctY3NwPlxyXG4gICAgIC4uLlxyXG4gICAgIC4uLlxyXG4gICAgIDwvaHRtbD5cclxuICAgPC9wcmU+XHJcbiAqL1xyXG5cclxudmFyIG5nQ3NwRGlyZWN0aXZlID0gWyckc25pZmZlcicsIGZ1bmN0aW9uKCRzbmlmZmVyKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHByaW9yaXR5OiAxMDAwLFxyXG4gICAgY29tcGlsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICRzbmlmZmVyLmNzcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfTtcclxufV07XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdDbGlja1xyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIG5nQ2xpY2sgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciB3aGVuXHJcbiAqIGVsZW1lbnQgaXMgY2xpY2tlZC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdDbGljayB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXHJcbiAqIGNsaWNrLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcclxuICpcclxuICogQGV4YW1wbGVcclxuICAgPGRvYzpleGFtcGxlPlxyXG4gICAgIDxkb2M6c291cmNlPlxyXG4gICAgICA8YnV0dG9uIG5nLWNsaWNrPVwiY291bnQgPSBjb3VudCArIDFcIiBuZy1pbml0PVwiY291bnQ9MFwiPlxyXG4gICAgICAgIEluY3JlbWVudFxyXG4gICAgICA8L2J1dHRvbj5cclxuICAgICAgY291bnQ6IHt7Y291bnR9fVxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBuZy1jbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnY291bnQnKSkudG9CZSgnMCcpO1xyXG4gICAgICAgICBlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSA6YnV0dG9uJykuY2xpY2soKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2NvdW50JykpLnRvQmUoJzEnKTtcclxuICAgICAgIH0pO1xyXG4gICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICA8L2RvYzpleGFtcGxlPlxyXG4gKi9cclxuLypcclxuICogQSBkaXJlY3RpdmUgdGhhdCBhbGxvd3MgY3JlYXRpb24gb2YgY3VzdG9tIG9uY2xpY2sgaGFuZGxlcnMgdGhhdCBhcmUgZGVmaW5lZCBhcyBhbmd1bGFyXHJcbiAqIGV4cHJlc3Npb25zIGFuZCBhcmUgY29tcGlsZWQgYW5kIGV4ZWN1dGVkIHdpdGhpbiB0aGUgY3VycmVudCBzY29wZS5cclxuICpcclxuICogRXZlbnRzIHRoYXQgYXJlIGhhbmRsZWQgdmlhIHRoZXNlIGhhbmRsZXIgYXJlIGFsd2F5cyBjb25maWd1cmVkIG5vdCB0byBwcm9wYWdhdGUgZnVydGhlci5cclxuICovXHJcbnZhciBuZ0V2ZW50RGlyZWN0aXZlcyA9IHt9O1xyXG5mb3JFYWNoKFxyXG4gICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBrZXlkb3duIGtleXVwIGtleXByZXNzIHN1Ym1pdCBmb2N1cyBibHVyJy5zcGxpdCgnICcpLFxyXG4gIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHZhciBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlTm9ybWFsaXplKCduZy0nICsgbmFtZSk7XHJcbiAgICBuZ0V2ZW50RGlyZWN0aXZlc1tkaXJlY3RpdmVOYW1lXSA9IFsnJHBhcnNlJywgZnVuY3Rpb24oJHBhcnNlKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gICAgICAgIHZhciBmbiA9ICRwYXJzZShhdHRyW2RpcmVjdGl2ZU5hbWVdKTtcclxuICAgICAgICBlbGVtZW50Lm9uKGxvd2VyY2FzZShuYW1lKSwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZm4oc2NvcGUsIHskZXZlbnQ6ZXZlbnR9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgfV07XHJcbiAgfVxyXG4pO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nRGJsY2xpY2tcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgbmdEYmxjbGlja2AgZGlyZWN0aXZlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gZGJsY2xpY2sgZXZlbnQuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nRGJsY2xpY2sge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUgdXBvblxyXG4gKiBkYmxjbGljay4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFNlZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xpY2sgbmdDbGlja31cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTW91c2Vkb3duXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgbmdNb3VzZWRvd24gZGlyZWN0aXZlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gbW91c2Vkb3duIGV2ZW50LlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ01vdXNlZG93biB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXHJcbiAqIG1vdXNlZG93bi4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFNlZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xpY2sgbmdDbGlja31cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTW91c2V1cFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gbW91c2V1cCBldmVudC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdNb3VzZXVwIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cclxuICogbW91c2V1cC4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFNlZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xpY2sgbmdDbGlja31cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdNb3VzZW92ZXJcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFNwZWNpZnkgY3VzdG9tIGJlaGF2aW9yIG9uIG1vdXNlb3ZlciBldmVudC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdNb3VzZW92ZXIge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUgdXBvblxyXG4gKiBtb3VzZW92ZXIuIChFdmVudCBvYmplY3QgaXMgYXZhaWxhYmxlIGFzIGAkZXZlbnRgKVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBTZWUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrIG5nQ2xpY2t9XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vdXNlZW50ZXJcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFNwZWNpZnkgY3VzdG9tIGJlaGF2aW9yIG9uIG1vdXNlZW50ZXIgZXZlbnQuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nTW91c2VlbnRlciB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXHJcbiAqIG1vdXNlZW50ZXIuIChFdmVudCBvYmplY3QgaXMgYXZhaWxhYmxlIGFzIGAkZXZlbnRgKVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBTZWUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrIG5nQ2xpY2t9XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vdXNlbGVhdmVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFNwZWNpZnkgY3VzdG9tIGJlaGF2aW9yIG9uIG1vdXNlbGVhdmUgZXZlbnQuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nTW91c2VsZWF2ZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXHJcbiAqIG1vdXNlbGVhdmUuIChFdmVudCBvYmplY3QgaXMgYXZhaWxhYmxlIGFzIGAkZXZlbnRgKVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBTZWUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrIG5nQ2xpY2t9XHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vdXNlbW92ZVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gbW91c2Vtb3ZlIGV2ZW50LlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ01vdXNlbW92ZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXHJcbiAqIG1vdXNlbW92ZS4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFNlZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xpY2sgbmdDbGlja31cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nS2V5ZG93blxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24ga2V5ZG93biBldmVudC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdLZXlkb3duIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cclxuICoga2V5ZG93bi4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGAgYW5kIGNhbiBiZSBpbnRlcnJvZ2F0ZWQgZm9yIGtleUNvZGUsIGFsdEtleSwgZXRjLilcclxuICpcclxuICogQGV4YW1wbGVcclxuICogU2VlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdLZXl1cFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24ga2V5dXAgZXZlbnQuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nS2V5dXAge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUgdXBvblxyXG4gKiBrZXl1cC4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGAgYW5kIGNhbiBiZSBpbnRlcnJvZ2F0ZWQgZm9yIGtleUNvZGUsIGFsdEtleSwgZXRjLilcclxuICpcclxuICogQGV4YW1wbGVcclxuICogU2VlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdLZXlwcmVzc1xyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24ga2V5cHJlc3MgZXZlbnQuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nS2V5cHJlc3Mge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUgdXBvblxyXG4gKiBrZXlwcmVzcy4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGAgYW5kIGNhbiBiZSBpbnRlcnJvZ2F0ZWQgZm9yIGtleUNvZGUsIGFsdEtleSwgZXRjLilcclxuICpcclxuICogQGV4YW1wbGVcclxuICogU2VlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfVxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdTdWJtaXRcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEVuYWJsZXMgYmluZGluZyBhbmd1bGFyIGV4cHJlc3Npb25zIHRvIG9uc3VibWl0IGV2ZW50cy5cclxuICpcclxuICogQWRkaXRpb25hbGx5IGl0IHByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiAod2hpY2ggZm9yIGZvcm0gbWVhbnMgc2VuZGluZyB0aGUgcmVxdWVzdCB0byB0aGVcclxuICogc2VydmVyIGFuZCByZWxvYWRpbmcgdGhlIGN1cnJlbnQgcGFnZSkgKipidXQgb25seSBpZiB0aGUgZm9ybSBkb2VzIG5vdCBjb250YWluIGFuIGBhY3Rpb25gXHJcbiAqIGF0dHJpYnV0ZSoqLlxyXG4gKlxyXG4gKiBAZWxlbWVudCBmb3JtXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdTdWJtaXQge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbC4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgPHNjcmlwdD5cclxuICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgJHNjb3BlLmxpc3QgPSBbXTtcclxuICAgICAgICAgICRzY29wZS50ZXh0ID0gJ2hlbGxvJztcclxuICAgICAgICAgICRzY29wZS5zdWJtaXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dCkge1xyXG4gICAgICAgICAgICAgIHRoaXMubGlzdC5wdXNoKHRoaXMudGV4dCk7XHJcbiAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICA8L3NjcmlwdD5cclxuICAgICAgPGZvcm0gbmctc3VibWl0PVwic3VibWl0KClcIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgIEVudGVyIHRleHQgYW5kIGhpdCBlbnRlcjpcclxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInRleHRcIiBuYW1lPVwidGV4dFwiIC8+XHJcbiAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiBpZD1cInN1Ym1pdFwiIHZhbHVlPVwiU3VibWl0XCIgLz5cclxuICAgICAgICA8cHJlPmxpc3Q9e3tsaXN0fX08L3ByZT5cclxuICAgICAgPC9mb3JtPlxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBuZy1zdWJtaXQnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2xpc3QnKSkudG9CZSgnW10nKTtcclxuICAgICAgICAgZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI3N1Ym1pdCcpLmNsaWNrKCk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdsaXN0JykpLnRvQmUoJ1tcImhlbGxvXCJdJyk7XHJcbiAgICAgICAgIGV4cGVjdChpbnB1dCgndGV4dCcpLnZhbCgpKS50b0JlKCcnKTtcclxuICAgICAgIH0pO1xyXG4gICAgICAgaXQoJ3Nob3VsZCBpZ25vcmUgZW1wdHkgc3RyaW5ncycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnbGlzdCcpKS50b0JlKCdbXScpO1xyXG4gICAgICAgICBlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAjc3VibWl0JykuY2xpY2soKTtcclxuICAgICAgICAgZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI3N1Ym1pdCcpLmNsaWNrKCk7XHJcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdsaXN0JykpLnRvQmUoJ1tcImhlbGxvXCJdJyk7XHJcbiAgICAgICB9KTtcclxuICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgPC9kb2M6ZXhhbXBsZT5cclxuICovXHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdGb2N1c1xyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gZm9jdXMgZXZlbnQuXHJcbiAqXHJcbiAqIEBlbGVtZW50IHdpbmRvdywgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGFcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0ZvY3VzIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cclxuICogZm9jdXMuIChFdmVudCBvYmplY3QgaXMgYXZhaWxhYmxlIGFzIGAkZXZlbnRgKVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBTZWUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrIG5nQ2xpY2t9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQmx1clxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gYmx1ciBldmVudC5cclxuICpcclxuICogQGVsZW1lbnQgd2luZG93LCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgYVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQmx1ciB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXHJcbiAqIGJsdXIuIChFdmVudCBvYmplY3QgaXMgYXZhaWxhYmxlIGFzIGAkZXZlbnRgKVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBTZWUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrIG5nQ2xpY2t9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nSWZcclxuICogQHJlc3RyaWN0IEFcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgbmdJZmAgZGlyZWN0aXZlIHJlbW92ZXMgYW5kIHJlY3JlYXRlcyBhIHBvcnRpb24gb2YgdGhlIERPTSB0cmVlIChIVE1MKVxyXG4gKiBjb25kaXRpb25hbGx5IGJhc2VkIG9uICoqXCJmYWxzeVwiKiogYW5kICoqXCJ0cnV0aHlcIioqIHZhbHVlcywgcmVzcGVjdGl2ZWx5LCBldmFsdWF0ZWQgd2l0aGluXHJcbiAqIGFuIHtleHByZXNzaW9ufS4gSW4gb3RoZXIgd29yZHMsIGlmIHRoZSBleHByZXNzaW9uIGFzc2lnbmVkIHRvICoqbmdJZiBldmFsdWF0ZXMgdG8gYSBmYWxzZVxyXG4gKiB2YWx1ZSoqIHRoZW4gKip0aGUgZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSoqIGFuZCAqKmlmIHRydWUqKiB0aGVuICoqYSBjbG9uZSBvZiB0aGVcclxuICogZWxlbWVudCBpcyByZWluc2VydGVkIGludG8gdGhlIERPTSoqLlxyXG4gKlxyXG4gKiBgbmdJZmAgZGlmZmVycyBmcm9tIGBuZ1Nob3dgIGFuZCBgbmdIaWRlYCBpbiB0aGF0IGBuZ0lmYCBjb21wbGV0ZWx5IHJlbW92ZXMgYW5kIHJlY3JlYXRlcyB0aGVcclxuICogZWxlbWVudCBpbiB0aGUgRE9NIHJhdGhlciB0aGFuIGNoYW5naW5nIGl0cyB2aXNpYmlsaXR5IHZpYSB0aGUgYGRpc3BsYXlgIGNzcyBwcm9wZXJ0eS4gIEEgY29tbW9uXHJcbiAqIGNhc2Ugd2hlbiB0aGlzIGRpZmZlcmVuY2UgaXMgc2lnbmlmaWNhbnQgaXMgd2hlbiB1c2luZyBjc3Mgc2VsZWN0b3JzIHRoYXQgcmVseSBvbiBhbiBlbGVtZW50J3NcclxuICogcG9zaXRpb24gd2l0aGluIHRoZSBET00gKEhUTUwpLCBzdWNoIGFzIHRoZSBgOmZpcnN0LWNoaWxkYCBvciBgOmxhc3QtY2hpbGRgIHBzZXVkby1jbGFzc2VzLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgKip3aGVuIGFuIGVsZW1lbnQgaXMgcmVtb3ZlZCB1c2luZyBuZ0lmIGl0cyBzY29wZSBpcyBkZXN0cm95ZWQqKiBhbmQgKiphIG5ldyBzY29wZVxyXG4gKiBpcyBjcmVhdGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVzdG9yZWQqKi4gIFRoZSBzY29wZSBjcmVhdGVkIHdpdGhpbiBgbmdJZmAgaW5oZXJpdHMgZnJvbSBcclxuICogaXRzIHBhcmVudCBzY29wZSB1c2luZ1xyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy93aWtpL1RoZS1OdWFuY2VzLW9mLVNjb3BlLVByb3RvdHlwYWwtSW5oZXJpdGFuY2UgcHJvdG90eXBhbCBpbmhlcml0YW5jZX0uXHJcbiAqIEFuIGltcG9ydGFudCBpbXBsaWNhdGlvbiBvZiB0aGlzIGlzIGlmIGBuZ01vZGVsYCBpcyB1c2VkIHdpdGhpbiBgbmdJZmAgdG8gYmluZCB0b1xyXG4gKiBhIGphdmFzY3JpcHQgcHJpbWl0aXZlIGRlZmluZWQgaW4gdGhlIHBhcmVudCBzY29wZS4gSW4gdGhpcyBjYXNlIGFueSBtb2RpZmljYXRpb25zIG1hZGUgdG8gdGhlXHJcbiAqIHZhcmlhYmxlIHdpdGhpbiB0aGUgY2hpbGQgc2NvcGUgd2lsbCBvdmVycmlkZSAoaGlkZSkgdGhlIHZhbHVlIGluIHRoZSBwYXJlbnQgc2NvcGUuXHJcbiAqXHJcbiAqIEFsc28sIGBuZ0lmYCByZWNyZWF0ZXMgZWxlbWVudHMgdXNpbmcgdGhlaXIgY29tcGlsZWQgc3RhdGUuIEFuIGV4YW1wbGUgc2NlbmFyaW8gb2YgdGhpcyBiZWhhdmlvclxyXG4gKiBpcyBpZiBhbiBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlIGlzIGRpcmVjdGx5IG1vZGlmaWVkIGFmdGVyIGl0J3MgY29tcGlsZWQsIHVzaW5nIHNvbWV0aGluZyBsaWtlIFxyXG4gKiBqUXVlcnkncyBgLmFkZENsYXNzKClgIG1ldGhvZCwgYW5kIHRoZSBlbGVtZW50IGlzIGxhdGVyIHJlbW92ZWQuIFdoZW4gYG5nSWZgIHJlY3JlYXRlcyB0aGUgZWxlbWVudFxyXG4gKiB0aGUgYWRkZWQgY2xhc3Mgd2lsbCBiZSBsb3N0IGJlY2F1c2UgdGhlIG9yaWdpbmFsIGNvbXBpbGVkIHN0YXRlIGlzIHVzZWQgdG8gcmVnZW5lcmF0ZSB0aGUgZWxlbWVudC5cclxuICpcclxuICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIHByb3ZpZGUgYW5pbWF0aW9ucyB2aWEgdGhlIG5nQW5pbWF0ZSBtb2R1bGUgdG8gYW5pbWF0ZSB0aGUgKiplbnRlcioqXHJcbiAqIGFuZCAqKmxlYXZlKiogZWZmZWN0cy5cclxuICpcclxuICogQGFuaW1hdGlvbnNcclxuICogZW50ZXIgLSBoYXBwZW5zIGp1c3QgYWZ0ZXIgdGhlIG5nSWYgY29udGVudHMgY2hhbmdlIGFuZCBhIG5ldyBET00gZWxlbWVudCBpcyBjcmVhdGVkIGFuZCBpbmplY3RlZCBpbnRvIHRoZSBuZ0lmIGNvbnRhaW5lclxyXG4gKiBsZWF2ZSAtIGhhcHBlbnMganVzdCBiZWZvcmUgdGhlIG5nSWYgY29udGVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAc2NvcGVcclxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0lmIElmIHRoZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpcyBmYWxzeSB0aGVuXHJcbiAqICAgICB0aGUgZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSB0cmVlIChIVE1MKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICA8ZXhhbXBsZSBhbmltYXRpb25zPVwidHJ1ZVwiPlxyXG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgICAgQ2xpY2sgbWU6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImNoZWNrZWRcIiBuZy1pbml0PVwiY2hlY2tlZD10cnVlXCIgLz48YnIvPlxyXG4gICAgICBTaG93IHdoZW4gY2hlY2tlZDpcclxuICAgICAgPHNwYW4gbmctaWY9XCJjaGVja2VkXCIgY2xhc3M9XCJhbmltYXRlLWlmXCI+XHJcbiAgICAgICAgSSdtIHJlbW92ZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgdW5jaGVja2VkLlxyXG4gICAgICA8L3NwYW4+XHJcbiAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwiYW5pbWF0aW9ucy5jc3NcIj5cclxuICAgICAgLmFuaW1hdGUtaWYge1xyXG4gICAgICAgIGJhY2tncm91bmQ6d2hpdGU7XHJcbiAgICAgICAgYm9yZGVyOjFweCBzb2xpZCBibGFjaztcclxuICAgICAgICBwYWRkaW5nOjEwcHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5hbmltYXRlLWlmLm5nLWVudGVyLCAuYW5pbWF0ZS1pZi5uZy1sZWF2ZSB7XHJcbiAgICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XHJcbiAgICAgICAgLW1vei10cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XHJcbiAgICAgICAgLW8tdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG4gICAgICAgIHRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtaWYubmctZW50ZXIsXHJcbiAgICAgIC5hbmltYXRlLWlmLm5nLWxlYXZlLm5nLWxlYXZlLWFjdGl2ZSB7XHJcbiAgICAgICAgb3BhY2l0eTowO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuYW5pbWF0ZS1pZi5uZy1lbnRlci5uZy1lbnRlci1hY3RpdmUsXHJcbiAgICAgIC5hbmltYXRlLWlmLm5nLWxlYXZlIHtcclxuICAgICAgICBvcGFjaXR5OjE7XHJcbiAgICAgIH1cclxuICAgIDwvZmlsZT5cclxuICA8L2V4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdJZkRpcmVjdGl2ZSA9IFsnJGFuaW1hdGUnLCBmdW5jdGlvbigkYW5pbWF0ZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXHJcbiAgICBwcmlvcml0eTogMTAwMCxcclxuICAgIHRlcm1pbmFsOiB0cnVlLFxyXG4gICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyLCB0cmFuc2NsdWRlKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoJHNjb3BlLCAkZWxlbWVudCwgJGF0dHIpIHtcclxuICAgICAgICB2YXIgY2hpbGRFbGVtZW50LCBjaGlsZFNjb3BlO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goJGF0dHIubmdJZiwgZnVuY3Rpb24gbmdJZldhdGNoQWN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICBpZiAoY2hpbGRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICRhbmltYXRlLmxlYXZlKGNoaWxkRWxlbWVudCk7XHJcbiAgICAgICAgICAgIGNoaWxkRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChjaGlsZFNjb3BlKSB7XHJcbiAgICAgICAgICAgIGNoaWxkU2NvcGUuJGRlc3Ryb3koKTtcclxuICAgICAgICAgICAgY2hpbGRTY29wZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0b0Jvb2xlYW4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGNoaWxkU2NvcGUgPSAkc2NvcGUuJG5ldygpO1xyXG4gICAgICAgICAgICB0cmFuc2NsdWRlKGNoaWxkU2NvcGUsIGZ1bmN0aW9uIChjbG9uZSkge1xyXG4gICAgICAgICAgICAgIGNoaWxkRWxlbWVudCA9IGNsb25lO1xyXG4gICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGNsb25lLCAkZWxlbWVudC5wYXJlbnQoKSwgJGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufV07XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdJbmNsdWRlXHJcbiAqIEByZXN0cmljdCBFQ0FcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEZldGNoZXMsIGNvbXBpbGVzIGFuZCBpbmNsdWRlcyBhbiBleHRlcm5hbCBIVE1MIGZyYWdtZW50LlxyXG4gKlxyXG4gKiBLZWVwIGluIG1pbmQgdGhhdDpcclxuICpcclxuICogLSAgICBieSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgVVJMIGlzIHJlc3RyaWN0ZWQgdG8gdGhlIHNhbWUgZG9tYWluIGFuZCBwcm90b2NvbCBhcyB0aGVcclxuICogICAgICBhcHBsaWNhdGlvbiBkb2N1bWVudC4gIFRoaXMgaXMgZG9uZSBieSBjYWxsaW5nIHtAbGluayBuZy4kc2NlI2dldFRydXN0ZWRSZXNvdXJjZVVybFxyXG4gKiAgICAgICRzY2UuZ2V0VHJ1c3RlZFJlc291cmNlVXJsfSBvbiBpdC4gIFRvIGxvYWQgdGVtcGxhdGVzIGZyb20gb3RoZXIgZG9tYWlucyBhbmQvb3IgcHJvdG9jb2xzLFxyXG4gKiAgICAgIHlvdSBtYXkgZWl0aGVyIGVpdGhlciB7QGxpbmsgbmcuJHNjZURlbGVnYXRlUHJvdmlkZXIjcmVzb3VyY2VVcmxXaGl0ZWxpc3Qgd2hpdGVsaXN0IHRoZW19IG9yXHJcbiAqICAgICAge0BsaW5rIG5nLiRzY2UjdHJ1c3RBc1Jlc291cmNlVXJsIHdyYXAgaXR9IGludG8gYSB0cnVzdGVkIHZhbHVlLiAgUmVmZXIgQW5ndWxhcidzIHtAbGlua1xyXG4gKiAgICAgIG5nLiRzY2UgU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmd9LlxyXG4gKiAtICAgIGluIGFkZGl0aW9uLCB0aGUgYnJvd3NlcidzXHJcbiAqICAgICAge0BsaW5rIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvYnJvd3NlcnNlYy93aWtpL1BhcnQyI1NhbWUtb3JpZ2luX3BvbGljeV9mb3JfWE1MSHR0cFJlcXVlc3RcclxuICogICAgICBTYW1lIE9yaWdpbiBQb2xpY3l9IGFuZCB7QGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvY29ycy8gQ3Jvc3MtT3JpZ2luIFJlc291cmNlIFNoYXJpbmdcclxuICogICAgICAoQ09SUyl9IHBvbGljeSBhcHBseSB0aGF0IG1heSBmdXJ0aGVyIHJlc3RyaWN0IHdoZXRoZXIgdGhlIHRlbXBsYXRlIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXHJcbiAqICAgICAgKGUuZy4gIG5nSW5jbHVkZSB3b24ndCB3b3JrIGZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMgb24gYWxsIGJyb3dzZXJzIGFuZCBmb3IgYGZpbGU6Ly9gXHJcbiAqICAgICAgYWNjZXNzIG9uIHNvbWUgYnJvd3NlcnMpXHJcbiAqXHJcbiAqIEBhbmltYXRpb25zXHJcbiAqIGVudGVyIC0gYW5pbWF0aW9uIGlzIHVzZWQgdG8gYnJpbmcgbmV3IGNvbnRlbnQgaW50byB0aGUgYnJvd3Nlci5cclxuICogbGVhdmUgLSBhbmltYXRpb24gaXMgdXNlZCB0byBhbmltYXRlIGV4aXN0aW5nIGNvbnRlbnQgYXdheS5cclxuICpcclxuICogVGhlIGVudGVyIGFuZCBsZWF2ZSBhbmltYXRpb24gb2NjdXIgY29uY3VycmVudGx5LlxyXG4gKlxyXG4gKiBAc2NvcGVcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5nSW5jbHVkZXxzcmMgYW5ndWxhciBleHByZXNzaW9uIGV2YWx1YXRpbmcgdG8gVVJMLiBJZiB0aGUgc291cmNlIGlzIGEgc3RyaW5nIGNvbnN0YW50LFxyXG4gKiAgICAgICAgICAgICAgICAgbWFrZSBzdXJlIHlvdSB3cmFwIGl0IGluIHF1b3RlcywgZS5nLiBgc3JjPVwiJ215UGFydGlhbFRlbXBsYXRlLmh0bWwnXCJgLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG9ubG9hZCBFeHByZXNzaW9uIHRvIGV2YWx1YXRlIHdoZW4gYSBuZXcgcGFydGlhbCBpcyBsb2FkZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gYXV0b3Njcm9sbCBXaGV0aGVyIGBuZ0luY2x1ZGVgIHNob3VsZCBjYWxsIHtAbGluayBuZy4kYW5jaG9yU2Nyb2xsXHJcbiAqICAgICAgICAgICAgICAgICAgJGFuY2hvclNjcm9sbH0gdG8gc2Nyb2xsIHRoZSB2aWV3cG9ydCBhZnRlciB0aGUgY29udGVudCBpcyBsb2FkZWQuXHJcbiAqXHJcbiAqICAgICAgICAgICAgICAgICAgLSBJZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBzZXQsIGRpc2FibGUgc2Nyb2xsaW5nLlxyXG4gKiAgICAgICAgICAgICAgICAgIC0gSWYgdGhlIGF0dHJpYnV0ZSBpcyBzZXQgd2l0aG91dCB2YWx1ZSwgZW5hYmxlIHNjcm9sbGluZy5cclxuICogICAgICAgICAgICAgICAgICAtIE90aGVyd2lzZSBlbmFibGUgc2Nyb2xsaW5nIG9ubHkgaWYgdGhlIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRydXRoeSB2YWx1ZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICA8ZXhhbXBsZSBhbmltYXRpb25zPVwidHJ1ZVwiPlxyXG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XHJcbiAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwidGVtcGxhdGVcIiBuZy1vcHRpb25zPVwidC5uYW1lIGZvciB0IGluIHRlbXBsYXRlc1wiPlxyXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj4oYmxhbmspPC9vcHRpb24+XHJcbiAgICAgICA8L3NlbGVjdD5cclxuICAgICAgIHVybCBvZiB0aGUgdGVtcGxhdGU6IDx0dD57e3RlbXBsYXRlLnVybH19PC90dD5cclxuICAgICAgIDxoci8+XHJcbiAgICAgICA8ZGl2IGNsYXNzPVwiZXhhbXBsZS1hbmltYXRlLWNvbnRhaW5lclwiPlxyXG4gICAgICAgICA8ZGl2IGNsYXNzPVwiaW5jbHVkZS1leGFtcGxlXCIgbmctaW5jbHVkZT1cInRlbXBsYXRlLnVybFwiPjwvZGl2PlxyXG4gICAgICAgPC9kaXY+XHJcbiAgICAgPC9kaXY+XHJcbiAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XHJcbiAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgJHNjb3BlLnRlbXBsYXRlcyA9XHJcbiAgICAgICAgICBbIHsgbmFtZTogJ3RlbXBsYXRlMS5odG1sJywgdXJsOiAndGVtcGxhdGUxLmh0bWwnfVxyXG4gICAgICAgICAgLCB7IG5hbWU6ICd0ZW1wbGF0ZTIuaHRtbCcsIHVybDogJ3RlbXBsYXRlMi5odG1sJ30gXTtcclxuICAgICAgICAkc2NvcGUudGVtcGxhdGUgPSAkc2NvcGUudGVtcGxhdGVzWzBdO1xyXG4gICAgICB9XHJcbiAgICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cInRlbXBsYXRlMS5odG1sXCI+XHJcbiAgICAgIENvbnRlbnQgb2YgdGVtcGxhdGUxLmh0bWxcclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJ0ZW1wbGF0ZTIuaHRtbFwiPlxyXG4gICAgICBDb250ZW50IG9mIHRlbXBsYXRlMi5odG1sXHJcbiAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwiYW5pbWF0aW9ucy5jc3NcIj5cclxuICAgICAgLmV4YW1wbGUtYW5pbWF0ZS1jb250YWluZXIge1xyXG4gICAgICAgIHBvc2l0aW9uOnJlbGF0aXZlO1xyXG4gICAgICAgIGJhY2tncm91bmQ6d2hpdGU7XHJcbiAgICAgICAgYm9yZGVyOjFweCBzb2xpZCBibGFjaztcclxuICAgICAgICBoZWlnaHQ6NDBweDtcclxuICAgICAgICBvdmVyZmxvdzpoaWRkZW47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5leGFtcGxlLWFuaW1hdGUtY29udGFpbmVyID4gZGl2IHtcclxuICAgICAgICBwYWRkaW5nOjEwcHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5pbmNsdWRlLWV4YW1wbGUubmctZW50ZXIsIC5pbmNsdWRlLWV4YW1wbGUubmctbGVhdmUge1xyXG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG4gICAgICAgIC1tb3otdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG4gICAgICAgIC1vLXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuICAgICAgICB0cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XHJcblxyXG4gICAgICAgIHBvc2l0aW9uOmFic29sdXRlO1xyXG4gICAgICAgIHRvcDowO1xyXG4gICAgICAgIGxlZnQ6MDtcclxuICAgICAgICByaWdodDowO1xyXG4gICAgICAgIGJvdHRvbTowO1xyXG4gICAgICAgIGRpc3BsYXk6YmxvY2s7XHJcbiAgICAgICAgcGFkZGluZzoxMHB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuaW5jbHVkZS1leGFtcGxlLm5nLWVudGVyIHtcclxuICAgICAgICB0b3A6LTUwcHg7XHJcbiAgICAgIH1cclxuICAgICAgLmluY2x1ZGUtZXhhbXBsZS5uZy1lbnRlci5uZy1lbnRlci1hY3RpdmUge1xyXG4gICAgICAgIHRvcDowO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuaW5jbHVkZS1leGFtcGxlLm5nLWxlYXZlIHtcclxuICAgICAgICB0b3A6MDtcclxuICAgICAgfVxyXG4gICAgICAuaW5jbHVkZS1leGFtcGxlLm5nLWxlYXZlLm5nLWxlYXZlLWFjdGl2ZSB7XHJcbiAgICAgICAgdG9wOjUwcHg7XHJcbiAgICAgIH1cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxyXG4gICAgICBpdCgnc2hvdWxkIGxvYWQgdGVtcGxhdGUxLmh0bWwnLCBmdW5jdGlvbigpIHtcclxuICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctaW5jbHVkZV0nKS50ZXh0KCkpLlxyXG4gICAgICAgICB0b01hdGNoKC9Db250ZW50IG9mIHRlbXBsYXRlMS5odG1sLyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpdCgnc2hvdWxkIGxvYWQgdGVtcGxhdGUyLmh0bWwnLCBmdW5jdGlvbigpIHtcclxuICAgICAgIHNlbGVjdCgndGVtcGxhdGUnKS5vcHRpb24oJzEnKTtcclxuICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctaW5jbHVkZV0nKS50ZXh0KCkpLlxyXG4gICAgICAgICB0b01hdGNoKC9Db250ZW50IG9mIHRlbXBsYXRlMi5odG1sLyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpdCgnc2hvdWxkIGNoYW5nZSB0byBibGFuaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgc2VsZWN0KCd0ZW1wbGF0ZScpLm9wdGlvbignJyk7XHJcbiAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgW25nLWluY2x1ZGVdJykpLnRvQmUodW5kZWZpbmVkKTtcclxuICAgICAgfSk7XHJcbiAgICA8L2ZpbGU+XHJcbiAgPC9leGFtcGxlPlxyXG4gKi9cclxuXHJcblxyXG4vKipcclxuICogQG5nZG9jIGV2ZW50XHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0luY2x1ZGUjJGluY2x1ZGVDb250ZW50UmVxdWVzdGVkXHJcbiAqIEBldmVudE9mIG5nLmRpcmVjdGl2ZTpuZ0luY2x1ZGVcclxuICogQGV2ZW50VHlwZSBlbWl0IG9uIHRoZSBzY29wZSBuZ0luY2x1ZGUgd2FzIGRlY2xhcmVkIGluXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBFbWl0dGVkIGV2ZXJ5IHRpbWUgdGhlIG5nSW5jbHVkZSBjb250ZW50IGlzIHJlcXVlc3RlZC5cclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBldmVudFxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdJbmNsdWRlIyRpbmNsdWRlQ29udGVudExvYWRlZFxyXG4gKiBAZXZlbnRPZiBuZy5kaXJlY3RpdmU6bmdJbmNsdWRlXHJcbiAqIEBldmVudFR5cGUgZW1pdCBvbiB0aGUgY3VycmVudCBuZ0luY2x1ZGUgc2NvcGVcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEVtaXR0ZWQgZXZlcnkgdGltZSB0aGUgbmdJbmNsdWRlIGNvbnRlbnQgaXMgcmVsb2FkZWQuXHJcbiAqL1xyXG52YXIgbmdJbmNsdWRlRGlyZWN0aXZlID0gWyckaHR0cCcsICckdGVtcGxhdGVDYWNoZScsICckYW5jaG9yU2Nyb2xsJywgJyRjb21waWxlJywgJyRhbmltYXRlJywgJyRzY2UnLFxyXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbigkaHR0cCwgICAkdGVtcGxhdGVDYWNoZSwgICAkYW5jaG9yU2Nyb2xsLCAgICRjb21waWxlLCAgICRhbmltYXRlLCAgICRzY2UpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQ0EnLFxyXG4gICAgdGVybWluYWw6IHRydWUsXHJcbiAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXHJcbiAgICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyLCB0cmFuc2NsdXNpb24pIHtcclxuICAgICAgdmFyIHNyY0V4cCA9IGF0dHIubmdJbmNsdWRlIHx8IGF0dHIuc3JjLFxyXG4gICAgICAgICAgb25sb2FkRXhwID0gYXR0ci5vbmxvYWQgfHwgJycsXHJcbiAgICAgICAgICBhdXRvU2Nyb2xsRXhwID0gYXR0ci5hdXRvc2Nyb2xsO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCAkZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBjaGFuZ2VDb3VudGVyID0gMCxcclxuICAgICAgICAgICAgY3VycmVudFNjb3BlLFxyXG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudDtcclxuXHJcbiAgICAgICAgdmFyIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmIChjdXJyZW50U2NvcGUpIHtcclxuICAgICAgICAgICAgY3VycmVudFNjb3BlLiRkZXN0cm95KCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZihjdXJyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShjdXJyZW50RWxlbWVudCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzY29wZS4kd2F0Y2goJHNjZS5wYXJzZUFzUmVzb3VyY2VVcmwoc3JjRXhwKSwgZnVuY3Rpb24gbmdJbmNsdWRlV2F0Y2hBY3Rpb24oc3JjKSB7XHJcbiAgICAgICAgICB2YXIgdGhpc0NoYW5nZUlkID0gKytjaGFuZ2VDb3VudGVyO1xyXG5cclxuICAgICAgICAgIGlmIChzcmMpIHtcclxuICAgICAgICAgICAgJGh0dHAuZ2V0KHNyYywge2NhY2hlOiAkdGVtcGxhdGVDYWNoZX0pLnN1Y2Nlc3MoZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICBpZiAodGhpc0NoYW5nZUlkICE9PSBjaGFuZ2VDb3VudGVyKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgdmFyIG5ld1Njb3BlID0gc2NvcGUuJG5ldygpO1xyXG5cclxuICAgICAgICAgICAgICB0cmFuc2NsdXNpb24obmV3U2NvcGUsIGZ1bmN0aW9uKGNsb25lKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbmV3U2NvcGU7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGNsb25lO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50Lmh0bWwocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoY3VycmVudEVsZW1lbnQsIG51bGwsICRlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICRjb21waWxlKGN1cnJlbnRFbGVtZW50LmNvbnRlbnRzKCkpKGN1cnJlbnRTY29wZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChhdXRvU2Nyb2xsRXhwKSAmJiAoIWF1dG9TY3JvbGxFeHAgfHwgc2NvcGUuJGV2YWwoYXV0b1Njcm9sbEV4cCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICRhbmNob3JTY3JvbGwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyRpbmNsdWRlQ29udGVudExvYWRlZCcpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUuJGV2YWwob25sb2FkRXhwKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkuZXJyb3IoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRoaXNDaGFuZ2VJZCA9PT0gY2hhbmdlQ291bnRlcikgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2NvcGUuJGVtaXQoJyRpbmNsdWRlQ29udGVudFJlcXVlc3RlZCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn1dO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nSW5pdFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ0luaXRgIGRpcmVjdGl2ZSBzcGVjaWZpZXMgaW5pdGlhbGl6YXRpb24gdGFza3MgdG8gYmUgZXhlY3V0ZWRcclxuICogIGJlZm9yZSB0aGUgdGVtcGxhdGUgZW50ZXJzIGV4ZWN1dGlvbiBtb2RlIGR1cmluZyBib290c3RyYXAuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nSW5pdCB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gICA8ZG9jOmV4YW1wbGU+XHJcbiAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICA8ZGl2IG5nLWluaXQ9XCJncmVldGluZz0nSGVsbG8nOyBwZXJzb249J1dvcmxkJ1wiPlxyXG4gICAgICB7e2dyZWV0aW5nfX0ge3twZXJzb259fSFcclxuICAgIDwvZGl2PlxyXG4gICAgIDwvZG9jOnNvdXJjZT5cclxuICAgICA8ZG9jOnNjZW5hcmlvPlxyXG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBncmVldGluZycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QoYmluZGluZygnZ3JlZXRpbmcnKSkudG9CZSgnSGVsbG8nKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3BlcnNvbicpKS50b0JlKCdXb3JsZCcpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9kb2M6c2NlbmFyaW8+XHJcbiAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdJbml0RGlyZWN0aXZlID0gbmdEaXJlY3RpdmUoe1xyXG4gIGNvbXBpbGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcHJlOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcclxuICAgICAgICBzY29wZS4kZXZhbChhdHRycy5uZ0luaXQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ05vbkJpbmRhYmxlXHJcbiAqIEBwcmlvcml0eSAxMDAwXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTb21ldGltZXMgaXQgaXMgbmVjZXNzYXJ5IHRvIHdyaXRlIGNvZGUgd2hpY2ggbG9va3MgbGlrZSBiaW5kaW5ncyBidXQgd2hpY2ggc2hvdWxkIGJlIGxlZnQgYWxvbmVcclxuICogYnkgYW5ndWxhci4gVXNlIGBuZ05vbkJpbmRhYmxlYCB0byBtYWtlIGFuZ3VsYXIgaWdub3JlIGEgY2h1bmsgb2YgSFRNTC5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIEluIHRoaXMgZXhhbXBsZSB0aGVyZSBhcmUgdHdvIGxvY2F0aW9uIHdoZXJlIGEgc2ltcGxlIGJpbmRpbmcgKGB7e319YCkgaXMgcHJlc2VudCwgYnV0IHRoZSBvbmVcclxuICogd3JhcHBlZCBpbiBgbmdOb25CaW5kYWJsZWAgaXMgbGVmdCBhbG9uZS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgPGRpdj5Ob3JtYWw6IHt7MSArIDJ9fTwvZGl2PlxyXG4gICAgICAgIDxkaXYgbmctbm9uLWJpbmRhYmxlPklnbm9yZWQ6IHt7MSArIDJ9fTwvZGl2PlxyXG4gICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLW5vbi1iaW5kYWJsZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICBleHBlY3QodXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuYmluZGluZygnMSArIDInKSkudG9CZSgnMycpO1xyXG4gICAgICAgICBleHBlY3QodXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuZWxlbWVudCgnZGl2Omxhc3QnKS50ZXh0KCkpLlxyXG4gICAgICAgICAgIHRvTWF0Y2goLzEgXFwrIDIvKTtcclxuICAgICAgIH0pO1xyXG4gICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdOb25CaW5kYWJsZURpcmVjdGl2ZSA9IG5nRGlyZWN0aXZlKHsgdGVybWluYWw6IHRydWUsIHByaW9yaXR5OiAxMDAwIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nUGx1cmFsaXplXHJcbiAqIEByZXN0cmljdCBFQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogIyBPdmVydmlld1xyXG4gKiBgbmdQbHVyYWxpemVgIGlzIGEgZGlyZWN0aXZlIHRoYXQgZGlzcGxheXMgbWVzc2FnZXMgYWNjb3JkaW5nIHRvIGVuLVVTIGxvY2FsaXphdGlvbiBydWxlcy5cclxuICogVGhlc2UgcnVsZXMgYXJlIGJ1bmRsZWQgd2l0aCBhbmd1bGFyLmpzLCBidXQgY2FuIGJlIG92ZXJyaWRkZW5cclxuICogKHNlZSB7QGxpbmsgZ3VpZGUvaTE4biBBbmd1bGFyIGkxOG59IGRldiBndWlkZSkuIFlvdSBjb25maWd1cmUgbmdQbHVyYWxpemUgZGlyZWN0aXZlXHJcbiAqIGJ5IHNwZWNpZnlpbmcgdGhlIG1hcHBpbmdzIGJldHdlZW5cclxuICoge0BsaW5rIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcy9jbGRyLXRtcC90cnVuay9kaWZmL3N1cHBsZW1lbnRhbC9sYW5ndWFnZV9wbHVyYWxfcnVsZXMuaHRtbFxyXG4gKiBwbHVyYWwgY2F0ZWdvcmllc30gYW5kIHRoZSBzdHJpbmdzIHRvIGJlIGRpc3BsYXllZC5cclxuICpcclxuICogIyBQbHVyYWwgY2F0ZWdvcmllcyBhbmQgZXhwbGljaXQgbnVtYmVyIHJ1bGVzXHJcbiAqIFRoZXJlIGFyZSB0d29cclxuICoge0BsaW5rIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcy9jbGRyLXRtcC90cnVuay9kaWZmL3N1cHBsZW1lbnRhbC9sYW5ndWFnZV9wbHVyYWxfcnVsZXMuaHRtbFxyXG4gKiBwbHVyYWwgY2F0ZWdvcmllc30gaW4gQW5ndWxhcidzIGRlZmF1bHQgZW4tVVMgbG9jYWxlOiBcIm9uZVwiIGFuZCBcIm90aGVyXCIuXHJcbiAqXHJcbiAqIFdoaWxlIGEgcGx1cmFsIGNhdGVnb3J5IG1heSBtYXRjaCBtYW55IG51bWJlcnMgKGZvciBleGFtcGxlLCBpbiBlbi1VUyBsb2NhbGUsIFwib3RoZXJcIiBjYW4gbWF0Y2hcclxuICogYW55IG51bWJlciB0aGF0IGlzIG5vdCAxKSwgYW4gZXhwbGljaXQgbnVtYmVyIHJ1bGUgY2FuIG9ubHkgbWF0Y2ggb25lIG51bWJlci4gRm9yIGV4YW1wbGUsIHRoZVxyXG4gKiBleHBsaWNpdCBudW1iZXIgcnVsZSBmb3IgXCIzXCIgbWF0Y2hlcyB0aGUgbnVtYmVyIDMuIFRoZXJlIGFyZSBleGFtcGxlcyBvZiBwbHVyYWwgY2F0ZWdvcmllc1xyXG4gKiBhbmQgZXhwbGljaXQgbnVtYmVyIHJ1bGVzIHRocm91Z2hvdXQgdGhlIHJlc3Qgb2YgdGhpcyBkb2N1bWVudGF0aW9uLlxyXG4gKlxyXG4gKiAjIENvbmZpZ3VyaW5nIG5nUGx1cmFsaXplXHJcbiAqIFlvdSBjb25maWd1cmUgbmdQbHVyYWxpemUgYnkgcHJvdmlkaW5nIDIgYXR0cmlidXRlczogYGNvdW50YCBhbmQgYHdoZW5gLlxyXG4gKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhbiBvcHRpb25hbCBhdHRyaWJ1dGUsIGBvZmZzZXRgLlxyXG4gKlxyXG4gKiBUaGUgdmFsdWUgb2YgdGhlIGBjb3VudGAgYXR0cmlidXRlIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4ge0BsaW5rIGd1aWRlL2V4cHJlc3Npb25cclxuICogQW5ndWxhciBleHByZXNzaW9ufTsgdGhlc2UgYXJlIGV2YWx1YXRlZCBvbiB0aGUgY3VycmVudCBzY29wZSBmb3IgaXRzIGJvdW5kIHZhbHVlLlxyXG4gKlxyXG4gKiBUaGUgYHdoZW5gIGF0dHJpYnV0ZSBzcGVjaWZpZXMgdGhlIG1hcHBpbmdzIGJldHdlZW4gcGx1cmFsIGNhdGVnb3JpZXMgYW5kIHRoZSBhY3R1YWxcclxuICogc3RyaW5nIHRvIGJlIGRpc3BsYXllZC4gVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIGEgSlNPTiBvYmplY3QuXHJcbiAqXHJcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gY29uZmlndXJlIG5nUGx1cmFsaXplOlxyXG4gKlxyXG4gKiA8cHJlPlxyXG4gKiA8bmctcGx1cmFsaXplIGNvdW50PVwicGVyc29uQ291bnRcIlxyXG4gICAgICAgICAgICAgICAgIHdoZW49XCJ7JzAnOiAnTm9ib2R5IGlzIHZpZXdpbmcuJyxcclxuICogICAgICAgICAgICAgICAgICAgICAgJ29uZSc6ICcxIHBlcnNvbiBpcyB2aWV3aW5nLicsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICdvdGhlcic6ICd7fSBwZW9wbGUgYXJlIHZpZXdpbmcuJ31cIj5cclxuICogPC9uZy1wbHVyYWxpemU+XHJcbiAqPC9wcmU+XHJcbiAqXHJcbiAqIEluIHRoZSBleGFtcGxlLCBgXCIwOiBOb2JvZHkgaXMgdmlld2luZy5cImAgaXMgYW4gZXhwbGljaXQgbnVtYmVyIHJ1bGUuIElmIHlvdSBkaWQgbm90XHJcbiAqIHNwZWNpZnkgdGhpcyBydWxlLCAwIHdvdWxkIGJlIG1hdGNoZWQgdG8gdGhlIFwib3RoZXJcIiBjYXRlZ29yeSBhbmQgXCIwIHBlb3BsZSBhcmUgdmlld2luZ1wiXHJcbiAqIHdvdWxkIGJlIHNob3duIGluc3RlYWQgb2YgXCJOb2JvZHkgaXMgdmlld2luZ1wiLiBZb3UgY2FuIHNwZWNpZnkgYW4gZXhwbGljaXQgbnVtYmVyIHJ1bGUgZm9yXHJcbiAqIG90aGVyIG51bWJlcnMsIGZvciBleGFtcGxlIDEyLCBzbyB0aGF0IGluc3RlYWQgb2Ygc2hvd2luZyBcIjEyIHBlb3BsZSBhcmUgdmlld2luZ1wiLCB5b3UgY2FuXHJcbiAqIHNob3cgXCJhIGRvemVuIHBlb3BsZSBhcmUgdmlld2luZ1wiLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHVzZSBhIHNldCBvZiBjbG9zZWQgYnJhY2VzKGB7fWApIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHRoZSBudW1iZXIgdGhhdCB5b3Ugd2FudCBzdWJzdGl0dXRlZFxyXG4gKiBpbnRvIHBsdXJhbGl6ZWQgc3RyaW5ncy4gSW4gdGhlIHByZXZpb3VzIGV4YW1wbGUsIEFuZ3VsYXIgd2lsbCByZXBsYWNlIGB7fWAgd2l0aFxyXG4gKiA8c3BhbiBuZy1ub24tYmluZGFibGU+YHt7cGVyc29uQ291bnR9fWA8L3NwYW4+LiBUaGUgY2xvc2VkIGJyYWNlcyBge31gIGlzIGEgcGxhY2Vob2xkZXJcclxuICogZm9yIDxzcGFuIG5nLW5vbi1iaW5kYWJsZT57e251bWJlckV4cHJlc3Npb259fTwvc3Bhbj4uXHJcbiAqXHJcbiAqICMgQ29uZmlndXJpbmcgbmdQbHVyYWxpemUgd2l0aCBvZmZzZXRcclxuICogVGhlIGBvZmZzZXRgIGF0dHJpYnV0ZSBhbGxvd3MgZnVydGhlciBjdXN0b21pemF0aW9uIG9mIHBsdXJhbGl6ZWQgdGV4dCwgd2hpY2ggY2FuIHJlc3VsdCBpblxyXG4gKiBhIGJldHRlciB1c2VyIGV4cGVyaWVuY2UuIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mIHRoZSBtZXNzYWdlIFwiNCBwZW9wbGUgYXJlIHZpZXdpbmcgdGhpcyBkb2N1bWVudFwiLFxyXG4gKiB5b3UgbWlnaHQgZGlzcGxheSBcIkpvaG4sIEthdGUgYW5kIDIgb3RoZXJzIGFyZSB2aWV3aW5nIHRoaXMgZG9jdW1lbnRcIi5cclxuICogVGhlIG9mZnNldCBhdHRyaWJ1dGUgYWxsb3dzIHlvdSB0byBvZmZzZXQgYSBudW1iZXIgYnkgYW55IGRlc2lyZWQgdmFsdWUuXHJcbiAqIExldCdzIHRha2UgYSBsb29rIGF0IGFuIGV4YW1wbGU6XHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIDxuZy1wbHVyYWxpemUgY291bnQ9XCJwZXJzb25Db3VudFwiIG9mZnNldD0yXHJcbiAqICAgICAgICAgICAgICAgd2hlbj1cInsnMCc6ICdOb2JvZHkgaXMgdmlld2luZy4nLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAnMSc6ICd7e3BlcnNvbjF9fSBpcyB2aWV3aW5nLicsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICcyJzogJ3t7cGVyc29uMX19IGFuZCB7e3BlcnNvbjJ9fSBhcmUgdmlld2luZy4nLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAnb25lJzogJ3t7cGVyc29uMX19LCB7e3BlcnNvbjJ9fSBhbmQgb25lIG90aGVyIHBlcnNvbiBhcmUgdmlld2luZy4nLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAnb3RoZXInOiAne3twZXJzb24xfX0sIHt7cGVyc29uMn19IGFuZCB7fSBvdGhlciBwZW9wbGUgYXJlIHZpZXdpbmcuJ31cIj5cclxuICogPC9uZy1wbHVyYWxpemU+XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBOb3RpY2UgdGhhdCB3ZSBhcmUgc3RpbGwgdXNpbmcgdHdvIHBsdXJhbCBjYXRlZ29yaWVzKG9uZSwgb3RoZXIpLCBidXQgd2UgYWRkZWRcclxuICogdGhyZWUgZXhwbGljaXQgbnVtYmVyIHJ1bGVzIDAsIDEgYW5kIDIuXHJcbiAqIFdoZW4gb25lIHBlcnNvbiwgcGVyaGFwcyBKb2huLCB2aWV3cyB0aGUgZG9jdW1lbnQsIFwiSm9obiBpcyB2aWV3aW5nXCIgd2lsbCBiZSBzaG93bi5cclxuICogV2hlbiB0aHJlZSBwZW9wbGUgdmlldyB0aGUgZG9jdW1lbnQsIG5vIGV4cGxpY2l0IG51bWJlciBydWxlIGlzIGZvdW5kLCBzb1xyXG4gKiBhbiBvZmZzZXQgb2YgMiBpcyB0YWtlbiBvZmYgMywgYW5kIEFuZ3VsYXIgdXNlcyAxIHRvIGRlY2lkZSB0aGUgcGx1cmFsIGNhdGVnb3J5LlxyXG4gKiBJbiB0aGlzIGNhc2UsIHBsdXJhbCBjYXRlZ29yeSAnb25lJyBpcyBtYXRjaGVkIGFuZCBcIkpvaG4sIE1hcnJ5IGFuZCBvbmUgb3RoZXIgcGVyc29uIGFyZSB2aWV3aW5nXCJcclxuICogaXMgc2hvd24uXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB3aGVuIHlvdSBzcGVjaWZ5IG9mZnNldHMsIHlvdSBtdXN0IHByb3ZpZGUgZXhwbGljaXQgbnVtYmVyIHJ1bGVzIGZvclxyXG4gKiBudW1iZXJzIGZyb20gMCB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBvZmZzZXQuIElmIHlvdSB1c2UgYW4gb2Zmc2V0IG9mIDMsIGZvciBleGFtcGxlLFxyXG4gKiB5b3UgbXVzdCBwcm92aWRlIGV4cGxpY2l0IG51bWJlciBydWxlcyBmb3IgMCwgMSwgMiBhbmQgMy4gWW91IG11c3QgYWxzbyBwcm92aWRlIHBsdXJhbCBzdHJpbmdzIGZvclxyXG4gKiBwbHVyYWwgY2F0ZWdvcmllcyBcIm9uZVwiIGFuZCBcIm90aGVyXCIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfGV4cHJlc3Npb259IGNvdW50IFRoZSB2YXJpYWJsZSB0byBiZSBib3VuZGVkIHRvLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd2hlbiBUaGUgbWFwcGluZyBiZXR3ZWVuIHBsdXJhbCBjYXRlZ29yeSB0byBpdHMgY29ycmVzcG9uZGluZyBzdHJpbmdzLlxyXG4gKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gZGVkdWN0IGZyb20gdGhlIHRvdGFsIG51bWJlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAgICRzY29wZS5wZXJzb24xID0gJ0lnb3InO1xyXG4gICAgICAgICAgICAkc2NvcGUucGVyc29uMiA9ICdNaXNrbyc7XHJcbiAgICAgICAgICAgICRzY29wZS5wZXJzb25Db3VudCA9IDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxyXG4gICAgICAgICAgUGVyc29uIDE6PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJwZXJzb24xXCIgdmFsdWU9XCJJZ29yXCIgLz48YnIvPlxyXG4gICAgICAgICAgUGVyc29uIDI6PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJwZXJzb24yXCIgdmFsdWU9XCJNaXNrb1wiIC8+PGJyLz5cclxuICAgICAgICAgIE51bWJlciBvZiBQZW9wbGU6PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJwZXJzb25Db3VudFwiIHZhbHVlPVwiMVwiIC8+PGJyLz5cclxuXHJcbiAgICAgICAgICA8IS0tLSBFeGFtcGxlIHdpdGggc2ltcGxlIHBsdXJhbGl6YXRpb24gcnVsZXMgZm9yIGVuIGxvY2FsZSAtLS0+XHJcbiAgICAgICAgICBXaXRob3V0IE9mZnNldDpcclxuICAgICAgICAgIDxuZy1wbHVyYWxpemUgY291bnQ9XCJwZXJzb25Db3VudFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW49XCJ7JzAnOiAnTm9ib2R5IGlzIHZpZXdpbmcuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmUnOiAnMSBwZXJzb24gaXMgdmlld2luZy4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ290aGVyJzogJ3t9IHBlb3BsZSBhcmUgdmlld2luZy4nfVwiPlxyXG4gICAgICAgICAgPC9uZy1wbHVyYWxpemU+PGJyPlxyXG5cclxuICAgICAgICAgIDwhLS0tIEV4YW1wbGUgd2l0aCBvZmZzZXQgLS0tPlxyXG4gICAgICAgICAgV2l0aCBPZmZzZXQoMik6XHJcbiAgICAgICAgICA8bmctcGx1cmFsaXplIGNvdW50PVwicGVyc29uQ291bnRcIiBvZmZzZXQ9MlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVuPVwieycwJzogJ05vYm9keSBpcyB2aWV3aW5nLicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnMSc6ICd7e3BlcnNvbjF9fSBpcyB2aWV3aW5nLicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnMic6ICd7e3BlcnNvbjF9fSBhbmQge3twZXJzb24yfX0gYXJlIHZpZXdpbmcuJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmUnOiAne3twZXJzb24xfX0sIHt7cGVyc29uMn19IGFuZCBvbmUgb3RoZXIgcGVyc29uIGFyZSB2aWV3aW5nLicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3RoZXInOiAne3twZXJzb24xfX0sIHt7cGVyc29uMn19IGFuZCB7fSBvdGhlciBwZW9wbGUgYXJlIHZpZXdpbmcuJ31cIj5cclxuICAgICAgICAgIDwvbmctcGx1cmFsaXplPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgaXQoJ3Nob3VsZCBzaG93IGNvcnJlY3QgcGx1cmFsaXplZCBzdHJpbmcnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBuZy1wbHVyYWxpemU6Zmlyc3QnKS50ZXh0KCkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCcxIHBlcnNvbiBpcyB2aWV3aW5nLicpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpsYXN0JykudGV4dCgpKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9CZSgnSWdvciBpcyB2aWV3aW5nLicpO1xyXG5cclxuICAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCdwZXJzb25Db3VudCcpLmVudGVyKCcwJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmZpcnN0JykudGV4dCgpKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCdOb2JvZHkgaXMgdmlld2luZy4nKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBuZy1wbHVyYWxpemU6bGFzdCcpLnRleHQoKSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCdOb2JvZHkgaXMgdmlld2luZy4nKTtcclxuXHJcbiAgICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5pbnB1dCgncGVyc29uQ291bnQnKS5lbnRlcignMicpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpmaXJzdCcpLnRleHQoKSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9CZSgnMiBwZW9wbGUgYXJlIHZpZXdpbmcuJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmxhc3QnKS50ZXh0KCkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCdJZ29yIGFuZCBNaXNrbyBhcmUgdmlld2luZy4nKTtcclxuXHJcbiAgICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5pbnB1dCgncGVyc29uQ291bnQnKS5lbnRlcignMycpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpmaXJzdCcpLnRleHQoKSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9CZSgnMyBwZW9wbGUgYXJlIHZpZXdpbmcuJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmxhc3QnKS50ZXh0KCkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCdJZ29yLCBNaXNrbyBhbmQgb25lIG90aGVyIHBlcnNvbiBhcmUgdmlld2luZy4nKTtcclxuXHJcbiAgICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5pbnB1dCgncGVyc29uQ291bnQnKS5lbnRlcignNCcpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpmaXJzdCcpLnRleHQoKSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9CZSgnNCBwZW9wbGUgYXJlIHZpZXdpbmcuJyk7XHJcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmxhc3QnKS50ZXh0KCkpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCdJZ29yLCBNaXNrbyBhbmQgMiBvdGhlciBwZW9wbGUgYXJlIHZpZXdpbmcuJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzaG91bGQgc2hvdyBkYXRhLWJpbmRlZCBuYW1lcycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuaW5wdXQoJ3BlcnNvbkNvdW50JykuZW50ZXIoJzQnKTtcclxuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBuZy1wbHVyYWxpemU6bGFzdCcpLnRleHQoKSkuXHJcbiAgICAgICAgICAgICAgdG9CZSgnSWdvciwgTWlza28gYW5kIDIgb3RoZXIgcGVvcGxlIGFyZSB2aWV3aW5nLicpO1xyXG5cclxuICAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCdwZXJzb24xJykuZW50ZXIoJ0RpJyk7XHJcbiAgICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5pbnB1dCgncGVyc29uMicpLmVudGVyKCdWb2p0YScpO1xyXG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpsYXN0JykudGV4dCgpKS5cclxuICAgICAgICAgICAgICB0b0JlKCdEaSwgVm9qdGEgYW5kIDIgb3RoZXIgcGVvcGxlIGFyZSB2aWV3aW5nLicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdQbHVyYWxpemVEaXJlY3RpdmUgPSBbJyRsb2NhbGUnLCAnJGludGVycG9sYXRlJywgZnVuY3Rpb24oJGxvY2FsZSwgJGludGVycG9sYXRlKSB7XHJcbiAgdmFyIEJSQUNFID0gL3t9L2c7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRUEnLFxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcclxuICAgICAgdmFyIG51bWJlckV4cCA9IGF0dHIuY291bnQsXHJcbiAgICAgICAgICB3aGVuRXhwID0gYXR0ci4kYXR0ci53aGVuICYmIGVsZW1lbnQuYXR0cihhdHRyLiRhdHRyLndoZW4pLCAvLyB3ZSBoYXZlIHt7fX0gaW4gYXR0cnNcclxuICAgICAgICAgIG9mZnNldCA9IGF0dHIub2Zmc2V0IHx8IDAsXHJcbiAgICAgICAgICB3aGVucyA9IHNjb3BlLiRldmFsKHdoZW5FeHApIHx8IHt9LFxyXG4gICAgICAgICAgd2hlbnNFeHBGbnMgPSB7fSxcclxuICAgICAgICAgIHN0YXJ0U3ltYm9sID0gJGludGVycG9sYXRlLnN0YXJ0U3ltYm9sKCksXHJcbiAgICAgICAgICBlbmRTeW1ib2wgPSAkaW50ZXJwb2xhdGUuZW5kU3ltYm9sKCksXHJcbiAgICAgICAgICBpc1doZW4gPSAvXndoZW4oTWludXMpPyguKykkLztcclxuXHJcbiAgICAgIGZvckVhY2goYXR0ciwgZnVuY3Rpb24oZXhwcmVzc2lvbiwgYXR0cmlidXRlTmFtZSkge1xyXG4gICAgICAgIGlmIChpc1doZW4udGVzdChhdHRyaWJ1dGVOYW1lKSkge1xyXG4gICAgICAgICAgd2hlbnNbbG93ZXJjYXNlKGF0dHJpYnV0ZU5hbWUucmVwbGFjZSgnd2hlbicsICcnKS5yZXBsYWNlKCdNaW51cycsICctJykpXSA9XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYXR0cihhdHRyLiRhdHRyW2F0dHJpYnV0ZU5hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBmb3JFYWNoKHdoZW5zLCBmdW5jdGlvbihleHByZXNzaW9uLCBrZXkpIHtcclxuICAgICAgICB3aGVuc0V4cEZuc1trZXldID1cclxuICAgICAgICAgICRpbnRlcnBvbGF0ZShleHByZXNzaW9uLnJlcGxhY2UoQlJBQ0UsIHN0YXJ0U3ltYm9sICsgbnVtYmVyRXhwICsgJy0nICtcclxuICAgICAgICAgICAgb2Zmc2V0ICsgZW5kU3ltYm9sKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uIG5nUGx1cmFsaXplV2F0Y2goKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdChzY29wZS4kZXZhbChudW1iZXJFeHApKTtcclxuXHJcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgIC8vaWYgZXhwbGljaXQgbnVtYmVyIHJ1bGUgc3VjaCBhcyAxLCAyLCAzLi4uIGlzIGRlZmluZWQsIGp1c3QgdXNlIGl0LiBPdGhlcndpc2UsXHJcbiAgICAgICAgICAvL2NoZWNrIGl0IGFnYWluc3QgcGx1cmFsaXphdGlvbiBydWxlcyBpbiAkbG9jYWxlIHNlcnZpY2VcclxuICAgICAgICAgIGlmICghKHZhbHVlIGluIHdoZW5zKSkgdmFsdWUgPSAkbG9jYWxlLnBsdXJhbENhdCh2YWx1ZSAtIG9mZnNldCk7XHJcbiAgICAgICAgICAgcmV0dXJuIHdoZW5zRXhwRm5zW3ZhbHVlXShzY29wZSwgZWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgIH0sIGZ1bmN0aW9uIG5nUGx1cmFsaXplV2F0Y2hBY3Rpb24obmV3VmFsKSB7XHJcbiAgICAgICAgZWxlbWVudC50ZXh0KG5ld1ZhbCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1dO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nUmVwZWF0XHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBUaGUgYG5nUmVwZWF0YCBkaXJlY3RpdmUgaW5zdGFudGlhdGVzIGEgdGVtcGxhdGUgb25jZSBwZXIgaXRlbSBmcm9tIGEgY29sbGVjdGlvbi4gRWFjaCB0ZW1wbGF0ZVxyXG4gKiBpbnN0YW5jZSBnZXRzIGl0cyBvd24gc2NvcGUsIHdoZXJlIHRoZSBnaXZlbiBsb29wIHZhcmlhYmxlIGlzIHNldCB0byB0aGUgY3VycmVudCBjb2xsZWN0aW9uIGl0ZW0sXHJcbiAqIGFuZCBgJGluZGV4YCBpcyBzZXQgdG8gdGhlIGl0ZW0gaW5kZXggb3Iga2V5LlxyXG4gKlxyXG4gKiBTcGVjaWFsIHByb3BlcnRpZXMgYXJlIGV4cG9zZWQgb24gdGhlIGxvY2FsIHNjb3BlIG9mIGVhY2ggdGVtcGxhdGUgaW5zdGFuY2UsIGluY2x1ZGluZzpcclxuICpcclxuICogfCBWYXJpYWJsZSAgfCBUeXBlICAgICAgICAgICAgfCBEZXRhaWxzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiB8LS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XHJcbiAqIHwgYCRpbmRleGAgIHwge0B0eXBlIG51bWJlcn0gIHwgaXRlcmF0b3Igb2Zmc2V0IG9mIHRoZSByZXBlYXRlZCBlbGVtZW50ICgwLi5sZW5ndGgtMSkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogfCBgJGZpcnN0YCAgfCB7QHR5cGUgYm9vbGVhbn0gfCB0cnVlIGlmIHRoZSByZXBlYXRlZCBlbGVtZW50IGlzIGZpcnN0IGluIHRoZSBpdGVyYXRvci4gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiB8IGAkbWlkZGxlYCB8IHtAdHlwZSBib29sZWFufSB8IHRydWUgaWYgdGhlIHJlcGVhdGVkIGVsZW1lbnQgaXMgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3QgaW4gdGhlIGl0ZXJhdG9yLiB8XHJcbiAqIHwgYCRsYXN0YCAgIHwge0B0eXBlIGJvb2xlYW59IHwgdHJ1ZSBpZiB0aGUgcmVwZWF0ZWQgZWxlbWVudCBpcyBsYXN0IGluIHRoZSBpdGVyYXRvci4gICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogfCBgJGV2ZW5gICAgfCB7QHR5cGUgYm9vbGVhbn0gfCB0cnVlIGlmIHRoZSBpdGVyYXRvciBwb3NpdGlvbiBgJGluZGV4YCBpcyBldmVuIChvdGhlcndpc2UgZmFsc2UpLiAgICAgICAgICAgfFxyXG4gKiB8IGAkb2RkYCAgICB8IHtAdHlwZSBib29sZWFufSB8IHRydWUgaWYgdGhlIGl0ZXJhdG9yIHBvc2l0aW9uIGAkaW5kZXhgIGlzIG9kZCAob3RoZXJ3aXNlIGZhbHNlKS4gICAgICAgICAgICB8XHJcbiAqXHJcbiAqXHJcbiAqICMgU3BlY2lhbCByZXBlYXQgc3RhcnQgYW5kIGVuZCBwb2ludHNcclxuICogVG8gcmVwZWF0IGEgc2VyaWVzIG9mIGVsZW1lbnRzIGluc3RlYWQgb2YganVzdCBvbmUgcGFyZW50IGVsZW1lbnQsIG5nUmVwZWF0IChhcyB3ZWxsIGFzIG90aGVyIG5nIGRpcmVjdGl2ZXMpIHN1cHBvcnRzIGV4dGVuZGluZ1xyXG4gKiB0aGUgcmFuZ2Ugb2YgdGhlIHJlcGVhdGVyIGJ5IGRlZmluaW5nIGV4cGxpY2l0IHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGJ5IHVzaW5nICoqbmctcmVwZWF0LXN0YXJ0KiogYW5kICoqbmctcmVwZWF0LWVuZCoqIHJlc3BlY3RpdmVseS5cclxuICogVGhlICoqbmctcmVwZWF0LXN0YXJ0KiogZGlyZWN0aXZlIHdvcmtzIHRoZSBzYW1lIGFzICoqbmctcmVwZWF0KiosIGJ1dCB3aWxsIHJlcGVhdCBhbGwgdGhlIEhUTUwgY29kZSAoaW5jbHVkaW5nIHRoZSB0YWcgaXQncyBkZWZpbmVkIG9uKVxyXG4gKiB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBlbmRpbmcgSFRNTCB0YWcgd2hlcmUgKipuZy1yZXBlYXQtZW5kKiogaXMgcGxhY2VkLlxyXG4gKlxyXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBtYWtlcyB1c2Ugb2YgdGhpcyBmZWF0dXJlOlxyXG4gKiA8cHJlPlxyXG4gKiAgIDxoZWFkZXIgbmctcmVwZWF0LXN0YXJ0PVwiaXRlbSBpbiBpdGVtc1wiPlxyXG4gKiAgICAgSGVhZGVyIHt7IGl0ZW0gfX1cclxuICogICA8L2hlYWRlcj5cclxuICogICA8ZGl2IGNsYXNzPVwiYm9keVwiPlxyXG4gKiAgICAgQm9keSB7eyBpdGVtIH19XHJcbiAqICAgPC9kaXY+XHJcbiAqICAgPGZvb3RlciBuZy1yZXBlYXQtZW5kPlxyXG4gKiAgICAgRm9vdGVyIHt7IGl0ZW0gfX1cclxuICogICA8L2Zvb3Rlcj5cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIEFuZCB3aXRoIGFuIGlucHV0IG9mIHtAdHlwZSBbJ0EnLCdCJ119IGZvciB0aGUgaXRlbXMgdmFyaWFibGUgaW4gdGhlIGV4YW1wbGUgYWJvdmUsIHRoZSBvdXRwdXQgd2lsbCBldmFsdWF0ZSB0bzpcclxuICogPHByZT5cclxuICogICA8aGVhZGVyPlxyXG4gKiAgICAgSGVhZGVyIEFcclxuICogICA8L2hlYWRlcj5cclxuICogICA8ZGl2IGNsYXNzPVwiYm9keVwiPlxyXG4gKiAgICAgQm9keSBBXHJcbiAqICAgPC9kaXY+XHJcbiAqICAgPGZvb3Rlcj5cclxuICogICAgIEZvb3RlciBBXHJcbiAqICAgPC9mb290ZXI+XHJcbiAqICAgPGhlYWRlcj5cclxuICogICAgIEhlYWRlciBCXHJcbiAqICAgPC9oZWFkZXI+XHJcbiAqICAgPGRpdiBjbGFzcz1cImJvZHlcIj5cclxuICogICAgIEJvZHkgQlxyXG4gKiAgIDwvZGl2PlxyXG4gKiAgIDxmb290ZXI+XHJcbiAqICAgICBGb290ZXIgQlxyXG4gKiAgIDwvZm9vdGVyPlxyXG4gKiA8L3ByZT5cclxuICpcclxuICogVGhlIGN1c3RvbSBzdGFydCBhbmQgZW5kIHBvaW50cyBmb3IgbmdSZXBlYXQgYWxzbyBzdXBwb3J0IGFsbCBvdGhlciBIVE1MIGRpcmVjdGl2ZSBzeW50YXggZmxhdm9ycyBwcm92aWRlZCBpbiBBbmd1bGFySlMgKHN1Y2hcclxuICogYXMgKipkYXRhLW5nLXJlcGVhdC1zdGFydCoqLCAqKngtbmctcmVwZWF0LXN0YXJ0KiogYW5kICoqbmc6cmVwZWF0LXN0YXJ0KiopLlxyXG4gKlxyXG4gKiBAYW5pbWF0aW9uc1xyXG4gKiBlbnRlciAtIHdoZW4gYSBuZXcgaXRlbSBpcyBhZGRlZCB0byB0aGUgbGlzdCBvciB3aGVuIGFuIGl0ZW0gaXMgcmV2ZWFsZWQgYWZ0ZXIgYSBmaWx0ZXJcclxuICogbGVhdmUgLSB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0IG9yIHdoZW4gYW4gaXRlbSBpcyBmaWx0ZXJlZCBvdXRcclxuICogbW92ZSAtIHdoZW4gYW4gYWRqYWNlbnQgaXRlbSBpcyBmaWx0ZXJlZCBvdXQgY2F1c2luZyBhIHJlb3JkZXIgb3Igd2hlbiB0aGUgaXRlbSBjb250ZW50cyBhcmUgcmVvcmRlcmVkXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAc2NvcGVcclxuICogQHByaW9yaXR5IDEwMDBcclxuICogQHBhcmFtIHtyZXBlYXRfZXhwcmVzc2lvbn0gbmdSZXBlYXQgVGhlIGV4cHJlc3Npb24gaW5kaWNhdGluZyBob3cgdG8gZW51bWVyYXRlIGEgY29sbGVjdGlvbi4gVGhlc2VcclxuICogICBmb3JtYXRzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkOlxyXG4gKlxyXG4gKiAgICogYHZhcmlhYmxlIGluIGV4cHJlc3Npb25gIMOi4oKs4oCcIHdoZXJlIHZhcmlhYmxlIGlzIHRoZSB1c2VyIGRlZmluZWQgbG9vcCB2YXJpYWJsZSBhbmQgYGV4cHJlc3Npb25gXHJcbiAqICAgICBpcyBhIHNjb3BlIGV4cHJlc3Npb24gZ2l2aW5nIHRoZSBjb2xsZWN0aW9uIHRvIGVudW1lcmF0ZS5cclxuICpcclxuICogICAgIEZvciBleGFtcGxlOiBgYWxidW0gaW4gYXJ0aXN0LmFsYnVtc2AuXHJcbiAqXHJcbiAqICAgKiBgKGtleSwgdmFsdWUpIGluIGV4cHJlc3Npb25gIMOi4oKs4oCcIHdoZXJlIGBrZXlgIGFuZCBgdmFsdWVgIGNhbiBiZSBhbnkgdXNlciBkZWZpbmVkIGlkZW50aWZpZXJzLFxyXG4gKiAgICAgYW5kIGBleHByZXNzaW9uYCBpcyB0aGUgc2NvcGUgZXhwcmVzc2lvbiBnaXZpbmcgdGhlIGNvbGxlY3Rpb24gdG8gZW51bWVyYXRlLlxyXG4gKlxyXG4gKiAgICAgRm9yIGV4YW1wbGU6IGAobmFtZSwgYWdlKSBpbiB7J2FkYW0nOjEwLCAnYW1hbGllJzoxMn1gLlxyXG4gKlxyXG4gKiAgICogYHZhcmlhYmxlIGluIGV4cHJlc3Npb24gdHJhY2sgYnkgdHJhY2tpbmdfZXhwcmVzc2lvbmAgw6LigqzigJwgWW91IGNhbiBhbHNvIHByb3ZpZGUgYW4gb3B0aW9uYWwgdHJhY2tpbmcgZnVuY3Rpb25cclxuICogICAgIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGFzc29jaWF0ZSB0aGUgb2JqZWN0cyBpbiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSBET00gZWxlbWVudHMuIElmIG5vIHRyYWNraW5nIGZ1bmN0aW9uXHJcbiAqICAgICBpcyBzcGVjaWZpZWQgdGhlIG5nLXJlcGVhdCBhc3NvY2lhdGVzIGVsZW1lbnRzIGJ5IGlkZW50aXR5IGluIHRoZSBjb2xsZWN0aW9uLiBJdCBpcyBhbiBlcnJvciB0byBoYXZlXHJcbiAqICAgICBtb3JlIHRoYW4gb25lIHRyYWNraW5nIGZ1bmN0aW9uIHRvIHJlc29sdmUgdG8gdGhlIHNhbWUga2V5LiAoVGhpcyB3b3VsZCBtZWFuIHRoYXQgdHdvIGRpc3RpbmN0IG9iamVjdHMgYXJlXHJcbiAqICAgICBtYXBwZWQgdG8gdGhlIHNhbWUgRE9NIGVsZW1lbnQsIHdoaWNoIGlzIG5vdCBwb3NzaWJsZS4pICBGaWx0ZXJzIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBleHByZXNzaW9uLFxyXG4gKiAgICAgYmVmb3JlIHNwZWNpZnlpbmcgYSB0cmFja2luZyBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiAgICAgRm9yIGV4YW1wbGU6IGBpdGVtIGluIGl0ZW1zYCBpcyBlcXVpdmFsZW50IHRvIGBpdGVtIGluIGl0ZW1zIHRyYWNrIGJ5ICRpZChpdGVtKScuIFRoaXMgaW1wbGllcyB0aGF0IHRoZSBET00gZWxlbWVudHNcclxuICogICAgIHdpbGwgYmUgYXNzb2NpYXRlZCBieSBpdGVtIGlkZW50aXR5IGluIHRoZSBhcnJheS5cclxuICpcclxuICogICAgIEZvciBleGFtcGxlOiBgaXRlbSBpbiBpdGVtcyB0cmFjayBieSAkaWQoaXRlbSlgLiBBIGJ1aWx0IGluIGAkaWQoKWAgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gYXNzaWduIGEgdW5pcXVlXHJcbiAqICAgICBgJCRoYXNoS2V5YCBwcm9wZXJ0eSB0byBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LiBUaGlzIHByb3BlcnR5IGlzIHRoZW4gdXNlZCBhcyBhIGtleSB0byBhc3NvY2lhdGVkIERPTSBlbGVtZW50c1xyXG4gKiAgICAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBpdGVtIGluIHRoZSBhcnJheSBieSBpZGVudGl0eS4gTW92aW5nIHRoZSBzYW1lIG9iamVjdCBpbiBhcnJheSB3b3VsZCBtb3ZlIHRoZSBET01cclxuICogICAgIGVsZW1lbnQgaW4gdGhlIHNhbWUgd2F5IGlhbiB0aGUgRE9NLlxyXG4gKlxyXG4gKiAgICAgRm9yIGV4YW1wbGU6IGBpdGVtIGluIGl0ZW1zIHRyYWNrIGJ5IGl0ZW0uaWRgIGlzIGEgdHlwaWNhbCBwYXR0ZXJuIHdoZW4gdGhlIGl0ZW1zIGNvbWUgZnJvbSB0aGUgZGF0YWJhc2UuIEluIHRoaXNcclxuICogICAgIGNhc2UgdGhlIG9iamVjdCBpZGVudGl0eSBkb2VzIG5vdCBtYXR0ZXIuIFR3byBvYmplY3RzIGFyZSBjb25zaWRlcmVkIGVxdWl2YWxlbnQgYXMgbG9uZyBhcyB0aGVpciBgaWRgXHJcbiAqICAgICBwcm9wZXJ0eSBpcyBzYW1lLlxyXG4gKlxyXG4gKiAgICAgRm9yIGV4YW1wbGU6IGBpdGVtIGluIGl0ZW1zIHwgZmlsdGVyOnNlYXJjaFRleHQgdHJhY2sgYnkgaXRlbS5pZGAgaXMgYSBwYXR0ZXJuIHRoYXQgbWlnaHQgYmUgdXNlZCB0byBhcHBseSBhIGZpbHRlclxyXG4gKiAgICAgdG8gaXRlbXMgaW4gY29uanVuY3Rpb24gd2l0aCBhIHRyYWNraW5nIGV4cHJlc3Npb24uXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIFRoaXMgZXhhbXBsZSBpbml0aWFsaXplcyB0aGUgc2NvcGUgdG8gYSBsaXN0IG9mIG5hbWVzIGFuZFxyXG4gKiB0aGVuIHVzZXMgYG5nUmVwZWF0YCB0byBkaXNwbGF5IGV2ZXJ5IHBlcnNvbjpcclxuICA8ZXhhbXBsZSBhbmltYXRpb25zPVwidHJ1ZVwiPlxyXG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgICAgPGRpdiBuZy1pbml0PVwiZnJpZW5kcyA9IFtcclxuICAgICAgICB7bmFtZTonSm9obicsIGFnZToyNSwgZ2VuZGVyOidib3knfSxcclxuICAgICAgICB7bmFtZTonSmVzc2llJywgYWdlOjMwLCBnZW5kZXI6J2dpcmwnfSxcclxuICAgICAgICB7bmFtZTonSm9oYW5uYScsIGFnZToyOCwgZ2VuZGVyOidnaXJsJ30sXHJcbiAgICAgICAge25hbWU6J0pveScsIGFnZToxNSwgZ2VuZGVyOidnaXJsJ30sXHJcbiAgICAgICAge25hbWU6J01hcnknLCBhZ2U6MjgsIGdlbmRlcjonZ2lybCd9LFxyXG4gICAgICAgIHtuYW1lOidQZXRlcicsIGFnZTo5NSwgZ2VuZGVyOidib3knfSxcclxuICAgICAgICB7bmFtZTonU2ViYXN0aWFuJywgYWdlOjUwLCBnZW5kZXI6J2JveSd9LFxyXG4gICAgICAgIHtuYW1lOidFcmlrYScsIGFnZToyNywgZ2VuZGVyOidnaXJsJ30sXHJcbiAgICAgICAge25hbWU6J1BhdHJpY2snLCBhZ2U6NDAsIGdlbmRlcjonYm95J30sXHJcbiAgICAgICAge25hbWU6J1NhbWFudGhhJywgYWdlOjYwLCBnZW5kZXI6J2dpcmwnfVxyXG4gICAgICBdXCI+XHJcbiAgICAgICAgSSBoYXZlIHt7ZnJpZW5kcy5sZW5ndGh9fSBmcmllbmRzLiBUaGV5IGFyZTpcclxuICAgICAgICA8aW5wdXQgdHlwZT1cInNlYXJjaFwiIG5nLW1vZGVsPVwicVwiIHBsYWNlaG9sZGVyPVwiZmlsdGVyIGZyaWVuZHMuLi5cIiAvPlxyXG4gICAgICAgIDx1bCBjbGFzcz1cImV4YW1wbGUtYW5pbWF0ZS1jb250YWluZXJcIj5cclxuICAgICAgICAgIDxsaSBjbGFzcz1cImFuaW1hdGUtcmVwZWF0XCIgbmctcmVwZWF0PVwiZnJpZW5kIGluIGZyaWVuZHMgfCBmaWx0ZXI6cVwiPlxyXG4gICAgICAgICAgICBbe3skaW5kZXggKyAxfX1dIHt7ZnJpZW5kLm5hbWV9fSB3aG8gaXMge3tmcmllbmQuYWdlfX0geWVhcnMgb2xkLlxyXG4gICAgICAgICAgPC9saT5cclxuICAgICAgICA8L3VsPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJhbmltYXRpb25zLmNzc1wiPlxyXG4gICAgICAuZXhhbXBsZS1hbmltYXRlLWNvbnRhaW5lciB7XHJcbiAgICAgICAgYmFja2dyb3VuZDp3aGl0ZTtcclxuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xyXG4gICAgICAgIGxpc3Qtc3R5bGU6bm9uZTtcclxuICAgICAgICBtYXJnaW46MDtcclxuICAgICAgICBwYWRkaW5nOjA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5leGFtcGxlLWFuaW1hdGUtY29udGFpbmVyID4gbGkge1xyXG4gICAgICAgIHBhZGRpbmc6MTBweDtcclxuICAgICAgICBsaXN0LXN0eWxlOm5vbmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1lbnRlcixcclxuICAgICAgLmFuaW1hdGUtcmVwZWF0Lm5nLWxlYXZlLFxyXG4gICAgICAuYW5pbWF0ZS1yZXBlYXQubmctbW92ZSB7XHJcbiAgICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOmFsbCBsaW5lYXIgMC41cztcclxuICAgICAgICAtbW96LXRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xyXG4gICAgICAgIC1vLXRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xyXG4gICAgICAgIHRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuYW5pbWF0ZS1yZXBlYXQubmctZW50ZXIge1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OjA7XHJcbiAgICAgICAgb3BhY2l0eTowO1xyXG4gICAgICAgIHBhZGRpbmctdG9wOjA7XHJcbiAgICAgICAgcGFkZGluZy1ib3R0b206MDtcclxuICAgICAgfVxyXG4gICAgICAuYW5pbWF0ZS1yZXBlYXQubmctZW50ZXIubmctZW50ZXItYWN0aXZlIHtcclxuICAgICAgICBsaW5lLWhlaWdodDoyMHB4O1xyXG4gICAgICAgIG9wYWNpdHk6MTtcclxuICAgICAgICBwYWRkaW5nOjEwcHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1sZWF2ZSB7XHJcbiAgICAgICAgb3BhY2l0eToxO1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OjIwcHg7XHJcbiAgICAgICAgcGFkZGluZzoxMHB4O1xyXG4gICAgICB9XHJcbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1sZWF2ZS5uZy1sZWF2ZS1hY3RpdmUge1xyXG4gICAgICAgIG9wYWNpdHk6MDtcclxuICAgICAgICBsaW5lLWhlaWdodDowO1xyXG4gICAgICAgIHBhZGRpbmctdG9wOjA7XHJcbiAgICAgICAgcGFkZGluZy1ib3R0b206MDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtcmVwZWF0Lm5nLW1vdmUgeyB9XHJcbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1tb3ZlLm5nLW1vdmUtYWN0aXZlIHsgfVxyXG4gICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XHJcbiAgICAgICBpdCgnc2hvdWxkIHJlbmRlciBpbml0aWFsIGRhdGEgc2V0JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIHZhciByID0gdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykucmVwZWF0ZXIoJ3VsIGxpJyk7XHJcbiAgICAgICAgIGV4cGVjdChyLmNvdW50KCkpLnRvQmUoMTApO1xyXG4gICAgICAgICBleHBlY3Qoci5yb3coMCkpLnRvRXF1YWwoW1wiMVwiLFwiSm9oblwiLFwiMjVcIl0pO1xyXG4gICAgICAgICBleHBlY3Qoci5yb3coMSkpLnRvRXF1YWwoW1wiMlwiLFwiSmVzc2llXCIsXCIzMFwiXSk7XHJcbiAgICAgICAgIGV4cGVjdChyLnJvdyg5KSkudG9FcXVhbChbXCIxMFwiLFwiU2FtYW50aGFcIixcIjYwXCJdKTtcclxuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2ZyaWVuZHMubGVuZ3RoJykpLnRvQmUoXCIxMFwiKTtcclxuICAgICAgIH0pO1xyXG5cclxuICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIHJlcGVhdGVyIHdoZW4gZmlsdGVyIHByZWRpY2F0ZSBjaGFuZ2VzJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIHZhciByID0gdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykucmVwZWF0ZXIoJ3VsIGxpJyk7XHJcbiAgICAgICAgIGV4cGVjdChyLmNvdW50KCkpLnRvQmUoMTApO1xyXG5cclxuICAgICAgICAgaW5wdXQoJ3EnKS5lbnRlcignbWEnKTtcclxuXHJcbiAgICAgICAgIGV4cGVjdChyLmNvdW50KCkpLnRvQmUoMik7XHJcbiAgICAgICAgIGV4cGVjdChyLnJvdygwKSkudG9FcXVhbChbXCIxXCIsXCJNYXJ5XCIsXCIyOFwiXSk7XHJcbiAgICAgICAgIGV4cGVjdChyLnJvdygxKSkudG9FcXVhbChbXCIyXCIsXCJTYW1hbnRoYVwiLFwiNjBcIl0pO1xyXG4gICAgICAgfSk7XHJcbiAgICAgIDwvZmlsZT5cclxuICAgIDwvZXhhbXBsZT5cclxuICovXHJcbnZhciBuZ1JlcGVhdERpcmVjdGl2ZSA9IFsnJHBhcnNlJywgJyRhbmltYXRlJywgZnVuY3Rpb24oJHBhcnNlLCAkYW5pbWF0ZSkge1xyXG4gIHZhciBOR19SRU1PVkVEID0gJyQkTkdfUkVNT1ZFRCc7XHJcbiAgdmFyIG5nUmVwZWF0TWluRXJyID0gbWluRXJyKCduZ1JlcGVhdCcpO1xyXG4gIHJldHVybiB7XHJcbiAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXHJcbiAgICBwcmlvcml0eTogMTAwMCxcclxuICAgIHRlcm1pbmFsOiB0cnVlLFxyXG4gICAgY29tcGlsZTogZnVuY3Rpb24oZWxlbWVudCwgYXR0ciwgbGlua2VyKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cil7XHJcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSAkYXR0ci5uZ1JlcGVhdDtcclxuICAgICAgICB2YXIgbWF0Y2ggPSBleHByZXNzaW9uLm1hdGNoKC9eXFxzKiguKylcXHMraW5cXHMrKC4qPylcXHMqKFxccyt0cmFja1xccytieVxccysoLispXFxzKik/JC8pLFxyXG4gICAgICAgICAgdHJhY2tCeUV4cCwgdHJhY2tCeUV4cEdldHRlciwgdHJhY2tCeUlkRm4sIHRyYWNrQnlJZEFycmF5Rm4sIHRyYWNrQnlJZE9iakZuLCBsaHMsIHJocywgdmFsdWVJZGVudGlmaWVyLCBrZXlJZGVudGlmaWVyLFxyXG4gICAgICAgICAgaGFzaEZuTG9jYWxzID0geyRpZDogaGFzaEtleX07XHJcblxyXG4gICAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICAgIHRocm93IG5nUmVwZWF0TWluRXJyKCdpZXhwJywgXCJFeHBlY3RlZCBleHByZXNzaW9uIGluIGZvcm0gb2YgJ19pdGVtXyBpbiBfY29sbGVjdGlvbl9bIHRyYWNrIGJ5IF9pZF9dJyBidXQgZ290ICd7MH0nLlwiLFxyXG4gICAgICAgICAgICBleHByZXNzaW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxocyA9IG1hdGNoWzFdO1xyXG4gICAgICAgIHJocyA9IG1hdGNoWzJdO1xyXG4gICAgICAgIHRyYWNrQnlFeHAgPSBtYXRjaFs0XTtcclxuXHJcbiAgICAgICAgaWYgKHRyYWNrQnlFeHApIHtcclxuICAgICAgICAgIHRyYWNrQnlFeHBHZXR0ZXIgPSAkcGFyc2UodHJhY2tCeUV4cCk7XHJcbiAgICAgICAgICB0cmFja0J5SWRGbiA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIC8vIGFzc2lnbiBrZXksIHZhbHVlLCBhbmQgJGluZGV4IHRvIHRoZSBsb2NhbHMgc28gdGhhdCB0aGV5IGNhbiBiZSB1c2VkIGluIGhhc2ggZnVuY3Rpb25zXHJcbiAgICAgICAgICAgIGlmIChrZXlJZGVudGlmaWVyKSBoYXNoRm5Mb2NhbHNba2V5SWRlbnRpZmllcl0gPSBrZXk7XHJcbiAgICAgICAgICAgIGhhc2hGbkxvY2Fsc1t2YWx1ZUlkZW50aWZpZXJdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGhhc2hGbkxvY2Fscy4kaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYWNrQnlFeHBHZXR0ZXIoJHNjb3BlLCBoYXNoRm5Mb2NhbHMpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdHJhY2tCeUlkQXJyYXlGbiA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2hLZXkodmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdHJhY2tCeUlkT2JqRm4gPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1hdGNoID0gbGhzLm1hdGNoKC9eKD86KFtcXCRcXHddKyl8XFwoKFtcXCRcXHddKylcXHMqLFxccyooW1xcJFxcd10rKVxcKSkkLyk7XHJcbiAgICAgICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgICAgdGhyb3cgbmdSZXBlYXRNaW5FcnIoJ2lpZGV4cCcsIFwiJ19pdGVtXycgaW4gJ19pdGVtXyBpbiBfY29sbGVjdGlvbl8nIHNob3VsZCBiZSBhbiBpZGVudGlmaWVyIG9yICcoX2tleV8sIF92YWx1ZV8pJyBleHByZXNzaW9uLCBidXQgZ290ICd7MH0nLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxocyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlSWRlbnRpZmllciA9IG1hdGNoWzNdIHx8IG1hdGNoWzFdO1xyXG4gICAgICAgIGtleUlkZW50aWZpZXIgPSBtYXRjaFsyXTtcclxuXHJcbiAgICAgICAgLy8gU3RvcmUgYSBsaXN0IG9mIGVsZW1lbnRzIGZyb20gcHJldmlvdXMgcnVuLiBUaGlzIGlzIGEgaGFzaCB3aGVyZSBrZXkgaXMgdGhlIGl0ZW0gZnJvbSB0aGVcclxuICAgICAgICAvLyBpdGVyYXRvciwgYW5kIHRoZSB2YWx1ZSBpcyBvYmplY3RzIHdpdGggZm9sbG93aW5nIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gICAtIHNjb3BlOiBib3VuZCBzY29wZVxyXG4gICAgICAgIC8vICAgLSBlbGVtZW50OiBwcmV2aW91cyBlbGVtZW50LlxyXG4gICAgICAgIC8vICAgLSBpbmRleDogcG9zaXRpb25cclxuICAgICAgICB2YXIgbGFzdEJsb2NrTWFwID0ge307XHJcblxyXG4gICAgICAgIC8vd2F0Y2ggcHJvcHNcclxuICAgICAgICAkc2NvcGUuJHdhdGNoQ29sbGVjdGlvbihyaHMsIGZ1bmN0aW9uIG5nUmVwZWF0QWN0aW9uKGNvbGxlY3Rpb24pe1xyXG4gICAgICAgICAgdmFyIGluZGV4LCBsZW5ndGgsXHJcbiAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gJGVsZW1lbnRbMF0sICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBub2RlXHJcbiAgICAgICAgICAgICAgbmV4dE5vZGUsXHJcbiAgICAgICAgICAgICAgLy8gU2FtZSBhcyBsYXN0QmxvY2tNYXAgYnV0IGl0IGhhcyB0aGUgY3VycmVudCBzdGF0ZS4gSXQgd2lsbCBiZWNvbWUgdGhlXHJcbiAgICAgICAgICAgICAgLy8gbGFzdEJsb2NrTWFwIG9uIHRoZSBuZXh0IGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgICBuZXh0QmxvY2tNYXAgPSB7fSxcclxuICAgICAgICAgICAgICBhcnJheUxlbmd0aCxcclxuICAgICAgICAgICAgICBjaGlsZFNjb3BlLFxyXG4gICAgICAgICAgICAgIGtleSwgdmFsdWUsIC8vIGtleS92YWx1ZSBvZiBpdGVyYXRpb25cclxuICAgICAgICAgICAgICB0cmFja0J5SWQsXHJcbiAgICAgICAgICAgICAgY29sbGVjdGlvbktleXMsXHJcbiAgICAgICAgICAgICAgYmxvY2ssICAgICAgIC8vIGxhc3Qgb2JqZWN0IGluZm9ybWF0aW9uIHtzY29wZSwgZWxlbWVudCwgaWR9XHJcbiAgICAgICAgICAgICAgbmV4dEJsb2NrT3JkZXIgPSBbXTtcclxuXHJcblxyXG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25LZXlzID0gY29sbGVjdGlvbjtcclxuICAgICAgICAgICAgdHJhY2tCeUlkRm4gPSB0cmFja0J5SWRGbiB8fCB0cmFja0J5SWRBcnJheUZuO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdHJhY2tCeUlkRm4gPSB0cmFja0J5SWRGbiB8fCB0cmFja0J5SWRPYmpGbjtcclxuICAgICAgICAgICAgLy8gaWYgb2JqZWN0LCBleHRyYWN0IGtleXMsIHNvcnQgdGhlbSBhbmQgdXNlIHRvIGRldGVybWluZSBvcmRlciBvZiBpdGVyYXRpb24gb3ZlciBvYmogcHJvcHNcclxuICAgICAgICAgICAgY29sbGVjdGlvbktleXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChrZXkgaW4gY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5LmNoYXJBdCgwKSAhPSAnJCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25LZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29sbGVjdGlvbktleXMuc29ydCgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGFycmF5TGVuZ3RoID0gY29sbGVjdGlvbktleXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIGxvY2F0ZSBleGlzdGluZyBpdGVtc1xyXG4gICAgICAgICAgbGVuZ3RoID0gbmV4dEJsb2NrT3JkZXIubGVuZ3RoID0gY29sbGVjdGlvbktleXMubGVuZ3RoO1xyXG4gICAgICAgICAgZm9yKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICBrZXkgPSAoY29sbGVjdGlvbiA9PT0gY29sbGVjdGlvbktleXMpID8gaW5kZXggOiBjb2xsZWN0aW9uS2V5c1tpbmRleF07XHJcbiAgICAgICAgICAgdmFsdWUgPSBjb2xsZWN0aW9uW2tleV07XHJcbiAgICAgICAgICAgdHJhY2tCeUlkID0gdHJhY2tCeUlkRm4oa2V5LCB2YWx1ZSwgaW5kZXgpO1xyXG4gICAgICAgICAgIGlmKGxhc3RCbG9ja01hcC5oYXNPd25Qcm9wZXJ0eSh0cmFja0J5SWQpKSB7XHJcbiAgICAgICAgICAgICBibG9jayA9IGxhc3RCbG9ja01hcFt0cmFja0J5SWRdXHJcbiAgICAgICAgICAgICBkZWxldGUgbGFzdEJsb2NrTWFwW3RyYWNrQnlJZF07XHJcbiAgICAgICAgICAgICBuZXh0QmxvY2tNYXBbdHJhY2tCeUlkXSA9IGJsb2NrO1xyXG4gICAgICAgICAgICAgbmV4dEJsb2NrT3JkZXJbaW5kZXhdID0gYmxvY2s7XHJcbiAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0QmxvY2tNYXAuaGFzT3duUHJvcGVydHkodHJhY2tCeUlkKSkge1xyXG4gICAgICAgICAgICAgLy8gcmVzdG9yZSBsYXN0QmxvY2tNYXBcclxuICAgICAgICAgICAgIGZvckVhY2gobmV4dEJsb2NrT3JkZXIsIGZ1bmN0aW9uKGJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5zdGFydE5vZGUpIGxhc3RCbG9ja01hcFtibG9jay5pZF0gPSBibG9jaztcclxuICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGR1cGxpY2F0ZSBhbmQgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvclxyXG4gICAgICAgICAgICAgdGhyb3cgbmdSZXBlYXRNaW5FcnIoJ2R1cGVzJywgXCJEdXBsaWNhdGVzIGluIGEgcmVwZWF0ZXIgYXJlIG5vdCBhbGxvd2VkLiBVc2UgJ3RyYWNrIGJ5JyBleHByZXNzaW9uIHRvIHNwZWNpZnkgdW5pcXVlIGtleXMuIFJlcGVhdGVyOiB7MH0sIER1cGxpY2F0ZSBrZXk6IHsxfVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiwgICAgICAgdHJhY2tCeUlkKTtcclxuICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgLy8gbmV3IG5ldmVyIGJlZm9yZSBzZWVuIGJsb2NrXHJcbiAgICAgICAgICAgICBuZXh0QmxvY2tPcmRlcltpbmRleF0gPSB7IGlkOiB0cmFja0J5SWQgfTtcclxuICAgICAgICAgICAgIG5leHRCbG9ja01hcFt0cmFja0J5SWRdID0gZmFsc2U7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nIGl0ZW1zXHJcbiAgICAgICAgICBmb3IgKGtleSBpbiBsYXN0QmxvY2tNYXApIHtcclxuICAgICAgICAgICAgaWYgKGxhc3RCbG9ja01hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgYmxvY2sgPSBsYXN0QmxvY2tNYXBba2V5XTtcclxuICAgICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShibG9jay5lbGVtZW50cyk7XHJcbiAgICAgICAgICAgICAgZm9yRWFjaChibG9jay5lbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkgeyBlbGVtZW50W05HX1JFTU9WRURdID0gdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgIGJsb2NrLnNjb3BlLiRkZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIGZvckVhY2ggZm9yIHBlcmYgcmVhc29ucyAodHJ5aW5nIHRvIGF2b2lkICNjYWxsKVxyXG4gICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGNvbGxlY3Rpb25LZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAga2V5ID0gKGNvbGxlY3Rpb24gPT09IGNvbGxlY3Rpb25LZXlzKSA/IGluZGV4IDogY29sbGVjdGlvbktleXNbaW5kZXhdO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGNvbGxlY3Rpb25ba2V5XTtcclxuICAgICAgICAgICAgYmxvY2sgPSBuZXh0QmxvY2tPcmRlcltpbmRleF07XHJcblxyXG4gICAgICAgICAgICBpZiAoYmxvY2suc3RhcnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbHJlYWR5IHNlZW4gdGhpcyBvYmplY3QsIHRoZW4gd2UgbmVlZCB0byByZXVzZSB0aGVcclxuICAgICAgICAgICAgICAvLyBhc3NvY2lhdGVkIHNjb3BlL2VsZW1lbnRcclxuICAgICAgICAgICAgICBjaGlsZFNjb3BlID0gYmxvY2suc2NvcGU7XHJcblxyXG4gICAgICAgICAgICAgIG5leHROb2RlID0gcHJldmlvdXNOb2RlO1xyXG4gICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dE5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgfSB3aGlsZShuZXh0Tm9kZSAmJiBuZXh0Tm9kZVtOR19SRU1PVkVEXSk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChibG9jay5zdGFydE5vZGUgPT0gbmV4dE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgaXRlbSB3aGljaCBnb3QgbW92ZWRcclxuICAgICAgICAgICAgICAgICRhbmltYXRlLm1vdmUoYmxvY2suZWxlbWVudHMsIG51bGwsIGpxTGl0ZShwcmV2aW91c05vZGUpKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gYmxvY2suZW5kTm9kZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBuZXcgaXRlbSB3aGljaCB3ZSBkb24ndCBrbm93IGFib3V0XHJcbiAgICAgICAgICAgICAgY2hpbGRTY29wZSA9ICRzY29wZS4kbmV3KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNoaWxkU2NvcGVbdmFsdWVJZGVudGlmaWVyXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoa2V5SWRlbnRpZmllcikgY2hpbGRTY29wZVtrZXlJZGVudGlmaWVyXSA9IGtleTtcclxuICAgICAgICAgICAgY2hpbGRTY29wZS4kaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgY2hpbGRTY29wZS4kZmlyc3QgPSAoaW5kZXggPT09IDApO1xyXG4gICAgICAgICAgICBjaGlsZFNjb3BlLiRsYXN0ID0gKGluZGV4ID09PSAoYXJyYXlMZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgIGNoaWxkU2NvcGUuJG1pZGRsZSA9ICEoY2hpbGRTY29wZS4kZmlyc3QgfHwgY2hpbGRTY29wZS4kbGFzdCk7XHJcbiAgICAgICAgICAgIGNoaWxkU2NvcGUuJG9kZCA9ICEoY2hpbGRTY29wZS4kZXZlbiA9IGluZGV4JTI9PTApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFibG9jay5zdGFydE5vZGUpIHtcclxuICAgICAgICAgICAgICBsaW5rZXIoY2hpbGRTY29wZSwgZnVuY3Rpb24oY2xvbmUpIHtcclxuICAgICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGNsb25lLCBudWxsLCBqcUxpdGUocHJldmlvdXNOb2RlKSk7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSBjbG9uZTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLnNjb3BlID0gY2hpbGRTY29wZTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLnN0YXJ0Tm9kZSA9IGNsb25lWzBdO1xyXG4gICAgICAgICAgICAgICAgYmxvY2suZWxlbWVudHMgPSBjbG9uZTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLmVuZE5vZGUgPSBjbG9uZVtjbG9uZS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIG5leHRCbG9ja01hcFtibG9jay5pZF0gPSBibG9jaztcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGFzdEJsb2NrTWFwID0gbmV4dEJsb2NrTWFwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn1dO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nU2hvd1xyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIGBuZ1Nob3dgIGRpcmVjdGl2ZSBzaG93cyBhbmQgaGlkZXMgdGhlIGdpdmVuIEhUTUwgZWxlbWVudCBjb25kaXRpb25hbGx5IGJhc2VkIG9uIHRoZSBleHByZXNzaW9uXHJcbiAqIHByb3ZpZGVkIHRvIHRoZSBuZ1Nob3cgYXR0cmlidXRlLiBUaGUgc2hvdyBhbmQgaGlkZSBtZWNoYW5pc20gaXMgYSBhY2hpZXZlZCBieSByZW1vdmluZyBhbmQgYWRkaW5nXHJcbiAqIHRoZSBgbmctaGlkZWAgQ1NTIGNsYXNzIG9udG8gdGhlIGVsZW1lbnQuIFRoZSBgLm5nLWhpZGVgIENTUyBjbGFzcyBpcyBhIHByZWRlZmluZWQgQ1NTIGNsYXNzIHByZXNlbnRcclxuICogaW4gQW5ndWxhckpTIHdoaWNoIHNldHMgdGhlIGRpc3BsYXkgc3R5bGUgdG8gbm9uZSAodXNpbmcgYW4gIWltcG9ydGFudCBmbGFnKS5cclxuICpcclxuICogPHByZT5cclxuICogPCEtLSB3aGVuICRzY29wZS5teVZhbHVlIGlzIHRydXRoeSAoZWxlbWVudCBpcyB2aXNpYmxlKSAtLT5cclxuICogPGRpdiBuZy1zaG93PVwibXlWYWx1ZVwiPjwvZGl2PlxyXG4gKlxyXG4gKiA8IS0tIHdoZW4gJHNjb3BlLm15VmFsdWUgaXMgZmFsc3kgKGVsZW1lbnQgaXMgaGlkZGVuKSAtLT5cclxuICogPGRpdiBuZy1zaG93PVwibXlWYWx1ZVwiIGNsYXNzPVwibmctaGlkZVwiPjwvZGl2PlxyXG4gKiA8L3ByZT5cclxuICpcclxuICogV2hlbiB0aGUgbmdTaG93IGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGZhbHNlIHRoZW4gdGhlIG5nLWhpZGUgQ1NTIGNsYXNzIGlzIGFkZGVkIHRvIHRoZSBjbGFzcyBhdHRyaWJ1dGVcclxuICogb24gdGhlIGVsZW1lbnQgY2F1c2luZyBpdCB0byBiZWNvbWUgaGlkZGVuLiBXaGVuIHRydWUsIHRoZSBuZy1oaWRlIENTUyBjbGFzcyBpcyByZW1vdmVkXHJcbiAqIGZyb20gdGhlIGVsZW1lbnQgY2F1c2luZyB0aGUgZWxlbWVudCBub3QgdG8gYXBwZWFyIGhpZGRlbi5cclxuICpcclxuICogIyMgV2h5IGlzICFpbXBvcnRhbnQgdXNlZD9cclxuICpcclxuICogWW91IG1heSBiZSB3b25kZXJpbmcgd2h5ICFpbXBvcnRhbnQgaXMgdXNlZCBmb3IgdGhlIC5uZy1oaWRlIENTUyBjbGFzcy4gVGhpcyBpcyBiZWNhdXNlIHRoZSBgLm5nLWhpZGVgIHNlbGVjdG9yXHJcbiAqIGNhbiBiZSBlYXNpbHkgb3ZlcnJpZGRlbiBieSBoZWF2aWVyIHNlbGVjdG9ycy4gRm9yIGV4YW1wbGUsIHNvbWV0aGluZyBhcyBzaW1wbGVcclxuICogYXMgY2hhbmdpbmcgdGhlIGRpc3BsYXkgc3R5bGUgb24gYSBIVE1MIGxpc3QgaXRlbSB3b3VsZCBtYWtlIGhpZGRlbiBlbGVtZW50cyBhcHBlYXIgdmlzaWJsZS5cclxuICogVGhpcyBhbHNvIGJlY29tZXMgYSBiaWdnZXIgaXNzdWUgd2hlbiBkZWFsaW5nIHdpdGggQ1NTIGZyYW1ld29ya3MuXHJcbiAqXHJcbiAqIEJ5IHVzaW5nICFpbXBvcnRhbnQsIHRoZSBzaG93IGFuZCBoaWRlIGJlaGF2aW9yIHdpbGwgd29yayBhcyBleHBlY3RlZCBkZXNwaXRlIGFueSBjbGFzaCBiZXR3ZWVuIENTUyBzZWxlY3RvclxyXG4gKiBzcGVjaWZpY2l0eSAod2hlbiAhaW1wb3J0YW50IGlzbid0IHVzZWQgd2l0aCBhbnkgY29uZmxpY3Rpbmcgc3R5bGVzKS4gSWYgYSBkZXZlbG9wZXIgY2hvb3NlcyB0byBvdmVycmlkZSB0aGVcclxuICogc3R5bGluZyB0byBjaGFuZ2UgaG93IHRvIGhpZGUgYW4gZWxlbWVudCB0aGVuIGl0IGlzIGp1c3QgYSBtYXR0ZXIgb2YgdXNpbmcgIWltcG9ydGFudCBpbiB0aGVpciBvd24gQ1NTIGNvZGUuXHJcbiAqXHJcbiAqICMjIyBPdmVycmlkaW5nIC5uZy1oaWRlXHJcbiAqXHJcbiAqIElmIHlvdSB3aXNoIHRvIGNoYW5nZSB0aGUgaGlkZSBiZWhhdmlvciB3aXRoIG5nU2hvdy9uZ0hpZGUgdGhlbiB0aGlzIGNhbiBiZSBhY2hpZXZlZCBieVxyXG4gKiByZXN0YXRpbmcgdGhlIHN0eWxlcyBmb3IgdGhlIC5uZy1oaWRlIGNsYXNzIGluIENTUzpcclxuICogPHByZT5cclxuICogLm5nLWhpZGUge1xyXG4gKiAgIC8vIWFubm90YXRlIENTUyBTcGVjaWZpY2l0eXxOb3QgdG8gd29ycnksIHRoaXMgd2lsbCBvdmVycmlkZSB0aGUgQW5ndWxhckpTIGRlZmF1bHQuLi5cclxuICogICBkaXNwbGF5OmJsb2NrIWltcG9ydGFudDtcclxuICpcclxuICogICAvL3RoaXMgaXMganVzdCBhbm90aGVyIGZvcm0gb2YgaGlkaW5nIGFuIGVsZW1lbnRcclxuICogICBwb3NpdGlvbjphYnNvbHV0ZTtcclxuICogICB0b3A6LTk5OTlweDtcclxuICogICBsZWZ0Oi05OTk5cHg7XHJcbiAqIH1cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIEp1c3QgcmVtZW1iZXIgdG8gaW5jbHVkZSB0aGUgaW1wb3J0YW50IGZsYWcgc28gdGhlIENTUyBvdmVycmlkZSB3aWxsIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiAjIyBBIG5vdGUgYWJvdXQgYW5pbWF0aW9ucyB3aXRoIG5nU2hvd1xyXG4gKlxyXG4gKiBBbmltYXRpb25zIGluIG5nU2hvdy9uZ0hpZGUgd29yayB3aXRoIHRoZSBzaG93IGFuZCBoaWRlIGV2ZW50cyB0aGF0IGFyZSB0cmlnZ2VyZWQgd2hlbiB0aGUgZGlyZWN0aXZlIGV4cHJlc3Npb25cclxuICogaXMgdHJ1ZSBhbmQgZmFsc2UuIFRoaXMgc3lzdGVtIHdvcmtzIHNpbWlsYXIgdG8gdGhlIGFuaW1hdGlvbiBzeXN0ZW0gcHJlc2VudCB3aXRoIG5nQ2xhc3MsIGhvd2V2ZXIsIHRoZVxyXG4gKiBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB5b3UgbXVzdCBhbHNvIGluY2x1ZGUgdGhlICFpbXBvcnRhbnQgZmxhZyB0byBvdmVycmlkZSB0aGUgZGlzcGxheSBwcm9wZXJ0eSBzb1xyXG4gKiB0aGF0IHlvdSBjYW4gcGVyZm9ybSBhbiBhbmltYXRpb24gd2hlbiB0aGUgZWxlbWVudCBpcyBoaWRkZW4gZHVyaW5nIHRoZSB0aW1lIG9mIHRoZSBhbmltYXRpb24uXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIC8vXHJcbiAqIC8vYSB3b3JraW5nIGV4YW1wbGUgY2FuIGJlIGZvdW5kIGF0IHRoZSBib3R0b20gb2YgdGhpcyBwYWdlXHJcbiAqIC8vXHJcbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtYWRkLCAubXktZWxlbWVudC5uZy1oaWRlLXJlbW92ZSB7XHJcbiAqICAgdHJhbnNpdGlvbjowLjVzIGxpbmVhciBhbGw7XHJcbiAqICAgZGlzcGxheTpibG9jayFpbXBvcnRhbnQ7XHJcbiAqIH1cclxuICpcclxuICogLm15LWVsZW1lbnQubmctaGlkZS1hZGQgeyAuLi4gfVxyXG4gKiAubXktZWxlbWVudC5uZy1oaWRlLWFkZC5uZy1oaWRlLWFkZC1hY3RpdmUgeyAuLi4gfVxyXG4gKiAubXktZWxlbWVudC5uZy1oaWRlLXJlbW92ZSB7IC4uLiB9XHJcbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtcmVtb3ZlLm5nLWhpZGUtcmVtb3ZlLWFjdGl2ZSB7IC4uLiB9XHJcbiAqIDwvcHJlPlxyXG4gKlxyXG4gKiBAYW5pbWF0aW9uc1xyXG4gKiBhZGRDbGFzczogLm5nLWhpZGUgLSBoYXBwZW5zIGFmdGVyIHRoZSBuZ1Nob3cgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYSB0cnV0aHkgdmFsdWUgYW5kIHRoZSBqdXN0IGJlZm9yZSBjb250ZW50cyBhcmUgc2V0IHRvIHZpc2libGVcclxuICogcmVtb3ZlQ2xhc3M6IC5uZy1oaWRlIC0gaGFwcGVucyBhZnRlciB0aGUgbmdTaG93IGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGEgbm9uIHRydXRoeSB2YWx1ZSBhbmQganVzdCBiZWZvcmUgdGhlIGNvbnRlbnRzIGFyZSBzZXQgdG8gaGlkZGVuXHJcbiAqXHJcbiAqIEBlbGVtZW50IEFOWVxyXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nU2hvdyBJZiB0aGUge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0gaXMgdHJ1dGh5XHJcbiAqICAgICB0aGVuIHRoZSBlbGVtZW50IGlzIHNob3duIG9yIGhpZGRlbiByZXNwZWN0aXZlbHkuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgPGV4YW1wbGUgYW5pbWF0aW9ucz1cInRydWVcIj5cclxuICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICAgIENsaWNrIG1lOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJjaGVja2VkXCI+PGJyLz5cclxuICAgICAgPGRpdj5cclxuICAgICAgICBTaG93OlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjaGVjay1lbGVtZW50IGFuaW1hdGUtc2hvd1wiIG5nLXNob3c9XCJjaGVja2VkXCI+XHJcbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24tdGh1bWJzLXVwXCI+PC9zcGFuPiBJIHNob3cgdXAgd2hlbiB5b3VyIGNoZWNrYm94IGlzIGNoZWNrZWQuXHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2PlxyXG4gICAgICAgIEhpZGU6XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNoZWNrLWVsZW1lbnQgYW5pbWF0ZS1zaG93XCIgbmctaGlkZT1cImNoZWNrZWRcIj5cclxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi10aHVtYnMtZG93blwiPjwvc3Bhbj4gSSBoaWRlIHdoZW4geW91ciBjaGVja2JveCBpcyBjaGVja2VkLlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJhbmltYXRpb25zLmNzc1wiPlxyXG4gICAgICAuYW5pbWF0ZS1zaG93Lm5nLWhpZGUtYWRkLCBcclxuICAgICAgLmFuaW1hdGUtc2hvdy5uZy1oaWRlLXJlbW92ZSB7XHJcbiAgICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOmFsbCBsaW5lYXIgMC41cztcclxuICAgICAgICAtbW96LXRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xyXG4gICAgICAgIC1vLXRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xyXG4gICAgICAgIHRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xyXG4gICAgICAgIGRpc3BsYXk6YmxvY2shaW1wb3J0YW50O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuYW5pbWF0ZS1zaG93Lm5nLWhpZGUtYWRkLm5nLWhpZGUtYWRkLWFjdGl2ZSxcclxuICAgICAgLmFuaW1hdGUtc2hvdy5uZy1oaWRlLXJlbW92ZSB7XHJcbiAgICAgICAgbGluZS1oZWlnaHQ6MDtcclxuICAgICAgICBvcGFjaXR5OjA7XHJcbiAgICAgICAgcGFkZGluZzowIDEwcHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5hbmltYXRlLXNob3cubmctaGlkZS1hZGQsXHJcbiAgICAgIC5hbmltYXRlLXNob3cubmctaGlkZS1yZW1vdmUubmctaGlkZS1yZW1vdmUtYWN0aXZlIHtcclxuICAgICAgICBsaW5lLWhlaWdodDoyMHB4O1xyXG4gICAgICAgIG9wYWNpdHk6MTtcclxuICAgICAgICBwYWRkaW5nOjEwcHg7XHJcbiAgICAgICAgYm9yZGVyOjFweCBzb2xpZCBibGFjaztcclxuICAgICAgICBiYWNrZ3JvdW5kOndoaXRlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuY2hlY2stZWxlbWVudCB7XHJcbiAgICAgICAgcGFkZGluZzoxMHB4O1xyXG4gICAgICAgIGJvcmRlcjoxcHggc29saWQgYmxhY2s7XHJcbiAgICAgICAgYmFja2dyb3VuZDp3aGl0ZTtcclxuICAgICAgfVxyXG4gICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLXNob3cgLyBuZy1oaWRlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBzcGFuOmZpcnN0OmhpZGRlbicpLmNvdW50KCkpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBzcGFuOmxhc3Q6dmlzaWJsZScpLmNvdW50KCkpLnRvRXF1YWwoMSk7XHJcblxyXG4gICAgICAgICBpbnB1dCgnY2hlY2tlZCcpLmNoZWNrKCk7XHJcblxyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgc3BhbjpmaXJzdDp2aXNpYmxlJykuY291bnQoKSkudG9FcXVhbCgxKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHNwYW46bGFzdDpoaWRkZW4nKS5jb3VudCgpKS50b0VxdWFsKDEpO1xyXG4gICAgICAgfSk7XHJcbiAgICA8L2ZpbGU+XHJcbiAgPC9leGFtcGxlPlxyXG4gKi9cclxudmFyIG5nU2hvd0RpcmVjdGl2ZSA9IFsnJGFuaW1hdGUnLCBmdW5jdGlvbigkYW5pbWF0ZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gICAgc2NvcGUuJHdhdGNoKGF0dHIubmdTaG93LCBmdW5jdGlvbiBuZ1Nob3dXYXRjaEFjdGlvbih2YWx1ZSl7XHJcbiAgICAgICRhbmltYXRlW3RvQm9vbGVhbih2YWx1ZSkgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oZWxlbWVudCwgJ25nLWhpZGUnKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1dO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0hpZGVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgbmdIaWRlYCBkaXJlY3RpdmUgc2hvd3MgYW5kIGhpZGVzIHRoZSBnaXZlbiBIVE1MIGVsZW1lbnQgY29uZGl0aW9uYWxseSBiYXNlZCBvbiB0aGUgZXhwcmVzc2lvblxyXG4gKiBwcm92aWRlZCB0byB0aGUgbmdIaWRlIGF0dHJpYnV0ZS4gVGhlIHNob3cgYW5kIGhpZGUgbWVjaGFuaXNtIGlzIGEgYWNoaWV2ZWQgYnkgcmVtb3ZpbmcgYW5kIGFkZGluZ1xyXG4gKiB0aGUgYG5nLWhpZGVgIENTUyBjbGFzcyBvbnRvIHRoZSBlbGVtZW50LiBUaGUgYC5uZy1oaWRlYCBDU1MgY2xhc3MgaXMgYSBwcmVkZWZpbmVkIENTUyBjbGFzcyBwcmVzZW50XHJcbiAqIGluIEFuZ3VsYXJKUyB3aGljaCBzZXRzIHRoZSBkaXNwbGF5IHN0eWxlIHRvIG5vbmUgKHVzaW5nIGFuICFpbXBvcnRhbnQgZmxhZykuXHJcbiAqXHJcbiAqIDxwcmU+XHJcbiAqIDwhLS0gd2hlbiAkc2NvcGUubXlWYWx1ZSBpcyB0cnV0aHkgKGVsZW1lbnQgaXMgaGlkZGVuKSAtLT5cclxuICogPGRpdiBuZy1oaWRlPVwibXlWYWx1ZVwiPjwvZGl2PlxyXG4gKlxyXG4gKiA8IS0tIHdoZW4gJHNjb3BlLm15VmFsdWUgaXMgZmFsc3kgKGVsZW1lbnQgaXMgdmlzaWJsZSkgLS0+XHJcbiAqIDxkaXYgbmctaGlkZT1cIm15VmFsdWVcIiBjbGFzcz1cIm5nLWhpZGVcIj48L2Rpdj5cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIFdoZW4gdGhlIG5nSGlkZSBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlIHRoZW4gdGhlIC5uZy1oaWRlIENTUyBjbGFzcyBpcyBhZGRlZCB0byB0aGUgY2xhc3MgYXR0cmlidXRlXHJcbiAqIG9uIHRoZSBlbGVtZW50IGNhdXNpbmcgaXQgdG8gYmVjb21lIGhpZGRlbi4gV2hlbiBmYWxzZSwgdGhlIG5nLWhpZGUgQ1NTIGNsYXNzIGlzIHJlbW92ZWRcclxuICogZnJvbSB0aGUgZWxlbWVudCBjYXVzaW5nIHRoZSBlbGVtZW50IG5vdCB0byBhcHBlYXIgaGlkZGVuLlxyXG4gKlxyXG4gKiAjIyBXaHkgaXMgIWltcG9ydGFudCB1c2VkP1xyXG4gKlxyXG4gKiBZb3UgbWF5IGJlIHdvbmRlcmluZyB3aHkgIWltcG9ydGFudCBpcyB1c2VkIGZvciB0aGUgLm5nLWhpZGUgQ1NTIGNsYXNzLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGAubmctaGlkZWAgc2VsZWN0b3JcclxuICogY2FuIGJlIGVhc2lseSBvdmVycmlkZGVuIGJ5IGhlYXZpZXIgc2VsZWN0b3JzLiBGb3IgZXhhbXBsZSwgc29tZXRoaW5nIGFzIHNpbXBsZVxyXG4gKiBhcyBjaGFuZ2luZyB0aGUgZGlzcGxheSBzdHlsZSBvbiBhIEhUTUwgbGlzdCBpdGVtIHdvdWxkIG1ha2UgaGlkZGVuIGVsZW1lbnRzIGFwcGVhciB2aXNpYmxlLlxyXG4gKiBUaGlzIGFsc28gYmVjb21lcyBhIGJpZ2dlciBpc3N1ZSB3aGVuIGRlYWxpbmcgd2l0aCBDU1MgZnJhbWV3b3Jrcy5cclxuICpcclxuICogQnkgdXNpbmcgIWltcG9ydGFudCwgdGhlIHNob3cgYW5kIGhpZGUgYmVoYXZpb3Igd2lsbCB3b3JrIGFzIGV4cGVjdGVkIGRlc3BpdGUgYW55IGNsYXNoIGJldHdlZW4gQ1NTIHNlbGVjdG9yXHJcbiAqIHNwZWNpZmljaXR5ICh3aGVuICFpbXBvcnRhbnQgaXNuJ3QgdXNlZCB3aXRoIGFueSBjb25mbGljdGluZyBzdHlsZXMpLiBJZiBhIGRldmVsb3BlciBjaG9vc2VzIHRvIG92ZXJyaWRlIHRoZVxyXG4gKiBzdHlsaW5nIHRvIGNoYW5nZSBob3cgdG8gaGlkZSBhbiBlbGVtZW50IHRoZW4gaXQgaXMganVzdCBhIG1hdHRlciBvZiB1c2luZyAhaW1wb3J0YW50IGluIHRoZWlyIG93biBDU1MgY29kZS5cclxuICpcclxuICogIyMjIE92ZXJyaWRpbmcgLm5nLWhpZGVcclxuICpcclxuICogSWYgeW91IHdpc2ggdG8gY2hhbmdlIHRoZSBoaWRlIGJlaGF2aW9yIHdpdGggbmdTaG93L25nSGlkZSB0aGVuIHRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5XHJcbiAqIHJlc3RhdGluZyB0aGUgc3R5bGVzIGZvciB0aGUgLm5nLWhpZGUgY2xhc3MgaW4gQ1NTOlxyXG4gKiA8cHJlPlxyXG4gKiAubmctaGlkZSB7XHJcbiAqICAgLy8hYW5ub3RhdGUgQ1NTIFNwZWNpZmljaXR5fE5vdCB0byB3b3JyeSwgdGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBBbmd1bGFySlMgZGVmYXVsdC4uLlxyXG4gKiAgIGRpc3BsYXk6YmxvY2shaW1wb3J0YW50O1xyXG4gKlxyXG4gKiAgIC8vdGhpcyBpcyBqdXN0IGFub3RoZXIgZm9ybSBvZiBoaWRpbmcgYW4gZWxlbWVudFxyXG4gKiAgIHBvc2l0aW9uOmFic29sdXRlO1xyXG4gKiAgIHRvcDotOTk5OXB4O1xyXG4gKiAgIGxlZnQ6LTk5OTlweDtcclxuICogfVxyXG4gKiA8L3ByZT5cclxuICpcclxuICogSnVzdCByZW1lbWJlciB0byBpbmNsdWRlIHRoZSBpbXBvcnRhbnQgZmxhZyBzbyB0aGUgQ1NTIG92ZXJyaWRlIHdpbGwgZnVuY3Rpb24uXHJcbiAqXHJcbiAqICMjIEEgbm90ZSBhYm91dCBhbmltYXRpb25zIHdpdGggbmdIaWRlXHJcbiAqXHJcbiAqIEFuaW1hdGlvbnMgaW4gbmdTaG93L25nSGlkZSB3b3JrIHdpdGggdGhlIHNob3cgYW5kIGhpZGUgZXZlbnRzIHRoYXQgYXJlIHRyaWdnZXJlZCB3aGVuIHRoZSBkaXJlY3RpdmUgZXhwcmVzc2lvblxyXG4gKiBpcyB0cnVlIGFuZCBmYWxzZS4gVGhpcyBzeXN0ZW0gd29ya3Mgc2ltaWxhciB0byB0aGUgYW5pbWF0aW9uIHN5c3RlbSBwcmVzZW50IHdpdGggbmdDbGFzcywgaG93ZXZlciwgdGhlXHJcbiAqIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHlvdSBtdXN0IGFsc28gaW5jbHVkZSB0aGUgIWltcG9ydGFudCBmbGFnIHRvIG92ZXJyaWRlIHRoZSBkaXNwbGF5IHByb3BlcnR5IHNvXHJcbiAqIHRoYXQgeW91IGNhbiBwZXJmb3JtIGFuIGFuaW1hdGlvbiB3aGVuIHRoZSBlbGVtZW50IGlzIGhpZGRlbiBkdXJpbmcgdGhlIHRpbWUgb2YgdGhlIGFuaW1hdGlvbi5cclxuICpcclxuICogPHByZT5cclxuICogLy9cclxuICogLy9hIHdvcmtpbmcgZXhhbXBsZSBjYW4gYmUgZm91bmQgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIHBhZ2VcclxuICogLy9cclxuICogLm15LWVsZW1lbnQubmctaGlkZS1hZGQsIC5teS1lbGVtZW50Lm5nLWhpZGUtcmVtb3ZlIHtcclxuICogICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcclxuICogICBkaXNwbGF5OmJsb2NrIWltcG9ydGFudDtcclxuICogfVxyXG4gKlxyXG4gKiAubXktZWxlbWVudC5uZy1oaWRlLWFkZCB7IC4uLiB9XHJcbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtYWRkLm5nLWhpZGUtYWRkLWFjdGl2ZSB7IC4uLiB9XHJcbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtcmVtb3ZlIHsgLi4uIH1cclxuICogLm15LWVsZW1lbnQubmctaGlkZS1yZW1vdmUubmctaGlkZS1yZW1vdmUtYWN0aXZlIHsgLi4uIH1cclxuICogPC9wcmU+XHJcbiAqXHJcbiAqIEBhbmltYXRpb25zXHJcbiAqIHJlbW92ZUNsYXNzOiAubmctaGlkZSAtIGhhcHBlbnMgYWZ0ZXIgdGhlIG5nSGlkZSBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBhIHRydXRoeSB2YWx1ZSBhbmQganVzdCBiZWZvcmUgdGhlIGNvbnRlbnRzIGFyZSBzZXQgdG8gaGlkZGVuXHJcbiAqIGFkZENsYXNzOiAubmctaGlkZSAtIGhhcHBlbnMgYWZ0ZXIgdGhlIG5nSGlkZSBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBhIG5vbiB0cnV0aHkgdmFsdWUgYW5kIGp1c3QgYmVmb3JlIHRoZSBjb250ZW50cyBhcmUgc2V0IHRvIHZpc2libGVcclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdIaWRlIElmIHRoZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpcyB0cnV0aHkgdGhlblxyXG4gKiAgICAgdGhlIGVsZW1lbnQgaXMgc2hvd24gb3IgaGlkZGVuIHJlc3BlY3RpdmVseS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICA8ZXhhbXBsZSBhbmltYXRpb25zPVwidHJ1ZVwiPlxyXG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cclxuICAgICAgQ2xpY2sgbWU6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImNoZWNrZWRcIj48YnIvPlxyXG4gICAgICA8ZGl2PlxyXG4gICAgICAgIFNob3c6XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNoZWNrLWVsZW1lbnQgYW5pbWF0ZS1oaWRlXCIgbmctc2hvdz1cImNoZWNrZWRcIj5cclxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi10aHVtYnMtdXBcIj48L3NwYW4+IEkgc2hvdyB1cCB3aGVuIHlvdXIgY2hlY2tib3ggaXMgY2hlY2tlZC5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgSGlkZTpcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2hlY2stZWxlbWVudCBhbmltYXRlLWhpZGVcIiBuZy1oaWRlPVwiY2hlY2tlZFwiPlxyXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uLXRodW1icy1kb3duXCI+PC9zcGFuPiBJIGhpZGUgd2hlbiB5b3VyIGNoZWNrYm94IGlzIGNoZWNrZWQuXHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9maWxlPlxyXG4gICAgPGZpbGUgbmFtZT1cImFuaW1hdGlvbnMuY3NzXCI+XHJcbiAgICAgIC5hbmltYXRlLWhpZGUubmctaGlkZS1hZGQsIFxyXG4gICAgICAuYW5pbWF0ZS1oaWRlLm5nLWhpZGUtcmVtb3ZlIHtcclxuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xyXG4gICAgICAgIC1tb3otdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XHJcbiAgICAgICAgLW8tdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XHJcbiAgICAgICAgdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XHJcbiAgICAgICAgZGlzcGxheTpibG9jayFpbXBvcnRhbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5hbmltYXRlLWhpZGUubmctaGlkZS1hZGQubmctaGlkZS1hZGQtYWN0aXZlLFxyXG4gICAgICAuYW5pbWF0ZS1oaWRlLm5nLWhpZGUtcmVtb3ZlIHtcclxuICAgICAgICBsaW5lLWhlaWdodDowO1xyXG4gICAgICAgIG9wYWNpdHk6MDtcclxuICAgICAgICBwYWRkaW5nOjAgMTBweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtaGlkZS5uZy1oaWRlLWFkZCxcclxuICAgICAgLmFuaW1hdGUtaGlkZS5uZy1oaWRlLXJlbW92ZS5uZy1oaWRlLXJlbW92ZS1hY3RpdmUge1xyXG4gICAgICAgIGxpbmUtaGVpZ2h0OjIwcHg7XHJcbiAgICAgICAgb3BhY2l0eToxO1xyXG4gICAgICAgIHBhZGRpbmc6MTBweDtcclxuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xyXG4gICAgICAgIGJhY2tncm91bmQ6d2hpdGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC5jaGVjay1lbGVtZW50IHtcclxuICAgICAgICBwYWRkaW5nOjEwcHg7XHJcbiAgICAgICAgYm9yZGVyOjFweCBzb2xpZCBibGFjaztcclxuICAgICAgICBiYWNrZ3JvdW5kOndoaXRlO1xyXG4gICAgICB9XHJcbiAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cclxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctc2hvdyAvIG5nLWhpZGUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIC5jaGVjay1lbGVtZW50OmZpcnN0OmhpZGRlbicpLmNvdW50KCkpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAuY2hlY2stZWxlbWVudDpsYXN0OnZpc2libGUnKS5jb3VudCgpKS50b0VxdWFsKDEpO1xyXG5cclxuICAgICAgICAgaW5wdXQoJ2NoZWNrZWQnKS5jaGVjaygpO1xyXG5cclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIC5jaGVjay1lbGVtZW50OmZpcnN0OnZpc2libGUnKS5jb3VudCgpKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgLmNoZWNrLWVsZW1lbnQ6bGFzdDpoaWRkZW4nKS5jb3VudCgpKS50b0VxdWFsKDEpO1xyXG4gICAgICAgfSk7XHJcbiAgICA8L2ZpbGU+XHJcbiAgPC9leGFtcGxlPlxyXG4gKi9cclxudmFyIG5nSGlkZURpcmVjdGl2ZSA9IFsnJGFuaW1hdGUnLCBmdW5jdGlvbigkYW5pbWF0ZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gICAgc2NvcGUuJHdhdGNoKGF0dHIubmdIaWRlLCBmdW5jdGlvbiBuZ0hpZGVXYXRjaEFjdGlvbih2YWx1ZSl7XHJcbiAgICAgICRhbmltYXRlW3RvQm9vbGVhbih2YWx1ZSkgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oZWxlbWVudCwgJ25nLWhpZGUnKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1dO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nU3R5bGVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoZSBgbmdTdHlsZWAgZGlyZWN0aXZlIGFsbG93cyB5b3UgdG8gc2V0IENTUyBzdHlsZSBvbiBhbiBIVE1MIGVsZW1lbnQgY29uZGl0aW9uYWxseS5cclxuICpcclxuICogQGVsZW1lbnQgQU5ZXHJcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdTdHlsZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB3aGljaCBldmFscyB0byBhblxyXG4gKiAgICAgIG9iamVjdCB3aG9zZSBrZXlzIGFyZSBDU1Mgc3R5bGUgbmFtZXMgYW5kIHZhbHVlcyBhcmUgY29ycmVzcG9uZGluZyB2YWx1ZXMgZm9yIHRob3NlIENTU1xyXG4gKiAgICAgIGtleXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgIDxleGFtcGxlPlxyXG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICAgICAgPGlucHV0IHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cInNldFwiIG5nLWNsaWNrPVwibXlTdHlsZT17Y29sb3I6J3JlZCd9XCI+XHJcbiAgICAgICAgPGlucHV0IHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cImNsZWFyXCIgbmctY2xpY2s9XCJteVN0eWxlPXt9XCI+XHJcbiAgICAgICAgPGJyLz5cclxuICAgICAgICA8c3BhbiBuZy1zdHlsZT1cIm15U3R5bGVcIj5TYW1wbGUgVGV4dDwvc3Bhbj5cclxuICAgICAgICA8cHJlPm15U3R5bGU9e3tteVN0eWxlfX08L3ByZT5cclxuICAgICA8L2ZpbGU+XHJcbiAgICAgPGZpbGUgbmFtZT1cInN0eWxlLmNzc1wiPlxyXG4gICAgICAgc3BhbiB7XHJcbiAgICAgICAgIGNvbG9yOiBibGFjaztcclxuICAgICAgIH1cclxuICAgICA8L2ZpbGU+XHJcbiAgICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XHJcbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLXN0eWxlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBzcGFuJykuY3NzKCdjb2xvcicpKS50b0JlKCdyZ2IoMCwgMCwgMCknKTtcclxuICAgICAgICAgZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgOmJ1dHRvblt2YWx1ZT1zZXRdJykuY2xpY2soKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHNwYW4nKS5jc3MoJ2NvbG9yJykpLnRvQmUoJ3JnYigyNTUsIDAsIDApJyk7XHJcbiAgICAgICAgIGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIDpidXR0b25bdmFsdWU9Y2xlYXJdJykuY2xpY2soKTtcclxuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHNwYW4nKS5jc3MoJ2NvbG9yJykpLnRvQmUoJ3JnYigwLCAwLCAwKScpO1xyXG4gICAgICAgfSk7XHJcbiAgICAgPC9maWxlPlxyXG4gICA8L2V4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdTdHlsZURpcmVjdGl2ZSA9IG5nRGlyZWN0aXZlKGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XHJcbiAgc2NvcGUuJHdhdGNoKGF0dHIubmdTdHlsZSwgZnVuY3Rpb24gbmdTdHlsZVdhdGNoQWN0aW9uKG5ld1N0eWxlcywgb2xkU3R5bGVzKSB7XHJcbiAgICBpZiAob2xkU3R5bGVzICYmIChuZXdTdHlsZXMgIT09IG9sZFN0eWxlcykpIHtcclxuICAgICAgZm9yRWFjaChvbGRTdHlsZXMsIGZ1bmN0aW9uKHZhbCwgc3R5bGUpIHsgZWxlbWVudC5jc3Moc3R5bGUsICcnKTt9KTtcclxuICAgIH1cclxuICAgIGlmIChuZXdTdHlsZXMpIGVsZW1lbnQuY3NzKG5ld1N0eWxlcyk7XHJcbiAgfSwgdHJ1ZSk7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nU3dpdGNoXHJcbiAqIEByZXN0cmljdCBFQVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogVGhlIG5nU3dpdGNoIGRpcmVjdGl2ZSBpcyB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgc3dhcCBET00gc3RydWN0dXJlIG9uIHlvdXIgdGVtcGxhdGUgYmFzZWQgb24gYSBzY29wZSBleHByZXNzaW9uLlxyXG4gKiBFbGVtZW50cyB3aXRoaW4gbmdTd2l0Y2ggYnV0IHdpdGhvdXQgbmdTd2l0Y2hXaGVuIG9yIG5nU3dpdGNoRGVmYXVsdCBkaXJlY3RpdmVzIHdpbGwgYmUgcHJlc2VydmVkIGF0IHRoZSBsb2NhdGlvblxyXG4gKiBhcyBzcGVjaWZpZWQgaW4gdGhlIHRlbXBsYXRlLlxyXG4gKlxyXG4gKiBUaGUgZGlyZWN0aXZlIGl0c2VsZiB3b3JrcyBzaW1pbGFyIHRvIG5nSW5jbHVkZSwgaG93ZXZlciwgaW5zdGVhZCBvZiBkb3dubG9hZGluZyB0ZW1wbGF0ZSBjb2RlIChvciBsb2FkaW5nIGl0XHJcbiAqIGZyb20gdGhlIHRlbXBsYXRlIGNhY2hlKSwgbmdTd2l0Y2ggc2ltcGx5IGNob3NlcyBvbmUgb2YgdGhlIG5lc3RlZCBlbGVtZW50cyBhbmQgbWFrZXMgaXQgdmlzaWJsZSBiYXNlZCBvbiB3aGljaCBlbGVtZW50XHJcbiAqIG1hdGNoZXMgdGhlIHZhbHVlIG9idGFpbmVkIGZyb20gdGhlIGV2YWx1YXRlZCBleHByZXNzaW9uLiBJbiBvdGhlciB3b3JkcywgeW91IGRlZmluZSBhIGNvbnRhaW5lciBlbGVtZW50XHJcbiAqICh3aGVyZSB5b3UgcGxhY2UgdGhlIGRpcmVjdGl2ZSksIHBsYWNlIGFuIGV4cHJlc3Npb24gb24gdGhlICoqb249XCIuLi5cIiBhdHRyaWJ1dGUqKlxyXG4gKiAob3IgdGhlICoqbmctc3dpdGNoPVwiLi4uXCIgYXR0cmlidXRlKiopLCBkZWZpbmUgYW55IGlubmVyIGVsZW1lbnRzIGluc2lkZSBvZiB0aGUgZGlyZWN0aXZlIGFuZCBwbGFjZVxyXG4gKiBhIHdoZW4gYXR0cmlidXRlIHBlciBlbGVtZW50LiBUaGUgd2hlbiBhdHRyaWJ1dGUgaXMgdXNlZCB0byBpbmZvcm0gbmdTd2l0Y2ggd2hpY2ggZWxlbWVudCB0byBkaXNwbGF5IHdoZW4gdGhlIG9uXHJcbiAqIGV4cHJlc3Npb24gaXMgZXZhbHVhdGVkLiBJZiBhIG1hdGNoaW5nIGV4cHJlc3Npb24gaXMgbm90IGZvdW5kIHZpYSBhIHdoZW4gYXR0cmlidXRlIHRoZW4gYW4gZWxlbWVudCB3aXRoIHRoZSBkZWZhdWx0XHJcbiAqIGF0dHJpYnV0ZSBpcyBkaXNwbGF5ZWQuXHJcbiAqXHJcbiAqIEBhbmltYXRpb25zXHJcbiAqIGVudGVyIC0gaGFwcGVucyBhZnRlciB0aGUgbmdTd3RpY2ggY29udGVudHMgY2hhbmdlIGFuZCB0aGUgbWF0Y2hlZCBjaGlsZCBlbGVtZW50IGlzIHBsYWNlZCBpbnNpZGUgdGhlIGNvbnRhaW5lclxyXG4gKiBsZWF2ZSAtIGhhcHBlbnMganVzdCBhZnRlciB0aGUgbmdTd2l0Y2ggY29udGVudHMgY2hhbmdlIGFuZCBqdXN0IGJlZm9yZSB0aGUgZm9ybWVyIGNvbnRlbnRzIGFyZSByZW1vdmVkIGZyb20gdGhlIERPTVxyXG4gKlxyXG4gKiBAdXNhZ2VcclxuICogPEFOWSBuZy1zd2l0Y2g9XCJleHByZXNzaW9uXCI+XHJcbiAqICAgPEFOWSBuZy1zd2l0Y2gtd2hlbj1cIm1hdGNoVmFsdWUxXCI+Li4uPC9BTlk+XHJcbiAqICAgPEFOWSBuZy1zd2l0Y2gtd2hlbj1cIm1hdGNoVmFsdWUyXCI+Li4uPC9BTlk+XHJcbiAqICAgPEFOWSBuZy1zd2l0Y2gtZGVmYXVsdD4uLi48L0FOWT5cclxuICogPC9BTlk+XHJcbiAqXHJcbiAqIEBzY29wZVxyXG4gKiBAcGFyYW0geyp9IG5nU3dpdGNofG9uIGV4cHJlc3Npb24gdG8gbWF0Y2ggYWdhaW5zdCA8dHQ+bmctc3dpdGNoLXdoZW48L3R0Pi5cclxuICogQHBhcmFtRGVzY3JpcHRpb25cclxuICogT24gY2hpbGQgZWxlbWVudHMgYWRkOlxyXG4gKlxyXG4gKiAqIGBuZ1N3aXRjaFdoZW5gOiB0aGUgY2FzZSBzdGF0ZW1lbnQgdG8gbWF0Y2ggYWdhaW5zdC4gSWYgbWF0Y2ggdGhlbiB0aGlzXHJcbiAqICAgY2FzZSB3aWxsIGJlIGRpc3BsYXllZC4gSWYgdGhlIHNhbWUgbWF0Y2ggYXBwZWFycyBtdWx0aXBsZSB0aW1lcywgYWxsIHRoZVxyXG4gKiAgIGVsZW1lbnRzIHdpbGwgYmUgZGlzcGxheWVkLlxyXG4gKiAqIGBuZ1N3aXRjaERlZmF1bHRgOiB0aGUgZGVmYXVsdCBjYXNlIHdoZW4gbm8gb3RoZXIgY2FzZSBtYXRjaC4gSWYgdGhlcmVcclxuICogICBhcmUgbXVsdGlwbGUgZGVmYXVsdCBjYXNlcywgYWxsIG9mIHRoZW0gd2lsbCBiZSBkaXNwbGF5ZWQgd2hlbiBubyBvdGhlclxyXG4gKiAgIGNhc2UgbWF0Y2guXHJcbiAqXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAgPGV4YW1wbGUgYW5pbWF0aW9ucz1cInRydWVcIj5cclxuICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XHJcbiAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwic2VsZWN0aW9uXCIgbmctb3B0aW9ucz1cIml0ZW0gZm9yIGl0ZW0gaW4gaXRlbXNcIj5cclxuICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICA8dHQ+c2VsZWN0aW9uPXt7c2VsZWN0aW9ufX08L3R0PlxyXG4gICAgICAgIDxoci8+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImFuaW1hdGUtc3dpdGNoLWNvbnRhaW5lclwiXHJcbiAgICAgICAgICBuZy1zd2l0Y2ggb249XCJzZWxlY3Rpb25cIj5cclxuICAgICAgICAgICAgPGRpdiBuZy1zd2l0Y2gtd2hlbj1cInNldHRpbmdzXCI+U2V0dGluZ3MgRGl2PC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgbmctc3dpdGNoLXdoZW49XCJob21lXCI+SG9tZSBTcGFuPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgbmctc3dpdGNoLWRlZmF1bHQ+ZGVmYXVsdDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZmlsZT5cclxuICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cclxuICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcclxuICAgICAgICAkc2NvcGUuaXRlbXMgPSBbJ3NldHRpbmdzJywgJ2hvbWUnLCAnb3RoZXInXTtcclxuICAgICAgICAkc2NvcGUuc2VsZWN0aW9uID0gJHNjb3BlLml0ZW1zWzBdO1xyXG4gICAgICB9XHJcbiAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwiYW5pbWF0aW9ucy5jc3NcIj5cclxuICAgICAgLmFuaW1hdGUtc3dpdGNoLWNvbnRhaW5lciB7XHJcbiAgICAgICAgcG9zaXRpb246cmVsYXRpdmU7XHJcbiAgICAgICAgYmFja2dyb3VuZDp3aGl0ZTtcclxuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xyXG4gICAgICAgIGhlaWdodDo0MHB4O1xyXG4gICAgICAgIG92ZXJmbG93OmhpZGRlbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtc3dpdGNoLWNvbnRhaW5lciA+IGRpdiB7XHJcbiAgICAgICAgcGFkZGluZzoxMHB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAuYW5pbWF0ZS1zd2l0Y2gtY29udGFpbmVyID4gLm5nLWVudGVyLFxyXG4gICAgICAuYW5pbWF0ZS1zd2l0Y2gtY29udGFpbmVyID4gLm5nLWxlYXZlIHtcclxuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuICAgICAgICAtbW96LXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcclxuICAgICAgICAtby10cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XHJcbiAgICAgICAgdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xyXG5cclxuICAgICAgICBwb3NpdGlvbjphYnNvbHV0ZTtcclxuICAgICAgICB0b3A6MDtcclxuICAgICAgICBsZWZ0OjA7XHJcbiAgICAgICAgcmlnaHQ6MDtcclxuICAgICAgICBib3R0b206MDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtc3dpdGNoLWNvbnRhaW5lciA+IC5uZy1lbnRlciB7XHJcbiAgICAgICAgdG9wOi01MHB4O1xyXG4gICAgICB9XHJcbiAgICAgIC5hbmltYXRlLXN3aXRjaC1jb250YWluZXIgPiAubmctZW50ZXIubmctZW50ZXItYWN0aXZlIHtcclxuICAgICAgICB0b3A6MDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLmFuaW1hdGUtc3dpdGNoLWNvbnRhaW5lciA+IC5uZy1sZWF2ZSB7XHJcbiAgICAgICAgdG9wOjA7XHJcbiAgICAgIH1cclxuICAgICAgLmFuaW1hdGUtc3dpdGNoLWNvbnRhaW5lciA+IC5uZy1sZWF2ZS5uZy1sZWF2ZS1hY3RpdmUge1xyXG4gICAgICAgIHRvcDo1MHB4O1xyXG4gICAgICB9XHJcbiAgICA8L2ZpbGU+XHJcbiAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cclxuICAgICAgaXQoJ3Nob3VsZCBzdGFydCBpbiBzZXR0aW5ncycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctc3dpdGNoXScpLnRleHQoKSkudG9NYXRjaCgvU2V0dGluZ3MgRGl2Lyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpdCgnc2hvdWxkIGNoYW5nZSB0byBob21lJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZWN0KCdzZWxlY3Rpb24nKS5vcHRpb24oJ2hvbWUnKTtcclxuICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgW25nLXN3aXRjaF0nKS50ZXh0KCkpLnRvTWF0Y2goL0hvbWUgU3Bhbi8pO1xyXG4gICAgICB9KTtcclxuICAgICAgaXQoJ3Nob3VsZCBzZWxlY3QgZGVmYXVsdCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGVjdCgnc2VsZWN0aW9uJykub3B0aW9uKCdvdGhlcicpO1xyXG4gICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctc3dpdGNoXScpLnRleHQoKSkudG9NYXRjaCgvZGVmYXVsdC8pO1xyXG4gICAgICB9KTtcclxuICAgIDwvZmlsZT5cclxuICA8L2V4YW1wbGU+XHJcbiAqL1xyXG52YXIgbmdTd2l0Y2hEaXJlY3RpdmUgPSBbJyRhbmltYXRlJywgZnVuY3Rpb24oJGFuaW1hdGUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFQScsXHJcbiAgICByZXF1aXJlOiAnbmdTd2l0Y2gnLFxyXG5cclxuICAgIC8vIGFza3MgZm9yICRzY29wZSB0byBmb29sIHRoZSBCQyBjb250cm9sbGVyIG1vZHVsZVxyXG4gICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbiBuZ1N3aXRjaENvbnRyb2xsZXIoKSB7XHJcbiAgICAgdGhpcy5jYXNlcyA9IHt9O1xyXG4gICAgfV0sXHJcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0ciwgbmdTd2l0Y2hDb250cm9sbGVyKSB7XHJcbiAgICAgIHZhciB3YXRjaEV4cHIgPSBhdHRyLm5nU3dpdGNoIHx8IGF0dHIub24sXHJcbiAgICAgICAgICBzZWxlY3RlZFRyYW5zY2x1ZGVzLFxyXG4gICAgICAgICAgc2VsZWN0ZWRFbGVtZW50cyxcclxuICAgICAgICAgIHNlbGVjdGVkU2NvcGVzID0gW107XHJcblxyXG4gICAgICBzY29wZS4kd2F0Y2god2F0Y2hFeHByLCBmdW5jdGlvbiBuZ1N3aXRjaFdhdGNoQWN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaT0gMCwgaWk9c2VsZWN0ZWRTY29wZXMubGVuZ3RoOyBpPGlpOyBpKyspIHtcclxuICAgICAgICAgIHNlbGVjdGVkU2NvcGVzW2ldLiRkZXN0cm95KCk7XHJcbiAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShzZWxlY3RlZEVsZW1lbnRzW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGVjdGVkRWxlbWVudHMgPSBbXTtcclxuICAgICAgICBzZWxlY3RlZFNjb3BlcyA9IFtdO1xyXG5cclxuICAgICAgICBpZiAoKHNlbGVjdGVkVHJhbnNjbHVkZXMgPSBuZ1N3aXRjaENvbnRyb2xsZXIuY2FzZXNbJyEnICsgdmFsdWVdIHx8IG5nU3dpdGNoQ29udHJvbGxlci5jYXNlc1snPyddKSkge1xyXG4gICAgICAgICAgc2NvcGUuJGV2YWwoYXR0ci5jaGFuZ2UpO1xyXG4gICAgICAgICAgZm9yRWFjaChzZWxlY3RlZFRyYW5zY2x1ZGVzLCBmdW5jdGlvbihzZWxlY3RlZFRyYW5zY2x1ZGUpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkU2NvcGUgPSBzY29wZS4kbmV3KCk7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkU2NvcGVzLnB1c2goc2VsZWN0ZWRTY29wZSk7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkVHJhbnNjbHVkZS50cmFuc2NsdWRlKHNlbGVjdGVkU2NvcGUsIGZ1bmN0aW9uKGNhc2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgdmFyIGFuY2hvciA9IHNlbGVjdGVkVHJhbnNjbHVkZS5lbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnRzLnB1c2goY2FzZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGNhc2VFbGVtZW50LCBhbmNob3IucGFyZW50KCksIGFuY2hvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbn1dO1xyXG5cclxudmFyIG5nU3dpdGNoV2hlbkRpcmVjdGl2ZSA9IG5nRGlyZWN0aXZlKHtcclxuICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXHJcbiAgcHJpb3JpdHk6IDUwMCxcclxuICByZXF1aXJlOiAnXm5nU3dpdGNoJyxcclxuICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycywgdHJhbnNjbHVkZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsKSB7XHJcbiAgICAgIGN0cmwuY2FzZXNbJyEnICsgYXR0cnMubmdTd2l0Y2hXaGVuXSA9IChjdHJsLmNhc2VzWychJyArIGF0dHJzLm5nU3dpdGNoV2hlbl0gfHwgW10pO1xyXG4gICAgICBjdHJsLmNhc2VzWychJyArIGF0dHJzLm5nU3dpdGNoV2hlbl0ucHVzaCh7IHRyYW5zY2x1ZGU6IHRyYW5zY2x1ZGUsIGVsZW1lbnQ6IGVsZW1lbnQgfSk7XHJcbiAgICB9O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgbmdTd2l0Y2hEZWZhdWx0RGlyZWN0aXZlID0gbmdEaXJlY3RpdmUoe1xyXG4gIHRyYW5zY2x1ZGU6ICdlbGVtZW50JyxcclxuICBwcmlvcml0eTogNTAwLFxyXG4gIHJlcXVpcmU6ICdebmdTd2l0Y2gnLFxyXG4gIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzLCB0cmFuc2NsdWRlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwpIHtcclxuICAgICAgY3RybC5jYXNlc1snPyddID0gKGN0cmwuY2FzZXNbJz8nXSB8fCBbXSk7XHJcbiAgICAgIGN0cmwuY2FzZXNbJz8nXS5wdXNoKHsgdHJhbnNjbHVkZTogdHJhbnNjbHVkZSwgZWxlbWVudDogZWxlbWVudCB9KTtcclxuICAgIH07XHJcbiAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAbmdkb2MgZGlyZWN0aXZlXHJcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ1RyYW5zY2x1ZGVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIERpcmVjdGl2ZSB0aGF0IG1hcmtzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSB0cmFuc2NsdWRlZCBET00gb2YgdGhlIG5lYXJlc3QgcGFyZW50IGRpcmVjdGl2ZSB0aGF0IHVzZXMgdHJhbnNjbHVzaW9uLlxyXG4gKlxyXG4gKiBBbnkgZXhpc3RpbmcgY29udGVudCBvZiB0aGUgZWxlbWVudCB0aGF0IHRoaXMgZGlyZWN0aXZlIGlzIHBsYWNlZCBvbiB3aWxsIGJlIHJlbW92ZWQgYmVmb3JlIHRoZSB0cmFuc2NsdWRlZCBjb250ZW50IGlzIGluc2VydGVkLlxyXG4gKlxyXG4gKiBAZWxlbWVudCBBTllcclxuICpcclxuICogQGV4YW1wbGVcclxuICAgPGRvYzpleGFtcGxlIG1vZHVsZT1cInRyYW5zY2x1ZGVcIj5cclxuICAgICA8ZG9jOnNvdXJjZT5cclxuICAgICAgIDxzY3JpcHQ+XHJcbiAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XHJcbiAgICAgICAgICAgJHNjb3BlLnRpdGxlID0gJ0xvcmVtIElwc3VtJztcclxuICAgICAgICAgICAkc2NvcGUudGV4dCA9ICdOZXF1ZSBwb3JybyBxdWlzcXVhbSBlc3QgcXVpIGRvbG9yZW0gaXBzdW0gcXVpYSBkb2xvci4uLic7XHJcbiAgICAgICAgIH1cclxuXHJcbiAgICAgICAgIGFuZ3VsYXIubW9kdWxlKCd0cmFuc2NsdWRlJywgW10pXHJcbiAgICAgICAgICAuZGlyZWN0aXZlKCdwYW5lJywgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgIHNjb3BlOiB7IHRpdGxlOidAJyB9LFxyXG4gICAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxkaXYgc3R5bGU9XCJib3JkZXI6IDFweCBzb2xpZCBibGFjaztcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiBncmF5XCI+e3t0aXRsZX19PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IG5nLXRyYW5zY2x1ZGU+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+J1xyXG4gICAgICAgICAgICAgfTtcclxuICAgICAgICAgfSk7XHJcbiAgICAgICA8L3NjcmlwdD5cclxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cclxuICAgICAgICAgPGlucHV0IG5nLW1vZGVsPVwidGl0bGVcIj48YnI+XHJcbiAgICAgICAgIDx0ZXh0YXJlYSBuZy1tb2RlbD1cInRleHRcIj48L3RleHRhcmVhPiA8YnIvPlxyXG4gICAgICAgICA8cGFuZSB0aXRsZT1cInt7dGl0bGV9fVwiPnt7dGV4dH19PC9wYW5lPlxyXG4gICAgICAgPC9kaXY+XHJcbiAgICAgPC9kb2M6c291cmNlPlxyXG4gICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgaXQoJ3Nob3VsZCBoYXZlIHRyYW5zY2x1ZGVkJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpbnB1dCgndGl0bGUnKS5lbnRlcignVElUTEUnKTtcclxuICAgICAgICAgIGlucHV0KCd0ZXh0JykuZW50ZXIoJ1RFWFQnKTtcclxuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd0aXRsZScpKS50b0VxdWFsKCdUSVRMRScpO1xyXG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3RleHQnKSkudG9FcXVhbCgnVEVYVCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gICA8L2RvYzpleGFtcGxlPlxyXG4gKlxyXG4gKi9cclxudmFyIG5nVHJhbnNjbHVkZURpcmVjdGl2ZSA9IG5nRGlyZWN0aXZlKHtcclxuICBjb250cm9sbGVyOiBbJyR0cmFuc2NsdWRlJywgZnVuY3Rpb24oJHRyYW5zY2x1ZGUpIHtcclxuICAgIC8vIHJlbWVtYmVyIHRoZSB0cmFuc2NsdXNpb24gZm4gYnV0IGNhbGwgaXQgZHVyaW5nIGxpbmtpbmcgc28gdGhhdCB3ZSBkb24ndCBwcm9jZXNzIHRyYW5zY2x1c2lvbiBiZWZvcmUgZGlyZWN0aXZlcyBvblxyXG4gICAgLy8gdGhlIHBhcmVudCBlbGVtZW50IGV2ZW4gd2hlbiB0aGUgdHJhbnNjbHVzaW9uIHJlcGxhY2VzIHRoZSBjdXJyZW50IGVsZW1lbnQuICh3ZSBjYW4ndCB1c2UgcHJpb3JpdHkgaGVyZSBiZWNhdXNlXHJcbiAgICAvLyB0aGF0IGFwcGxpZXMgb25seSB0byBjb21waWxlIGZucyBhbmQgbm90IGNvbnRyb2xsZXJzXHJcbiAgICB0aGlzLiR0cmFuc2NsdWRlID0gJHRyYW5zY2x1ZGU7XHJcbiAgfV0sXHJcblxyXG4gIGxpbms6IGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgY29udHJvbGxlcikge1xyXG4gICAgY29udHJvbGxlci4kdHJhbnNjbHVkZShmdW5jdGlvbihjbG9uZSkge1xyXG4gICAgICAkZWxlbWVudC5odG1sKCcnKTtcclxuICAgICAgJGVsZW1lbnQuYXBwZW5kKGNsb25lKTtcclxuICAgIH0pO1xyXG4gIH1cclxufSk7XHJcblxyXG4vKipcclxuICogQG5nZG9jIGRpcmVjdGl2ZVxyXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6c2NyaXB0XHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBMb2FkIGNvbnRlbnQgb2YgYSBzY3JpcHQgdGFnLCB3aXRoIHR5cGUgYHRleHQvbmctdGVtcGxhdGVgLCBpbnRvIGAkdGVtcGxhdGVDYWNoZWAsIHNvIHRoYXQgdGhlXHJcbiAqIHRlbXBsYXRlIGNhbiBiZSB1c2VkIGJ5IGBuZ0luY2x1ZGVgLCBgbmdWaWV3YCBvciBkaXJlY3RpdmUgdGVtcGxhdGVzLlxyXG4gKlxyXG4gKiBAcmVzdHJpY3QgRVxyXG4gKiBAcGFyYW0geyd0ZXh0L25nLXRlbXBsYXRlJ30gdHlwZSBtdXN0IGJlIHNldCB0byBgJ3RleHQvbmctdGVtcGxhdGUnYFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gIDxkb2M6ZXhhbXBsZT5cclxuICAgIDxkb2M6c291cmNlPlxyXG4gICAgICA8c2NyaXB0IHR5cGU9XCJ0ZXh0L25nLXRlbXBsYXRlXCIgaWQ9XCIvdHBsLmh0bWxcIj5cclxuICAgICAgICBDb250ZW50IG9mIHRoZSB0ZW1wbGF0ZS5cclxuICAgICAgPC9zY3JpcHQ+XHJcblxyXG4gICAgICA8YSBuZy1jbGljaz1cImN1cnJlbnRUcGw9Jy90cGwuaHRtbCdcIiBpZD1cInRwbC1saW5rXCI+TG9hZCBpbmxpbmVkIHRlbXBsYXRlPC9hPlxyXG4gICAgICA8ZGl2IGlkPVwidHBsLWNvbnRlbnRcIiBuZy1pbmNsdWRlIHNyYz1cImN1cnJlbnRUcGxcIj48L2Rpdj5cclxuICAgIDwvZG9jOnNvdXJjZT5cclxuICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgIGl0KCdzaG91bGQgbG9hZCB0ZW1wbGF0ZSBkZWZpbmVkIGluc2lkZSBzY3JpcHQgdGFnJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZWxlbWVudCgnI3RwbC1saW5rJykuY2xpY2soKTtcclxuICAgICAgICBleHBlY3QoZWxlbWVudCgnI3RwbC1jb250ZW50JykudGV4dCgpKS50b01hdGNoKC9Db250ZW50IG9mIHRoZSB0ZW1wbGF0ZS8pO1xyXG4gICAgICB9KTtcclxuICAgIDwvZG9jOnNjZW5hcmlvPlxyXG4gIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG52YXIgc2NyaXB0RGlyZWN0aXZlID0gWyckdGVtcGxhdGVDYWNoZScsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICB0ZXJtaW5hbDogdHJ1ZSxcclxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcclxuICAgICAgaWYgKGF0dHIudHlwZSA9PSAndGV4dC9uZy10ZW1wbGF0ZScpIHtcclxuICAgICAgICB2YXIgdGVtcGxhdGVVcmwgPSBhdHRyLmlkLFxyXG4gICAgICAgICAgICAvLyBJRSBpcyBub3QgY29uc2lzdGVudCwgaW4gc2NyaXB0cyB3ZSBoYXZlIHRvIHJlYWQgLnRleHQgYnV0IGluIG90aGVyIG5vZGVzIHdlIGhhdmUgdG8gcmVhZCAudGV4dENvbnRlbnRcclxuICAgICAgICAgICAgdGV4dCA9IGVsZW1lbnRbMF0udGV4dDtcclxuXHJcbiAgICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KHRlbXBsYXRlVXJsLCB0ZXh0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn1dO1xyXG5cclxuLyoqXHJcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcclxuICogQG5hbWUgbmcuZGlyZWN0aXZlOnNlbGVjdFxyXG4gKiBAcmVzdHJpY3QgRVxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogSFRNTCBgU0VMRUNUYCBlbGVtZW50IHdpdGggYW5ndWxhciBkYXRhLWJpbmRpbmcuXHJcbiAqXHJcbiAqICMgYG5nT3B0aW9uc2BcclxuICpcclxuICogT3B0aW9uYWxseSBgbmdPcHRpb25zYCBhdHRyaWJ1dGUgY2FuIGJlIHVzZWQgdG8gZHluYW1pY2FsbHkgZ2VuZXJhdGUgYSBsaXN0IG9mIGA8b3B0aW9uPmBcclxuICogZWxlbWVudHMgZm9yIGEgYDxzZWxlY3Q+YCBlbGVtZW50IHVzaW5nIGFuIGFycmF5IG9yIGFuIG9iamVjdCBvYnRhaW5lZCBieSBldmFsdWF0aW5nIHRoZVxyXG4gKiBgbmdPcHRpb25zYCBleHByZXNzaW9uLlxyXG4gKlxyXG4gKiBXaGVuIGFuIGl0ZW0gaW4gdGhlIGA8c2VsZWN0PmAgbWVudSBpcyBzZWxlY3RlZCwgdGhlIHZhbHVlIG9mIGFycmF5IGVsZW1lbnQgb3Igb2JqZWN0IHByb3BlcnR5XHJcbiAqIHJlcHJlc2VudGVkIGJ5IHRoZSBzZWxlY3RlZCBvcHRpb24gd2lsbCBiZSBib3VuZCB0byB0aGUgbW9kZWwgaWRlbnRpZmllZCBieSB0aGUgYG5nTW9kZWxgXHJcbiAqIGRpcmVjdGl2ZSBvZiB0aGUgcGFyZW50IHNlbGVjdCBlbGVtZW50LlxyXG4gKlxyXG4gKiBPcHRpb25hbGx5LCBhIHNpbmdsZSBoYXJkLWNvZGVkIGA8b3B0aW9uPmAgZWxlbWVudCwgd2l0aCB0aGUgdmFsdWUgc2V0IHRvIGFuIGVtcHR5IHN0cmluZywgY2FuXHJcbiAqIGJlIG5lc3RlZCBpbnRvIHRoZSBgPHNlbGVjdD5gIGVsZW1lbnQuIFRoaXMgZWxlbWVudCB3aWxsIHRoZW4gcmVwcmVzZW50IGBudWxsYCBvciBcIm5vdCBzZWxlY3RlZFwiXHJcbiAqIG9wdGlvbi4gU2VlIGV4YW1wbGUgYmVsb3cgZm9yIGRlbW9uc3RyYXRpb24uXHJcbiAqXHJcbiAqIE5vdGU6IGBuZ09wdGlvbnNgIHByb3ZpZGVzIGl0ZXJhdG9yIGZhY2lsaXR5IGZvciBgPG9wdGlvbj5gIGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZFxyXG4gKiBvZiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nUmVwZWF0IG5nUmVwZWF0fSB3aGVuIHlvdSB3YW50IHRoZVxyXG4gKiBgc2VsZWN0YCBtb2RlbCB0byBiZSBib3VuZCB0byBhIG5vbi1zdHJpbmcgdmFsdWUuIFRoaXMgaXMgYmVjYXVzZSBhbiBvcHRpb24gZWxlbWVudCBjYW4gY3VycmVudGx5XHJcbiAqIGJlIGJvdW5kIHRvIHN0cmluZyB2YWx1ZXMgb25seS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG5nTW9kZWwgQXNzaWduYWJsZSBhbmd1bGFyIGV4cHJlc3Npb24gdG8gZGF0YS1iaW5kIHRvLlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgUHJvcGVydHkgbmFtZSBvZiB0aGUgZm9ybSB1bmRlciB3aGljaCB0aGUgY29udHJvbCBpcyBwdWJsaXNoZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gcmVxdWlyZWQgVGhlIGNvbnRyb2wgaXMgY29uc2lkZXJlZCB2YWxpZCBvbmx5IGlmIHZhbHVlIGlzIGVudGVyZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmdSZXF1aXJlZCBBZGRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGFuZCBgcmVxdWlyZWRgIHZhbGlkYXRpb24gY29uc3RyYWludCB0b1xyXG4gKiAgICB0aGUgZWxlbWVudCB3aGVuIHRoZSBuZ1JlcXVpcmVkIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRydWUuIFVzZSBgbmdSZXF1aXJlZGAgaW5zdGVhZCBvZlxyXG4gKiAgICBgcmVxdWlyZWRgIHdoZW4geW91IHdhbnQgdG8gZGF0YS1iaW5kIHRvIHRoZSBgcmVxdWlyZWRgIGF0dHJpYnV0ZS5cclxuICogQHBhcmFtIHtjb21wcmVoZW5zaW9uX2V4cHJlc3Npb249fSBuZ09wdGlvbnMgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6XHJcbiAqXHJcbiAqICAgKiBmb3IgYXJyYXkgZGF0YSBzb3VyY2VzOlxyXG4gKiAgICAgKiBgbGFiZWxgICoqYGZvcmAqKiBgdmFsdWVgICoqYGluYCoqIGBhcnJheWBcclxuICogICAgICogYHNlbGVjdGAgKipgYXNgKiogYGxhYmVsYCAqKmBmb3JgKiogYHZhbHVlYCAqKmBpbmAqKiBgYXJyYXlgXHJcbiAqICAgICAqIGBsYWJlbGAgICoqYGdyb3VwIGJ5YCoqIGBncm91cGAgKipgZm9yYCoqIGB2YWx1ZWAgKipgaW5gKiogYGFycmF5YFxyXG4gKiAgICAgKiBgc2VsZWN0YCAqKmBhc2AqKiBgbGFiZWxgICoqYGdyb3VwIGJ5YCoqIGBncm91cGAgKipgZm9yYCoqIGB2YWx1ZWAgKipgaW5gKiogYGFycmF5YCAqKmB0cmFjayBieWAqKiBgdHJhY2tleHByYFxyXG4gKiAgICogZm9yIG9iamVjdCBkYXRhIHNvdXJjZXM6XHJcbiAqICAgICAqIGBsYWJlbGAgKipgZm9yIChgKipga2V5YCAqKmAsYCoqIGB2YWx1ZWAqKmApIGluYCoqIGBvYmplY3RgXHJcbiAqICAgICAqIGBzZWxlY3RgICoqYGFzYCoqIGBsYWJlbGAgKipgZm9yIChgKipga2V5YCAqKmAsYCoqIGB2YWx1ZWAqKmApIGluYCoqIGBvYmplY3RgXHJcbiAqICAgICAqIGBsYWJlbGAgKipgZ3JvdXAgYnlgKiogYGdyb3VwYCAqKmBmb3IgKGAqKmBrZXlgKipgLGAqKiBgdmFsdWVgKipgKSBpbmAqKiBgb2JqZWN0YFxyXG4gKiAgICAgKiBgc2VsZWN0YCAqKmBhc2AqKiBgbGFiZWxgICoqYGdyb3VwIGJ5YCoqIGBncm91cGBcclxuICogICAgICAgICAqKmBmb3JgIGAoYCoqYGtleWAqKmAsYCoqIGB2YWx1ZWAqKmApIGluYCoqIGBvYmplY3RgXHJcbiAqXHJcbiAqIFdoZXJlOlxyXG4gKlxyXG4gKiAgICogYGFycmF5YCAvIGBvYmplY3RgOiBhbiBleHByZXNzaW9uIHdoaWNoIGV2YWx1YXRlcyB0byBhbiBhcnJheSAvIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXHJcbiAqICAgKiBgdmFsdWVgOiBsb2NhbCB2YXJpYWJsZSB3aGljaCB3aWxsIHJlZmVyIHRvIGVhY2ggaXRlbSBpbiB0aGUgYGFycmF5YCBvciBlYWNoIHByb3BlcnR5IHZhbHVlXHJcbiAqICAgICAgb2YgYG9iamVjdGAgZHVyaW5nIGl0ZXJhdGlvbi5cclxuICogICAqIGBrZXlgOiBsb2NhbCB2YXJpYWJsZSB3aGljaCB3aWxsIHJlZmVyIHRvIGEgcHJvcGVydHkgbmFtZSBpbiBgb2JqZWN0YCBkdXJpbmcgaXRlcmF0aW9uLlxyXG4gKiAgICogYGxhYmVsYDogVGhlIHJlc3VsdCBvZiB0aGlzIGV4cHJlc3Npb24gd2lsbCBiZSB0aGUgbGFiZWwgZm9yIGA8b3B0aW9uPmAgZWxlbWVudC4gVGhlXHJcbiAqICAgICBgZXhwcmVzc2lvbmAgd2lsbCBtb3N0IGxpa2VseSByZWZlciB0byB0aGUgYHZhbHVlYCB2YXJpYWJsZSAoZS5nLiBgdmFsdWUucHJvcGVydHlOYW1lYCkuXHJcbiAqICAgKiBgc2VsZWN0YDogVGhlIHJlc3VsdCBvZiB0aGlzIGV4cHJlc3Npb24gd2lsbCBiZSBib3VuZCB0byB0aGUgbW9kZWwgb2YgdGhlIHBhcmVudCBgPHNlbGVjdD5gXHJcbiAqICAgICAgZWxlbWVudC4gSWYgbm90IHNwZWNpZmllZCwgYHNlbGVjdGAgZXhwcmVzc2lvbiB3aWxsIGRlZmF1bHQgdG8gYHZhbHVlYC5cclxuICogICAqIGBncm91cGA6IFRoZSByZXN1bHQgb2YgdGhpcyBleHByZXNzaW9uIHdpbGwgYmUgdXNlZCB0byBncm91cCBvcHRpb25zIHVzaW5nIHRoZSBgPG9wdGdyb3VwPmBcclxuICogICAgICBET00gZWxlbWVudC5cclxuICogICAqIGB0cmFja2V4cHJgOiBVc2VkIHdoZW4gd29ya2luZyB3aXRoIGFuIGFycmF5IG9mIG9iamVjdHMuIFRoZSByZXN1bHQgb2YgdGhpcyBleHByZXNzaW9uIHdpbGwgYmVcclxuICogICAgICB1c2VkIHRvIGlkZW50aWZ5IHRoZSBvYmplY3RzIGluIHRoZSBhcnJheS4gVGhlIGB0cmFja2V4cHJgIHdpbGwgbW9zdCBsaWtlbHkgcmVmZXIgdG8gdGhlXHJcbiAqICAgICBgdmFsdWVgIHZhcmlhYmxlIChlLmcuIGB2YWx1ZS5wcm9wZXJ0eU5hbWVgKS5cclxuICpcclxuICogQGV4YW1wbGVcclxuICAgIDxkb2M6ZXhhbXBsZT5cclxuICAgICAgPGRvYzpzb3VyY2U+XHJcbiAgICAgICAgPHNjcmlwdD5cclxuICAgICAgICBmdW5jdGlvbiBNeUNudHJsKCRzY29wZSkge1xyXG4gICAgICAgICAgJHNjb3BlLmNvbG9ycyA9IFtcclxuICAgICAgICAgICAge25hbWU6J2JsYWNrJywgc2hhZGU6J2RhcmsnfSxcclxuICAgICAgICAgICAge25hbWU6J3doaXRlJywgc2hhZGU6J2xpZ2h0J30sXHJcbiAgICAgICAgICAgIHtuYW1lOidyZWQnLCBzaGFkZTonZGFyayd9LFxyXG4gICAgICAgICAgICB7bmFtZTonYmx1ZScsIHNoYWRlOidkYXJrJ30sXHJcbiAgICAgICAgICAgIHtuYW1lOid5ZWxsb3cnLCBzaGFkZTonbGlnaHQnfVxyXG4gICAgICAgICAgXTtcclxuICAgICAgICAgICRzY29wZS5jb2xvciA9ICRzY29wZS5jb2xvcnNbMl07IC8vIHJlZFxyXG4gICAgICAgIH1cclxuICAgICAgICA8L3NjcmlwdD5cclxuICAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJNeUNudHJsXCI+XHJcbiAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgIDxsaSBuZy1yZXBlYXQ9XCJjb2xvciBpbiBjb2xvcnNcIj5cclxuICAgICAgICAgICAgICBOYW1lOiA8aW5wdXQgbmctbW9kZWw9XCJjb2xvci5uYW1lXCI+XHJcbiAgICAgICAgICAgICAgWzxhIGhyZWYgbmctY2xpY2s9XCJjb2xvcnMuc3BsaWNlKCRpbmRleCwgMSlcIj5YPC9hPl1cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICAgIFs8YSBocmVmIG5nLWNsaWNrPVwiY29sb3JzLnB1c2goe30pXCI+YWRkPC9hPl1cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICA8aHIvPlxyXG4gICAgICAgICAgQ29sb3IgKG51bGwgbm90IGFsbG93ZWQpOlxyXG4gICAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cImNvbG9yXCIgbmctb3B0aW9ucz1cImMubmFtZSBmb3IgYyBpbiBjb2xvcnNcIj48L3NlbGVjdD48YnI+XHJcblxyXG4gICAgICAgICAgQ29sb3IgKG51bGwgYWxsb3dlZCk6XHJcbiAgICAgICAgICA8c3BhbiAgY2xhc3M9XCJudWxsYWJsZVwiPlxyXG4gICAgICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwiY29sb3JcIiBuZy1vcHRpb25zPVwiYy5uYW1lIGZvciBjIGluIGNvbG9yc1wiPlxyXG4gICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj4tLSBjaG9zZSBjb2xvciAtLTwvb3B0aW9uPlxyXG4gICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgIDwvc3Bhbj48YnIvPlxyXG5cclxuICAgICAgICAgIENvbG9yIGdyb3VwZWQgYnkgc2hhZGU6XHJcbiAgICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwiY29sb3JcIiBuZy1vcHRpb25zPVwiYy5uYW1lIGdyb3VwIGJ5IGMuc2hhZGUgZm9yIGMgaW4gY29sb3JzXCI+XHJcbiAgICAgICAgICA8L3NlbGVjdD48YnIvPlxyXG5cclxuXHJcbiAgICAgICAgICBTZWxlY3QgPGEgaHJlZiBuZy1jbGljaz1cImNvbG9yPXtuYW1lOidub3QgaW4gbGlzdCd9XCI+Ym9ndXM8L2E+Ljxicj5cclxuICAgICAgICAgIDxoci8+XHJcbiAgICAgICAgICBDdXJyZW50bHkgc2VsZWN0ZWQ6IHt7IHtzZWxlY3RlZF9jb2xvcjpjb2xvcn0gIH19XHJcbiAgICAgICAgICA8ZGl2IHN0eWxlPVwiYm9yZGVyOnNvbGlkIDFweCBibGFjazsgaGVpZ2h0OjIwcHhcIlxyXG4gICAgICAgICAgICAgICBuZy1zdHlsZT1cInsnYmFja2dyb3VuZC1jb2xvcic6Y29sb3IubmFtZX1cIj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2RvYzpzb3VyY2U+XHJcbiAgICAgIDxkb2M6c2NlbmFyaW8+XHJcbiAgICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctb3B0aW9ucycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd7c2VsZWN0ZWRfY29sb3I6Y29sb3J9JykpLnRvTWF0Y2goJ3JlZCcpO1xyXG4gICAgICAgICAgIHNlbGVjdCgnY29sb3InKS5vcHRpb24oJzAnKTtcclxuICAgICAgICAgICBleHBlY3QoYmluZGluZygne3NlbGVjdGVkX2NvbG9yOmNvbG9yfScpKS50b01hdGNoKCdibGFjaycpO1xyXG4gICAgICAgICAgIHVzaW5nKCcubnVsbGFibGUnKS5zZWxlY3QoJ2NvbG9yJykub3B0aW9uKCcnKTtcclxuICAgICAgICAgICBleHBlY3QoYmluZGluZygne3NlbGVjdGVkX2NvbG9yOmNvbG9yfScpKS50b01hdGNoKCdudWxsJyk7XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICA8L2RvYzpzY2VuYXJpbz5cclxuICAgIDwvZG9jOmV4YW1wbGU+XHJcbiAqL1xyXG5cclxudmFyIG5nT3B0aW9uc0RpcmVjdGl2ZSA9IHZhbHVlRm4oeyB0ZXJtaW5hbDogdHJ1ZSB9KTtcclxudmFyIHNlbGVjdERpcmVjdGl2ZSA9IFsnJGNvbXBpbGUnLCAnJHBhcnNlJywgZnVuY3Rpb24oJGNvbXBpbGUsICAgJHBhcnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLzAwMDAxMTExMTAwMDAwMDAwMDAwMjIyMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzMzMzMDAwMDAwMDAwMDAwMDA0NDQ0NDQ0NDQ0NDQ0NDQ0NDAwMDAwMDAwMDU1NTU1NTU1NTU1NTU1NTU1MDAwMDAwMDY2NjY2NjY2NjY2NjY2NjY2MDAwMDAwMDAwMDAwMDAwMDc3NzcwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODhcclxuICB2YXIgTkdfT1BUSU9OU19SRUdFWFAgPSAvXlxccyooLio/KSg/Olxccythc1xccysoLio/KSk/KD86XFxzK2dyb3VwXFxzK2J5XFxzKyguKikpP1xccytmb3JcXHMrKD86KFtcXCRcXHddW1xcJFxcd1xcZF0qKXwoPzpcXChcXHMqKFtcXCRcXHddW1xcJFxcd1xcZF0qKVxccyosXFxzKihbXFwkXFx3XVtcXCRcXHdcXGRdKilcXHMqXFwpKSlcXHMraW5cXHMrKC4qPykoPzpcXHMrdHJhY2tcXHMrYnlcXHMrKC4qPykpPyQvLFxyXG4gICAgICBudWxsTW9kZWxDdHJsID0geyRzZXRWaWV3VmFsdWU6IG5vb3B9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgIHJlcXVpcmU6IFsnc2VsZWN0JywgJz9uZ01vZGVsJ10sXHJcbiAgICBjb250cm9sbGVyOiBbJyRlbGVtZW50JywgJyRzY29wZScsICckYXR0cnMnLCBmdW5jdGlvbigkZWxlbWVudCwgJHNjb3BlLCAkYXR0cnMpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgb3B0aW9uc01hcCA9IHt9LFxyXG4gICAgICAgICAgbmdNb2RlbEN0cmwgPSBudWxsTW9kZWxDdHJsLFxyXG4gICAgICAgICAgbnVsbE9wdGlvbixcclxuICAgICAgICAgIHVua25vd25PcHRpb247XHJcblxyXG5cclxuICAgICAgc2VsZi5kYXRhYm91bmQgPSAkYXR0cnMubmdNb2RlbDtcclxuXHJcblxyXG4gICAgICBzZWxmLmluaXQgPSBmdW5jdGlvbihuZ01vZGVsQ3RybF8sIG51bGxPcHRpb25fLCB1bmtub3duT3B0aW9uXykge1xyXG4gICAgICAgIG5nTW9kZWxDdHJsID0gbmdNb2RlbEN0cmxfO1xyXG4gICAgICAgIG51bGxPcHRpb24gPSBudWxsT3B0aW9uXztcclxuICAgICAgICB1bmtub3duT3B0aW9uID0gdW5rbm93bk9wdGlvbl87XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBzZWxmLmFkZE9wdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgb3B0aW9uc01hcFt2YWx1ZV0gPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgJGVsZW1lbnQudmFsKHZhbHVlKTtcclxuICAgICAgICAgIGlmICh1bmtub3duT3B0aW9uLnBhcmVudCgpKSB1bmtub3duT3B0aW9uLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcblxyXG4gICAgICBzZWxmLnJlbW92ZU9wdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzT3B0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnNNYXBbdmFsdWVdO1xyXG4gICAgICAgICAgaWYgKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJVbmtub3duT3B0aW9uKHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG5cclxuICAgICAgc2VsZi5yZW5kZXJVbmtub3duT3B0aW9uID0gZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgdmFyIHVua25vd25WYWwgPSAnPyAnICsgaGFzaEtleSh2YWwpICsgJyA/JztcclxuICAgICAgICB1bmtub3duT3B0aW9uLnZhbCh1bmtub3duVmFsKTtcclxuICAgICAgICAkZWxlbWVudC5wcmVwZW5kKHVua25vd25PcHRpb24pO1xyXG4gICAgICAgICRlbGVtZW50LnZhbCh1bmtub3duVmFsKTtcclxuICAgICAgICB1bmtub3duT3B0aW9uLnByb3AoJ3NlbGVjdGVkJywgdHJ1ZSk7IC8vIG5lZWRlZCBmb3IgSUVcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIHNlbGYuaGFzT3B0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gb3B0aW9uc01hcC5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gZGlzYWJsZSB1bmtub3duIG9wdGlvbiBzbyB0aGF0IHdlIGRvbid0IGRvIHdvcmsgd2hlbiB0aGUgd2hvbGUgc2VsZWN0IGlzIGJlaW5nIGRlc3Ryb3llZFxyXG4gICAgICAgIHNlbGYucmVuZGVyVW5rbm93bk9wdGlvbiA9IG5vb3A7XHJcbiAgICAgIH0pO1xyXG4gICAgfV0sXHJcblxyXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmxzKSB7XHJcbiAgICAgIC8vIGlmIG5nTW9kZWwgaXMgbm90IGRlZmluZWQsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcclxuICAgICAgaWYgKCFjdHJsc1sxXSkgcmV0dXJuO1xyXG5cclxuICAgICAgdmFyIHNlbGVjdEN0cmwgPSBjdHJsc1swXSxcclxuICAgICAgICAgIG5nTW9kZWxDdHJsID0gY3RybHNbMV0sXHJcbiAgICAgICAgICBtdWx0aXBsZSA9IGF0dHIubXVsdGlwbGUsXHJcbiAgICAgICAgICBvcHRpb25zRXhwID0gYXR0ci5uZ09wdGlvbnMsXHJcbiAgICAgICAgICBudWxsT3B0aW9uID0gZmFsc2UsIC8vIGlmIGZhbHNlLCB1c2VyIHdpbGwgbm90IGJlIGFibGUgdG8gc2VsZWN0IGl0ICh1c2VkIGJ5IG5nT3B0aW9ucylcclxuICAgICAgICAgIGVtcHR5T3B0aW9uLFxyXG4gICAgICAgICAgLy8gd2UgY2FuJ3QganVzdCBqcUxpdGUoJzxvcHRpb24+Jykgc2luY2UganFMaXRlIGlzIG5vdCBzbWFydCBlbm91Z2hcclxuICAgICAgICAgIC8vIHRvIGNyZWF0ZSBpdCBpbiA8c2VsZWN0PiBhbmQgSUUgYmFyZnMgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgb3B0aW9uVGVtcGxhdGUgPSBqcUxpdGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJykpLFxyXG4gICAgICAgICAgb3B0R3JvdXBUZW1wbGF0ZSA9anFMaXRlKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJykpLFxyXG4gICAgICAgICAgdW5rbm93bk9wdGlvbiA9IG9wdGlvblRlbXBsYXRlLmNsb25lKCk7XHJcblxyXG4gICAgICAvLyBmaW5kIFwibnVsbFwiIG9wdGlvblxyXG4gICAgICBmb3IodmFyIGkgPSAwLCBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4oKSwgaWkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnZhbHVlID09ICcnKSB7XHJcbiAgICAgICAgICBlbXB0eU9wdGlvbiA9IG51bGxPcHRpb24gPSBjaGlsZHJlbi5lcShpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZWN0Q3RybC5pbml0KG5nTW9kZWxDdHJsLCBudWxsT3B0aW9uLCB1bmtub3duT3B0aW9uKTtcclxuXHJcbiAgICAgIC8vIHJlcXVpcmVkIHZhbGlkYXRvclxyXG4gICAgICBpZiAobXVsdGlwbGUgJiYgKGF0dHIucmVxdWlyZWQgfHwgYXR0ci5uZ1JlcXVpcmVkKSkge1xyXG4gICAgICAgIHZhciByZXF1aXJlZFZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3JlcXVpcmVkJywgIWF0dHIucmVxdWlyZWQgfHwgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCkpO1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG5nTW9kZWxDdHJsLiRwYXJzZXJzLnB1c2gocmVxdWlyZWRWYWxpZGF0b3IpO1xyXG4gICAgICAgIG5nTW9kZWxDdHJsLiRmb3JtYXR0ZXJzLnVuc2hpZnQocmVxdWlyZWRWYWxpZGF0b3IpO1xyXG5cclxuICAgICAgICBhdHRyLiRvYnNlcnZlKCdyZXF1aXJlZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmVxdWlyZWRWYWxpZGF0b3IobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChvcHRpb25zRXhwKSBPcHRpb25zKHNjb3BlLCBlbGVtZW50LCBuZ01vZGVsQ3RybCk7XHJcbiAgICAgIGVsc2UgaWYgKG11bHRpcGxlKSBNdWx0aXBsZShzY29wZSwgZWxlbWVudCwgbmdNb2RlbEN0cmwpO1xyXG4gICAgICBlbHNlIFNpbmdsZShzY29wZSwgZWxlbWVudCwgbmdNb2RlbEN0cmwsIHNlbGVjdEN0cmwpO1xyXG5cclxuXHJcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcblxyXG5cclxuICAgICAgZnVuY3Rpb24gU2luZ2xlKHNjb3BlLCBzZWxlY3RFbGVtZW50LCBuZ01vZGVsQ3RybCwgc2VsZWN0Q3RybCkge1xyXG4gICAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciB2aWV3VmFsdWUgPSBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlO1xyXG5cclxuICAgICAgICAgIGlmIChzZWxlY3RDdHJsLmhhc09wdGlvbih2aWV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmICh1bmtub3duT3B0aW9uLnBhcmVudCgpKSB1bmtub3duT3B0aW9uLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50LnZhbCh2aWV3VmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAodmlld1ZhbHVlID09PSAnJykgZW1wdHlPcHRpb24ucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTsgLy8gdG8gbWFrZSBJRTkgaGFwcHlcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2aWV3VmFsdWUpICYmIGVtcHR5T3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC52YWwoJycpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHNlbGVjdEN0cmwucmVuZGVyVW5rbm93bk9wdGlvbih2aWV3VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc2VsZWN0RWxlbWVudC5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh1bmtub3duT3B0aW9uLnBhcmVudCgpKSB1bmtub3duT3B0aW9uLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKHNlbGVjdEVsZW1lbnQudmFsKCkpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIE11bHRpcGxlKHNjb3BlLCBzZWxlY3RFbGVtZW50LCBjdHJsKSB7XHJcbiAgICAgICAgdmFyIGxhc3RWaWV3O1xyXG4gICAgICAgIGN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIGl0ZW1zID0gbmV3IEhhc2hNYXAoY3RybC4kdmlld1ZhbHVlKTtcclxuICAgICAgICAgIGZvckVhY2goc2VsZWN0RWxlbWVudC5maW5kKCdvcHRpb24nKSwgZnVuY3Rpb24ob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGlzRGVmaW5lZChpdGVtcy5nZXQob3B0aW9uLnZhbHVlKSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGRvIGl0IG9uIGVhY2ggd2F0Y2ggc2luY2UgbmdNb2RlbCB3YXRjaGVzIHJlZmVyZW5jZSwgYnV0XHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byB3b3JrIG9mIGFuIGFycmF5LCBzbyB3ZSBuZWVkIHRvIHNlZSBpZiBhbnl0aGluZyB3YXMgaW5zZXJ0ZWQvcmVtb3ZlZFxyXG4gICAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbiBzZWxlY3RNdWx0aXBsZVdhdGNoKCkge1xyXG4gICAgICAgICAgaWYgKCFlcXVhbHMobGFzdFZpZXcsIGN0cmwuJHZpZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgbGFzdFZpZXcgPSBjb3B5KGN0cmwuJHZpZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIGN0cmwuJHJlbmRlcigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzZWxlY3RFbGVtZW50Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XHJcbiAgICAgICAgICAgIGZvckVhY2goc2VsZWN0RWxlbWVudC5maW5kKCdvcHRpb24nKSwgZnVuY3Rpb24ob3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaChvcHRpb24udmFsdWUpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGN0cmwuJHNldFZpZXdWYWx1ZShhcnJheSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gT3B0aW9ucyhzY29wZSwgc2VsZWN0RWxlbWVudCwgY3RybCkge1xyXG4gICAgICAgIHZhciBtYXRjaDtcclxuXHJcbiAgICAgICAgaWYgKCEgKG1hdGNoID0gb3B0aW9uc0V4cC5tYXRjaChOR19PUFRJT05TX1JFR0VYUCkpKSB7XHJcbiAgICAgICAgICB0aHJvdyBtaW5FcnIoJ25nT3B0aW9ucycpKCdpZXhwJyxcclxuICAgICAgICAgICAgXCJFeHBlY3RlZCBleHByZXNzaW9uIGluIGZvcm0gb2YgJ19zZWxlY3RfIChhcyBfbGFiZWxfKT8gZm9yIChfa2V5XywpP192YWx1ZV8gaW4gX2NvbGxlY3Rpb25fJyBidXQgZ290ICd7MH0nLiBFbGVtZW50OiB7MX1cIixcclxuICAgICAgICAgICAgb3B0aW9uc0V4cCwgc3RhcnRpbmdUYWcoc2VsZWN0RWxlbWVudCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRpc3BsYXlGbiA9ICRwYXJzZShtYXRjaFsyXSB8fCBtYXRjaFsxXSksXHJcbiAgICAgICAgICAgIHZhbHVlTmFtZSA9IG1hdGNoWzRdIHx8IG1hdGNoWzZdLFxyXG4gICAgICAgICAgICBrZXlOYW1lID0gbWF0Y2hbNV0sXHJcbiAgICAgICAgICAgIGdyb3VwQnlGbiA9ICRwYXJzZShtYXRjaFszXSB8fCAnJyksXHJcbiAgICAgICAgICAgIHZhbHVlRm4gPSAkcGFyc2UobWF0Y2hbMl0gPyBtYXRjaFsxXSA6IHZhbHVlTmFtZSksXHJcbiAgICAgICAgICAgIHZhbHVlc0ZuID0gJHBhcnNlKG1hdGNoWzddKSxcclxuICAgICAgICAgICAgdHJhY2sgPSBtYXRjaFs4XSxcclxuICAgICAgICAgICAgdHJhY2tGbiA9IHRyYWNrID8gJHBhcnNlKG1hdGNoWzhdKSA6IG51bGwsXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gYXJyYXkgb2YgYXJyYXkgb2YgZXhpc3Rpbmcgb3B0aW9uIGdyb3VwcyBpbiBET00uIFdlIHRyeSB0byByZXVzZSB0aGVzZSBpZiBwb3NzaWJsZVxyXG4gICAgICAgICAgICAvLyBvcHRpb25Hcm91cHNDYWNoZVswXSBpcyB0aGUgb3B0aW9ucyB3aXRoIG5vIG9wdGlvbiBncm91cFxyXG4gICAgICAgICAgICAvLyBvcHRpb25Hcm91cHNDYWNoZVs/XVswXSBpcyB0aGUgcGFyZW50OiBlaXRoZXIgdGhlIFNFTEVDVCBvciBPUFRHUk9VUCBlbGVtZW50XHJcbiAgICAgICAgICAgIG9wdGlvbkdyb3Vwc0NhY2hlID0gW1t7ZWxlbWVudDogc2VsZWN0RWxlbWVudCwgbGFiZWw6Jyd9XV07XHJcblxyXG4gICAgICAgIGlmIChudWxsT3B0aW9uKSB7XHJcbiAgICAgICAgICAvLyBjb21waWxlIHRoZSBlbGVtZW50IHNpbmNlIHRoZXJlIG1pZ2h0IGJlIGJpbmRpbmdzIGluIGl0XHJcbiAgICAgICAgICAkY29tcGlsZShudWxsT3B0aW9uKShzY29wZSk7XHJcblxyXG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjbGFzcywgd2hpY2ggaXMgYWRkZWQgYXV0b21hdGljYWxseSBiZWNhdXNlIHdlIHJlY29tcGlsZSB0aGUgZWxlbWVudCBhbmQgaXRcclxuICAgICAgICAgIC8vIGJlY29tZXMgdGhlIGNvbXBpbGF0aW9uIHJvb3RcclxuICAgICAgICAgIG51bGxPcHRpb24ucmVtb3ZlQ2xhc3MoJ25nLXNjb3BlJyk7XHJcblxyXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byByZW1vdmUgaXQgYmVmb3JlIGNhbGxpbmcgc2VsZWN0RWxlbWVudC5odG1sKCcnKSBiZWNhdXNlIG90aGVyd2lzZSBJRSB3aWxsXHJcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGxhYmVsIGZyb20gdGhlIGVsZW1lbnQuIHd0Zj9cclxuICAgICAgICAgIG51bGxPcHRpb24ucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjbGVhciBjb250ZW50cywgd2UnbGwgYWRkIHdoYXQncyBuZWVkZWQgYmFzZWQgb24gdGhlIG1vZGVsXHJcbiAgICAgICAgc2VsZWN0RWxlbWVudC5odG1sKCcnKTtcclxuXHJcbiAgICAgICAgc2VsZWN0RWxlbWVudC5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25Hcm91cCxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSB2YWx1ZXNGbihzY29wZSkgfHwgW10sXHJcbiAgICAgICAgICAgICAgICBsb2NhbHMgPSB7fSxcclxuICAgICAgICAgICAgICAgIGtleSwgdmFsdWUsIG9wdGlvbkVsZW1lbnQsIGluZGV4LCBncm91cEluZGV4LCBsZW5ndGgsIGdyb3VwTGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICBmb3IgKGdyb3VwSW5kZXggPSAwLCBncm91cExlbmd0aCA9IG9wdGlvbkdyb3Vwc0NhY2hlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kZXggPCBncm91cExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBvcHRpb25zIGZvciB0aGF0IGdyb3VwLiAoZmlyc3QgaXRlbSBoYXMgdGhlIHBhcmVudClcclxuICAgICAgICAgICAgICAgIG9wdGlvbkdyb3VwID0gb3B0aW9uR3JvdXBzQ2FjaGVbZ3JvdXBJbmRleF07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yKGluZGV4ID0gMSwgbGVuZ3RoID0gb3B0aW9uR3JvdXAubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbkVsZW1lbnQgPSBvcHRpb25Hcm91cFtpbmRleF0uZWxlbWVudClbMF0uc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBvcHRpb25FbGVtZW50LnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lKSBsb2NhbHNba2V5TmFtZV0gPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrRm4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRyYWNrSW5kZXggPSAwOyB0cmFja0luZGV4IDwgY29sbGVjdGlvbi5sZW5ndGg7IHRyYWNrSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbHNbdmFsdWVOYW1lXSA9IGNvbGxlY3Rpb25bdHJhY2tJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFja0ZuKHNjb3BlLCBsb2NhbHMpID09IGtleSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGxvY2Fsc1t2YWx1ZU5hbWVdID0gY29sbGVjdGlvbltrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbHVlRm4oc2NvcGUsIGxvY2FscykpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGtleSA9IHNlbGVjdEVsZW1lbnQudmFsKCk7XHJcbiAgICAgICAgICAgICAgaWYgKGtleSA9PSAnPycpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09ICcnKXtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrRm4pIHtcclxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdHJhY2tJbmRleCA9IDA7IHRyYWNrSW5kZXggPCBjb2xsZWN0aW9uLmxlbmd0aDsgdHJhY2tJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxzW3ZhbHVlTmFtZV0gPSBjb2xsZWN0aW9uW3RyYWNrSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja0ZuKHNjb3BlLCBsb2NhbHMpID09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZUZuKHNjb3BlLCBsb2NhbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBsb2NhbHNbdmFsdWVOYW1lXSA9IGNvbGxlY3Rpb25ba2V5XTtcclxuICAgICAgICAgICAgICAgICAgaWYgKGtleU5hbWUpIGxvY2Fsc1trZXlOYW1lXSA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZUZuKHNjb3BlLCBsb2NhbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHJsLiRzZXRWaWV3VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGN0cmwuJHJlbmRlciA9IHJlbmRlcjtcclxuXHJcbiAgICAgICAgLy8gVE9ETyh2b2p0YSk6IGNhbid0IHdlIG9wdGltaXplIHRoaXMgP1xyXG4gICAgICAgIHNjb3BlLiR3YXRjaChyZW5kZXIpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XHJcbiAgICAgICAgICB2YXIgb3B0aW9uR3JvdXBzID0geycnOltdfSwgLy8gVGVtcG9yYXJ5IGxvY2F0aW9uIGZvciB0aGUgb3B0aW9uIGdyb3VwcyBiZWZvcmUgd2UgcmVuZGVyIHRoZW1cclxuICAgICAgICAgICAgICBvcHRpb25Hcm91cE5hbWVzID0gWycnXSxcclxuICAgICAgICAgICAgICBvcHRpb25Hcm91cE5hbWUsXHJcbiAgICAgICAgICAgICAgb3B0aW9uR3JvdXAsXHJcbiAgICAgICAgICAgICAgb3B0aW9uLFxyXG4gICAgICAgICAgICAgIGV4aXN0aW5nUGFyZW50LCBleGlzdGluZ09wdGlvbnMsIGV4aXN0aW5nT3B0aW9uLFxyXG4gICAgICAgICAgICAgIG1vZGVsVmFsdWUgPSBjdHJsLiRtb2RlbFZhbHVlLFxyXG4gICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlc0ZuKHNjb3BlKSB8fCBbXSxcclxuICAgICAgICAgICAgICBrZXlzID0ga2V5TmFtZSA/IHNvcnRlZEtleXModmFsdWVzKSA6IHZhbHVlcyxcclxuICAgICAgICAgICAgICBncm91cExlbmd0aCwgbGVuZ3RoLFxyXG4gICAgICAgICAgICAgIGdyb3VwSW5kZXgsIGluZGV4LFxyXG4gICAgICAgICAgICAgIGxvY2FscyA9IHt9LFxyXG4gICAgICAgICAgICAgIHNlbGVjdGVkLFxyXG4gICAgICAgICAgICAgIHNlbGVjdGVkU2V0ID0gZmFsc2UsIC8vIG5vdGhpbmcgaXMgc2VsZWN0ZWQgeWV0XHJcbiAgICAgICAgICAgICAgbGFzdEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgZWxlbWVudCxcclxuICAgICAgICAgICAgICBsYWJlbDtcclxuXHJcbiAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgaWYgKHRyYWNrRm4gJiYgaXNBcnJheShtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIHNlbGVjdGVkU2V0ID0gbmV3IEhhc2hNYXAoW10pO1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIHRyYWNrSW5kZXggPSAwOyB0cmFja0luZGV4IDwgbW9kZWxWYWx1ZS5sZW5ndGg7IHRyYWNrSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxzW3ZhbHVlTmFtZV0gPSBtb2RlbFZhbHVlW3RyYWNrSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRTZXQucHV0KHRyYWNrRm4oc2NvcGUsIGxvY2FscyksIG1vZGVsVmFsdWVbdHJhY2tJbmRleF0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzZWxlY3RlZFNldCA9IG5ldyBIYXNoTWFwKG1vZGVsVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gV2Ugbm93IGJ1aWxkIHVwIHRoZSBsaXN0IG9mIG9wdGlvbnMgd2UgbmVlZCAod2UgbWVyZ2UgbGF0ZXIpXHJcbiAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgIGxvY2Fsc1t2YWx1ZU5hbWVdID0gdmFsdWVzW2tleU5hbWUgPyBsb2NhbHNba2V5TmFtZV09a2V5c1tpbmRleF06aW5kZXhdO1xyXG4gICAgICAgICAgICAgICBvcHRpb25Hcm91cE5hbWUgPSBncm91cEJ5Rm4oc2NvcGUsIGxvY2FscykgfHwgJyc7XHJcbiAgICAgICAgICAgIGlmICghKG9wdGlvbkdyb3VwID0gb3B0aW9uR3JvdXBzW29wdGlvbkdyb3VwTmFtZV0pKSB7XHJcbiAgICAgICAgICAgICAgb3B0aW9uR3JvdXAgPSBvcHRpb25Hcm91cHNbb3B0aW9uR3JvdXBOYW1lXSA9IFtdO1xyXG4gICAgICAgICAgICAgIG9wdGlvbkdyb3VwTmFtZXMucHVzaChvcHRpb25Hcm91cE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWRTZXQucmVtb3ZlKHRyYWNrRm4gPyB0cmFja0ZuKHNjb3BlLCBsb2NhbHMpIDogdmFsdWVGbihzY29wZSwgbG9jYWxzKSkgIT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmICh0cmFja0ZuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kZWxDYXN0ID0ge307XHJcbiAgICAgICAgICAgICAgICBtb2RlbENhc3RbdmFsdWVOYW1lXSA9IG1vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRyYWNrRm4oc2NvcGUsIG1vZGVsQ2FzdCkgPT09IHRyYWNrRm4oc2NvcGUsIGxvY2Fscyk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gbW9kZWxWYWx1ZSA9PT0gdmFsdWVGbihzY29wZSwgbG9jYWxzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWRTZXQgPSBzZWxlY3RlZFNldCB8fCBzZWxlY3RlZDsgLy8gc2VlIGlmIGF0IGxlYXN0IG9uZSBpdGVtIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFiZWwgPSBkaXNwbGF5Rm4oc2NvcGUsIGxvY2Fscyk7IC8vIHdoYXQgd2lsbCBiZSBzZWVuIGJ5IHRoZSB1c2VyXHJcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWwgPT09IHVuZGVmaW5lZCA/ICcnIDogbGFiZWw7IC8vIGRvaW5nIGRpc3BsYXlGbihzY29wZSwgbG9jYWxzKSB8fCAnJyBvdmVyd3JpdGVzIHplcm8gdmFsdWVzXHJcbiAgICAgICAgICAgIG9wdGlvbkdyb3VwLnB1c2goe1xyXG4gICAgICAgICAgICAgIGlkOiB0cmFja0ZuID8gdHJhY2tGbihzY29wZSwgbG9jYWxzKSA6IChrZXlOYW1lID8ga2V5c1tpbmRleF0gOiBpbmRleCksICAgLy8gZWl0aGVyIHRoZSBpbmRleCBpbnRvIGFycmF5IG9yIGtleSBmcm9tIG9iamVjdFxyXG4gICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcclxuICAgICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBiZSBzZWxlY3RlZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghbXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgaWYgKG51bGxPcHRpb24gfHwgbW9kZWxWYWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIC8vIGluc2VydCBudWxsIG9wdGlvbiBpZiB3ZSBoYXZlIGEgcGxhY2Vob2xkZXIsIG9yIHRoZSBtb2RlbCBpcyBudWxsXHJcbiAgICAgICAgICAgICAgb3B0aW9uR3JvdXBzWycnXS51bnNoaWZ0KHtpZDonJywgbGFiZWw6JycsIHNlbGVjdGVkOiFzZWxlY3RlZFNldH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzZWxlY3RlZFNldCkge1xyXG4gICAgICAgICAgICAgIC8vIG9wdGlvbiBjb3VsZCBub3QgYmUgZm91bmQsIHdlIGhhdmUgdG8gaW5zZXJ0IHRoZSB1bmRlZmluZWQgaXRlbVxyXG4gICAgICAgICAgICAgIG9wdGlvbkdyb3Vwc1snJ10udW5zaGlmdCh7aWQ6Jz8nLCBsYWJlbDonJywgc2VsZWN0ZWQ6dHJ1ZX0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTm93IHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIERPTSBub2RlcyB0byBtYXRjaCB0aGUgb3B0aW9uR3JvdXBzIHdlIGNvbXB1dGVkIGFib3ZlXHJcbiAgICAgICAgICBmb3IgKGdyb3VwSW5kZXggPSAwLCBncm91cExlbmd0aCA9IG9wdGlvbkdyb3VwTmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICBncm91cEluZGV4IDwgZ3JvdXBMZW5ndGg7XHJcbiAgICAgICAgICAgICAgIGdyb3VwSW5kZXgrKykge1xyXG4gICAgICAgICAgICAvLyBjdXJyZW50IG9wdGlvbiBncm91cCBuYW1lIG9yICcnIGlmIG5vIGdyb3VwXHJcbiAgICAgICAgICAgIG9wdGlvbkdyb3VwTmFtZSA9IG9wdGlvbkdyb3VwTmFtZXNbZ3JvdXBJbmRleF07XHJcblxyXG4gICAgICAgICAgICAvLyBsaXN0IG9mIG9wdGlvbnMgZm9yIHRoYXQgZ3JvdXAuIChmaXJzdCBpdGVtIGhhcyB0aGUgcGFyZW50KVxyXG4gICAgICAgICAgICBvcHRpb25Hcm91cCA9IG9wdGlvbkdyb3Vwc1tvcHRpb25Hcm91cE5hbWVdO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbkdyb3Vwc0NhY2hlLmxlbmd0aCA8PSBncm91cEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBncm93IHRoZSBvcHRpb25Hcm91cHNcclxuICAgICAgICAgICAgICBleGlzdGluZ1BhcmVudCA9IHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG9wdEdyb3VwVGVtcGxhdGUuY2xvbmUoKS5hdHRyKCdsYWJlbCcsIG9wdGlvbkdyb3VwTmFtZSksXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogb3B0aW9uR3JvdXAubGFiZWxcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGV4aXN0aW5nT3B0aW9ucyA9IFtleGlzdGluZ1BhcmVudF07XHJcbiAgICAgICAgICAgICAgb3B0aW9uR3JvdXBzQ2FjaGUucHVzaChleGlzdGluZ09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKGV4aXN0aW5nUGFyZW50LmVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGV4aXN0aW5nT3B0aW9ucyA9IG9wdGlvbkdyb3Vwc0NhY2hlW2dyb3VwSW5kZXhdO1xyXG4gICAgICAgICAgICAgIGV4aXN0aW5nUGFyZW50ID0gZXhpc3RpbmdPcHRpb25zWzBdOyAgLy8gZWl0aGVyIFNFTEVDVCAobm8gZ3JvdXApIG9yIE9QVEdST1VQIGVsZW1lbnRcclxuXHJcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBPUFRHUk9VUCBsYWJlbCBpZiBub3QgdGhlIHNhbWUuXHJcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGFyZW50LmxhYmVsICE9IG9wdGlvbkdyb3VwTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdQYXJlbnQuZWxlbWVudC5hdHRyKCdsYWJlbCcsIGV4aXN0aW5nUGFyZW50LmxhYmVsID0gb3B0aW9uR3JvdXBOYW1lKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gbnVsbDsgIC8vIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmdcclxuICAgICAgICAgICAgZm9yKGluZGV4ID0gMCwgbGVuZ3RoID0gb3B0aW9uR3JvdXAubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbkdyb3VwW2luZGV4XTtcclxuICAgICAgICAgICAgICBpZiAoKGV4aXN0aW5nT3B0aW9uID0gZXhpc3RpbmdPcHRpb25zW2luZGV4KzFdKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV1c2UgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZXhpc3RpbmdPcHRpb24uZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ09wdGlvbi5sYWJlbCAhPT0gb3B0aW9uLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50LnRleHQoZXhpc3RpbmdPcHRpb24ubGFiZWwgPSBvcHRpb24ubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nT3B0aW9uLmlkICE9PSBvcHRpb24uaWQpIHtcclxuICAgICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQudmFsKGV4aXN0aW5nT3B0aW9uLmlkID0gb3B0aW9uLmlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGxhc3RFbGVtZW50LnByb3AoJ3NlbGVjdGVkJykgcHJvdmlkZWQgYnkgalF1ZXJ5IGhhcyBzaWRlLWVmZmVjdHNcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0RWxlbWVudFswXS5zZWxlY3RlZCAhPT0gb3B0aW9uLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50LnByb3AoJ3NlbGVjdGVkJywgKGV4aXN0aW5nT3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnNlbGVjdGVkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGdyb3cgZWxlbWVudHNcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGEgbnVsbCBvcHRpb25cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb24uaWQgPT09ICcnICYmIG51bGxPcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgLy8gcHV0IGJhY2sgdGhlIHByZS1jb21waWxlZCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsT3B0aW9uO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgLy8galF1ZXJ5KHYxLjQuMikgQnVnOiBXZSBzaG91bGQgYmUgYWJsZSB0byBjaGFpbiB0aGUgbWV0aG9kIGNhbGxzLCBidXRcclxuICAgICAgICAgICAgICAgICAgLy8gaW4gdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSBvbiBzb21lIGJyb3dzZXIgdGhlIC50ZXh0KCkgcmV0dXJucyBhIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAvLyByYXRoZXIgdGhlbiB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgKGVsZW1lbnQgPSBvcHRpb25UZW1wbGF0ZS5jbG9uZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgLnZhbChvcHRpb24uaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc2VsZWN0ZWQnLCBvcHRpb24uc2VsZWN0ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAudGV4dChvcHRpb24ubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGV4aXN0aW5nT3B0aW9ucy5wdXNoKGV4aXN0aW5nT3B0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG9wdGlvbi5sYWJlbCxcclxuICAgICAgICAgICAgICAgICAgICBpZDogb3B0aW9uLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBvcHRpb24uc2VsZWN0ZWRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50LmFmdGVyKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXJlbnQuZWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgZXhjZXNzaXZlIE9QVElPTnMgaW4gYSBncm91cFxyXG4gICAgICAgICAgICBpbmRleCsrOyAvLyBpbmNyZW1lbnQgc2luY2UgdGhlIGV4aXN0aW5nT3B0aW9uc1swXSBpcyBwYXJlbnQgZWxlbWVudCBub3QgT1BUSU9OXHJcbiAgICAgICAgICAgIHdoaWxlKGV4aXN0aW5nT3B0aW9ucy5sZW5ndGggPiBpbmRleCkge1xyXG4gICAgICAgICAgICAgIGV4aXN0aW5nT3B0aW9ucy5wb3AoKS5lbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyByZW1vdmUgYW55IGV4Y2Vzc2l2ZSBPUFRHUk9VUHMgZnJvbSBzZWxlY3RcclxuICAgICAgICAgIHdoaWxlKG9wdGlvbkdyb3Vwc0NhY2hlLmxlbmd0aCA+IGdyb3VwSW5kZXgpIHtcclxuICAgICAgICAgICAgb3B0aW9uR3JvdXBzQ2FjaGUucG9wKClbMF0uZWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1dO1xyXG5cclxudmFyIG9wdGlvbkRpcmVjdGl2ZSA9IFsnJGludGVycG9sYXRlJywgZnVuY3Rpb24oJGludGVycG9sYXRlKSB7XHJcbiAgdmFyIG51bGxTZWxlY3RDdHJsID0ge1xyXG4gICAgYWRkT3B0aW9uOiBub29wLFxyXG4gICAgcmVtb3ZlT3B0aW9uOiBub29wXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICBwcmlvcml0eTogMTAwLFxyXG4gICAgY29tcGlsZTogZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xyXG4gICAgICBpZiAoaXNVbmRlZmluZWQoYXR0ci52YWx1ZSkpIHtcclxuICAgICAgICB2YXIgaW50ZXJwb2xhdGVGbiA9ICRpbnRlcnBvbGF0ZShlbGVtZW50LnRleHQoKSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKCFpbnRlcnBvbGF0ZUZuKSB7XHJcbiAgICAgICAgICBhdHRyLiRzZXQoJ3ZhbHVlJywgZWxlbWVudC50ZXh0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cikge1xyXG4gICAgICAgIHZhciBzZWxlY3RDdHJsTmFtZSA9ICckc2VsZWN0Q29udHJvbGxlcicsXHJcbiAgICAgICAgICAgIHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCksXHJcbiAgICAgICAgICAgIHNlbGVjdEN0cmwgPSBwYXJlbnQuZGF0YShzZWxlY3RDdHJsTmFtZSkgfHxcclxuICAgICAgICAgICAgICBwYXJlbnQucGFyZW50KCkuZGF0YShzZWxlY3RDdHJsTmFtZSk7IC8vIGluIGNhc2Ugd2UgYXJlIGluIG9wdGdyb3VwXHJcblxyXG4gICAgICAgIGlmIChzZWxlY3RDdHJsICYmIHNlbGVjdEN0cmwuZGF0YWJvdW5kKSB7XHJcbiAgICAgICAgICAvLyBGb3Igc29tZSByZWFzb24gT3BlcmEgZGVmYXVsdHMgdG8gdHJ1ZSBhbmQgaWYgbm90IG92ZXJyaWRkZW4gdGhpcyBtZXNzZXMgdXAgdGhlIHJlcGVhdGVyLlxyXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgdmlldyB0byBkcml2ZSB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIG1vZGVsIGFueXdheS5cclxuICAgICAgICAgIGVsZW1lbnQucHJvcCgnc2VsZWN0ZWQnLCBmYWxzZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNlbGVjdEN0cmwgPSBudWxsU2VsZWN0Q3RybDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZUZuKSB7XHJcbiAgICAgICAgICBzY29wZS4kd2F0Y2goaW50ZXJwb2xhdGVGbiwgZnVuY3Rpb24gaW50ZXJwb2xhdGVXYXRjaEFjdGlvbihuZXdWYWwsIG9sZFZhbCkge1xyXG4gICAgICAgICAgICBhdHRyLiRzZXQoJ3ZhbHVlJywgbmV3VmFsKTtcclxuICAgICAgICAgICAgaWYgKG5ld1ZhbCAhPT0gb2xkVmFsKSBzZWxlY3RDdHJsLnJlbW92ZU9wdGlvbihvbGRWYWwpO1xyXG4gICAgICAgICAgICBzZWxlY3RDdHJsLmFkZE9wdGlvbihuZXdWYWwpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNlbGVjdEN0cmwuYWRkT3B0aW9uKGF0dHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxlbWVudC5vbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNlbGVjdEN0cmwucmVtb3ZlT3B0aW9uKGF0dHIudmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxufV07XHJcblxyXG52YXIgc3R5bGVEaXJlY3RpdmUgPSB2YWx1ZUZuKHtcclxuICByZXN0cmljdDogJ0UnLFxyXG4gIHRlcm1pbmFsOiB0cnVlXHJcbn0pO1xyXG5cclxuICAvL3RyeSB0byBiaW5kIHRvIGpxdWVyeSBub3cgc28gdGhhdCBvbmUgY2FuIHdyaXRlIGFuZ3VsYXIuZWxlbWVudCgpLnJlYWQoKVxyXG4gIC8vYnV0IHdlIHdpbGwgcmViaW5kIG9uIGJvb3RzdHJhcCBhZ2Fpbi5cclxuICBiaW5kSlF1ZXJ5KCk7XHJcblxyXG4gIHB1Ymxpc2hFeHRlcm5hbEFQSShhbmd1bGFyKTtcclxuXHJcbiAganFMaXRlKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuICAgIGFuZ3VsYXJJbml0KGRvY3VtZW50LCBib290c3RyYXApO1xyXG4gIH0pO1xyXG5cclxufSkod2luZG93LCBkb2N1bWVudCk7XHJcbmFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZCgnaGVhZCcpLnByZXBlbmQoJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj5AY2hhcnNldCBcIlVURi04XCI7W25nXFxcXDpjbG9ha10sW25nLWNsb2FrXSxbZGF0YS1uZy1jbG9ha10sW3gtbmctY2xvYWtdLC5uZy1jbG9haywueC1uZy1jbG9haywubmctaGlkZXtkaXNwbGF5Om5vbmUgIWltcG9ydGFudDt9bmdcXFxcOmZvcm17ZGlzcGxheTpibG9jazt9PC9zdHlsZT4nKTsiLCIvKipcclxuICogT3BlcmF0aXZlXHJcbiAqIC0tLVxyXG4gKiBPcGVyYXRpdmUgaXMgYSBzbWFsbCBKUyB1dGlsaXR5IGZvciBzZWFtbGVzc2x5IGNyZWF0aW5nIFdlYiBXb3JrZXIgc2NyaXB0cy5cclxuICogLS0tXHJcbiAqIEBhdXRob3IgSmFtZXMgUGFkb2xzZXkgaHR0cDovL2phbWVzLnBhZG9sc2V5LmNvbVxyXG4gKiBAcmVwbyBodHRwOi8vZ2l0aHViLmNvbS9wYWRvbHNleS9vcGVyYXRpdmVcclxuICogQHZlcnNpb24gMC4yLjFcclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG5cdGlmICh0eXBlb2Ygd2luZG93ID09ICd1bmRlZmluZWQnICYmIHNlbGYuaW1wb3J0U2NyaXB0cykge1xyXG5cdFx0Ly8gSSdtIGEgd29ya2VyISBSdW4gdGhlIGJvaWxlci1zY3JpcHQ6XHJcblx0XHQvLyAoT3BlcmF0aXZlIGl0c2VsZiBpcyBjYWxsZWQgaW4gSUUxMCBhcyBhIHdvcmtlcixcclxuXHRcdC8vICB0byBhdm9pZCBTZWN1cml0eUVycm9ycylcclxuXHRcdHdvcmtlckJvaWxlclNjcmlwdCgpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0dmFyIHNsaWNlID0gW10uc2xpY2U7XHJcblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xyXG5cclxuXHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcclxuXHR2YXIgb3BTY3JpcHQgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV07XHJcblx0dmFyIG9wU2NyaXB0VVJMID0gL29wZXJhdGl2ZS8udGVzdChvcFNjcmlwdC5zcmMpICYmIG9wU2NyaXB0LnNyYztcclxuXHJcblx0Ly8gRGVmYXVsdCBiYXNlIFVSTCAodG8gYmUgcHJlcGVuZGVkIHRvIHJlbGF0aXZlIGRlcGVuZGVuY3kgVVJMcylcclxuXHQvLyBpcyBjdXJyZW50IHBhZ2UncyBwYXJlbnQgZGlyOlxyXG5cdHZhciBiYXNlVVJMID0gKFxyXG5cdFx0bG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICtcclxuXHRcdGxvY2F0aW9uLmhvc3RuYW1lICtcclxuXHRcdChsb2NhdGlvbi5wb3J0Pyc6Jytsb2NhdGlvbi5wb3J0OicnKSArXHJcblx0XHRsb2NhdGlvbi5wYXRobmFtZVxyXG5cdCkucmVwbGFjZSgvW15cXC9dKyQvLCAnJyk7XHJcblxyXG5cdHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XHJcblx0dmFyIEJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXI7XHJcblxyXG5cdHZhciB3b3JrZXJWaWFCbG9iU3VwcG9ydCA9IChmdW5jdGlvbigpIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdG5ldyBXb3JrZXIobWFrZUJsb2JVUkkoJzsnKSk7XHJcblx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSgpKTtcclxuXHJcblx0LyoqXHJcblx0ICogUHJvdmlkZSBPYmplY3QuY3JlYXRlIHNoaW1cclxuXHQgKi9cclxuXHR2YXIgb2JqQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbihvKSB7XHJcblx0XHRmdW5jdGlvbiBGKCkge31cclxuXHRcdEYucHJvdG90eXBlID0gbztcclxuXHRcdHJldHVybiBuZXcgRigpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIG1ha2VCbG9iVVJJKHNjcmlwdCkge1xyXG5cdFx0dmFyIGJsb2I7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0YmxvYiA9IG5ldyBCbG9iKFtzY3JpcHRdLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xyXG5cdFx0fSBjYXRjaCAoZSkgeyBcclxuXHRcdFx0YmxvYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xyXG5cdFx0XHRibG9iLmFwcGVuZChzY3JpcHQpO1xyXG5cdFx0XHRibG9iID0gYmxvYi5nZXRCbG9iKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblx0fVxyXG5cclxuXHQvLyBJbmRpY2F0ZXMgd2hldGhlciBvcGVyYXRpdmVzIHdpbGwgcnVuIHdpdGhpbiB3b3JrZXJzOlxyXG5cdG9wZXJhdGl2ZS5oYXNXb3JrZXJTdXBwb3J0ID0gISF3aW5kb3cuV29ya2VyO1xyXG5cclxuXHRvcGVyYXRpdmUuUHJvbWlzZSA9IHdpbmRvdy5Qcm9taXNlO1xyXG5cclxuXHQvLyBFeHBvc2U6XHJcblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IG9wZXJhdGl2ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2luZG93Lm9wZXJhdGl2ZSA9IG9wZXJhdGl2ZTtcclxuXHR9XHJcblx0XHJcblxyXG5cdG9wZXJhdGl2ZS5zZXRTZWxmVVJMID0gZnVuY3Rpb24odXJsKSB7XHJcblx0XHRvcFNjcmlwdFVSTCA9IHVybDtcclxuXHR9O1xyXG5cclxuXHRvcGVyYXRpdmUuc2V0QmFzZVVSTCA9IGZ1bmN0aW9uKGJhc2UpIHtcclxuXHRcdGJhc2VVUkwgPSBiYXNlO1xyXG5cdH07XHJcblxyXG5cdG9wZXJhdGl2ZS5nZXRCYXNlVVJMID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gYmFzZVVSTDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBPcGVyYXRpdmU6IEV4cG9zZWQgT3BlcmF0aXZlIENvbnN0cnVjdG9yXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBPYmplY3QgY29udGFpbmluZyBtZXRob2RzL3Byb3BlcnRpZXNcclxuXHQgKi9cclxuXHRmdW5jdGlvbiBPcGVyYXRpdmUobW9kdWxlLCBkZXBlbmRlbmNpZXMpIHtcclxuXHJcblx0XHR2YXIgX3NlbGYgPSB0aGlzO1xyXG5cclxuXHRcdG1vZHVsZS5nZXQgPSBtb2R1bGUuZ2V0IHx8IGZ1bmN0aW9uKHByb3ApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXNbcHJvcF07XHJcblx0XHR9O1xyXG5cclxuXHRcdG1vZHVsZS5zZXQgPSBtb2R1bGUuc2V0IHx8IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XHJcblx0XHRcdHJldHVybiB0aGlzW3Byb3BdID0gdmFsdWU7XHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuX2N1clRva2VuID0gMDtcclxuXHRcdHRoaXMuX3F1ZXVlID0gW107XHJcblxyXG5cdFx0dGhpcy5pc0Rlc3Ryb3llZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc0NvbnRleHRSZWFkeSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMubW9kdWxlID0gbW9kdWxlO1xyXG5cdFx0dGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMgfHwgW107XHJcblxyXG5cdFx0dGhpcy5kYXRhUHJvcGVydGllcyA9IHt9O1xyXG5cdFx0dGhpcy5hcGkgPSB7fTtcclxuXHRcdHRoaXMuY2FsbGJhY2tzID0ge307XHJcblx0XHR0aGlzLmRlZmVycmVkcyA9IHt9O1xyXG5cclxuXHRcdHRoaXMuX2ZpeERlcGVuZGVuY3lVUkxzKCk7XHJcblx0XHR0aGlzLl9zZXR1cCgpO1xyXG5cclxuXHRcdGZvciAodmFyIG1ldGhvZE5hbWUgaW4gbW9kdWxlKSB7XHJcblx0XHRcdGlmIChoYXNPd24uY2FsbChtb2R1bGUsIG1ldGhvZE5hbWUpKSB7XHJcblx0XHRcdFx0dGhpcy5fY3JlYXRlRXhwb3NlZE1ldGhvZChtZXRob2ROYW1lKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYXBpLl9fb3BlcmF0aXZlX18gPSB0aGlzO1xyXG5cclxuXHRcdC8vIFByb3ZpZGUgdGhlIGluc3RhbmNlJ3MgZGVzdHJveSBtZXRob2Qgb24gdGhlIGV4cG9zZWQgQVBJOlxyXG5cdFx0dGhpcy5hcGkuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gX3NlbGYuZGVzdHJveSgpO1xyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRPcGVyYXRpdmUucHJvdG90eXBlID0ge1xyXG5cclxuXHRcdF9tYXJzaGFsOiBmdW5jdGlvbih2KSB7XHJcblx0XHRcdHJldHVybiB2O1xyXG5cdFx0fSxcclxuXHJcblx0XHRfZGVtYXJzaGFsOiBmdW5jdGlvbih2KSB7XHJcblx0XHRcdHJldHVybiB2O1xyXG5cdFx0fSxcclxuXHJcblx0XHRfZW5xdWV1ZTogZnVuY3Rpb24oZm4pIHtcclxuXHRcdFx0dGhpcy5fcXVldWUucHVzaChmbik7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9maXhEZXBlbmRlbmN5VVJMczogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBkZXBzID0gdGhpcy5kZXBlbmRlbmNpZXM7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZGVwcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuXHRcdFx0XHR2YXIgZGVwID0gZGVwc1tpXTtcclxuXHRcdFx0XHRpZiAoIS9cXC9cXC8vLnRlc3QoZGVwKSkge1xyXG5cdFx0XHRcdFx0ZGVwc1tpXSA9IGRlcC5yZXBsYWNlKC9eXFwvPy8sIGJhc2VVUkwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHRfZGVxdWV1ZUFsbDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fcXVldWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XHJcblx0XHRcdFx0dGhpcy5fcXVldWVbaV0uY2FsbCh0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9xdWV1ZSA9IFtdO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfYnVpbGRDb250ZXh0U2NyaXB0OiBmdW5jdGlvbihib2lsZXJTY3JpcHQpIHtcclxuXHJcblx0XHRcdHZhciBzY3JpcHQgPSBbXTtcclxuXHRcdFx0dmFyIG1vZHVsZSA9IHRoaXMubW9kdWxlO1xyXG5cdFx0XHR2YXIgZGF0YVByb3BlcnRpZXMgPSB0aGlzLmRhdGFQcm9wZXJ0aWVzO1xyXG5cdFx0XHR2YXIgcHJvcGVydHk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpIGluIG1vZHVsZSkge1xyXG5cdFx0XHRcdHByb3BlcnR5ID0gbW9kdWxlW2ldO1xyXG5cdFx0XHRcdGlmICh0eXBlb2YgcHJvcGVydHkgPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0c2NyaXB0LnB1c2goJyAgIHNlbGZbXCInICsgaS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCJdID0gJyArIHByb3BlcnR5LnRvU3RyaW5nKCkgKyAnOycpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRkYXRhUHJvcGVydGllc1tpXSA9IHByb3BlcnR5O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHNjcmlwdC5qb2luKCdcXG4nKSArIChcclxuXHRcdFx0XHRib2lsZXJTY3JpcHQgPyAnXFxuKCcgKyBib2lsZXJTY3JpcHQudG9TdHJpbmcoKSArICcoKSk7JyA6ICcnXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRfY3JlYXRlRXhwb3NlZE1ldGhvZDogZnVuY3Rpb24obWV0aG9kTmFtZSkge1xyXG5cclxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHRcdFx0dGhpcy5hcGlbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0aWYgKHNlbGYuaXNEZXN0cm95ZWQpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignT3BlcmF0aXZlOiBDYW5ub3QgcnVuIG1ldGhvZC4gT3BlcmF0aXZlIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkJyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgdG9rZW4gPSArK3NlbGYuX2N1clRva2VuO1xyXG5cdFx0XHRcdHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cdFx0XHRcdHZhciBjYiA9IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJyAmJiBhcmdzLnBvcCgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWNiICYmICFvcGVyYXRpdmUuUHJvbWlzZSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxyXG5cdFx0XHRcdFx0XHQnT3BlcmF0aXZlOiBObyBjYWxsYmFjayBoYXMgYmVlbiBwYXNzZWQuIEFzc3VtZWQgdGhhdCB5b3Ugd2FudCBhIHByb21pc2UuICcgK1xyXG5cdFx0XHRcdFx0XHQnQnV0IGBvcGVyYXRpdmUuUHJvbWlzZWAgaXMgbnVsbC4gUGxlYXNlIHByb3ZpZGUgUHJvbWlzZSBwb2x5ZmlsbC9saWIuJ1xyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjYikge1xyXG5cclxuXHRcdFx0XHRcdHNlbGYuY2FsbGJhY2tzW3Rva2VuXSA9IGNiO1xyXG5cclxuXHRcdFx0XHRcdC8vIEVuc3VyZSBlaXRoZXIgY29udGV4dCBydW5zIHRoZSBtZXRob2QgYXN5bmM6XHJcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRydW5NZXRob2QoKTtcclxuXHRcdFx0XHRcdH0sIDEpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKG9wZXJhdGl2ZS5Qcm9taXNlKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gTm8gQ2FsbGJhY2sgLS0gUHJvbWlzZSB1c2VkOlxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBuZXcgb3BlcmF0aXZlLlByb21pc2UoZnVuY3Rpb24oZGVmZXJyZWQpIHtcclxuXHRcdFx0XHRcdFx0ZGVmZXJyZWQuZnVsZmlsID0gZGVmZXJyZWQuZnVsZmlsbDtcclxuXHRcdFx0XHRcdFx0c2VsZi5kZWZlcnJlZHNbdG9rZW5dID0gZGVmZXJyZWQ7XHJcblx0XHRcdFx0XHRcdHJ1bk1ldGhvZCgpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZnVuY3Rpb24gcnVuTWV0aG9kKCkge1xyXG5cdFx0XHRcdFx0aWYgKHNlbGYuaXNDb250ZXh0UmVhZHkpIHtcclxuXHRcdFx0XHRcdFx0c2VsZi5fcnVuTWV0aG9kKG1ldGhvZE5hbWUsIHRva2VuLCBhcmdzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHNlbGYuX2VucXVldWUocnVuTWV0aG9kKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRoaXMuaXNEZXN0cm95ZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBPcGVyYXRpdmUgV29ya2VyXHJcblx0ICovXHJcblx0T3BlcmF0aXZlLldvcmtlciA9IGZ1bmN0aW9uIFdvcmtlcihtb2R1bGUpIHtcclxuXHRcdHRoaXMuX21zZ1F1ZXVlID0gW107XHJcblx0XHRPcGVyYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgV29ya2VyUHJvdG8gPSBPcGVyYXRpdmUuV29ya2VyLnByb3RvdHlwZSA9IG9iakNyZWF0ZShPcGVyYXRpdmUucHJvdG90eXBlKTtcclxuXHJcblx0V29ya2VyUHJvdG8uX29uV29ya2VyTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcclxuXHRcdHZhciBkYXRhID0gZS5kYXRhO1xyXG5cclxuXHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5pbmRleE9mKCdwaW5nYmFjaycpID09PSAwKSB7XHJcblx0XHRcdGlmIChkYXRhID09PSAncGluZ2JhY2s6c3RydWN0dXJlZENsb25pbmdTdXBwb3J0PU5PJykge1xyXG5cdFx0XHRcdC8vIE5vIHN0cnVjdHVyZWRDbG9uaW5nU3VwcG9ydCBzdXBwb3J0IChtYXJzaGFsIEpTT04gZnJvbSBub3cgb24pOlxyXG5cdFx0XHRcdHRoaXMuX21hcnNoYWwgPSBmdW5jdGlvbihvKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeShvKTsgfTtcclxuXHRcdFx0XHR0aGlzLl9kZW1hcnNoYWwgPSBmdW5jdGlvbihvKSB7IHJldHVybiBKU09OLnBhcnNlKG8pOyB9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmlzQ29udGV4dFJlYWR5ID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5fcG9zdE1lc3NhZ2Uoe1xyXG5cdFx0XHRcdGRlZmluaXRpb25zOiB0aGlzLmRhdGFQcm9wZXJ0aWVzXHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLl9kZXF1ZXVlQWxsKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGF0YSA9IHRoaXMuX2RlbWFyc2hhbChkYXRhKTtcclxuXHJcblx0XHRzd2l0Y2ggKGRhdGEuY21kKSB7XHJcblx0XHRcdGNhc2UgJ2NvbnNvbGUnOlxyXG5cdFx0XHRcdHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlW2RhdGEubWV0aG9kXS5hcHBseSh3aW5kb3cuY29uc29sZSwgZGF0YS5hcmdzKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAncmVzdWx0JzpcclxuXHJcblx0XHRcdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbZGF0YS50b2tlbl07XHJcblx0XHRcdFx0dmFyIGRlZmVycmVkID0gdGhpcy5kZWZlcnJlZHNbZGF0YS50b2tlbl07XHJcblxyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tkYXRhLnRva2VuXTtcclxuXHRcdFx0XHRkZWxldGUgdGhpcy5kZWZlcnJlZHNbZGF0YS50b2tlbl07XHJcblxyXG5cdFx0XHRcdHZhciBkZWZlcnJlZEFjdGlvbiA9IGRhdGEucmVzdWx0ICYmIGRhdGEucmVzdWx0LmlzRGVmZXJyZWQgJiYgZGF0YS5yZXN1bHQuYWN0aW9uO1xyXG5cclxuXHRcdFx0XHRpZiAoZGVmZXJyZWQgJiYgZGVmZXJyZWRBY3Rpb24pIHtcclxuXHRcdFx0XHRcdGRlZmVycmVkW2RlZmVycmVkQWN0aW9uXShkYXRhLnJlc3VsdC5hcmdzWzBdKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5hcHBseSh0aGlzLCBkYXRhLnJlc3VsdC5hcmdzKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFdvcmtlclByb3RvLl9zZXR1cCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHRcdHZhciB3b3JrZXI7XHJcblx0XHR2YXIgc2NyaXB0ID0gdGhpcy5fYnVpbGRDb250ZXh0U2NyaXB0KFxyXG5cdFx0XHQvLyBUaGUgc2NyaXB0IGlzIG5vdCBpbmNsdWRlZCBpZiB3ZSdyZSBFdmFsJ2luZyB0aGlzIGZpbGUgZGlyZWN0bHk6XHJcblx0XHRcdHdvcmtlclZpYUJsb2JTdXBwb3J0ID8gd29ya2VyQm9pbGVyU2NyaXB0IDogJydcclxuXHRcdCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuZGVwZW5kZW5jaWVzLmxlbmd0aCkge1xyXG5cdFx0XHRzY3JpcHQgPSAnaW1wb3J0U2NyaXB0cyhcIicgKyB0aGlzLmRlcGVuZGVuY2llcy5qb2luKCdcIiwgXCInKSArICdcIik7XFxuJyArIHNjcmlwdDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod29ya2VyVmlhQmxvYlN1cHBvcnQpIHtcclxuXHRcdFx0d29ya2VyID0gdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKCBtYWtlQmxvYlVSSShzY3JpcHQpICk7XHJcblx0XHR9ICBlbHNlIHtcclxuXHRcdFx0aWYgKCFvcFNjcmlwdFVSTCkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignT3BlcmFyaXR2ZTogTm8gb3BlcmF0aXZlLmpzIFVSTCBhdmFpbGFibGUuIFBsZWFzZSBzZXQgdmlhIG9wZXJhdGl2ZS5zZXRTZWxmVVJMKC4uLiknKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR3b3JrZXIgPSB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIoIG9wU2NyaXB0VVJMICk7XHJcblx0XHRcdC8vIE1hcnNoYWwtYWdub3N0aWMgaW5pdGlhbCBtZXNzYWdlIGlzIGJvaWxlci1jb2RlOlxyXG5cdFx0XHQvLyAoV2UgZG9uJ3QgeWV0IGtub3cgaWYgc3RydWN0dXJlZC1jbG9uaW5nIGlzIHN1cHBvcnRlZCBzbyB3ZSBzZW5kIGEgc3RyaW5nKVxyXG5cdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UoJ0VWQUx8JyArIHNjcmlwdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0d29ya2VyLnBvc3RNZXNzYWdlKFsnUElORyddKTsgLy8gSW5pdGlhbCBQSU5HXHJcblxyXG5cdFx0d29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdHNlbGYuX29uV29ya2VyTWVzc2FnZShlKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdFdvcmtlclByb3RvLl9wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xyXG5cdFx0cmV0dXJuIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHRoaXMuX21hcnNoYWwobXNnKSk7XHJcblx0fTtcclxuXHJcblx0V29ya2VyUHJvdG8uX3J1bk1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIHRva2VuLCBhcmdzKSB7XHJcblx0XHR0aGlzLl9wb3N0TWVzc2FnZSh7XHJcblx0XHRcdG1ldGhvZDogbWV0aG9kTmFtZSxcclxuXHRcdFx0YXJnczogYXJncyxcclxuXHRcdFx0dG9rZW46IHRva2VuXHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHRXb3JrZXJQcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcclxuXHRcdE9wZXJhdGl2ZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG5cdH07XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBPcGVyYXRpdmUgSUZyYW1lXHJcblx0ICovXHJcblx0T3BlcmF0aXZlLklmcmFtZSA9IGZ1bmN0aW9uIElmcmFtZShtb2R1bGUpIHtcclxuXHRcdE9wZXJhdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdH07XHJcblxyXG5cdHZhciBJZnJhbWVQcm90byA9IE9wZXJhdGl2ZS5JZnJhbWUucHJvdG90eXBlID0gb2JqQ3JlYXRlKE9wZXJhdGl2ZS5wcm90b3R5cGUpO1xyXG5cclxuXHR2YXIgX2xvYWRlZE1ldGhvZE5hbWVJID0gMDtcclxuXHJcblx0SWZyYW1lUHJvdG8uX3NldHVwID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0dmFyIGxvYWRlZE1ldGhvZE5hbWUgPSAnX19vcGVyYXRpdmVJRnJhbWVMb2FkZWQnICsgKytfbG9hZGVkTWV0aG9kTmFtZUk7XHJcblxyXG5cdFx0dGhpcy5tb2R1bGUuaXNXb3JrZXIgPSBmYWxzZTtcclxuXHJcblx0XHR2YXIgaWZyYW1lID0gdGhpcy5pZnJhbWUgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKFxyXG5cdFx0XHRkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKVxyXG5cdFx0KTtcclxuXHJcblx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHJcblx0XHR2YXIgaVdpbiA9IHRoaXMuaWZyYW1lV2luZG93ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XHJcblx0XHR2YXIgaURvYyA9IGlXaW4uZG9jdW1lbnQ7XHJcblxyXG5cdFx0Ly8gQ3Jvc3MgYnJvd3NlciAodGVzdGVkIGluIElFOCw5KSB3YXkgdG8gY2FsbCBtZXRob2QgZnJvbSB3aXRoaW5cclxuXHRcdC8vIElGUkFNRSBhZnRlciBhbGwgPFNjcmlwdD5zIGhhdmUgbG9hZGVkOlxyXG5cdFx0d2luZG93W2xvYWRlZE1ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHR3aW5kb3dbbG9hZGVkTWV0aG9kTmFtZV0gPSBudWxsO1xyXG5cclxuXHRcdFx0dmFyIHNjcmlwdCA9IGlEb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XHJcblx0XHRcdHZhciBqcyA9IHNlbGYuX2J1aWxkQ29udGV4dFNjcmlwdChpZnJhbWVCb2lsZXJTY3JpcHQpO1xyXG5cclxuXHRcdFx0aWYgKHNjcmlwdC50ZXh0ICE9PSB2b2lkIDApIHtcclxuXHRcdFx0XHRzY3JpcHQudGV4dCA9IGpzO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHNjcmlwdC5pbm5lckhUTUwgPSBqcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aURvYy5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgaW4gc2VsZi5kYXRhUHJvcGVydGllcykge1xyXG5cdFx0XHRcdGlXaW5baV0gPSBzZWxmLmRhdGFQcm9wZXJ0aWVzW2ldO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzZWxmLmlzQ29udGV4dFJlYWR5ID0gdHJ1ZTtcclxuXHRcdFx0c2VsZi5fZGVxdWV1ZUFsbCgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0aURvYy5vcGVuKCk7XHJcblx0XHRpZiAodGhpcy5kZXBlbmRlbmNpZXMubGVuZ3RoKSB7XHJcblx0XHRcdGlEb2Mud3JpdGUoXHJcblx0XHRcdFx0JzxzY3JpcHQgc3JjPVwiJyArIHRoaXMuZGVwZW5kZW5jaWVzLmpvaW4oJ1wiPjwvc2NyaXB0PjxzY3JpcHQgc3JjPVwiJykgKyAnXCI+PC9zY3JpcHQ+J1xyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gUGxhY2UgPHNjcmlwdD4gYXQgYm90dG9tIHRvIHRlbGwgcGFyZW50LXBhZ2Ugd2hlbiBkZXBlbmRlbmNpZXMgYXJlIGxvYWRlZDpcclxuXHRcdGlEb2Mud3JpdGUoJzxzY3JpcHQ+d2luZG93LnRvcC4nICsgbG9hZGVkTWV0aG9kTmFtZSArICcoKTs8L3NjcmlwdD4nKTtcclxuXHRcdGlEb2MuY2xvc2UoKTtcclxuXHJcblx0fTtcclxuXHJcblx0SWZyYW1lUHJvdG8uX3J1bk1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIHRva2VuLCBhcmdzKSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHR2YXIgY2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrc1t0b2tlbl07XHJcblx0XHR2YXIgZGVmZXJyZWQgPSB0aGlzLmRlZmVycmVkc1t0b2tlbl07XHJcblx0XHRkZWxldGUgdGhpcy5jYWxsYmFja3NbdG9rZW5dO1xyXG5cdFx0ZGVsZXRlIHRoaXMuZGVmZXJyZWRzW3Rva2VuXTtcclxuXHRcdHRoaXMuaWZyYW1lV2luZG93Ll9fcnVuX18obWV0aG9kTmFtZSwgYXJncywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBjYiA9IGNhbGxiYWNrO1xyXG5cdFx0XHRpZiAoY2IpIHtcclxuXHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XHJcblx0XHRcdFx0Y2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGl2ZTogWW91IGhhdmUgYWxyZWFkeSByZXR1cm5lZC4nKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgZGVmZXJyZWQpO1xyXG5cdH07XHJcblxyXG5cdElmcmFtZVByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5pZnJhbWUpO1xyXG5cdFx0T3BlcmF0aXZlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcblx0fTtcclxuXHJcblx0b3BlcmF0aXZlLk9wZXJhdGl2ZSA9IE9wZXJhdGl2ZTtcclxuXHJcblx0LyoqXHJcblx0ICogRXhwb3NlZCBvcGVyYXRpdmUgZmFjdG9yeVxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIG9wZXJhdGl2ZShtb2R1bGUsIGRlcGVuZGVuY2llcykge1xyXG5cclxuXHRcdHZhciBPcGVyYXRpdmVDb250ZXh0ID0gb3BlcmF0aXZlLmhhc1dvcmtlclN1cHBvcnQgP1xyXG5cdFx0XHRPcGVyYXRpdmUuV29ya2VyIDogT3BlcmF0aXZlLklmcmFtZTtcclxuXHJcblx0XHRpZiAodHlwZW9mIG1vZHVsZSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdC8vIEFsbG93IGEgc2luZ2xlIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZC5cclxuXHRcdFx0dmFyIG8gPSBuZXcgT3BlcmF0aXZlQ29udGV4dCh7IG1haW46IG1vZHVsZSB9LCBkZXBlbmRlbmNpZXMpO1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG8uYXBpLm1haW4uYXBwbHkobywgYXJndW1lbnRzKTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IE9wZXJhdGl2ZUNvbnRleHQobW9kdWxlLCBkZXBlbmRlbmNpZXMpLmFwaTtcclxuXHJcblx0fVxyXG5cclxuLyoqXHJcbiAqIFRoZSBib2lsZXJwbGF0ZSBmb3IgdGhlIElmcmFtZSBDb250ZXh0XHJcbiAqIE5PVEU6XHJcbiAqICB0aGlzJ2xsIGJlIGV4ZWN1dGVkIHdpdGhpbiBhbiBpZnJhbWUsIG5vdCBoZXJlLlxyXG4gKiAgSW5kZW50ZWQgQCBaZXJvIHRvIG1ha2UgbmljZXIgZGVidWcgY29kZSB3aXRoaW4gd29ya2VyXHJcbiAqL1xyXG5mdW5jdGlvbiBpZnJhbWVCb2lsZXJTY3JpcHQoKSB7XHJcblxyXG5cdC8vIENhbGxlZCBmcm9tIHBhcmVudC13aW5kb3c6XHJcblx0d2luZG93Ll9fcnVuX18gPSBmdW5jdGlvbihtZXRob2ROYW1lLCBhcmdzLCBjYiwgZGVmZXJyZWQpIHtcclxuXHJcblx0XHR2YXIgaXNBc3luYyA9IGZhbHNlO1xyXG5cdFx0dmFyIGlzRGVmZXJyZWQgPSBmYWxzZTtcclxuXHJcblx0XHR3aW5kb3cuYXN5bmMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0aXNBc3luYyA9IHRydWU7XHJcblx0XHRcdHJldHVybiBjYjtcclxuXHRcdH07XHJcblxyXG5cdFx0d2luZG93LmRlZmVycmVkID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlzRGVmZXJyZWQgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm4gZGVmZXJyZWQ7XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChjYikge1xyXG5cdFx0XHRhcmdzLnB1c2goY2IpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZXN1bHQgPSB3aW5kb3dbbWV0aG9kTmFtZV0uYXBwbHkod2luZG93LCBhcmdzKTtcclxuXHJcblx0XHR3aW5kb3cuYXN5bmMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpdmU6IGFzeW5jKCkgY2FsbGVkIGF0IG9kZCB0aW1lJyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHdpbmRvdy5kZWZlcnJlZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGl2ZTogZGVmZXJyZWQoKSBjYWxsZWQgYXQgb2RkIHRpbWUnKTtcclxuXHRcdH07XHJcblxyXG5cclxuXHRcdGlmICghaXNEZWZlcnJlZCAmJiAhaXNBc3luYyAmJiByZXN1bHQgIT09IHZvaWQgMCkge1xyXG5cdFx0XHQvLyBEZXByZWNhdGVkIGRpcmVjdC1yZXR1cm5pbmcgYXMgb2YgMC4yLjBcclxuXHRcdFx0Y2IocmVzdWx0KTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJvaWxlcnBsYXRlIGZvciB0aGUgV29ya2VyIEJsb2JcclxuICogTk9URTpcclxuICogIHRoaXMnbGwgYmUgZXhlY3V0ZWQgd2l0aGluIGFuIGlmcmFtZSwgbm90IGhlcmUuXHJcbiAqICBJbmRlbnRlZCBAIFplcm8gdG8gbWFrZSBuaWNlciBkZWJ1ZyBjb2RlIHdpdGhpbiB3b3JrZXJcclxuICovXHJcbmZ1bmN0aW9uIHdvcmtlckJvaWxlclNjcmlwdCgpIHtcclxuXHJcblx0dmFyIHBvc3RNZXNzYWdlID0gc2VsZi5wb3N0TWVzc2FnZTtcclxuXHR2YXIgc3RydWN0dXJlZENsb25pbmdTdXBwb3J0ID0gbnVsbDtcclxuXHJcblx0c2VsZi5jb25zb2xlID0ge307XHJcblx0c2VsZi5pc1dvcmtlciA9IHRydWU7XHJcblxyXG5cdC8vIFByb3ZpZGUgYmFzaWMgY29uc29sZSBpbnRlcmZhY2U6XHJcblx0Wydsb2cnLCAnZGVidWcnLCAnZXJyb3InLCAnaW5mbycsICd3YXJuJywgJ3RpbWUnLCAndGltZUVuZCddLmZvckVhY2goZnVuY3Rpb24obWV0aCkge1xyXG5cdFx0c2VsZi5jb25zb2xlW21ldGhdID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHBvc3RNZXNzYWdlKHtcclxuXHRcdFx0XHRjbWQ6ICdjb25zb2xlJyxcclxuXHRcdFx0XHRtZXRob2Q6IG1ldGgsXHJcblx0XHRcdFx0YXJnczogW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHR9KTtcclxuXHJcblx0c2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xyXG5cclxuXHRcdHZhciBkYXRhID0gZS5kYXRhO1xyXG5cclxuXHRcdGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyAmJiBkYXRhLmluZGV4T2YoJ0VWQUx8JykgPT09IDApIHtcclxuXHRcdFx0ZXZhbChkYXRhLnN1YnN0cmluZyg1KSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3RydWN0dXJlZENsb25pbmdTdXBwb3J0ID09IG51bGwpIHtcclxuXHJcblx0XHRcdC8vIGUuZGF0YSBvZiBbJ1BJTkcnXSAoQW4gYXJyYXkpIGluZGljYXRlcyB0cmFuc2ZlcnJhYmxlT2JqU3VwcG9ydFxyXG5cdFx0XHQvLyBlLmRhdGEgb2YgJ1wiUElOR1wiJyAoQSBzdHJpbmcpIGluZGljYXRlcyBubyBzdXBwb3J0IChBcnJheSBoYXMgYmVlbiBzZXJpYWxpemVkKVxyXG5cdFx0XHRzdHJ1Y3R1cmVkQ2xvbmluZ1N1cHBvcnQgPSBlLmRhdGFbMF0gPT09ICdQSU5HJztcclxuXHJcblx0XHRcdC8vIFBpbmdiYWNrIHRvIHBhcmVudCBwYWdlOlxyXG5cdFx0XHRzZWxmLnBvc3RNZXNzYWdlKFxyXG5cdFx0XHRcdHN0cnVjdHVyZWRDbG9uaW5nU3VwcG9ydCA/XHJcblx0XHRcdFx0XHQncGluZ2JhY2s6c3RydWN0dXJlZENsb25pbmdTdXBwb3J0PVlFUycgOlxyXG5cdFx0XHRcdFx0J3BpbmdiYWNrOnN0cnVjdHVyZWRDbG9uaW5nU3VwcG9ydD1OTydcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGlmICghc3RydWN0dXJlZENsb25pbmdTdXBwb3J0KSB7XHJcblx0XHRcdFx0cG9zdE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcclxuXHRcdFx0XHRcdC8vIE1hcnNoYWwgYmVmb3JlIHNlbmRpbmdcclxuXHRcdFx0XHRcdHJldHVybiBzZWxmLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KG1zZykpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXN0cnVjdHVyZWRDbG9uaW5nU3VwcG9ydCkge1xyXG5cdFx0XHQvLyBEZW1hcnNoYWw6XHJcblx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkZWZzID0gZGF0YS5kZWZpbml0aW9ucztcclxuXHRcdHZhciBpc0RlZmVycmVkID0gZmFsc2U7XHJcblx0XHR2YXIgaXNBc3luYyA9IGZhbHNlO1xyXG5cdFx0dmFyIGFyZ3MgPSBkYXRhLmFyZ3M7XHJcblxyXG5cdFx0aWYgKGRlZnMpIHtcclxuXHRcdFx0Ly8gSW5pdGlhbCBkZWZpbml0aW9uczpcclxuXHRcdFx0Zm9yICh2YXIgaSBpbiBkZWZzKSB7XHJcblx0XHRcdFx0c2VsZltpXSA9IGRlZnNbaV07XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGFyZ3MucHVzaChmdW5jdGlvbigpIHtcclxuXHRcdFx0Ly8gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIG9wZXJhdGl2ZSBtZXRob2RcclxuXHRcdFx0cmV0dXJuUmVzdWx0KHtcclxuXHRcdFx0XHRhcmdzOiBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRzZWxmLmFzeW5jID0gZnVuY3Rpb24oKSB7IC8vIEFzeW5jIGRlcHJlY2F0ZWQgYXMgb2YgMC4yLjBcclxuXHRcdFx0aXNBc3luYyA9IHRydWU7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuUmVzdWx0KHsgYXJnczogW10uc2xpY2UuY2FsbChhcmd1bWVudHMpIH0pOyB9O1xyXG5cdFx0fTtcclxuXHJcblx0XHRzZWxmLmRlZmVycmVkID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlzRGVmZXJyZWQgPSB0cnVlO1xyXG5cdFx0XHR2YXIgZGVmID0ge307XHJcblx0XHRcdGZ1bmN0aW9uIGZ1bGZpbGwocikge1xyXG5cdFx0XHRcdHJldHVyblJlc3VsdCh7XHJcblx0XHRcdFx0XHRpc0RlZmVycmVkOiB0cnVlLFxyXG5cdFx0XHRcdFx0YWN0aW9uOiAnZnVsZmlsbCcsXHJcblx0XHRcdFx0XHRhcmdzOiBbcl1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRyZXR1cm4gZGVmO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZ1bmN0aW9uIHJlamVjdChyKSB7XHJcblx0XHRcdFx0cmV0dXJuUmVzdWx0KHtcclxuXHRcdFx0XHRcdGlzRGVmZXJyZWQ6IHRydWUsXHJcblx0XHRcdFx0XHRhY3Rpb246ICdyZWplY3QnLFxyXG5cdFx0XHRcdFx0YXJnczogW3JdXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGVmLmZ1bGZpbCA9IGRlZi5mdWxmaWxsID0gZnVsZmlsbDtcclxuXHRcdFx0ZGVmLnJlamVjdCA9IHJlamVjdDtcclxuXHRcdFx0cmV0dXJuIGRlZjtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQ2FsbCBhY3R1YWwgb3BlcmF0aXZlIG1ldGhvZDpcclxuXHRcdHZhciByZXN1bHQgPSBzZWxmW2RhdGEubWV0aG9kXS5hcHBseShzZWxmLCBhcmdzKTtcclxuXHJcblx0XHRpZiAoIWlzRGVmZXJyZWQgJiYgIWlzQXN5bmMgJiYgcmVzdWx0ICE9PSB2b2lkIDApIHtcclxuXHRcdFx0Ly8gRGVwcmVjYXRlZCBkaXJlY3QtcmV0dXJuaW5nIGFzIG9mIDAuMi4wXHJcblx0XHRcdHJldHVyblJlc3VsdCh7XHJcblx0XHRcdFx0YXJnczogW3Jlc3VsdF1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0c2VsZi5kZWZlcnJlZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGl2ZTogZGVmZXJyZWQoKSBjYWxsZWQgYXQgb2RkIHRpbWUnKTtcclxuXHRcdH07XHJcblxyXG5cdFx0c2VsZi5hc3luYyA9IGZ1bmN0aW9uKCkgeyAvLyBBc3luYyBkZXByZWNhdGVkIGFzIG9mIDAuMi4wXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignT3BlcmF0aXZlOiBhc3luYygpIGNhbGxlZCBhdCBvZGQgdGltZScpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiByZXR1cm5SZXN1bHQocmVzKSB7XHJcblx0XHRcdHBvc3RNZXNzYWdlKHtcclxuXHRcdFx0XHRjbWQ6ICdyZXN1bHQnLFxyXG5cdFx0XHRcdHRva2VuOiBkYXRhLnRva2VuLFxyXG5cdFx0XHRcdHJlc3VsdDogcmVzXHJcblx0XHRcdH0pO1xyXG5cdFx0XHQvLyBPdmVycmlkZSB3aXRoIGVycm9yLXRocm93ZXIgaWYgd2UndmUgYWxyZWFkeSByZXR1cm5lZDpcclxuXHRcdFx0cmV0dXJuUmVzdWx0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpdmU6IFlvdSBoYXZlIGFscmVhZHkgcmV0dXJuZWQuJyk7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbn0oKSk7IiwiLy8gVGhpcyBpcyBhIHByZWx1ZGUgd2hpY2ggY29tZXMgYmVmb3JlIHRoZSBKUyBibG9iIG9mIGVhY2ggSlMgdHlwZSBmb3IgdGhlIHdlYi5cclxuKGZ1bmN0aW9uKCl7XHJcbiAgdmFyIG1vZHVsZSA9IHtleHBvcnRzOnt9fTtcclxuICB2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzO1xyXG5cclxuLy8gVGhlc2UgbWV0aG9kcyBsZXQgeW91IGJ1aWxkIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIGZyb20gYSB0cmFuc2Zvcm1Db21wb25lbnRcclxuLy8gZnVuY3Rpb24gZm9yIE9UIHR5cGVzIGxpa2UgSlNPTjAgaW4gd2hpY2ggb3BlcmF0aW9ucyBhcmUgbGlzdHMgb2YgY29tcG9uZW50c1xyXG4vLyBhbmQgdHJhbnNmb3JtaW5nIHRoZW0gcmVxcmV1aXJlcyBOXjIgd29yay4gSSBmaW5kIGl0IGtpbmQgb2YgbmFzdHkgdGhhdCBJIG5lZWRcclxuLy8gdGhpcywgYnV0IEknbSBub3QgcmVhbGx5IHN1cmUgd2hhdCBhIGJldHRlciBzb2x1dGlvbiBpcy4gTWF5YmUgSSBzaG91bGQgZG9cclxuLy8gdGhpcyBhdXRvbWF0aWNhbGx5IHRvIHR5cGVzIHRoYXQgZG9uJ3QgaGF2ZSBhIGNvbXBvc2UgZnVuY3Rpb24gZGVmaW5lZC5cclxuXHJcbi8vIEFkZCB0cmFuc2Zvcm0gYW5kIHRyYW5zZm9ybVggZnVuY3Rpb25zIGZvciBhbiBPVCB0eXBlIHdoaWNoIGhhc1xyXG4vLyB0cmFuc2Zvcm1Db21wb25lbnQgZGVmaW5lZC4gIHRyYW5zZm9ybUNvbXBvbmVudChkZXN0aW5hdGlvbiBhcnJheSxcclxuLy8gY29tcG9uZW50LCBvdGhlciBjb21wb25lbnQsIHNpZGUpXHJcbmV4cG9ydHMuX2Jvb3RzdHJhcFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHR5cGUsIHRyYW5zZm9ybUNvbXBvbmVudCwgY2hlY2tWYWxpZE9wLCBhcHBlbmQpIHtcclxuICB2YXIgdHJhbnNmb3JtQ29tcG9uZW50WCA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBkZXN0TGVmdCwgZGVzdFJpZ2h0KSB7XHJcbiAgICB0cmFuc2Zvcm1Db21wb25lbnQoZGVzdExlZnQsIGxlZnQsIHJpZ2h0LCAnbGVmdCcpO1xyXG4gICAgdHJhbnNmb3JtQ29tcG9uZW50KGRlc3RSaWdodCwgcmlnaHQsIGxlZnQsICdyaWdodCcpO1xyXG4gIH07XHJcblxyXG4gIHZhciB0cmFuc2Zvcm1YID0gdHlwZS50cmFuc2Zvcm1YID0gZnVuY3Rpb24obGVmdE9wLCByaWdodE9wKSB7XHJcbiAgICBjaGVja1ZhbGlkT3AobGVmdE9wKTtcclxuICAgIGNoZWNrVmFsaWRPcChyaWdodE9wKTtcclxuICAgIHZhciBuZXdSaWdodE9wID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaWdodE9wLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciByaWdodENvbXBvbmVudCA9IHJpZ2h0T3BbaV07XHJcblxyXG4gICAgICAvLyBHZW5lcmF0ZSBuZXdMZWZ0T3AgYnkgY29tcG9zaW5nIGxlZnRPcCBieSByaWdodENvbXBvbmVudFxyXG4gICAgICB2YXIgbmV3TGVmdE9wID0gW107XHJcbiAgICAgIHZhciBrID0gMDtcclxuICAgICAgd2hpbGUgKGsgPCBsZWZ0T3AubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIG5leHRDID0gW107XHJcbiAgICAgICAgdHJhbnNmb3JtQ29tcG9uZW50WChsZWZ0T3Bba10sIHJpZ2h0Q29tcG9uZW50LCBuZXdMZWZ0T3AsIG5leHRDKTtcclxuICAgICAgICBrKys7XHJcblxyXG4gICAgICAgIGlmIChuZXh0Qy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIHJpZ2h0Q29tcG9uZW50ID0gbmV4dENbMF07XHJcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0Qy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGZvciAodmFyIGogPSBrOyBqIDwgbGVmdE9wLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGFwcGVuZChuZXdMZWZ0T3AsIGxlZnRPcFtqXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByaWdodENvbXBvbmVudCA9IG51bGw7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gUmVjdXJzZS5cclxuICAgICAgICAgIHZhciBwYWlyID0gdHJhbnNmb3JtWChsZWZ0T3Auc2xpY2UoayksIG5leHRDKTtcclxuICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgcGFpclswXS5sZW5ndGg7IGwrKykge1xyXG4gICAgICAgICAgICBhcHBlbmQobmV3TGVmdE9wLCBwYWlyWzBdW2xdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcGFpclsxXS5sZW5ndGg7IHIrKykge1xyXG4gICAgICAgICAgICBhcHBlbmQobmV3UmlnaHRPcCwgcGFpclsxXVtyXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByaWdodENvbXBvbmVudCA9IG51bGw7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyaWdodENvbXBvbmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgYXBwZW5kKG5ld1JpZ2h0T3AsIHJpZ2h0Q29tcG9uZW50KTtcclxuICAgICAgfVxyXG4gICAgICBsZWZ0T3AgPSBuZXdMZWZ0T3A7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2xlZnRPcCwgbmV3UmlnaHRPcF07XHJcbiAgfTtcclxuXHJcbiAgLy8gVHJhbnNmb3JtcyBvcCB3aXRoIHNwZWNpZmllZCB0eXBlICgnbGVmdCcgb3IgJ3JpZ2h0JykgYnkgb3RoZXJPcC5cclxuICB0eXBlLnRyYW5zZm9ybSA9IHR5cGVbJ3RyYW5zZm9ybSddID0gZnVuY3Rpb24ob3AsIG90aGVyT3AsIHR5cGUpIHtcclxuICAgIGlmICghKHR5cGUgPT09ICdsZWZ0JyB8fCB0eXBlID09PSAncmlnaHQnKSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlICdsZWZ0JyBvciAncmlnaHQnXCIpO1xyXG5cclxuICAgIGlmIChvdGhlck9wLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG9wO1xyXG5cclxuICAgIGlmIChvcC5sZW5ndGggPT09IDEgJiYgb3RoZXJPcC5sZW5ndGggPT09IDEpXHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Db21wb25lbnQoW10sIG9wWzBdLCBvdGhlck9wWzBdLCB0eXBlKTtcclxuXHJcbiAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKVxyXG4gICAgICByZXR1cm4gdHJhbnNmb3JtWChvcCwgb3RoZXJPcClbMF07XHJcbiAgICBlbHNlXHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1YKG90aGVyT3AsIG9wKVsxXTtcclxuICB9O1xyXG59O1xyXG4vLyBERVBSRUNBVEVEIVxyXG4vL1xyXG4vLyBUaGlzIHR5cGUgd29ya3MsIGJ1dCBpcyBub3QgZXhwb3J0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiB0aGlzIGxpYnJhcnkuXHJcblxyXG5cclxuLy8gQSBzaW1wbGUgdGV4dCBpbXBsZW1lbnRhdGlvblxyXG4vL1xyXG4vLyBPcGVyYXRpb25zIGFyZSBsaXN0cyBvZiBjb21wb25lbnRzLlxyXG4vLyBFYWNoIGNvbXBvbmVudCBlaXRoZXIgaW5zZXJ0cyBvciBkZWxldGVzIGF0IGEgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuLy9cclxuLy8gQ29tcG9uZW50cyBhcmUgZWl0aGVyOlxyXG4vLyAge2k6J3N0cicsIHA6MTAwfTogSW5zZXJ0ICdzdHInIGF0IHBvc2l0aW9uIDEwMCBpbiB0aGUgZG9jdW1lbnRcclxuLy8gIHtkOidzdHInLCBwOjEwMH06IERlbGV0ZSAnc3RyJyBhdCBwb3NpdGlvbiAxMDAgaW4gdGhlIGRvY3VtZW50XHJcbi8vXHJcbi8vIENvbXBvbmVudHMgaW4gYW4gb3BlcmF0aW9uIGFyZSBleGVjdXRlZCBzZXF1ZW50aWFsbHksIHNvIHRoZSBwb3NpdGlvbiBvZiBjb21wb25lbnRzXHJcbi8vIGFzc3VtZXMgcHJldmlvdXMgY29tcG9uZW50cyBoYXZlIGFscmVhZHkgZXhlY3V0ZWQuXHJcbi8vXHJcbi8vIEVnOiBUaGlzIG9wOlxyXG4vLyAgIFt7aTonYWJjJywgcDowfV1cclxuLy8gaXMgZXF1aXZhbGVudCB0byB0aGlzIG9wOlxyXG4vLyAgIFt7aTonYScsIHA6MH0sIHtpOidiJywgcDoxfSwge2k6J2MnLCBwOjJ9XVxyXG5cclxuLy8gTk9URTogVGhlIGdsb2JhbCBzY29wZSBoZXJlIGlzIHNoYXJlZCB3aXRoIG90aGVyIHNoYXJlanMgZmlsZXMgd2hlbiBidWlsdCB3aXRoIGNsb3N1cmUuXHJcbi8vIEJlIGNhcmVmdWwgd2hhdCBlbmRzIHVwIGluIHlvdXIgbmFtZXNwYWNlLlxyXG5cclxudmFyIHRleHQgPSBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICBuYW1lOiAndGV4dDAnLFxyXG4gIHVyaTogJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy90ZXh0djAnLFxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oaW5pdGlhbCkge1xyXG4gICAgaWYgKChpbml0aWFsICE9IG51bGwpICYmIHR5cGVvZiBpbml0aWFsICE9PSAnc3RyaW5nJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaXRpYWwgZGF0YSBtdXN0IGJlIGEgc3RyaW5nJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5pdGlhbCB8fCAnJztcclxuICB9XHJcbn07XHJcblxyXG4vKiogSW5zZXJ0IHMyIGludG8gczEgYXQgcG9zLiAqL1xyXG52YXIgc3RySW5qZWN0ID0gZnVuY3Rpb24oczEsIHBvcywgczIpIHtcclxuICByZXR1cm4gczEuc2xpY2UoMCwgcG9zKSArIHMyICsgczEuc2xpY2UocG9zKTtcclxufTtcclxuXHJcbi8qKiBDaGVjayB0aGF0IGFuIG9wZXJhdGlvbiBjb21wb25lbnQgaXMgdmFsaWQuIFRocm93cyBpZiBpdHMgaW52YWxpZC4gKi9cclxudmFyIGNoZWNrVmFsaWRDb21wb25lbnQgPSBmdW5jdGlvbihjKSB7XHJcbiAgaWYgKHR5cGVvZiBjLnAgIT09ICdudW1iZXInKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb25lbnQgbWlzc2luZyBwb3NpdGlvbiBmaWVsZCcpO1xyXG5cclxuICBpZiAoKHR5cGVvZiBjLmkgPT09ICdzdHJpbmcnKSA9PT0gKHR5cGVvZiBjLmQgPT09ICdzdHJpbmcnKSlcclxuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9uZW50IG5lZWRzIGFuIGkgb3IgZCBmaWVsZCcpO1xyXG5cclxuICBpZiAoYy5wIDwgMClcclxuICAgIHRocm93IG5ldyBFcnJvcigncG9zaXRpb24gY2Fubm90IGJlIG5lZ2F0aXZlJyk7XHJcbn07XHJcblxyXG4vKiogQ2hlY2sgdGhhdCBhbiBvcGVyYXRpb24gaXMgdmFsaWQgKi9cclxudmFyIGNoZWNrVmFsaWRPcCA9IGZ1bmN0aW9uKG9wKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xyXG4gICAgY2hlY2tWYWxpZENvbXBvbmVudChvcFtpXSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqIEFwcGx5IG9wIHRvIHNuYXBzaG90ICovXHJcbnRleHQuYXBwbHkgPSBmdW5jdGlvbihzbmFwc2hvdCwgb3ApIHtcclxuICB2YXIgZGVsZXRlZDtcclxuXHJcbiAgY2hlY2tWYWxpZE9wKG9wKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgY29tcG9uZW50ID0gb3BbaV07XHJcbiAgICBpZiAoY29tcG9uZW50LmkgIT0gbnVsbCkge1xyXG4gICAgICBzbmFwc2hvdCA9IHN0ckluamVjdChzbmFwc2hvdCwgY29tcG9uZW50LnAsIGNvbXBvbmVudC5pKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRlbGV0ZWQgPSBzbmFwc2hvdC5zbGljZShjb21wb25lbnQucCwgY29tcG9uZW50LnAgKyBjb21wb25lbnQuZC5sZW5ndGgpO1xyXG4gICAgICBpZiAoY29tcG9uZW50LmQgIT09IGRlbGV0ZWQpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVsZXRlIGNvbXBvbmVudCAnXCIgKyBjb21wb25lbnQuZCArIFwiJyBkb2VzIG5vdCBtYXRjaCBkZWxldGVkIHRleHQgJ1wiICsgZGVsZXRlZCArIFwiJ1wiKTtcclxuXHJcbiAgICAgIHNuYXBzaG90ID0gc25hcHNob3Quc2xpY2UoMCwgY29tcG9uZW50LnApICsgc25hcHNob3Quc2xpY2UoY29tcG9uZW50LnAgKyBjb21wb25lbnQuZC5sZW5ndGgpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc25hcHNob3Q7XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwZW5kIGEgY29tcG9uZW50IHRvIHRoZSBlbmQgb2YgbmV3T3AuIEV4cG9ydGVkIGZvciB1c2UgYnkgdGhlIHJhbmRvbSBvcFxyXG4gKiBnZW5lcmF0b3IgYW5kIHRoZSBKU09OMCB0eXBlLlxyXG4gKi9cclxudmFyIGFwcGVuZCA9IHRleHQuX2FwcGVuZCA9IGZ1bmN0aW9uKG5ld09wLCBjKSB7XHJcbiAgaWYgKGMuaSA9PT0gJycgfHwgYy5kID09PSAnJykgcmV0dXJuO1xyXG5cclxuICBpZiAobmV3T3AubGVuZ3RoID09PSAwKSB7XHJcbiAgICBuZXdPcC5wdXNoKGMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXIgbGFzdCA9IG5ld09wW25ld09wLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgIGlmIChsYXN0LmkgIT0gbnVsbCAmJiBjLmkgIT0gbnVsbCAmJiBsYXN0LnAgPD0gYy5wICYmIGMucCA8PSBsYXN0LnAgKyBsYXN0LmkubGVuZ3RoKSB7XHJcbiAgICAgIC8vIENvbXBvc2UgdGhlIGluc2VydCBpbnRvIHRoZSBwcmV2aW91cyBpbnNlcnRcclxuICAgICAgbmV3T3BbbmV3T3AubGVuZ3RoIC0gMV0gPSB7aTpzdHJJbmplY3QobGFzdC5pLCBjLnAgLSBsYXN0LnAsIGMuaSksIHA6bGFzdC5wfTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKGxhc3QuZCAhPSBudWxsICYmIGMuZCAhPSBudWxsICYmIGMucCA8PSBsYXN0LnAgJiYgbGFzdC5wIDw9IGMucCArIGMuZC5sZW5ndGgpIHtcclxuICAgICAgLy8gQ29tcG9zZSB0aGUgZGVsZXRlcyB0b2dldGhlclxyXG4gICAgICBuZXdPcFtuZXdPcC5sZW5ndGggLSAxXSA9IHtkOnN0ckluamVjdChjLmQsIGxhc3QucCAtIGMucCwgbGFzdC5kKSwgcDpjLnB9O1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5ld09wLnB1c2goYyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqIENvbXBvc2Ugb3AxIGFuZCBvcDIgdG9nZXRoZXIgKi9cclxudGV4dC5jb21wb3NlID0gZnVuY3Rpb24ob3AxLCBvcDIpIHtcclxuICBjaGVja1ZhbGlkT3Aob3AxKTtcclxuICBjaGVja1ZhbGlkT3Aob3AyKTtcclxuICB2YXIgbmV3T3AgPSBvcDEuc2xpY2UoKTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wMi5sZW5ndGg7IGkrKykge1xyXG4gICAgYXBwZW5kKG5ld09wLCBvcDJbaV0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3T3A7XHJcbn07XHJcblxyXG4vKiogQ2xlYW4gdXAgYW4gb3AgKi9cclxudGV4dC5ub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xyXG4gIHZhciBuZXdPcCA9IFtdO1xyXG5cclxuICAvLyBOb3JtYWxpemUgc2hvdWxkIGFsbG93IG9wcyB3aGljaCBhcmUgYSBzaW5nbGUgKHVud3JhcHBlZCkgY29tcG9uZW50OlxyXG4gIC8vIHtpOidhc2RmJywgcDoyM30uXHJcbiAgLy8gVGhlcmUncyBubyBnb29kIHdheSB0byB0ZXN0IGlmIHNvbWV0aGluZyBpcyBhbiBhcnJheTpcclxuICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9pbnN0YW5jZW9mLWNvbnNpZGVyZWQtaGFybWZ1bC1vci1ob3ctdG8td3JpdGUtYS1yb2J1c3QtaXNhcnJheS9cclxuICAvLyBzbyB0aGlzIGlzIHByb2JhYmx5IHRoZSBsZWFzdCBiYWQgc29sdXRpb24uXHJcbiAgaWYgKG9wLmkgIT0gbnVsbCB8fCBvcC5wICE9IG51bGwpIG9wID0gW29wXTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGMgPSBvcFtpXTtcclxuICAgIGlmIChjLnAgPT0gbnVsbCkgYy5wID0gMDtcclxuXHJcbiAgICBhcHBlbmQobmV3T3AsIGMpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ld09wO1xyXG59O1xyXG5cclxuLy8gVGhpcyBoZWxwZXIgbWV0aG9kIHRyYW5zZm9ybXMgYSBwb3NpdGlvbiBieSBhbiBvcCBjb21wb25lbnQuXHJcbi8vXHJcbi8vIElmIGMgaXMgYW4gaW5zZXJ0LCBpbnNlcnRBZnRlciBzcGVjaWZpZXMgd2hldGhlciB0aGUgdHJhbnNmb3JtXHJcbi8vIGlzIHB1c2hlZCBhZnRlciB0aGUgaW5zZXJ0ICh0cnVlKSBvciBiZWZvcmUgaXQgKGZhbHNlKS5cclxuLy9cclxuLy8gaW5zZXJ0QWZ0ZXIgaXMgb3B0aW9uYWwgZm9yIGRlbGV0ZXMuXHJcbnZhciB0cmFuc2Zvcm1Qb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcywgYywgaW5zZXJ0QWZ0ZXIpIHtcclxuICAvLyBUaGlzIHdpbGwgZ2V0IGNvbGxhcHNlZCBpbnRvIGEgZ2lhbnQgdGVybmFyeSBieSB1Z2xpZnkuXHJcbiAgaWYgKGMuaSAhPSBudWxsKSB7XHJcbiAgICBpZiAoYy5wIDwgcG9zIHx8IChjLnAgPT09IHBvcyAmJiBpbnNlcnRBZnRlcikpIHtcclxuICAgICAgcmV0dXJuIHBvcyArIGMuaS5sZW5ndGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gcG9zO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBJIHRoaW5rIHRoaXMgY291bGQgYWxzbyBiZSB3cml0dGVuIGFzOiBNYXRoLm1pbihjLnAsIE1hdGgubWluKGMucCAtXHJcbiAgICAvLyBvdGhlckMucCwgb3RoZXJDLmQubGVuZ3RoKSkgYnV0IEkgdGhpbmsgaXRzIGhhcmRlciB0byByZWFkIHRoYXQgd2F5LCBhbmRcclxuICAgIC8vIGl0IGNvbXBpbGVzIHVzaW5nIHRlcm5hcnkgb3BlcmF0b3JzIGFueXdheSBzbyBpdHMgbm8gc2xvd2VyIHdyaXR0ZW4gbGlrZVxyXG4gICAgLy8gdGhpcy5cclxuICAgIGlmIChwb3MgPD0gYy5wKSB7XHJcbiAgICAgIHJldHVybiBwb3M7XHJcbiAgICB9IGVsc2UgaWYgKHBvcyA8PSBjLnAgKyBjLmQubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBjLnA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gcG9zIC0gYy5kLmxlbmd0aDtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgbWV0aG9kIHRvIHRyYW5zZm9ybSBhIGN1cnNvciBwb3NpdGlvbiBhcyBhIHJlc3VsdCBvZiBhbiBvcC5cclxuLy9cclxuLy8gTGlrZSB0cmFuc2Zvcm1Qb3NpdGlvbiBhYm92ZSwgaWYgYyBpcyBhbiBpbnNlcnQsIGluc2VydEFmdGVyIHNwZWNpZmllc1xyXG4vLyB3aGV0aGVyIHRoZSBjdXJzb3IgcG9zaXRpb24gaXMgcHVzaGVkIGFmdGVyIGFuIGluc2VydCAodHJ1ZSkgb3IgYmVmb3JlIGl0XHJcbi8vIChmYWxzZSkuXHJcbnRleHQudHJhbnNmb3JtQ3Vyc29yID0gZnVuY3Rpb24ocG9zaXRpb24sIG9wLCBzaWRlKSB7XHJcbiAgdmFyIGluc2VydEFmdGVyID0gc2lkZSA9PT0gJ3JpZ2h0JztcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBwb3NpdGlvbiA9IHRyYW5zZm9ybVBvc2l0aW9uKHBvc2l0aW9uLCBvcFtpXSwgaW5zZXJ0QWZ0ZXIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBvc2l0aW9uO1xyXG59O1xyXG5cclxuLy8gVHJhbnNmb3JtIGFuIG9wIGNvbXBvbmVudCBieSBhbm90aGVyIG9wIGNvbXBvbmVudC4gQXN5bW1ldHJpYy5cclxuLy8gVGhlIHJlc3VsdCB3aWxsIGJlIGFwcGVuZGVkIHRvIGRlc3RpbmF0aW9uLlxyXG4vL1xyXG4vLyBleHBvcnRlZCBmb3IgdXNlIGluIEpTT04gdHlwZVxyXG52YXIgdHJhbnNmb3JtQ29tcG9uZW50ID0gdGV4dC5fdGMgPSBmdW5jdGlvbihkZXN0LCBjLCBvdGhlckMsIHNpZGUpIHtcclxuICAvL3ZhciBjSW50ZXJzZWN0LCBpbnRlcnNlY3RFbmQsIGludGVyc2VjdFN0YXJ0LCBuZXdDLCBvdGhlckludGVyc2VjdCwgcztcclxuXHJcbiAgY2hlY2tWYWxpZENvbXBvbmVudChjKTtcclxuICBjaGVja1ZhbGlkQ29tcG9uZW50KG90aGVyQyk7XHJcblxyXG4gIGlmIChjLmkgIT0gbnVsbCkge1xyXG4gICAgLy8gSW5zZXJ0LlxyXG4gICAgYXBwZW5kKGRlc3QsIHtpOmMuaSwgcDp0cmFuc2Zvcm1Qb3NpdGlvbihjLnAsIG90aGVyQywgc2lkZSA9PT0gJ3JpZ2h0Jyl9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gRGVsZXRlXHJcbiAgICBpZiAob3RoZXJDLmkgIT0gbnVsbCkge1xyXG4gICAgICAvLyBEZWxldGUgdnMgaW5zZXJ0XHJcbiAgICAgIHZhciBzID0gYy5kO1xyXG4gICAgICBpZiAoYy5wIDwgb3RoZXJDLnApIHtcclxuICAgICAgICBhcHBlbmQoZGVzdCwge2Q6cy5zbGljZSgwLCBvdGhlckMucCAtIGMucCksIHA6Yy5wfSk7XHJcbiAgICAgICAgcyA9IHMuc2xpY2Uob3RoZXJDLnAgLSBjLnApO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzICE9PSAnJylcclxuICAgICAgICBhcHBlbmQoZGVzdCwge2Q6IHMsIHA6IGMucCArIG90aGVyQy5pLmxlbmd0aH0pO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIERlbGV0ZSB2cyBkZWxldGVcclxuICAgICAgaWYgKGMucCA+PSBvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aClcclxuICAgICAgICBhcHBlbmQoZGVzdCwge2Q6IGMuZCwgcDogYy5wIC0gb3RoZXJDLmQubGVuZ3RofSk7XHJcbiAgICAgIGVsc2UgaWYgKGMucCArIGMuZC5sZW5ndGggPD0gb3RoZXJDLnApXHJcbiAgICAgICAgYXBwZW5kKGRlc3QsIGMpO1xyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyBUaGV5IG92ZXJsYXAgc29tZXdoZXJlLlxyXG4gICAgICAgIHZhciBuZXdDID0ge2Q6ICcnLCBwOiBjLnB9O1xyXG5cclxuICAgICAgICBpZiAoYy5wIDwgb3RoZXJDLnApXHJcbiAgICAgICAgICBuZXdDLmQgPSBjLmQuc2xpY2UoMCwgb3RoZXJDLnAgLSBjLnApO1xyXG5cclxuICAgICAgICBpZiAoYy5wICsgYy5kLmxlbmd0aCA+IG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoKVxyXG4gICAgICAgICAgbmV3Qy5kICs9IGMuZC5zbGljZShvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aCAtIGMucCk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgaXMgZW50aXJlbHkgb3B0aW9uYWwgLSBJJ20ganVzdCBjaGVja2luZyB0aGUgZGVsZXRlZCB0ZXh0IGluXHJcbiAgICAgICAgLy8gdGhlIHR3byBvcHMgbWF0Y2hlc1xyXG4gICAgICAgIHZhciBpbnRlcnNlY3RTdGFydCA9IE1hdGgubWF4KGMucCwgb3RoZXJDLnApO1xyXG4gICAgICAgIHZhciBpbnRlcnNlY3RFbmQgPSBNYXRoLm1pbihjLnAgKyBjLmQubGVuZ3RoLCBvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aCk7XHJcbiAgICAgICAgdmFyIGNJbnRlcnNlY3QgPSBjLmQuc2xpY2UoaW50ZXJzZWN0U3RhcnQgLSBjLnAsIGludGVyc2VjdEVuZCAtIGMucCk7XHJcbiAgICAgICAgdmFyIG90aGVySW50ZXJzZWN0ID0gb3RoZXJDLmQuc2xpY2UoaW50ZXJzZWN0U3RhcnQgLSBvdGhlckMucCwgaW50ZXJzZWN0RW5kIC0gb3RoZXJDLnApO1xyXG4gICAgICAgIGlmIChjSW50ZXJzZWN0ICE9PSBvdGhlckludGVyc2VjdClcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVsZXRlIG9wcyBkZWxldGUgZGlmZmVyZW50IHRleHQgaW4gdGhlIHNhbWUgcmVnaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xyXG5cclxuICAgICAgICBpZiAobmV3Qy5kICE9PSAnJykge1xyXG4gICAgICAgICAgbmV3Qy5wID0gdHJhbnNmb3JtUG9zaXRpb24obmV3Qy5wLCBvdGhlckMpO1xyXG4gICAgICAgICAgYXBwZW5kKGRlc3QsIG5ld0MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRlc3Q7XHJcbn07XHJcblxyXG52YXIgaW52ZXJ0Q29tcG9uZW50ID0gZnVuY3Rpb24oYykge1xyXG4gIHJldHVybiAoYy5pICE9IG51bGwpID8ge2Q6Yy5pLCBwOmMucH0gOiB7aTpjLmQsIHA6Yy5wfTtcclxufTtcclxuXHJcbi8vIE5vIG5lZWQgdG8gdXNlIGFwcGVuZCBmb3IgaW52ZXJ0LCBiZWNhdXNlIHRoZSBjb21wb25lbnRzIHdvbid0IGJlIGFibGUgdG9cclxuLy8gY2FuY2VsIG9uZSBhbm90aGVyLlxyXG50ZXh0LmludmVydCA9IGZ1bmN0aW9uKG9wKSB7XHJcbiAgLy8gU2hhbGxvdyBjb3B5ICYgcmV2ZXJzZSB0aGF0IHN1Y2thLlxyXG4gIG9wID0gb3Auc2xpY2UoKS5yZXZlcnNlKCk7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xyXG4gICAgb3BbaV0gPSBpbnZlcnRDb21wb25lbnQob3BbaV0pO1xyXG4gIH1cclxuICByZXR1cm4gb3A7XHJcbn07XHJcblxyXG5leHBvcnRzLl9ib290c3RyYXBUcmFuc2Zvcm0odGV4dCwgdHJhbnNmb3JtQ29tcG9uZW50LCBjaGVja1ZhbGlkT3AsIGFwcGVuZCk7XHJcblxyXG4vKlxyXG4gVGhpcyBpcyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEpTT04gT1QgdHlwZS5cclxuXHJcbiBTcGVjIGlzIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NlcGhnL1NoYXJlSlMvd2lraS9KU09OLU9wZXJhdGlvbnNcclxuXHJcbiBOb3RlOiBUaGlzIGlzIGJlaW5nIG1hZGUgb2Jzb2xldGUuIEl0IHdpbGwgc29vbiBiZSByZXBsYWNlZCBieSB0aGUgSlNPTjIgdHlwZS5cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBVVElMSVRZIEZVTkNUSU9OU1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIHBhc3NlZCBvYmplY3QgaXMgYW4gQXJyYXkgaW5zdGFuY2UuIENhbid0IHVzZSBBcnJheS5pc0FycmF5XHJcbiAqIHlldCBiZWNhdXNlIGl0cyBub3Qgc3VwcG9ydGVkIG9uIElFOC5cclxuICpcclxuICogQHBhcmFtIG9ialxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2xvbmVzIHRoZSBwYXNzZWQgb2JqZWN0IHVzaW5nIEpTT04gc2VyaWFsaXphdGlvbiAod2hpY2ggaXMgc2xvdykuXHJcbiAqXHJcbiAqIGhheCwgY29waWVkIGZyb20gdGVzdC90eXBlcy9qc29uLiBBcHBhcmVudGx5IHRoaXMgaXMgc3RpbGwgdGhlIGZhc3Rlc3Qgd2F5XHJcbiAqIHRvIGRlZXAgY2xvbmUgYW4gb2JqZWN0LCBhc3N1bWluZyB3ZSBoYXZlIGJyb3dzZXIgc3VwcG9ydCBmb3IgSlNPTi4gIEBzZWVcclxuICogaHR0cDovL2pzcGVyZi5jb20vY2xvbmluZy1hbi1vYmplY3QvMTJcclxuICovXHJcbnZhciBjbG9uZSA9IGZ1bmN0aW9uKG8pIHtcclxuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVmZXJlbmNlIHRvIHRoZSBUZXh0IE9UIHR5cGUuIFRoaXMgaXMgdXNlZCBmb3IgdGhlIEpTT04gU3RyaW5nIG9wZXJhdGlvbnMuXHJcbiAqIEB0eXBlIHsqfVxyXG4gKi9cclxuaWYgKHR5cGVvZiB0ZXh0ID09PSAndW5kZWZpbmVkJylcclxuICB2YXIgdGV4dCA9IHdpbmRvdy5vdHR5cGVzLnRleHQ7XHJcblxyXG4vKipcclxuICogSlNPTiBPVCBUeXBlXHJcbiAqIEB0eXBlIHsqfVxyXG4gKi9cclxudmFyIGpzb24gPSB7IFxyXG4gIG5hbWU6ICdqc29uMCcsXHJcbiAgdXJpOiAnaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL0pTT052MCdcclxufTtcclxuXHJcbmpzb24uY3JlYXRlID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gIC8vIE51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQgaWYgeW91IGRvbid0IHBhc3MgYW4gYXJndW1lbnQuXHJcbiAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkYXRhO1xyXG59O1xyXG5cclxuanNvbi5pbnZlcnRDb21wb25lbnQgPSBmdW5jdGlvbihjKSB7XHJcbiAgdmFyIGNfID0ge3A6IGMucH07XHJcblxyXG4gIGlmIChjLnNpICE9PSB2b2lkIDApIGNfLnNkID0gYy5zaTtcclxuICBpZiAoYy5zZCAhPT0gdm9pZCAwKSBjXy5zaSA9IGMuc2Q7XHJcbiAgaWYgKGMub2kgIT09IHZvaWQgMCkgY18ub2QgPSBjLm9pO1xyXG4gIGlmIChjLm9kICE9PSB2b2lkIDApIGNfLm9pID0gYy5vZDtcclxuICBpZiAoYy5saSAhPT0gdm9pZCAwKSBjXy5sZCA9IGMubGk7XHJcbiAgaWYgKGMubGQgIT09IHZvaWQgMCkgY18ubGkgPSBjLmxkO1xyXG4gIGlmIChjLm5hICE9PSB2b2lkIDApIGNfLm5hID0gLWMubmE7XHJcblxyXG4gIGlmIChjLmxtICE9PSB2b2lkIDApIHtcclxuICAgIGNfLmxtID0gYy5wW2MucC5sZW5ndGgtMV07XHJcbiAgICBjXy5wID0gYy5wLnNsaWNlKDAsYy5wLmxlbmd0aC0xKS5jb25jYXQoW2MubG1dKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBjXztcclxufTtcclxuXHJcbmpzb24uaW52ZXJ0ID0gZnVuY3Rpb24ob3ApIHtcclxuICB2YXIgb3BfID0gb3Auc2xpY2UoKS5yZXZlcnNlKCk7XHJcbiAgdmFyIGlvcCA9IFtdO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3BfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpb3AucHVzaChqc29uLmludmVydENvbXBvbmVudChvcF9baV0pKTtcclxuICB9XHJcbiAgcmV0dXJuIGlvcDtcclxufTtcclxuXHJcbmpzb24uY2hlY2tWYWxpZE9wID0gZnVuY3Rpb24ob3ApIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XHJcbiAgaWYgKCFpc0FycmF5KG9wW2ldLnApKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBhdGgnKTtcclxuICB9XHJcbn07XHJcblxyXG5qc29uLmNoZWNrTGlzdCA9IGZ1bmN0aW9uKGVsZW0pIHtcclxuICBpZiAoIWlzQXJyYXkoZWxlbSkpXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBsaXN0Jyk7XHJcbn07XHJcblxyXG5qc29uLmNoZWNrT2JqID0gZnVuY3Rpb24oZWxlbSkge1xyXG4gIGlmIChlbGVtLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlJlZmVyZW5jZWQgZWxlbWVudCBub3QgYW4gb2JqZWN0IChpdCB3YXMgXCIgKyBKU09OLnN0cmluZ2lmeShlbGVtKSArIFwiKVwiKTtcclxuICB9XHJcbn07XHJcblxyXG5qc29uLmFwcGx5ID0gZnVuY3Rpb24oc25hcHNob3QsIG9wKSB7XHJcbiAganNvbi5jaGVja1ZhbGlkT3Aob3ApO1xyXG5cclxuICBvcCA9IGNsb25lKG9wKTtcclxuXHJcbiAgdmFyIGNvbnRhaW5lciA9IHtcclxuICAgIGRhdGE6IHNuYXBzaG90XHJcbiAgfTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIGMgPSBvcFtpXTtcclxuXHJcbiAgICB2YXIgcGFyZW50ID0gbnVsbDtcclxuICAgIHZhciBwYXJlbnRLZXkgPSBudWxsO1xyXG4gICAgdmFyIGVsZW0gPSBjb250YWluZXI7XHJcbiAgICB2YXIga2V5ID0gJ2RhdGEnO1xyXG5cclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5wLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIHZhciBwID0gYy5wW2pdO1xyXG5cclxuICAgICAgcGFyZW50ID0gZWxlbTtcclxuICAgICAgcGFyZW50S2V5ID0ga2V5O1xyXG4gICAgICBlbGVtID0gZWxlbVtrZXldO1xyXG4gICAgICBrZXkgPSBwO1xyXG5cclxuICAgICAgaWYgKHBhcmVudCA9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBpbnZhbGlkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTnVtYmVyIGFkZFxyXG4gICAgaWYgKGMubmEgIT09IHZvaWQgMCkge1xyXG4gICAgICBpZiAodHlwZW9mIGVsZW1ba2V5XSAhPSAnbnVtYmVyJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBudW1iZXInKTtcclxuXHJcbiAgICAgIGVsZW1ba2V5XSArPSBjLm5hO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0cmluZyBpbnNlcnRcclxuICAgIGVsc2UgaWYgKGMuc2kgIT09IHZvaWQgMCkge1xyXG4gICAgICBpZiAodHlwZW9mIGVsZW0gIT0gJ3N0cmluZycpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGEgc3RyaW5nIChpdCB3YXMgJytKU09OLnN0cmluZ2lmeShlbGVtKSsnKScpO1xyXG5cclxuICAgICAgcGFyZW50W3BhcmVudEtleV0gPSBlbGVtLnNsaWNlKDAsa2V5KSArIGMuc2kgKyBlbGVtLnNsaWNlKGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RyaW5nIGRlbGV0ZVxyXG4gICAgZWxzZSBpZiAoYy5zZCAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgZWxlbSAhPSAnc3RyaW5nJylcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBzdHJpbmcnKTtcclxuXHJcbiAgICAgIGlmIChlbGVtLnNsaWNlKGtleSxrZXkgKyBjLnNkLmxlbmd0aCkgIT09IGMuc2QpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxldGVkIHN0cmluZyBkb2VzIG5vdCBtYXRjaCcpO1xyXG5cclxuICAgICAgcGFyZW50W3BhcmVudEtleV0gPSBlbGVtLnNsaWNlKDAsa2V5KSArIGVsZW0uc2xpY2Uoa2V5ICsgYy5zZC5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExpc3QgcmVwbGFjZVxyXG4gICAgZWxzZSBpZiAoYy5saSAhPT0gdm9pZCAwICYmIGMubGQgIT09IHZvaWQgMCkge1xyXG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcclxuICAgICAgLy8gU2hvdWxkIGNoZWNrIHRoZSBsaXN0IGVsZW1lbnQgbWF0Y2hlcyBjLmxkXHJcbiAgICAgIGVsZW1ba2V5XSA9IGMubGk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGlzdCBpbnNlcnRcclxuICAgIGVsc2UgaWYgKGMubGkgIT09IHZvaWQgMCkge1xyXG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcclxuICAgICAgZWxlbS5zcGxpY2Uoa2V5LDAsIGMubGkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExpc3QgZGVsZXRlXHJcbiAgICBlbHNlIGlmIChjLmxkICE9PSB2b2lkIDApIHtcclxuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XHJcbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGUgbGlzdCBlbGVtZW50IG1hdGNoZXMgYy5sZCBoZXJlIHRvby5cclxuICAgICAgZWxlbS5zcGxpY2Uoa2V5LDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExpc3QgbW92ZVxyXG4gICAgZWxzZSBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIGpzb24uY2hlY2tMaXN0KGVsZW0pO1xyXG4gICAgICBpZiAoYy5sbSAhPSBrZXkpIHtcclxuICAgICAgICB2YXIgZSA9IGVsZW1ba2V5XTtcclxuICAgICAgICAvLyBSZW1vdmUgaXQuLi5cclxuICAgICAgICBlbGVtLnNwbGljZShrZXksMSk7XHJcbiAgICAgICAgLy8gQW5kIGluc2VydCBpdCBiYWNrLlxyXG4gICAgICAgIGVsZW0uc3BsaWNlKGMubG0sMCxlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE9iamVjdCBpbnNlcnQgLyByZXBsYWNlXHJcbiAgICBlbHNlIGlmIChjLm9pICE9PSB2b2lkIDApIHtcclxuICAgICAganNvbi5jaGVja09iaihlbGVtKTtcclxuXHJcbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGF0IGVsZW1ba2V5XSA9PSBjLm9kXHJcbiAgICAgIGVsZW1ba2V5XSA9IGMub2k7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT2JqZWN0IGRlbGV0ZVxyXG4gICAgZWxzZSBpZiAoYy5vZCAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIGpzb24uY2hlY2tPYmooZWxlbSk7XHJcblxyXG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhhdCBlbGVtW2tleV0gPT0gYy5vZFxyXG4gICAgICBkZWxldGUgZWxlbVtrZXldO1xyXG4gICAgfVxyXG5cclxuICAgIGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgLyBtaXNzaW5nIGluc3RydWN0aW9uIGluIG9wJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY29udGFpbmVyLmRhdGE7XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgZm9yIGluY3JlbWVudGFsbHkgYXBwbHlpbmcgYW4gb3BlcmF0aW9uIHRvIGEgc25hcHNob3QuIENhbGxzIHlpZWxkXHJcbi8vIGFmdGVyIGVhY2ggb3AgY29tcG9uZW50IGhhcyBiZWVuIGFwcGxpZWQuXHJcbmpzb24uaW5jcmVtZW50YWxBcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCwgX3lpZWxkKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHNtYWxsT3AgPSBbb3BbaV1dO1xyXG4gICAgc25hcHNob3QgPSBqc29uLmFwcGx5KHNuYXBzaG90LCBzbWFsbE9wKTtcclxuICAgIC8vIEknZCBqdXN0IGNhbGwgdGhpcyB5aWVsZCwgYnV0IHRoYXRzIGEgcmVzZXJ2ZWQga2V5d29yZC4gQmFoIVxyXG4gICAgX3lpZWxkKHNtYWxsT3AsIHNuYXBzaG90KTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHNuYXBzaG90O1xyXG59O1xyXG5cclxuLy8gQ2hlY2tzIGlmIHR3byBwYXRocywgcDEgYW5kIHAyIG1hdGNoLlxyXG52YXIgcGF0aE1hdGNoZXMgPSBqc29uLnBhdGhNYXRjaGVzID0gZnVuY3Rpb24ocDEsIHAyLCBpZ25vcmVMYXN0KSB7XHJcbiAgaWYgKHAxLmxlbmd0aCAhPSBwMi5sZW5ndGgpXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcDEubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChwMVtpXSAhPT0gcDJbaV0gJiYgKCFpZ25vcmVMYXN0IHx8IGkgIT09IHAxLmxlbmd0aCAtIDEpKVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbnZhciBfY29udmVydFRvVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gIHZhciBuZXdDID0ge3A6IGNvbXBvbmVudC5wW2NvbXBvbmVudC5wLmxlbmd0aCAtIDFdfTtcclxuICBpZiAoY29tcG9uZW50LnNpICE9IG51bGwpIHtcclxuICAgIG5ld0MuaSA9IGNvbXBvbmVudC5zaTtcclxuICB9IGVsc2Uge1xyXG4gICAgbmV3Qy5kID0gY29tcG9uZW50LnNkO1xyXG4gIH1cclxuICByZXR1cm4gbmV3QztcclxufTtcclxuXHJcbmpzb24uYXBwZW5kID0gZnVuY3Rpb24oZGVzdCxjKSB7XHJcbiAgYyA9IGNsb25lKGMpO1xyXG5cclxuICB2YXIgbGFzdDtcclxuXHJcbiAgaWYgKGRlc3QubGVuZ3RoICE9IDAgJiYgcGF0aE1hdGNoZXMoYy5wLCAobGFzdCA9IGRlc3RbZGVzdC5sZW5ndGggLSAxXSkucCkpIHtcclxuICAgIGlmIChsYXN0Lm5hICE9IG51bGwgJiYgYy5uYSAhPSBudWxsKSB7XHJcbiAgICAgIGRlc3RbZGVzdC5sZW5ndGggLSAxXSA9IHtwOiBsYXN0LnAsIG5hOiBsYXN0Lm5hICsgYy5uYX07XHJcbiAgICB9IGVsc2UgaWYgKGxhc3QubGkgIT09IHVuZGVmaW5lZCAmJiBjLmxpID09PSB1bmRlZmluZWQgJiYgYy5sZCA9PT0gbGFzdC5saSkge1xyXG4gICAgICAvLyBpbnNlcnQgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgZGVsZXRlIGJlY29tZXMgYSBub29wLlxyXG4gICAgICBpZiAobGFzdC5sZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gbGVhdmUgdGhlIGRlbGV0ZSBwYXJ0IG9mIHRoZSByZXBsYWNlXHJcbiAgICAgICAgZGVsZXRlIGxhc3QubGk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVzdC5wb3AoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChsYXN0Lm9kICE9PSB1bmRlZmluZWQgJiYgbGFzdC5vaSA9PT0gdW5kZWZpbmVkICYmIGMub2kgIT09IHVuZGVmaW5lZCAmJiBjLm9kID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgbGFzdC5vaSA9IGMub2k7XHJcbiAgICB9IGVsc2UgaWYgKGxhc3Qub2kgIT09IHVuZGVmaW5lZCAmJiBjLm9kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gVGhlIGxhc3QgcGF0aCBjb21wb25lbnQgaW5zZXJ0ZWQgc29tZXRoaW5nIHRoYXQgdGhlIG5ldyBjb21wb25lbnQgZGVsZXRlcyAob3IgcmVwbGFjZXMpLlxyXG4gICAgICAvLyBKdXN0IG1lcmdlIHRoZW0uXHJcbiAgICAgIGlmIChjLm9pICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBsYXN0Lm9pID0gYy5vaTtcclxuICAgICAgfSBlbHNlIGlmIChsYXN0Lm9kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBkZWxldGUgbGFzdC5vaTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBBbiBpbnNlcnQgZGlyZWN0bHkgZm9sbG93ZWQgYnkgYSBkZWxldGUgdHVybnMgaW50byBhIG5vLW9wIGFuZCBjYW4gYmUgcmVtb3ZlZC5cclxuICAgICAgICBkZXN0LnBvcCgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGMubG0gIT09IHVuZGVmaW5lZCAmJiBjLnBbYy5wLmxlbmd0aCAtIDFdID09PSBjLmxtKSB7XHJcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZXN0LnB1c2goYyk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChkZXN0Lmxlbmd0aCAhPSAwICYmIHBhdGhNYXRjaGVzKGMucCwgbGFzdC5wLCB0cnVlKSkge1xyXG4gICAgaWYgKChjLnNpICE9IG51bGwgfHwgYy5zZCAhPSBudWxsKSAmJiAobGFzdC5zaSAhPSBudWxsIHx8IGxhc3Quc2QgIT0gbnVsbCkpIHtcclxuICAgICAgLy8gVHJ5IHRvIGNvbXBvc2UgdGhlIHN0cmluZyBvcHMgdG9nZXRoZXIgdXNpbmcgdGV4dCdzIGVxdWl2YWxlbnQgbWV0aG9kc1xyXG4gICAgICB2YXIgdGV4dE9wID0gW19jb252ZXJ0VG9UZXh0Q29tcG9uZW50KGxhc3QpXTtcclxuICAgICAgdGV4dC5fYXBwZW5kKHRleHRPcCwgX2NvbnZlcnRUb1RleHRDb21wb25lbnQoYykpO1xyXG4gICAgICBcclxuICAgICAgLy8gVGhlbiBjb252ZXJ0IGJhY2suXHJcbiAgICAgIGlmICh0ZXh0T3AubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgZGVzdC5wdXNoKGMpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciB0ZXh0QyA9IHRleHRPcFswXTtcclxuICAgICAgICBsYXN0LnBbbGFzdC5wLmxlbmd0aCAtIDFdID0gdGV4dEMucDtcclxuICAgICAgICBpZiAodGV4dEMuaSAhPSBudWxsKVxyXG4gICAgICAgICAgbGFzdC5zaSA9IHRleHRDLmk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgbGFzdC5zZCA9IHRleHRDLmQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRlc3QucHVzaChjKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgZGVzdC5wdXNoKGMpO1xyXG4gIH1cclxufTtcclxuXHJcbmpzb24uY29tcG9zZSA9IGZ1bmN0aW9uKG9wMSxvcDIpIHtcclxuICBqc29uLmNoZWNrVmFsaWRPcChvcDEpO1xyXG4gIGpzb24uY2hlY2tWYWxpZE9wKG9wMik7XHJcblxyXG4gIHZhciBuZXdPcCA9IGNsb25lKG9wMSk7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBqc29uLmFwcGVuZChuZXdPcCxvcDJbaV0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ld09wO1xyXG59O1xyXG5cclxuanNvbi5ub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xyXG4gIHZhciBuZXdPcCA9IFtdO1xyXG5cclxuICBvcCA9IGlzQXJyYXkob3ApID8gb3AgOiBbb3BdO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgYyA9IG9wW2ldO1xyXG4gICAgaWYgKGMucCA9PSBudWxsKSBjLnAgPSBbXTtcclxuXHJcbiAgICBqc29uLmFwcGVuZChuZXdPcCxjKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXdPcDtcclxufTtcclxuXHJcbi8vIFJldHVybnMgdHJ1ZSBpZiBhbiBvcCBhdCBvdGhlclBhdGggbWF5IGFmZmVjdCBhbiBvcCBhdCBwYXRoXHJcbmpzb24uY2FuT3BBZmZlY3RPcCA9IGZ1bmN0aW9uKG90aGVyUGF0aCxwYXRoKSB7XHJcbiAgaWYgKG90aGVyUGF0aC5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xyXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICBwYXRoID0gcGF0aC5zbGljZSgwLHBhdGgubGVuZ3RoIC0gMSk7XHJcbiAgb3RoZXJQYXRoID0gb3RoZXJQYXRoLnNsaWNlKDAsb3RoZXJQYXRoLmxlbmd0aCAtIDEpO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyUGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgdmFyIHAgPSBvdGhlclBhdGhbaV07XHJcbiAgICBpZiAoaSA+PSBwYXRoLmxlbmd0aCB8fCBwICE9IHBhdGhbaV0pIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIFNhbWVcclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8vIHRyYW5zZm9ybSBjIHNvIGl0IGFwcGxpZXMgdG8gYSBkb2N1bWVudCB3aXRoIG90aGVyQyBhcHBsaWVkLlxyXG5qc29uLnRyYW5zZm9ybUNvbXBvbmVudCA9IGZ1bmN0aW9uKGRlc3QsIGMsIG90aGVyQywgdHlwZSkge1xyXG4gIGMgPSBjbG9uZShjKTtcclxuXHJcbiAgaWYgKGMubmEgIT09IHZvaWQgMClcclxuICAgIGMucC5wdXNoKDApO1xyXG5cclxuICBpZiAob3RoZXJDLm5hICE9PSB2b2lkIDApXHJcbiAgICBvdGhlckMucC5wdXNoKDApO1xyXG5cclxuICB2YXIgY29tbW9uO1xyXG4gIGlmIChqc29uLmNhbk9wQWZmZWN0T3Aob3RoZXJDLnAsIGMucCkpXHJcbiAgICBjb21tb24gPSBvdGhlckMucC5sZW5ndGggLSAxO1xyXG5cclxuICB2YXIgY29tbW9uMjtcclxuICBpZiAoanNvbi5jYW5PcEFmZmVjdE9wKGMucCxvdGhlckMucCkpXHJcbiAgICBjb21tb24yID0gYy5wLmxlbmd0aCAtIDE7XHJcblxyXG4gIHZhciBjcGxlbmd0aCA9IGMucC5sZW5ndGg7XHJcbiAgdmFyIG90aGVyQ3BsZW5ndGggPSBvdGhlckMucC5sZW5ndGg7XHJcblxyXG4gIGlmIChjLm5hICE9PSB2b2lkIDApIC8vIGhheFxyXG4gICAgYy5wLnBvcCgpO1xyXG5cclxuICBpZiAob3RoZXJDLm5hICE9PSB2b2lkIDApXHJcbiAgICBvdGhlckMucC5wb3AoKTtcclxuXHJcbiAgaWYgKG90aGVyQy5uYSkge1xyXG4gICAgaWYgKGNvbW1vbjIgIT0gbnVsbCAmJiBvdGhlckNwbGVuZ3RoID49IGNwbGVuZ3RoICYmIG90aGVyQy5wW2NvbW1vbjJdID09IGMucFtjb21tb24yXSkge1xyXG4gICAgICBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcclxuICAgICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XHJcbiAgICAgICAgYy5sZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5sZCksW29jXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYy5vZCAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcclxuICAgICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XHJcbiAgICAgICAgYy5vZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5vZCksW29jXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGpzb24uYXBwZW5kKGRlc3QsYyk7XHJcbiAgICByZXR1cm4gZGVzdDtcclxuICB9XHJcblxyXG4gIC8vIGlmIGMgaXMgZGVsZXRpbmcgc29tZXRoaW5nLCBhbmQgdGhhdCB0aGluZyBpcyBjaGFuZ2VkIGJ5IG90aGVyQywgd2UgbmVlZCB0b1xyXG4gIC8vIHVwZGF0ZSBjIHRvIHJlZmxlY3QgdGhhdCBjaGFuZ2UgZm9yIGludmVydGliaWxpdHkuXHJcbiAgLy8gVE9ETyB0aGlzIGlzIHByb2JhYmx5IG5vdCBuZWVkZWQgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBpbnZlcnRpYmlsaXR5XHJcbiAgaWYgKGNvbW1vbjIgIT0gbnVsbCAmJiBvdGhlckNwbGVuZ3RoID4gY3BsZW5ndGggJiYgYy5wW2NvbW1vbjJdID09IG90aGVyQy5wW2NvbW1vbjJdKSB7XHJcbiAgICBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIHZhciBvYyA9IGNsb25lKG90aGVyQyk7XHJcbiAgICAgIG9jLnAgPSBvYy5wLnNsaWNlKGNwbGVuZ3RoKTtcclxuICAgICAgYy5sZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5sZCksW29jXSk7XHJcbiAgICB9IGVsc2UgaWYgKGMub2QgIT09IHZvaWQgMCkge1xyXG4gICAgICB2YXIgb2MgPSBjbG9uZShvdGhlckMpO1xyXG4gICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XHJcbiAgICAgIGMub2QgPSBqc29uLmFwcGx5KGNsb25lKGMub2QpLFtvY10pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGNvbW1vbiAhPSBudWxsKSB7XHJcbiAgICB2YXIgY29tbW9uT3BlcmFuZCA9IGNwbGVuZ3RoID09IG90aGVyQ3BsZW5ndGg7XHJcblxyXG4gICAgLy8gdHJhbnNmb3JtIGJhc2VkIG9uIG90aGVyQ1xyXG4gICAgaWYgKG90aGVyQy5uYSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIC8vIHRoaXMgY2FzZSBpcyBoYW5kbGVkIGFib3ZlIGR1ZSB0byBpY2t5IHBhdGggaGF4XHJcbiAgICB9IGVsc2UgaWYgKG90aGVyQy5zaSAhPT0gdm9pZCAwIHx8IG90aGVyQy5zZCAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIC8vIFN0cmluZyBvcCB2cyBzdHJpbmcgb3AgLSBwYXNzIHRocm91Z2ggdG8gdGV4dCB0eXBlXHJcbiAgICAgIGlmIChjLnNpICE9PSB2b2lkIDAgfHwgYy5zZCAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgaWYgKCFjb21tb25PcGVyYW5kKSB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgYSBzdHJpbmc/Jyk7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgYW4gb3AgY29tcG9uZW50IHRvIGEgdGV4dCBvcCBjb21wb25lbnQgc28gd2UgY2FuIHVzZSB0aGVcclxuICAgICAgICAvLyB0ZXh0IHR5cGUncyB0cmFuc2Zvcm0gZnVuY3Rpb25cclxuICAgICAgICB2YXIgdGMxID0gX2NvbnZlcnRUb1RleHRDb21wb25lbnQoYyk7XHJcbiAgICAgICAgdmFyIHRjMiA9IF9jb252ZXJ0VG9UZXh0Q29tcG9uZW50KG90aGVyQyk7XHJcblxyXG4gICAgICAgIHZhciByZXMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gYWN0dWFsbHkgdHJhbnNmb3JtXHJcbiAgICAgICAgdGV4dC5fdGMocmVzLCB0YzEsIHRjMiwgdHlwZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gLi4uLiB0aGVuIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIGludG8gYSBKU09OIG9wIGFnYWluLlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAvLyBUZXh0IGNvbXBvbmVudFxyXG4gICAgICAgICAgdmFyIHRjID0gcmVzW2ldO1xyXG4gICAgICAgICAgLy8gSlNPTiBjb21wb25lbnRcclxuICAgICAgICAgIHZhciBqYyA9IHtwOiBjLnAuc2xpY2UoMCwgY29tbW9uKX07XHJcbiAgICAgICAgICBqYy5wLnB1c2godGMucCk7XHJcblxyXG4gICAgICAgICAgaWYgKHRjLmkgIT0gbnVsbCkgamMuc2kgPSB0Yy5pO1xyXG4gICAgICAgICAgaWYgKHRjLmQgIT0gbnVsbCkgamMuc2QgPSB0Yy5kO1xyXG4gICAgICAgICAganNvbi5hcHBlbmQoZGVzdCwgamMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvdGhlckMubGkgIT09IHZvaWQgMCAmJiBvdGhlckMubGQgIT09IHZvaWQgMCkge1xyXG4gICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA9PT0gYy5wW2NvbW1vbl0pIHtcclxuICAgICAgICAvLyBub29wXHJcblxyXG4gICAgICAgIGlmICghY29tbW9uT3BlcmFuZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjLmxkICE9PSB2b2lkIDApIHtcclxuICAgICAgICAgIC8vIHdlJ3JlIHRyeWluZyB0byBkZWxldGUgdGhlIHNhbWUgZWxlbWVudCwgLT4gbm9vcFxyXG4gICAgICAgICAgaWYgKGMubGkgIT09IHZvaWQgMCAmJiB0eXBlID09PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgYm90aCByZXBsYWNpbmcgb25lIGVsZW1lbnQgd2l0aCBhbm90aGVyLiBvbmx5IG9uZSBjYW4gc3Vydml2ZVxyXG4gICAgICAgICAgICBjLmxkID0gY2xvbmUob3RoZXJDLmxpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvdGhlckMubGkgIT09IHZvaWQgMCkge1xyXG4gICAgICBpZiAoYy5saSAhPT0gdm9pZCAwICYmIGMubGQgPT09IHVuZGVmaW5lZCAmJiBjb21tb25PcGVyYW5kICYmIGMucFtjb21tb25dID09PSBvdGhlckMucFtjb21tb25dKSB7XHJcbiAgICAgICAgLy8gaW4gbGkgdnMuIGxpLCBsZWZ0IHdpbnMuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyaWdodCcpXHJcbiAgICAgICAgICBjLnBbY29tbW9uXSsrO1xyXG4gICAgICB9IGVsc2UgaWYgKG90aGVyQy5wW2NvbW1vbl0gPD0gYy5wW2NvbW1vbl0pIHtcclxuICAgICAgICBjLnBbY29tbW9uXSsrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgaWYgKGNvbW1vbk9wZXJhbmQpIHtcclxuICAgICAgICAgIC8vIG90aGVyQyBlZGl0cyB0aGUgc2FtZSBsaXN0IHdlIGVkaXRcclxuICAgICAgICAgIGlmIChvdGhlckMucFtjb21tb25dIDw9IGMubG0pXHJcbiAgICAgICAgICAgIGMubG0rKztcclxuICAgICAgICAgIC8vIGNoYW5naW5nIGMuZnJvbSBpcyBoYW5kbGVkIGFib3ZlLlxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvdGhlckMubGQgIT09IHZvaWQgMCkge1xyXG4gICAgICBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgaWYgKGNvbW1vbk9wZXJhbmQpIHtcclxuICAgICAgICAgIGlmIChvdGhlckMucFtjb21tb25dID09PSBjLnBbY29tbW9uXSkge1xyXG4gICAgICAgICAgICAvLyB0aGV5IGRlbGV0ZWQgdGhlIHRoaW5nIHdlJ3JlIHRyeWluZyB0byBtb3ZlXHJcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gb3RoZXJDIGVkaXRzIHRoZSBzYW1lIGxpc3Qgd2UgZWRpdFxyXG4gICAgICAgICAgdmFyIHAgPSBvdGhlckMucFtjb21tb25dO1xyXG4gICAgICAgICAgdmFyIGZyb20gPSBjLnBbY29tbW9uXTtcclxuICAgICAgICAgIHZhciB0byA9IGMubG07XHJcbiAgICAgICAgICBpZiAocCA8IHRvIHx8IChwID09PSB0byAmJiBmcm9tIDwgdG8pKVxyXG4gICAgICAgICAgICBjLmxtLS07XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG90aGVyQy5wW2NvbW1vbl0gPCBjLnBbY29tbW9uXSkge1xyXG4gICAgICAgIGMucFtjb21tb25dLS07XHJcbiAgICAgIH0gZWxzZSBpZiAob3RoZXJDLnBbY29tbW9uXSA9PT0gYy5wW2NvbW1vbl0pIHtcclxuICAgICAgICBpZiAob3RoZXJDcGxlbmd0aCA8IGNwbGVuZ3RoKSB7XHJcbiAgICAgICAgICAvLyB3ZSdyZSBiZWxvdyB0aGUgZGVsZXRlZCBlbGVtZW50LCBzbyAtPiBub29wXHJcbiAgICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgICAgICB9IGVsc2UgaWYgKGMubGQgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgaWYgKGMubGkgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAvLyB3ZSdyZSByZXBsYWNpbmcsIHRoZXkncmUgZGVsZXRpbmcuIHdlIGJlY29tZSBhbiBpbnNlcnQuXHJcbiAgICAgICAgICAgIGRlbGV0ZSBjLmxkO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgdHJ5aW5nIHRvIGRlbGV0ZSB0aGUgc2FtZSBlbGVtZW50LCAtPiBub29wXHJcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSBpZiAob3RoZXJDLmxtICE9PSB2b2lkIDApIHtcclxuICAgICAgaWYgKGMubG0gIT09IHZvaWQgMCAmJiBjcGxlbmd0aCA9PT0gb3RoZXJDcGxlbmd0aCkge1xyXG4gICAgICAgIC8vIGxtIHZzIGxtLCBoZXJlIHdlIGdvIVxyXG4gICAgICAgIHZhciBmcm9tID0gYy5wW2NvbW1vbl07XHJcbiAgICAgICAgdmFyIHRvID0gYy5sbTtcclxuICAgICAgICB2YXIgb3RoZXJGcm9tID0gb3RoZXJDLnBbY29tbW9uXTtcclxuICAgICAgICB2YXIgb3RoZXJUbyA9IG90aGVyQy5sbTtcclxuICAgICAgICBpZiAob3RoZXJGcm9tICE9PSBvdGhlclRvKSB7XHJcbiAgICAgICAgICAvLyBpZiBvdGhlckZyb20gPT0gb3RoZXJUbywgd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2Ugb3VyIG9wLlxyXG5cclxuICAgICAgICAgIC8vIHdoZXJlIGRpZCBteSB0aGluZyBnbz9cclxuICAgICAgICAgIGlmIChmcm9tID09PSBvdGhlckZyb20pIHtcclxuICAgICAgICAgICAgLy8gdGhleSBtb3ZlZCBpdCEgdGllIGJyZWFrLlxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgYy5wW2NvbW1vbl0gPSBvdGhlclRvO1xyXG4gICAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykgLy8gdWdoXHJcbiAgICAgICAgICAgICAgICBjLmxtID0gb3RoZXJUbztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGhleSBtb3ZlZCBhcm91bmQgaXRcclxuICAgICAgICAgICAgaWYgKGZyb20gPiBvdGhlckZyb20pIGMucFtjb21tb25dLS07XHJcbiAgICAgICAgICAgIGlmIChmcm9tID4gb3RoZXJUbykgYy5wW2NvbW1vbl0rKztcclxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA9PT0gb3RoZXJUbykge1xyXG4gICAgICAgICAgICAgIGlmIChvdGhlckZyb20gPiBvdGhlclRvKSB7XHJcbiAgICAgICAgICAgICAgICBjLnBbY29tbW9uXSsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSAvLyB1Z2gsIGFnYWluXHJcbiAgICAgICAgICAgICAgICAgIGMubG0rKztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHN0ZXAgMjogd2hlcmUgYW0gaSBnb2luZyB0byBwdXQgaXQ/XHJcbiAgICAgICAgICAgIGlmICh0byA+IG90aGVyRnJvbSkge1xyXG4gICAgICAgICAgICAgIGMubG0tLTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0byA9PT0gb3RoZXJGcm9tKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHRvID4gZnJvbSlcclxuICAgICAgICAgICAgICAgIGMubG0tLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodG8gPiBvdGhlclRvKSB7XHJcbiAgICAgICAgICAgICAgYy5sbSsrO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvID09PSBvdGhlclRvKSB7XHJcbiAgICAgICAgICAgICAgLy8gaWYgd2UncmUgYm90aCBtb3ZpbmcgaW4gdGhlIHNhbWUgZGlyZWN0aW9uLCB0aWUgYnJlYWtcclxuICAgICAgICAgICAgICBpZiAoKG90aGVyVG8gPiBvdGhlckZyb20gJiYgdG8gPiBmcm9tKSB8fFxyXG4gICAgICAgICAgICAgICAgICAob3RoZXJUbyA8IG90aGVyRnJvbSAmJiB0byA8IGZyb20pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JpZ2h0JykgYy5sbSsrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG8gPiBmcm9tKSBjLmxtKys7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0byA9PT0gb3RoZXJGcm9tKSBjLmxtLS07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGMubGkgIT09IHZvaWQgMCAmJiBjLmxkID09PSB1bmRlZmluZWQgJiYgY29tbW9uT3BlcmFuZCkge1xyXG4gICAgICAgIC8vIGxpXHJcbiAgICAgICAgdmFyIGZyb20gPSBvdGhlckMucFtjb21tb25dO1xyXG4gICAgICAgIHZhciB0byA9IG90aGVyQy5sbTtcclxuICAgICAgICBwID0gYy5wW2NvbW1vbl07XHJcbiAgICAgICAgaWYgKHAgPiBmcm9tKSBjLnBbY29tbW9uXS0tO1xyXG4gICAgICAgIGlmIChwID4gdG8pIGMucFtjb21tb25dKys7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gbGQsIGxkK2xpLCBzaSwgc2QsIG5hLCBvaSwgb2QsIG9pK29kLCBhbnkgbGkgb24gYW4gZWxlbWVudCBiZW5lYXRoXHJcbiAgICAgICAgLy8gdGhlIGxtXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBpLmUuIHRoaW5ncyBjYXJlIGFib3V0IHdoZXJlIHRoZWlyIGl0ZW0gaXMgYWZ0ZXIgdGhlIG1vdmUuXHJcbiAgICAgICAgdmFyIGZyb20gPSBvdGhlckMucFtjb21tb25dO1xyXG4gICAgICAgIHZhciB0byA9IG90aGVyQy5sbTtcclxuICAgICAgICBwID0gYy5wW2NvbW1vbl07XHJcbiAgICAgICAgaWYgKHAgPT09IGZyb20pIHtcclxuICAgICAgICAgIGMucFtjb21tb25dID0gdG87XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChwID4gZnJvbSkgYy5wW2NvbW1vbl0tLTtcclxuICAgICAgICAgIGlmIChwID4gdG8pIGMucFtjb21tb25dKys7XHJcbiAgICAgICAgICBlbHNlIGlmIChwID09PSB0byAmJiBmcm9tID4gdG8pIGMucFtjb21tb25dKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvdGhlckMub2kgIT09IHZvaWQgMCAmJiBvdGhlckMub2QgIT09IHZvaWQgMCkge1xyXG4gICAgICBpZiAoYy5wW2NvbW1vbl0gPT09IG90aGVyQy5wW2NvbW1vbl0pIHtcclxuICAgICAgICBpZiAoYy5vaSAhPT0gdm9pZCAwICYmIGNvbW1vbk9wZXJhbmQpIHtcclxuICAgICAgICAgIC8vIHdlIGluc2VydGVkIHdoZXJlIHNvbWVvbmUgZWxzZSByZXBsYWNlZFxyXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgLy8gbGVmdCB3aW5zXHJcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gd2Ugd2luLCBtYWtlIG91ciBvcCByZXBsYWNlIHdoYXQgdGhleSBpbnNlcnRlZFxyXG4gICAgICAgICAgICBjLm9kID0gb3RoZXJDLm9pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyAtPiBub29wIGlmIHRoZSBvdGhlciBjb21wb25lbnQgaXMgZGVsZXRpbmcgdGhlIHNhbWUgb2JqZWN0IChvciBhbnkgcGFyZW50KVxyXG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG90aGVyQy5vaSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIGlmIChjLm9pICE9PSB2b2lkIDAgJiYgYy5wW2NvbW1vbl0gPT09IG90aGVyQy5wW2NvbW1vbl0pIHtcclxuICAgICAgICAvLyBsZWZ0IHdpbnMgaWYgd2UgdHJ5IHRvIGluc2VydCBhdCB0aGUgc2FtZSBwbGFjZVxyXG4gICAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcclxuICAgICAgICAgIGpzb24uYXBwZW5kKGRlc3Qse3A6IGMucCwgb2Q6b3RoZXJDLm9pfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvdGhlckMub2QgIT09IHZvaWQgMCkge1xyXG4gICAgICBpZiAoYy5wW2NvbW1vbl0gPT0gb3RoZXJDLnBbY29tbW9uXSkge1xyXG4gICAgICAgIGlmICghY29tbW9uT3BlcmFuZClcclxuICAgICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgICAgIGlmIChjLm9pICE9PSB2b2lkIDApIHtcclxuICAgICAgICAgIGRlbGV0ZSBjLm9kO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGpzb24uYXBwZW5kKGRlc3QsYyk7XHJcbiAgcmV0dXJuIGRlc3Q7XHJcbn07XHJcblxyXG5leHBvcnRzLl9ib290c3RyYXBUcmFuc2Zvcm0oanNvbiwganNvbi50cmFuc2Zvcm1Db21wb25lbnQsIGpzb24uY2hlY2tWYWxpZE9wLCBqc29uLmFwcGVuZCk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqc29uO1xyXG4vLyBUaGlzIGlzIGluY2x1ZGVkIGFmdGVyIHRoZSBKUyBmb3IgZWFjaCB0eXBlIHdoZW4gd2UgYnVpbGQgZm9yIHRoZSB3ZWIuXHJcblxyXG4gIHZhciBfdHlwZXMgPSB3aW5kb3cub3R0eXBlcyA9IHdpbmRvdy5vdHR5cGVzIHx8IHt9O1xyXG4gIHZhciBfdCA9IG1vZHVsZS5leHBvcnRzO1xyXG4gIF90eXBlc1tfdC5uYW1lXSA9IF90O1xyXG5cclxuICBpZiAoX3QudXJpKSBfdHlwZXNbX3QudXJpXSA9IF90O1xyXG59KSgpO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmlkKGxlbiwgcHJlZml4LCBrZXlzcGFjZSkge1xyXG4gIGlmIChsZW4gPT0gbnVsbCkge1xyXG4gICAgbGVuID0gMzI7XHJcbiAgfVxyXG4gIGlmIChwcmVmaXggPT0gbnVsbCkge1xyXG4gICAgcHJlZml4ID0gXCJcIjtcclxuICB9XHJcbiAgaWYgKGtleXNwYWNlID09IG51bGwpIHtcclxuICAgIGtleXNwYWNlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OVwiO1xyXG4gIH1cclxuICB3aGlsZSAobGVuLS0gPiAwKSB7XHJcbiAgICBwcmVmaXggKz0ga2V5c3BhY2UuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGtleXNwYWNlLmxlbmd0aCkpO1xyXG4gIH1cclxuICByZXR1cm4gcHJlZml4O1xyXG59OyIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvLURhc2ggMi4wLjAgPGh0dHA6Ly9sb2Rhc2guY29tLz5cbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNS4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2xvZGFzaC5pc2Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCdsb2Rhc2guaXNvYmplY3QnKSxcbiAgICByZU5hdGl2ZSA9IHJlcXVpcmUoJ2xvZGFzaC5fcmVuYXRpdmUnKTtcblxuLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlIEVTNSBlbnZpcm9ubWVudHMgKi9cbnZhciB1bmRlZmluZWQ7XG5cbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyAqL1xudmFyIG5vdyA9IHJlTmF0aXZlLnRlc3Qobm93ID0gRGF0ZS5ub3cpICYmIG5vdyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuICtuZXcgRGF0ZTsgfTtcblxuLyogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgZm9yIG1ldGhvZHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMgKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRlbGF5IHRoZSBleGVjdXRpb24gb2YgYGZ1bmNgIHVudGlsIGFmdGVyXG4gKiBgd2FpdGAgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLlxuICogUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvblxuICogdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzXG4gKiB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gKlxuICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCBgZnVuY2Agd2lsbCBiZSBjYWxsZWRcbiAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBjYWxsZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gKiB2YXIgbGF6eUxheW91dCA9IF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApO1xuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIGxhenlMYXlvdXQpO1xuICpcbiAqIC8vIGV4ZWN1dGUgYHNlbmRNYWlsYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzXG4gKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pO1xuICpcbiAqIC8vIGVuc3VyZSBgYmF0Y2hMb2dgIGlzIGV4ZWN1dGVkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzXG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICogICAnbWF4V2FpdCc6IDEwMDBcbiAqIH0sIGZhbHNlKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgYXJncyxcbiAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0YW1wLFxuICAgICAgdGhpc0FyZyxcbiAgICAgIHRpbWVvdXRJZCxcbiAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgbWF4V2FpdCA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gIH1cbiAgd2FpdCA9IG5hdGl2ZU1heCgwLCB3YWl0KSB8fCAwO1xuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICB0cmFpbGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9IG9wdGlvbnMubGVhZGluZztcbiAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKG5hdGl2ZU1heCh3YWl0LCBvcHRpb25zLm1heFdhaXQpIHx8IDApO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRyYWlsaW5nIHx8IChtYXhXYWl0ICE9PSB3YWl0KSkge1xuICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgc3RhbXAgPSBub3coKTtcbiAgICB0aGlzQXJnID0gdGhpcztcbiAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICB9XG4gICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQobWF4RGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aW1lb3V0SWQgJiYgd2FpdCAhPT0gbWF4V2FpdCkge1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICB9XG4gICAgaWYgKGxlYWRpbmdDYWxsKSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjAuMCA8aHR0cDovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS41LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHA6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZSAqL1xudmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIFN0cmluZyhvYmplY3RQcm90by52YWx1ZU9mKVxuICAgIC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL3ZhbHVlT2Z8Zm9yIFteXFxdXSsvZywgJy4rPycpICsgJyQnXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlTmF0aXZlO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjAuMCA8aHR0cDovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS41LjIgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEzIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHA6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMby1EYXNoIDIuMC4wIDxodHRwOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjUuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cDovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xudmFyIG9iamVjdFR5cGVzID0gcmVxdWlyZSgnbG9kYXNoLl9vYmplY3R0eXBlcycpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIHRoZSBFQ01BU2NyaXB0IGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0XG4gIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OFxuICAvLyBhbmQgYXZvaWQgYSBWOCBidWdcbiAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MVxuICByZXR1cm4gISEodmFsdWUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIHZhbHVlXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMby1EYXNoIDIuMC4wIDxodHRwOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjUuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cDovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbnZhciBvYmplY3RUeXBlcyA9IHtcbiAgJ2Jvb2xlYW4nOiBmYWxzZSxcbiAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgJ29iamVjdCc6IHRydWUsXG4gICdudW1iZXInOiBmYWxzZSxcbiAgJ3N0cmluZyc6IGZhbHNlLFxuICAndW5kZWZpbmVkJzogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VHlwZXM7XG4iXX0=
;